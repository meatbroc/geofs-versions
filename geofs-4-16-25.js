/* @preserve
 * Leaflet 1.9.4+v1.d15112c, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
!function(t, e) {
  "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).leaflet = {})
}(this, function(t) {
  "use strict";
  function l(t) {
      for (var e, i, n = 1, o = arguments.length; n < o; n++)
          for (e in i = arguments[n])
              t[e] = i[e];
      return t
  }
  var R = Object.create || function(t) {
      return N.prototype = t,
      new N
  }
  ;
  function N() {}
  function a(t, e) {
      var i, n = Array.prototype.slice;
      return t.bind ? t.bind.apply(t, n.call(arguments, 1)) : (i = n.call(arguments, 2),
      function() {
          return t.apply(e, i.length ? i.concat(n.call(arguments)) : arguments)
      }
      )
  }
  var D = 0;
  function h(t) {
      return "_leaflet_id"in t || (t._leaflet_id = ++D),
      t._leaflet_id
  }
  function j(t, e, i) {
      var n, o, s = function() {
          n = !1,
          o && (r.apply(i, o),
          o = !1)
      }, r = function() {
          n ? o = arguments : (t.apply(i, arguments),
          setTimeout(s, e),
          n = !0)
      };
      return r
  }
  function H(t, e, i) {
      var n = e[1]
        , e = e[0]
        , o = n - e;
      return t === n && i ? t : ((t - e) % o + o) % o + e
  }
  function u() {
      return !1
  }
  function i(t, e) {
      return !1 === e ? t : (e = Math.pow(10, void 0 === e ? 6 : e),
      Math.round(t * e) / e)
  }
  function W(t) {
      return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "")
  }
  function F(t) {
      return W(t).split(/\s+/)
  }
  function c(t, e) {
      for (var i in Object.prototype.hasOwnProperty.call(t, "options") || (t.options = t.options ? R(t.options) : {}),
      e)
          t.options[i] = e[i];
      return t.options
  }
  function U(t, e, i) {
      var n, o = [];
      for (n in t)
          o.push(encodeURIComponent(i ? n.toUpperCase() : n) + "=" + encodeURIComponent(t[n]));
      return (e && -1 !== e.indexOf("?") ? "&" : "?") + o.join("&")
  }
  var V = /\{ *([\w_ -]+) *\}/g;
  function q(t, i) {
      return t.replace(V, function(t, e) {
          e = i[e];
          if (void 0 === e)
              throw new Error("No value provided for variable " + t);
          return e = "function" == typeof e ? e(i) : e
      })
  }
  var d = Array.isArray || function(t) {
      return "[object Array]" === Object.prototype.toString.call(t)
  }
  ;
  function G(t, e) {
      for (var i = 0; i < t.length; i++)
          if (t[i] === e)
              return i;
      return -1
  }
  var K = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";
  function Y(t) {
      return window["webkit" + t] || window["moz" + t] || window["ms" + t]
  }
  var X = 0;
  function J(t) {
      var e = +new Date
        , i = Math.max(0, 16 - (e - X));
      return X = e + i,
      window.setTimeout(t, i)
  }
  var $ = window.requestAnimationFrame || Y("RequestAnimationFrame") || J
    , Q = window.cancelAnimationFrame || Y("CancelAnimationFrame") || Y("CancelRequestAnimationFrame") || function(t) {
      window.clearTimeout(t)
  }
  ;
  function x(t, e, i) {
      if (!i || $ !== J)
          return $.call(window, a(t, e));
      t.call(e)
  }
  function r(t) {
      t && Q.call(window, t)
  }
  var tt = {
      __proto__: null,
      extend: l,
      create: R,
      bind: a,
      get lastId() {
          return D
      },
      stamp: h,
      throttle: j,
      wrapNum: H,
      falseFn: u,
      formatNum: i,
      trim: W,
      splitWords: F,
      setOptions: c,
      getParamString: U,
      template: q,
      isArray: d,
      indexOf: G,
      emptyImageUrl: K,
      requestFn: $,
      cancelFn: Q,
      requestAnimFrame: x,
      cancelAnimFrame: r
  };
  function et() {}
  et.extend = function(t) {
      function e() {
          c(this),
          this.initialize && this.initialize.apply(this, arguments),
          this.callInitHooks()
      }
      var i, n = e.__super__ = this.prototype, o = R(n);
      for (i in (o.constructor = e).prototype = o,
      this)
          Object.prototype.hasOwnProperty.call(this, i) && "prototype" !== i && "__super__" !== i && (e[i] = this[i]);
      if (t.statics && l(e, t.statics),
      t.includes) {
          var s = t.includes;
          if ("undefined" != typeof L && L && L.Mixin) {
              s = d(s) ? s : [s];
              for (var r = 0; r < s.length; r++)
                  s[r] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", (new Error).stack)
          }
          l.apply(null, [o].concat(t.includes))
      }
      return l(o, t),
      delete o.statics,
      delete o.includes,
      o.options && (o.options = n.options ? R(n.options) : {},
      l(o.options, t.options)),
      o._initHooks = [],
      o.callInitHooks = function() {
          if (!this._initHooksCalled) {
              n.callInitHooks && n.callInitHooks.call(this),
              this._initHooksCalled = !0;
              for (var t = 0, e = o._initHooks.length; t < e; t++)
                  o._initHooks[t].call(this)
          }
      }
      ,
      e
  }
  ,
  et.include = function(t) {
      var e = this.prototype.options;
      return l(this.prototype, t),
      t.options && (this.prototype.options = e,
      this.mergeOptions(t.options)),
      this
  }
  ,
  et.mergeOptions = function(t) {
      return l(this.prototype.options, t),
      this
  }
  ,
  et.addInitHook = function(t) {
      var e = Array.prototype.slice.call(arguments, 1)
        , i = "function" == typeof t ? t : function() {
          this[t].apply(this, e)
      }
      ;
      return this.prototype._initHooks = this.prototype._initHooks || [],
      this.prototype._initHooks.push(i),
      this
  }
  ;
  var e = {
      on: function(t, e, i) {
          if ("object" == typeof t)
              for (var n in t)
                  this._on(n, t[n], e);
          else
              for (var o = 0, s = (t = F(t)).length; o < s; o++)
                  this._on(t[o], e, i);
          return this
      },
      off: function(t, e, i) {
          if (arguments.length)
              if ("object" == typeof t)
                  for (var n in t)
                      this._off(n, t[n], e);
              else {
                  t = F(t);
                  for (var o = 1 === arguments.length, s = 0, r = t.length; s < r; s++)
                      o ? this._off(t[s]) : this._off(t[s], e, i)
              }
          else
              delete this._events;
          return this
      },
      _on: function(t, e, i, n) {
          "function" != typeof e ? console.warn("wrong listener type: " + typeof e) : !1 === this._listens(t, e, i) && (e = {
              fn: e,
              ctx: i = i === this ? void 0 : i
          },
          n && (e.once = !0),
          this._events = this._events || {},
          this._events[t] = this._events[t] || [],
          this._events[t].push(e))
      },
      _off: function(t, e, i) {
          var n, o, s;
          if (this._events && (n = this._events[t]))
              if (1 === arguments.length) {
                  if (this._firingCount)
                      for (o = 0,
                      s = n.length; o < s; o++)
                          n[o].fn = u;
                  delete this._events[t]
              } else
                  "function" != typeof e ? console.warn("wrong listener type: " + typeof e) : !1 !== (e = this._listens(t, e, i)) && (i = n[e],
                  this._firingCount && (i.fn = u,
                  this._events[t] = n = n.slice()),
                  n.splice(e, 1))
      },
      fire: function(t, e, i) {
          if (this.listens(t, i)) {
              var n = l({}, e, {
                  type: t,
                  target: this,
                  sourceTarget: e && e.sourceTarget || this
              });
              if (this._events) {
                  var o = this._events[t];
                  if (o) {
                      this._firingCount = this._firingCount + 1 || 1;
                      for (var s = 0, r = o.length; s < r; s++) {
                          var a = o[s]
                            , h = a.fn;
                          a.once && this.off(t, h, a.ctx),
                          h.call(a.ctx || this, n)
                      }
                      this._firingCount--
                  }
              }
              i && this._propagateEvent(n)
          }
          return this
      },
      listens: function(t, e, i, n) {
          "string" != typeof t && console.warn('"string" type argument expected');
          var o = e
            , s = ("function" != typeof e && (n = !!e,
          i = o = void 0),
          this._events && this._events[t]);
          if (s && s.length && !1 !== this._listens(t, o, i))
              return !0;
          if (n)
              for (var r in this._eventParents)
                  if (this._eventParents[r].listens(t, e, i, n))
                      return !0;
          return !1
      },
      _listens: function(t, e, i) {
          if (this._events) {
              var n = this._events[t] || [];
              if (!e)
                  return !!n.length;
              i === this && (i = void 0);
              for (var o = 0, s = n.length; o < s; o++)
                  if (n[o].fn === e && n[o].ctx === i)
                      return o
          }
          return !1
      },
      once: function(t, e, i) {
          if ("object" == typeof t)
              for (var n in t)
                  this._on(n, t[n], e, !0);
          else
              for (var o = 0, s = (t = F(t)).length; o < s; o++)
                  this._on(t[o], e, i, !0);
          return this
      },
      addEventParent: function(t) {
          return this._eventParents = this._eventParents || {},
          this._eventParents[h(t)] = t,
          this
      },
      removeEventParent: function(t) {
          return this._eventParents && delete this._eventParents[h(t)],
          this
      },
      _propagateEvent: function(t) {
          for (var e in this._eventParents)
              this._eventParents[e].fire(t.type, l({
                  layer: t.target,
                  propagatedFrom: t.target
              }, t), !0)
      }
  }
    , it = (e.addEventListener = e.on,
  e.removeEventListener = e.clearAllEventListeners = e.off,
  e.addOneTimeEventListener = e.once,
  e.fireEvent = e.fire,
  e.hasEventListeners = e.listens,
  et.extend(e));
  function p(t, e, i) {
      this.x = i ? Math.round(t) : t,
      this.y = i ? Math.round(e) : e
  }
  var nt = Math.trunc || function(t) {
      return 0 < t ? Math.floor(t) : Math.ceil(t)
  }
  ;
  function m(t, e, i) {
      return t instanceof p ? t : d(t) ? new p(t[0],t[1]) : null == t ? t : "object" == typeof t && "x"in t && "y"in t ? new p(t.x,t.y) : new p(t,e,i)
  }
  function f(t, e) {
      if (t)
          for (var i = e ? [t, e] : t, n = 0, o = i.length; n < o; n++)
              this.extend(i[n])
  }
  function _(t, e) {
      return !t || t instanceof f ? t : new f(t,e)
  }
  function s(t, e) {
      if (t)
          for (var i = e ? [t, e] : t, n = 0, o = i.length; n < o; n++)
              this.extend(i[n])
  }
  function g(t, e) {
      return t instanceof s ? t : new s(t,e)
  }
  function v(t, e, i) {
      if (isNaN(t) || isNaN(e))
          throw new Error("Invalid LatLng object: (" + t + ", " + e + ")");
      this.lat = +t,
      this.lng = +e,
      void 0 !== i && (this.alt = +i)
  }
  function w(t, e, i) {
      return t instanceof v ? t : d(t) && "object" != typeof t[0] ? 3 === t.length ? new v(t[0],t[1],t[2]) : 2 === t.length ? new v(t[0],t[1]) : null : null == t ? t : "object" == typeof t && "lat"in t ? new v(t.lat,"lng"in t ? t.lng : t.lon,t.alt) : void 0 === e ? null : new v(t,e,i)
  }
  p.prototype = {
      clone: function() {
          return new p(this.x,this.y)
      },
      add: function(t) {
          return this.clone()._add(m(t))
      },
      _add: function(t) {
          return this.x += t.x,
          this.y += t.y,
          this
      },
      subtract: function(t) {
          return this.clone()._subtract(m(t))
      },
      _subtract: function(t) {
          return this.x -= t.x,
          this.y -= t.y,
          this
      },
      divideBy: function(t) {
          return this.clone()._divideBy(t)
      },
      _divideBy: function(t) {
          return this.x /= t,
          this.y /= t,
          this
      },
      multiplyBy: function(t) {
          return this.clone()._multiplyBy(t)
      },
      _multiplyBy: function(t) {
          return this.x *= t,
          this.y *= t,
          this
      },
      scaleBy: function(t) {
          return new p(this.x * t.x,this.y * t.y)
      },
      unscaleBy: function(t) {
          return new p(this.x / t.x,this.y / t.y)
      },
      round: function() {
          return this.clone()._round()
      },
      _round: function() {
          return this.x = Math.round(this.x),
          this.y = Math.round(this.y),
          this
      },
      floor: function() {
          return this.clone()._floor()
      },
      _floor: function() {
          return this.x = Math.floor(this.x),
          this.y = Math.floor(this.y),
          this
      },
      ceil: function() {
          return this.clone()._ceil()
      },
      _ceil: function() {
          return this.x = Math.ceil(this.x),
          this.y = Math.ceil(this.y),
          this
      },
      trunc: function() {
          return this.clone()._trunc()
      },
      _trunc: function() {
          return this.x = nt(this.x),
          this.y = nt(this.y),
          this
      },
      distanceTo: function(t) {
          var e = (t = m(t)).x - this.x
            , t = t.y - this.y;
          return Math.sqrt(e * e + t * t)
      },
      equals: function(t) {
          return (t = m(t)).x === this.x && t.y === this.y
      },
      contains: function(t) {
          return t = m(t),
          Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y)
      },
      toString: function() {
          return "Point(" + i(this.x) + ", " + i(this.y) + ")"
      }
  },
  f.prototype = {
      extend: function(t) {
          var e, i;
          if (t) {
              if (t instanceof p || "number" == typeof t[0] || "x"in t)
                  e = i = m(t);
              else if (e = (t = _(t)).min,
              i = t.max,
              !e || !i)
                  return this;
              this.min || this.max ? (this.min.x = Math.min(e.x, this.min.x),
              this.max.x = Math.max(i.x, this.max.x),
              this.min.y = Math.min(e.y, this.min.y),
              this.max.y = Math.max(i.y, this.max.y)) : (this.min = e.clone(),
              this.max = i.clone())
          }
          return this
      },
      getCenter: function(t) {
          return m((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t)
      },
      getBottomLeft: function() {
          return m(this.min.x, this.max.y)
      },
      getTopRight: function() {
          return m(this.max.x, this.min.y)
      },
      getTopLeft: function() {
          return this.min
      },
      getBottomRight: function() {
          return this.max
      },
      getSize: function() {
          return this.max.subtract(this.min)
      },
      contains: function(t) {
          var e, i;
          return (t = ("number" == typeof t[0] || t instanceof p ? m : _)(t))instanceof f ? (e = t.min,
          i = t.max) : e = i = t,
          e.x >= this.min.x && i.x <= this.max.x && e.y >= this.min.y && i.y <= this.max.y
      },
      intersects: function(t) {
          t = _(t);
          var e = this.min
            , i = this.max
            , n = t.min
            , t = t.max
            , o = t.x >= e.x && n.x <= i.x
            , t = t.y >= e.y && n.y <= i.y;
          return o && t
      },
      overlaps: function(t) {
          t = _(t);
          var e = this.min
            , i = this.max
            , n = t.min
            , t = t.max
            , o = t.x > e.x && n.x < i.x
            , t = t.y > e.y && n.y < i.y;
          return o && t
      },
      isValid: function() {
          return !(!this.min || !this.max)
      },
      pad: function(t) {
          var e = this.min
            , i = this.max
            , n = Math.abs(e.x - i.x) * t
            , t = Math.abs(e.y - i.y) * t;
          return _(m(e.x - n, e.y - t), m(i.x + n, i.y + t))
      },
      equals: function(t) {
          return !!t && (t = _(t),
          this.min.equals(t.getTopLeft()) && this.max.equals(t.getBottomRight()))
      }
  },
  s.prototype = {
      extend: function(t) {
          var e, i, n = this._southWest, o = this._northEast;
          if (t instanceof v)
              i = e = t;
          else {
              if (!(t instanceof s))
                  return t ? this.extend(w(t) || g(t)) : this;
              if (e = t._southWest,
              i = t._northEast,
              !e || !i)
                  return this
          }
          return n || o ? (n.lat = Math.min(e.lat, n.lat),
          n.lng = Math.min(e.lng, n.lng),
          o.lat = Math.max(i.lat, o.lat),
          o.lng = Math.max(i.lng, o.lng)) : (this._southWest = new v(e.lat,e.lng),
          this._northEast = new v(i.lat,i.lng)),
          this
      },
      pad: function(t) {
          var e = this._southWest
            , i = this._northEast
            , n = Math.abs(e.lat - i.lat) * t
            , t = Math.abs(e.lng - i.lng) * t;
          return new s(new v(e.lat - n,e.lng - t),new v(i.lat + n,i.lng + t))
      },
      getCenter: function() {
          return new v((this._southWest.lat + this._northEast.lat) / 2,(this._southWest.lng + this._northEast.lng) / 2)
      },
      getSouthWest: function() {
          return this._southWest
      },
      getNorthEast: function() {
          return this._northEast
      },
      getNorthWest: function() {
          return new v(this.getNorth(),this.getWest())
      },
      getSouthEast: function() {
          return new v(this.getSouth(),this.getEast())
      },
      getWest: function() {
          return this._southWest.lng
      },
      getSouth: function() {
          return this._southWest.lat
      },
      getEast: function() {
          return this._northEast.lng
      },
      getNorth: function() {
          return this._northEast.lat
      },
      contains: function(t) {
          t = ("number" == typeof t[0] || t instanceof v || "lat"in t ? w : g)(t);
          var e, i, n = this._southWest, o = this._northEast;
          return t instanceof s ? (e = t.getSouthWest(),
          i = t.getNorthEast()) : e = i = t,
          e.lat >= n.lat && i.lat <= o.lat && e.lng >= n.lng && i.lng <= o.lng
      },
      intersects: function(t) {
          t = g(t);
          var e = this._southWest
            , i = this._northEast
            , n = t.getSouthWest()
            , t = t.getNorthEast()
            , o = t.lat >= e.lat && n.lat <= i.lat
            , t = t.lng >= e.lng && n.lng <= i.lng;
          return o && t
      },
      overlaps: function(t) {
          t = g(t);
          var e = this._southWest
            , i = this._northEast
            , n = t.getSouthWest()
            , t = t.getNorthEast()
            , o = t.lat > e.lat && n.lat < i.lat
            , t = t.lng > e.lng && n.lng < i.lng;
          return o && t
      },
      toBBoxString: function() {
          return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",")
      },
      equals: function(t, e) {
          return !!t && (t = g(t),
          this._southWest.equals(t.getSouthWest(), e) && this._northEast.equals(t.getNorthEast(), e))
      },
      isValid: function() {
          return !(!this._southWest || !this._northEast)
      }
  };
  var ot = {
      latLngToPoint: function(t, e) {
          t = this.projection.project(t),
          e = this.scale(e);
          return this.transformation._transform(t, e)
      },
      pointToLatLng: function(t, e) {
          e = this.scale(e),
          t = this.transformation.untransform(t, e);
          return this.projection.unproject(t)
      },
      project: function(t) {
          return this.projection.project(t)
      },
      unproject: function(t) {
          return this.projection.unproject(t)
      },
      scale: function(t) {
          return 256 * Math.pow(2, t)
      },
      zoom: function(t) {
          return Math.log(t / 256) / Math.LN2
      },
      getProjectedBounds: function(t) {
          var e;
          return this.infinite ? null : (e = this.projection.bounds,
          t = this.scale(t),
          new f(this.transformation.transform(e.min, t),this.transformation.transform(e.max, t)))
      },
      infinite: !(v.prototype = {
          equals: function(t, e) {
              return !!t && (t = w(t),
              Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng)) <= (void 0 === e ? 1e-9 : e))
          },
          toString: function(t) {
              return "LatLng(" + i(this.lat, t) + ", " + i(this.lng, t) + ")"
          },
          distanceTo: function(t) {
              return st.distance(this, w(t))
          },
          wrap: function() {
              return st.wrapLatLng(this)
          },
          toBounds: function(t) {
              var t = 180 * t / 40075017
                , e = t / Math.cos(Math.PI / 180 * this.lat);
              return g([this.lat - t, this.lng - e], [this.lat + t, this.lng + e])
          },
          clone: function() {
              return new v(this.lat,this.lng,this.alt)
          }
      }),
      wrapLatLng: function(t) {
          var e = this.wrapLng ? H(t.lng, this.wrapLng, !0) : t.lng;
          return new v(this.wrapLat ? H(t.lat, this.wrapLat, !0) : t.lat,e,t.alt)
      },
      wrapLatLngBounds: function(t) {
          var e = t.getCenter()
            , i = this.wrapLatLng(e)
            , n = e.lat - i.lat
            , e = e.lng - i.lng;
          return 0 == n && 0 == e ? t : (i = t.getSouthWest(),
          t = t.getNorthEast(),
          new s(new v(i.lat - n,i.lng - e),new v(t.lat - n,t.lng - e)))
      }
  }
    , st = l({}, ot, {
      wrapLng: [-180, 180],
      R: 6371e3,
      distance: function(t, e) {
          var i = Math.PI / 180
            , n = t.lat * i
            , o = e.lat * i
            , s = Math.sin((e.lat - t.lat) * i / 2)
            , e = Math.sin((e.lng - t.lng) * i / 2)
            , t = s * s + Math.cos(n) * Math.cos(o) * e * e
            , i = 2 * Math.atan2(Math.sqrt(t), Math.sqrt(1 - t));
          return this.R * i
      }
  })
    , rt = 6378137
    , rt = {
      R: rt,
      MAX_LATITUDE: 85.0511287798,
      project: function(t) {
          var e = Math.PI / 180
            , i = this.MAX_LATITUDE
            , i = Math.max(Math.min(i, t.lat), -i)
            , i = Math.sin(i * e);
          return new p(this.R * t.lng * e,this.R * Math.log((1 + i) / (1 - i)) / 2)
      },
      unproject: function(t) {
          var e = 180 / Math.PI;
          return new v((2 * Math.atan(Math.exp(t.y / this.R)) - Math.PI / 2) * e,t.x * e / this.R)
      },
      bounds: new f([-(rt = rt * Math.PI), -rt],[rt, rt])
  };
  function at(t, e, i, n) {
      d(t) ? (this._a = t[0],
      this._b = t[1],
      this._c = t[2],
      this._d = t[3]) : (this._a = t,
      this._b = e,
      this._c = i,
      this._d = n)
  }
  function ht(t, e, i, n) {
      return new at(t,e,i,n)
  }
  at.prototype = {
      transform: function(t, e) {
          return this._transform(t.clone(), e)
      },
      _transform: function(t, e) {
          return t.x = (e = e || 1) * (this._a * t.x + this._b),
          t.y = e * (this._c * t.y + this._d),
          t
      },
      untransform: function(t, e) {
          return new p((t.x / (e = e || 1) - this._b) / this._a,(t.y / e - this._d) / this._c)
      }
  };
  var lt = l({}, st, {
      code: "EPSG:3857",
      projection: rt,
      transformation: ht(lt = .5 / (Math.PI * rt.R), .5, -lt, .5)
  })
    , ut = l({}, lt, {
      code: "EPSG:900913"
  });
  function ct(t) {
      return document.createElementNS("http://www.w3.org/2000/svg", t)
  }
  function dt(t, e) {
      for (var i, n, o, s, r = "", a = 0, h = t.length; a < h; a++) {
          for (i = 0,
          n = (o = t[a]).length; i < n; i++)
              r += (i ? "L" : "M") + (s = o[i]).x + " " + s.y;
          r += e ? b.svg ? "z" : "x" : ""
      }
      return r || "M0 0"
  }
  var _t = document.documentElement.style
    , pt = "ActiveXObject"in window
    , mt = pt && !document.addEventListener
    , n = "msLaunchUri"in navigator && !("documentMode"in document)
    , ft = y("webkit")
    , gt = y("android")
    , vt = y("android 2") || y("android 3")
    , yt = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10)
    , yt = gt && y("Google") && yt < 537 && !("AudioNode"in window)
    , xt = !!window.opera
    , wt = !n && y("chrome")
    , bt = y("gecko") && !ft && !xt && !pt
    , Pt = !wt && y("safari")
    , Lt = y("phantom")
    , o = "OTransition"in _t
    , Tt = 0 === navigator.platform.indexOf("Win")
    , Mt = pt && "transition"in _t
    , zt = "WebKitCSSMatrix"in window && "m11"in new window.WebKitCSSMatrix && !vt
    , _t = "MozPerspective"in _t
    , Ct = !window.L_DISABLE_3D && (Mt || zt || _t) && !o && !Lt
    , Zt = "undefined" != typeof orientation || y("mobile")
    , St = Zt && ft
    , Et = Zt && zt
    , kt = !window.PointerEvent && window.MSPointerEvent
    , Ot = !(!window.PointerEvent && !kt)
    , At = "ontouchstart"in window || !!window.TouchEvent
    , Bt = !window.L_NO_TOUCH && (At || Ot)
    , It = Zt && xt
    , Rt = Zt && bt
    , Nt = 1 < (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI)
    , Dt = function() {
      var t = !1;
      try {
          var e = Object.defineProperty({}, "passive", {
              get: function() {
                  t = !0
              }
          });
          window.addEventListener("testPassiveEventSupport", u, e),
          window.removeEventListener("testPassiveEventSupport", u, e)
      } catch (t) {}
      return t
  }()
    , jt = !!document.createElement("canvas").getContext
    , Ht = !(!document.createElementNS || !ct("svg").createSVGRect)
    , Wt = !!Ht && ((Wt = document.createElement("div")).innerHTML = "<svg/>",
  "http://www.w3.org/2000/svg" === (Wt.firstChild && Wt.firstChild.namespaceURI));
  function y(t) {
      return 0 <= navigator.userAgent.toLowerCase().indexOf(t)
  }
  var b = {
      ie: pt,
      ielt9: mt,
      edge: n,
      webkit: ft,
      android: gt,
      android23: vt,
      androidStock: yt,
      opera: xt,
      chrome: wt,
      gecko: bt,
      safari: Pt,
      phantom: Lt,
      opera12: o,
      win: Tt,
      ie3d: Mt,
      webkit3d: zt,
      gecko3d: _t,
      any3d: Ct,
      mobile: Zt,
      mobileWebkit: St,
      mobileWebkit3d: Et,
      msPointer: kt,
      pointer: Ot,
      touch: Bt,
      touchNative: At,
      mobileOpera: It,
      mobileGecko: Rt,
      retina: Nt,
      passiveEvents: Dt,
      canvas: jt,
      svg: Ht,
      vml: !Ht && function() {
          try {
              var t = document.createElement("div")
                , e = (t.innerHTML = '<v:shape adj="1"/>',
              t.firstChild);
              return e.style.behavior = "url(#default#VML)",
              e && "object" == typeof e.adj
          } catch (t) {
              return !1
          }
      }(),
      inlineSvg: Wt,
      mac: 0 === navigator.platform.indexOf("Mac"),
      linux: 0 === navigator.platform.indexOf("Linux")
  }
    , Ft = b.msPointer ? "MSPointerDown" : "pointerdown"
    , Ut = b.msPointer ? "MSPointerMove" : "pointermove"
    , Vt = b.msPointer ? "MSPointerUp" : "pointerup"
    , qt = b.msPointer ? "MSPointerCancel" : "pointercancel"
    , Gt = {
      touchstart: Ft,
      touchmove: Ut,
      touchend: Vt,
      touchcancel: qt
  }
    , Kt = {
      touchstart: function(t, e) {
          e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH && O(e);
          ee(t, e)
      },
      touchmove: ee,
      touchend: ee,
      touchcancel: ee
  }
    , Yt = {}
    , Xt = !1;
  function Jt(t, e, i) {
      return "touchstart" !== e || Xt || (document.addEventListener(Ft, $t, !0),
      document.addEventListener(Ut, Qt, !0),
      document.addEventListener(Vt, te, !0),
      document.addEventListener(qt, te, !0),
      Xt = !0),
      Kt[e] ? (i = Kt[e].bind(this, i),
      t.addEventListener(Gt[e], i, !1),
      i) : (console.warn("wrong event specified:", e),
      u)
  }
  function $t(t) {
      Yt[t.pointerId] = t
  }
  function Qt(t) {
      Yt[t.pointerId] && (Yt[t.pointerId] = t)
  }
  function te(t) {
      delete Yt[t.pointerId]
  }
  function ee(t, e) {
      if (e.pointerType !== (e.MSPOINTER_TYPE_MOUSE || "mouse")) {
          for (var i in e.touches = [],
          Yt)
              e.touches.push(Yt[i]);
          e.changedTouches = [e],
          t(e)
      }
  }
  var ie = 200;
  function ne(t, i) {
      t.addEventListener("dblclick", i);
      var n, o = 0;
      function e(t) {
          var e;
          1 !== t.detail ? n = t.detail : "mouse" === t.pointerType || t.sourceCapabilities && !t.sourceCapabilities.firesTouchEvents || ((e = Ne(t)).some(function(t) {
              return t instanceof HTMLLabelElement && t.attributes.for
          }) && !e.some(function(t) {
              return t instanceof HTMLInputElement || t instanceof HTMLSelectElement
          }) || ((e = Date.now()) - o <= ie ? 2 === ++n && i(function(t) {
              var e, i, n = {};
              for (i in t)
                  e = t[i],
                  n[i] = e && e.bind ? e.bind(t) : e;
              return (t = n).type = "dblclick",
              n.detail = 2,
              n.isTrusted = !1,
              n._simulated = !0,
              n
          }(t)) : n = 1,
          o = e))
      }
      return t.addEventListener("click", e),
      {
          dblclick: i,
          simDblclick: e
      }
  }
  var oe, se, re, ae, he, le, ue = we(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), ce = we(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]), de = "webkitTransition" === ce || "OTransition" === ce ? ce + "End" : "transitionend";
  function _e(t) {
      return "string" == typeof t ? document.getElementById(t) : t
  }
  function pe(t, e) {
      var i = t.style[e] || t.currentStyle && t.currentStyle[e];
      return "auto" === (i = i && "auto" !== i || !document.defaultView ? i : (t = document.defaultView.getComputedStyle(t, null)) ? t[e] : null) ? null : i
  }
  function P(t, e, i) {
      t = document.createElement(t);
      return t.className = e || "",
      i && i.appendChild(t),
      t
  }
  function T(t) {
      var e = t.parentNode;
      e && e.removeChild(t)
  }
  function me(t) {
      for (; t.firstChild; )
          t.removeChild(t.firstChild)
  }
  function fe(t) {
      var e = t.parentNode;
      e && e.lastChild !== t && e.appendChild(t)
  }
  function ge(t) {
      var e = t.parentNode;
      e && e.firstChild !== t && e.insertBefore(t, e.firstChild)
  }
  function ve(t, e) {
      return void 0 !== t.classList ? t.classList.contains(e) : 0 < (t = xe(t)).length && new RegExp("(^|\\s)" + e + "(\\s|$)").test(t)
  }
  function M(t, e) {
      var i;
      if (void 0 !== t.classList)
          for (var n = F(e), o = 0, s = n.length; o < s; o++)
              t.classList.add(n[o]);
      else
          ve(t, e) || ye(t, ((i = xe(t)) ? i + " " : "") + e)
  }
  function z(t, e) {
      void 0 !== t.classList ? t.classList.remove(e) : ye(t, W((" " + xe(t) + " ").replace(" " + e + " ", " ")))
  }
  function ye(t, e) {
      void 0 === t.className.baseVal ? t.className = e : t.className.baseVal = e
  }
  function xe(t) {
      return void 0 === (t = t.correspondingElement ? t.correspondingElement : t).className.baseVal ? t.className : t.className.baseVal
  }
  function C(t, e) {
      if ("opacity"in t.style)
          t.style.opacity = e;
      else if ("filter"in t.style) {
          var i = !1
            , n = "DXImageTransform.Microsoft.Alpha";
          try {
              i = t.filters.item(n)
          } catch (t) {
              if (1 === e)
                  return
          }
          e = Math.round(100 * e),
          i ? (i.Enabled = 100 !== e,
          i.Opacity = e) : t.style.filter += " progid:" + n + "(opacity=" + e + ")"
      }
  }
  function we(t) {
      for (var e = document.documentElement.style, i = 0; i < t.length; i++)
          if (t[i]in e)
              return t[i];
      return !1
  }
  function be(t, e, i) {
      e = e || new p(0,0);
      t.style[ue] = (b.ie3d ? "translate(" + e.x + "px," + e.y + "px)" : "translate3d(" + e.x + "px," + e.y + "px,0)") + (i ? " scale(" + i + ")" : "")
  }
  function Z(t, e) {
      t._leaflet_pos = e,
      b.any3d ? be(t, e) : (t.style.left = e.x + "px",
      t.style.top = e.y + "px")
  }
  function Pe(t) {
      return t._leaflet_pos || new p(0,0)
  }
  function Le() {
      S(window, "dragstart", O)
  }
  function Te() {
      k(window, "dragstart", O)
  }
  function Me(t) {
      for (; -1 === t.tabIndex; )
          t = t.parentNode;
      t.style && (ze(),
      le = (he = t).style.outlineStyle,
      t.style.outlineStyle = "none",
      S(window, "keydown", ze))
  }
  function ze() {
      he && (he.style.outlineStyle = le,
      le = he = void 0,
      k(window, "keydown", ze))
  }
  function Ce(t) {
      for (; !((t = t.parentNode).offsetWidth && t.offsetHeight || t === document.body); )
          ;
      return t
  }
  function Ze(t) {
      var e = t.getBoundingClientRect();
      return {
          x: e.width / t.offsetWidth || 1,
          y: e.height / t.offsetHeight || 1,
          boundingClientRect: e
      }
  }
  ae = "onselectstart"in document ? (re = function() {
      S(window, "selectstart", O)
  }
  ,
  function() {
      k(window, "selectstart", O)
  }
  ) : (se = we(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]),
  re = function() {
      var t;
      se && (t = document.documentElement.style,
      oe = t[se],
      t[se] = "none")
  }
  ,
  function() {
      se && (document.documentElement.style[se] = oe,
      oe = void 0)
  }
  );
  pt = {
      __proto__: null,
      TRANSFORM: ue,
      TRANSITION: ce,
      TRANSITION_END: de,
      get: _e,
      getStyle: pe,
      create: P,
      remove: T,
      empty: me,
      toFront: fe,
      toBack: ge,
      hasClass: ve,
      addClass: M,
      removeClass: z,
      setClass: ye,
      getClass: xe,
      setOpacity: C,
      testProp: we,
      setTransform: be,
      setPosition: Z,
      getPosition: Pe,
      get disableTextSelection() {
          return re
      },
      get enableTextSelection() {
          return ae
      },
      disableImageDrag: Le,
      enableImageDrag: Te,
      preventOutline: Me,
      restoreOutline: ze,
      getSizedParentNode: Ce,
      getScale: Ze
  };
  function S(t, e, i, n) {
      if (e && "object" == typeof e)
          for (var o in e)
              ke(t, o, e[o], i);
      else
          for (var s = 0, r = (e = F(e)).length; s < r; s++)
              ke(t, e[s], i, n);
      return this
  }
  var E = "_leaflet_events";
  function k(t, e, i, n) {
      if (1 === arguments.length)
          Se(t),
          delete t[E];
      else if (e && "object" == typeof e)
          for (var o in e)
              Oe(t, o, e[o], i);
      else if (e = F(e),
      2 === arguments.length)
          Se(t, function(t) {
              return -1 !== G(e, t)
          });
      else
          for (var s = 0, r = e.length; s < r; s++)
              Oe(t, e[s], i, n);
      return this
  }
  function Se(t, e) {
      for (var i in t[E]) {
          var n = i.split(/\d/)[0];
          e && !e(n) || Oe(t, n, null, null, i)
      }
  }
  var Ee = {
      mouseenter: "mouseover",
      mouseleave: "mouseout",
      wheel: !("onwheel"in window) && "mousewheel"
  };
  function ke(e, t, i, n) {
      var o, s, r = t + h(i) + (n ? "_" + h(n) : "");
      e[E] && e[E][r] || (s = o = function(t) {
          return i.call(n || e, t || window.event)
      }
      ,
      !b.touchNative && b.pointer && 0 === t.indexOf("touch") ? o = Jt(e, t, o) : b.touch && "dblclick" === t ? o = ne(e, o) : "addEventListener"in e ? "touchstart" === t || "touchmove" === t || "wheel" === t || "mousewheel" === t ? e.addEventListener(Ee[t] || t, o, !!b.passiveEvents && {
          passive: !1
      }) : "mouseenter" === t || "mouseleave" === t ? e.addEventListener(Ee[t], o = function(t) {
          t = t || window.event,
          We(e, t) && s(t)
      }
      , !1) : e.addEventListener(t, s, !1) : e.attachEvent("on" + t, o),
      e[E] = e[E] || {},
      e[E][r] = o)
  }
  function Oe(t, e, i, n, o) {
      o = o || e + h(i) + (n ? "_" + h(n) : "");
      var s, r, i = t[E] && t[E][o];
      i && (!b.touchNative && b.pointer && 0 === e.indexOf("touch") ? (n = t,
      r = i,
      Gt[s = e] ? n.removeEventListener(Gt[s], r, !1) : console.warn("wrong event specified:", s)) : b.touch && "dblclick" === e ? (n = i,
      (r = t).removeEventListener("dblclick", n.dblclick),
      r.removeEventListener("click", n.simDblclick)) : "removeEventListener"in t ? t.removeEventListener(Ee[e] || e, i, !1) : t.detachEvent("on" + e, i),
      t[E][o] = null)
  }
  function Ae(t) {
      return t.stopPropagation ? t.stopPropagation() : t.originalEvent ? t.originalEvent._stopped = !0 : t.cancelBubble = !0,
      this
  }
  function Be(t) {
      return ke(t, "wheel", Ae),
      this
  }
  function Ie(t) {
      return S(t, "mousedown touchstart dblclick contextmenu", Ae),
      t._leaflet_disable_click = !0,
      this
  }
  function O(t) {
      return t.preventDefault ? t.preventDefault() : t.returnValue = !1,
      this
  }
  function Re(t) {
      return O(t),
      Ae(t),
      this
  }
  function Ne(t) {
      if (t.composedPath)
          return t.composedPath();
      for (var e = [], i = t.target; i; )
          e.push(i),
          i = i.parentNode;
      return e
  }
  function De(t, e) {
      var i, n;
      return e ? (n = (i = Ze(e)).boundingClientRect,
      new p((t.clientX - n.left) / i.x - e.clientLeft,(t.clientY - n.top) / i.y - e.clientTop)) : new p(t.clientX,t.clientY)
  }
  var je = b.linux && b.chrome ? window.devicePixelRatio : b.mac ? 3 * window.devicePixelRatio : 0 < window.devicePixelRatio ? 2 * window.devicePixelRatio : 1;
  function He(t) {
      return b.edge ? t.wheelDeltaY / 2 : t.deltaY && 0 === t.deltaMode ? -t.deltaY / je : t.deltaY && 1 === t.deltaMode ? 20 * -t.deltaY : t.deltaY && 2 === t.deltaMode ? 60 * -t.deltaY : t.deltaX || t.deltaZ ? 0 : t.wheelDelta ? (t.wheelDeltaY || t.wheelDelta) / 2 : t.detail && Math.abs(t.detail) < 32765 ? 20 * -t.detail : t.detail ? t.detail / -32765 * 60 : 0
  }
  function We(t, e) {
      var i = e.relatedTarget;
      if (!i)
          return !0;
      try {
          for (; i && i !== t; )
              i = i.parentNode
      } catch (t) {
          return !1
      }
      return i !== t
  }
  var mt = {
      __proto__: null,
      on: S,
      off: k,
      stopPropagation: Ae,
      disableScrollPropagation: Be,
      disableClickPropagation: Ie,
      preventDefault: O,
      stop: Re,
      getPropagationPath: Ne,
      getMousePosition: De,
      getWheelDelta: He,
      isExternalTarget: We,
      addListener: S,
      removeListener: k
  }
    , Fe = it.extend({
      run: function(t, e, i, n) {
          this.stop(),
          this._el = t,
          this._inProgress = !0,
          this._duration = i || .25,
          this._easeOutPower = 1 / Math.max(n || .5, .2),
          this._startPos = Pe(t),
          this._offset = e.subtract(this._startPos),
          this._startTime = +new Date,
          this.fire("start"),
          this._animate()
      },
      stop: function() {
          this._inProgress && (this._step(!0),
          this._complete())
      },
      _animate: function() {
          this._animId = x(this._animate, this),
          this._step()
      },
      _step: function(t) {
          var e = +new Date - this._startTime
            , i = 1e3 * this._duration;
          e < i ? this._runFrame(this._easeOut(e / i), t) : (this._runFrame(1),
          this._complete())
      },
      _runFrame: function(t, e) {
          t = this._startPos.add(this._offset.multiplyBy(t));
          e && t._round(),
          Z(this._el, t),
          this.fire("step")
      },
      _complete: function() {
          r(this._animId),
          this._inProgress = !1,
          this.fire("end")
      },
      _easeOut: function(t) {
          return 1 - Math.pow(1 - t, this._easeOutPower)
      }
  })
    , A = it.extend({
      options: {
          crs: lt,
          center: void 0,
          zoom: void 0,
          minZoom: void 0,
          maxZoom: void 0,
          layers: [],
          maxBounds: void 0,
          renderer: void 0,
          zoomAnimation: !0,
          zoomAnimationThreshold: 4,
          fadeAnimation: !0,
          markerZoomAnimation: !0,
          transform3DLimit: 8388608,
          zoomSnap: 1,
          zoomDelta: 1,
          trackResize: !0
      },
      initialize: function(t, e) {
          e = c(this, e),
          this._handlers = [],
          this._layers = {},
          this._zoomBoundLayers = {},
          this._sizeChanged = !0,
          this._initContainer(t),
          this._initLayout(),
          this._onResize = a(this._onResize, this),
          this._initEvents(),
          e.maxBounds && this.setMaxBounds(e.maxBounds),
          void 0 !== e.zoom && (this._zoom = this._limitZoom(e.zoom)),
          e.center && void 0 !== e.zoom && this.setView(w(e.center), e.zoom, {
              reset: !0
          }),
          this.callInitHooks(),
          this._zoomAnimated = ce && b.any3d && !b.mobileOpera && this.options.zoomAnimation,
          this._zoomAnimated && (this._createAnimProxy(),
          S(this._proxy, de, this._catchTransitionEnd, this)),
          this._addLayers(this.options.layers)
      },
      setView: function(t, e, i) {
          if ((e = void 0 === e ? this._zoom : this._limitZoom(e),
          t = this._limitCenter(w(t), e, this.options.maxBounds),
          i = i || {},
          this._stop(),
          this._loaded && !i.reset && !0 !== i) && (void 0 !== i.animate && (i.zoom = l({
              animate: i.animate
          }, i.zoom),
          i.pan = l({
              animate: i.animate,
              duration: i.duration
          }, i.pan)),
          this._zoom !== e ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, e, i.zoom) : this._tryAnimatedPan(t, i.pan)))
              return clearTimeout(this._sizeTimer),
              this;
          return this._resetView(t, e, i.pan && i.pan.noMoveStart),
          this
      },
      setZoom: function(t, e) {
          return this._loaded ? this.setView(this.getCenter(), t, {
              zoom: e
          }) : (this._zoom = t,
          this)
      },
      zoomIn: function(t, e) {
          return t = t || (b.any3d ? this.options.zoomDelta : 1),
          this.setZoom(this._zoom + t, e)
      },
      zoomOut: function(t, e) {
          return t = t || (b.any3d ? this.options.zoomDelta : 1),
          this.setZoom(this._zoom - t, e)
      },
      setZoomAround: function(t, e, i) {
          var n = this.getZoomScale(e)
            , o = this.getSize().divideBy(2)
            , t = (t instanceof p ? t : this.latLngToContainerPoint(t)).subtract(o).multiplyBy(1 - 1 / n)
            , n = this.containerPointToLatLng(o.add(t));
          return this.setView(n, e, {
              zoom: i
          })
      },
      _getBoundsCenterZoom: function(t, e) {
          e = e || {},
          t = t.getBounds ? t.getBounds() : g(t);
          var i = m(e.paddingTopLeft || e.padding || [0, 0])
            , n = m(e.paddingBottomRight || e.padding || [0, 0])
            , o = this.getBoundsZoom(t, !1, i.add(n));
          return (o = "number" == typeof e.maxZoom ? Math.min(e.maxZoom, o) : o) === 1 / 0 ? {
              center: t.getCenter(),
              zoom: o
          } : (e = n.subtract(i).divideBy(2),
          n = this.project(t.getSouthWest(), o),
          i = this.project(t.getNorthEast(), o),
          {
              center: this.unproject(n.add(i).divideBy(2).add(e), o),
              zoom: o
          })
      },
      fitBounds: function(t, e) {
          if ((t = g(t)).isValid())
              return t = this._getBoundsCenterZoom(t, e),
              this.setView(t.center, t.zoom, e);
          throw new Error("Bounds are not valid.")
      },
      fitWorld: function(t) {
          return this.fitBounds([[-90, -180], [90, 180]], t)
      },
      panTo: function(t, e) {
          return this.setView(t, this._zoom, {
              pan: e
          })
      },
      panBy: function(t, e) {
          var i;
          return e = e || {},
          (t = m(t).round()).x || t.y ? (!0 === e.animate || this.getSize().contains(t) ? (this._panAnim || (this._panAnim = new Fe,
          this._panAnim.on({
              step: this._onPanTransitionStep,
              end: this._onPanTransitionEnd
          }, this)),
          e.noMoveStart || this.fire("movestart"),
          !1 !== e.animate ? (M(this._mapPane, "leaflet-pan-anim"),
          i = this._getMapPanePos().subtract(t).round(),
          this._panAnim.run(this._mapPane, i, e.duration || .25, e.easeLinearity)) : (this._rawPanBy(t),
          this.fire("move").fire("moveend"))) : this._resetView(this.unproject(this.project(this.getCenter()).add(t)), this.getZoom()),
          this) : this.fire("moveend")
      },
      flyTo: function(n, o, t) {
          if (!1 === (t = t || {}).animate || !b.any3d)
              return this.setView(n, o, t);
          this._stop();
          var s = this.project(this.getCenter())
            , r = this.project(n)
            , e = this.getSize()
            , a = this._zoom
            , h = (n = w(n),
          o = void 0 === o ? a : o,
          Math.max(e.x, e.y))
            , i = h * this.getZoomScale(a, o)
            , l = r.distanceTo(s) || 1
            , u = 1.42
            , c = u * u;
          function d(t) {
              t = (i * i - h * h + (t ? -1 : 1) * c * c * l * l) / (2 * (t ? i : h) * c * l),
              t = Math.sqrt(t * t + 1) - t;
              return t < 1e-9 ? -18 : Math.log(t)
          }
          function _(t) {
              return (Math.exp(t) - Math.exp(-t)) / 2
          }
          function p(t) {
              return (Math.exp(t) + Math.exp(-t)) / 2
          }
          var m = d(0);
          function f(t) {
              return h * (p(m) * (_(t = m + u * t) / p(t)) - _(m)) / c
          }
          var g = Date.now()
            , v = (d(1) - m) / u
            , y = t.duration ? 1e3 * t.duration : 1e3 * v * .8;
          return this._moveStart(!0, t.noMoveStart),
          function t() {
              var e = (Date.now() - g) / y
                , i = (1 - Math.pow(1 - e, 1.5)) * v;
              e <= 1 ? (this._flyToFrame = x(t, this),
              this._move(this.unproject(s.add(r.subtract(s).multiplyBy(f(i) / l)), a), this.getScaleZoom(h / (e = i,
              h * (p(m) / p(m + u * e))), a), {
                  flyTo: !0
              })) : this._move(n, o)._moveEnd(!0)
          }
          .call(this),
          this
      },
      flyToBounds: function(t, e) {
          t = this._getBoundsCenterZoom(t, e);
          return this.flyTo(t.center, t.zoom, e)
      },
      setMaxBounds: function(t) {
          return t = g(t),
          this.listens("moveend", this._panInsideMaxBounds) && this.off("moveend", this._panInsideMaxBounds),
          t.isValid() ? (this.options.maxBounds = t,
          this._loaded && this._panInsideMaxBounds(),
          this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null,
          this)
      },
      setMinZoom: function(t) {
          var e = this.options.minZoom;
          return this.options.minZoom = t,
          this._loaded && e !== t && (this.fire("zoomlevelschange"),
          this.getZoom() < this.options.minZoom) ? this.setZoom(t) : this
      },
      setMaxZoom: function(t) {
          var e = this.options.maxZoom;
          return this.options.maxZoom = t,
          this._loaded && e !== t && (this.fire("zoomlevelschange"),
          this.getZoom() > this.options.maxZoom) ? this.setZoom(t) : this
      },
      panInsideBounds: function(t, e) {
          this._enforcingBounds = !0;
          var i = this.getCenter()
            , t = this._limitCenter(i, this._zoom, g(t));
          return i.equals(t) || this.panTo(t, e),
          this._enforcingBounds = !1,
          this
      },
      panInside: function(t, e) {
          var i = m((e = e || {}).paddingTopLeft || e.padding || [0, 0])
            , n = m(e.paddingBottomRight || e.padding || [0, 0])
            , o = this.project(this.getCenter())
            , t = this.project(t)
            , s = this.getPixelBounds()
            , i = _([s.min.add(i), s.max.subtract(n)])
            , s = i.getSize();
          return i.contains(t) || (this._enforcingBounds = !0,
          n = t.subtract(i.getCenter()),
          i = i.extend(t).getSize().subtract(s),
          o.x += n.x < 0 ? -i.x : i.x,
          o.y += n.y < 0 ? -i.y : i.y,
          this.panTo(this.unproject(o), e),
          this._enforcingBounds = !1),
          this
      },
      invalidateSize: function(t) {
          if (!this._loaded)
              return this;
          t = l({
              animate: !1,
              pan: !0
          }, !0 === t ? {
              animate: !0
          } : t);
          var e = this.getSize()
            , i = (this._sizeChanged = !0,
          this._lastCenter = null,
          this.getSize())
            , n = e.divideBy(2).round()
            , o = i.divideBy(2).round()
            , n = n.subtract(o);
          return n.x || n.y ? (t.animate && t.pan ? this.panBy(n) : (t.pan && this._rawPanBy(n),
          this.fire("move"),
          t.debounceMoveend ? (clearTimeout(this._sizeTimer),
          this._sizeTimer = setTimeout(a(this.fire, this, "moveend"), 200)) : this.fire("moveend")),
          this.fire("resize", {
              oldSize: e,
              newSize: i
          })) : this
      },
      stop: function() {
          return this.setZoom(this._limitZoom(this._zoom)),
          this.options.zoomSnap || this.fire("viewreset"),
          this._stop()
      },
      locate: function(t) {
          var e, i;
          return t = this._locateOptions = l({
              timeout: 1e4,
              watch: !1
          }, t),
          "geolocation"in navigator ? (e = a(this._handleGeolocationResponse, this),
          i = a(this._handleGeolocationError, this),
          t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(e, i, t) : navigator.geolocation.getCurrentPosition(e, i, t)) : this._handleGeolocationError({
              code: 0,
              message: "Geolocation not supported."
          }),
          this
      },
      stopLocate: function() {
          return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId),
          this._locateOptions && (this._locateOptions.setView = !1),
          this
      },
      _handleGeolocationError: function(t) {
          var e;
          this._container._leaflet_id && (e = t.code,
          t = t.message || (1 === e ? "permission denied" : 2 === e ? "position unavailable" : "timeout"),
          this._locateOptions.setView && !this._loaded && this.fitWorld(),
          this.fire("locationerror", {
              code: e,
              message: "Geolocation error: " + t + "."
          }))
      },
      _handleGeolocationResponse: function(t) {
          if (this._container._leaflet_id) {
              var e, i, n = new v(t.coords.latitude,t.coords.longitude), o = n.toBounds(2 * t.coords.accuracy), s = this._locateOptions, r = (s.setView && (e = this.getBoundsZoom(o),
              this.setView(n, s.maxZoom ? Math.min(e, s.maxZoom) : e)),
              {
                  latlng: n,
                  bounds: o,
                  timestamp: t.timestamp
              });
              for (i in t.coords)
                  "number" == typeof t.coords[i] && (r[i] = t.coords[i]);
              this.fire("locationfound", r)
          }
      },
      addHandler: function(t, e) {
          return e && (e = this[t] = new e(this),
          this._handlers.push(e),
          this.options[t] && e.enable()),
          this
      },
      remove: function() {
          if (this._initEvents(!0),
          this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds),
          this._containerId !== this._container._leaflet_id)
              throw new Error("Map container is being reused by another instance");
          try {
              delete this._container._leaflet_id,
              delete this._containerId
          } catch (t) {
              this._container._leaflet_id = void 0,
              this._containerId = void 0
          }
          for (var t in void 0 !== this._locationWatchId && this.stopLocate(),
          this._stop(),
          T(this._mapPane),
          this._clearControlPos && this._clearControlPos(),
          this._resizeRequest && (r(this._resizeRequest),
          this._resizeRequest = null),
          this._clearHandlers(),
          this._loaded && this.fire("unload"),
          this._layers)
              this._layers[t].remove();
          for (t in this._panes)
              T(this._panes[t]);
          return this._layers = [],
          this._panes = [],
          delete this._mapPane,
          delete this._renderer,
          this
      },
      createPane: function(t, e) {
          e = P("div", "leaflet-pane" + (t ? " leaflet-" + t.replace("Pane", "") + "-pane" : ""), e || this._mapPane);
          return t && (this._panes[t] = e),
          e
      },
      getCenter: function() {
          return this._checkIfLoaded(),
          this._lastCenter && !this._moved() ? this._lastCenter.clone() : this.layerPointToLatLng(this._getCenterLayerPoint())
      },
      getZoom: function() {
          return this._zoom
      },
      getBounds: function() {
          var t = this.getPixelBounds();
          return new s(this.unproject(t.getBottomLeft()),this.unproject(t.getTopRight()))
      },
      getMinZoom: function() {
          return void 0 === this.options.minZoom ? this._layersMinZoom || 0 : this.options.minZoom
      },
      getMaxZoom: function() {
          return void 0 === this.options.maxZoom ? void 0 === this._layersMaxZoom ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom
      },
      getBoundsZoom: function(t, e, i) {
          t = g(t),
          i = m(i || [0, 0]);
          var n = this.getZoom() || 0
            , o = this.getMinZoom()
            , s = this.getMaxZoom()
            , r = t.getNorthWest()
            , t = t.getSouthEast()
            , i = this.getSize().subtract(i)
            , t = _(this.project(t, n), this.project(r, n)).getSize()
            , r = b.any3d ? this.options.zoomSnap : 1
            , a = i.x / t.x
            , i = i.y / t.y
            , t = e ? Math.max(a, i) : Math.min(a, i)
            , n = this.getScaleZoom(t, n);
          return r && (n = Math.round(n / (r / 100)) * (r / 100),
          n = e ? Math.ceil(n / r) * r : Math.floor(n / r) * r),
          Math.max(o, Math.min(s, n))
      },
      getSize: function() {
          return this._size && !this._sizeChanged || (this._size = new p(this._container.clientWidth || 0,this._container.clientHeight || 0),
          this._sizeChanged = !1),
          this._size.clone()
      },
      getPixelBounds: function(t, e) {
          t = this._getTopLeftPoint(t, e);
          return new f(t,t.add(this.getSize()))
      },
      getPixelOrigin: function() {
          return this._checkIfLoaded(),
          this._pixelOrigin
      },
      getPixelWorldBounds: function(t) {
          return this.options.crs.getProjectedBounds(void 0 === t ? this.getZoom() : t)
      },
      getPane: function(t) {
          return "string" == typeof t ? this._panes[t] : t
      },
      getPanes: function() {
          return this._panes
      },
      getContainer: function() {
          return this._container
      },
      getZoomScale: function(t, e) {
          var i = this.options.crs;
          return e = void 0 === e ? this._zoom : e,
          i.scale(t) / i.scale(e)
      },
      getScaleZoom: function(t, e) {
          var i = this.options.crs
            , t = (e = void 0 === e ? this._zoom : e,
          i.zoom(t * i.scale(e)));
          return isNaN(t) ? 1 / 0 : t
      },
      project: function(t, e) {
          return e = void 0 === e ? this._zoom : e,
          this.options.crs.latLngToPoint(w(t), e)
      },
      unproject: function(t, e) {
          return e = void 0 === e ? this._zoom : e,
          this.options.crs.pointToLatLng(m(t), e)
      },
      layerPointToLatLng: function(t) {
          t = m(t).add(this.getPixelOrigin());
          return this.unproject(t)
      },
      latLngToLayerPoint: function(t) {
          return this.project(w(t))._round()._subtract(this.getPixelOrigin())
      },
      wrapLatLng: function(t) {
          return this.options.crs.wrapLatLng(w(t))
      },
      wrapLatLngBounds: function(t) {
          return this.options.crs.wrapLatLngBounds(g(t))
      },
      distance: function(t, e) {
          return this.options.crs.distance(w(t), w(e))
      },
      containerPointToLayerPoint: function(t) {
          return m(t).subtract(this._getMapPanePos())
      },
      layerPointToContainerPoint: function(t) {
          return m(t).add(this._getMapPanePos())
      },
      containerPointToLatLng: function(t) {
          t = this.containerPointToLayerPoint(m(t));
          return this.layerPointToLatLng(t)
      },
      latLngToContainerPoint: function(t) {
          return this.layerPointToContainerPoint(this.latLngToLayerPoint(w(t)))
      },
      mouseEventToContainerPoint: function(t) {
          return De(t, this._container)
      },
      mouseEventToLayerPoint: function(t) {
          return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t))
      },
      mouseEventToLatLng: function(t) {
          return this.layerPointToLatLng(this.mouseEventToLayerPoint(t))
      },
      _initContainer: function(t) {
          t = this._container = _e(t);
          if (!t)
              throw new Error("Map container not found.");
          if (t._leaflet_id)
              throw new Error("Map container is already initialized.");
          S(t, "scroll", this._onScroll, this),
          this._containerId = h(t)
      },
      _initLayout: function() {
          var t = this._container
            , e = (this._fadeAnimated = this.options.fadeAnimation && b.any3d,
          M(t, "leaflet-container" + (b.touch ? " leaflet-touch" : "") + (b.retina ? " leaflet-retina" : "") + (b.ielt9 ? " leaflet-oldie" : "") + (b.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : "")),
          pe(t, "position"));
          "absolute" !== e && "relative" !== e && "fixed" !== e && "sticky" !== e && (t.style.position = "relative"),
          this._initPanes(),
          this._initControlPos && this._initControlPos()
      },
      _initPanes: function() {
          var t = this._panes = {};
          this._paneRenderers = {},
          this._mapPane = this.createPane("mapPane", this._container),
          Z(this._mapPane, new p(0,0)),
          this.createPane("tilePane"),
          this.createPane("overlayPane"),
          this.createPane("shadowPane"),
          this.createPane("markerPane"),
          this.createPane("tooltipPane"),
          this.createPane("popupPane"),
          this.options.markerZoomAnimation || (M(t.markerPane, "leaflet-zoom-hide"),
          M(t.shadowPane, "leaflet-zoom-hide"))
      },
      _resetView: function(t, e, i) {
          Z(this._mapPane, new p(0,0));
          var n = !this._loaded
            , o = (this._loaded = !0,
          e = this._limitZoom(e),
          this.fire("viewprereset"),
          this._zoom !== e);
          this._moveStart(o, i)._move(t, e)._moveEnd(o),
          this.fire("viewreset"),
          n && this.fire("load")
      },
      _moveStart: function(t, e) {
          return t && this.fire("zoomstart"),
          e || this.fire("movestart"),
          this
      },
      _move: function(t, e, i, n) {
          void 0 === e && (e = this._zoom);
          var o = this._zoom !== e;
          return this._zoom = e,
          this._lastCenter = t,
          this._pixelOrigin = this._getNewPixelOrigin(t),
          n ? i && i.pinch && this.fire("zoom", i) : ((o || i && i.pinch) && this.fire("zoom", i),
          this.fire("move", i)),
          this
      },
      _moveEnd: function(t) {
          return t && this.fire("zoomend"),
          this.fire("moveend")
      },
      _stop: function() {
          return r(this._flyToFrame),
          this._panAnim && this._panAnim.stop(),
          this
      },
      _rawPanBy: function(t) {
          Z(this._mapPane, this._getMapPanePos().subtract(t))
      },
      _getZoomSpan: function() {
          return this.getMaxZoom() - this.getMinZoom()
      },
      _panInsideMaxBounds: function() {
          this._enforcingBounds || this.panInsideBounds(this.options.maxBounds)
      },
      _checkIfLoaded: function() {
          if (!this._loaded)
              throw new Error("Set map center and zoom first.")
      },
      _initEvents: function(t) {
          this._targets = {};
          var e = t ? k : S;
          e((this._targets[h(this._container)] = this)._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this),
          this.options.trackResize && e(window, "resize", this._onResize, this),
          b.any3d && this.options.transform3DLimit && (t ? this.off : this.on).call(this, "moveend", this._onMoveEnd)
      },
      _onResize: function() {
          r(this._resizeRequest),
          this._resizeRequest = x(function() {
              this.invalidateSize({
                  debounceMoveend: !0
              })
          }, this)
      },
      _onScroll: function() {
          this._container.scrollTop = 0,
          this._container.scrollLeft = 0
      },
      _onMoveEnd: function() {
          var t = this._getMapPanePos();
          Math.max(Math.abs(t.x), Math.abs(t.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom())
      },
      _findEventTargets: function(t, e) {
          for (var i, n = [], o = "mouseout" === e || "mouseover" === e, s = t.target || t.srcElement, r = !1; s; ) {
              if ((i = this._targets[h(s)]) && ("click" === e || "preclick" === e) && this._draggableMoved(i)) {
                  r = !0;
                  break
              }
              if (i && i.listens(e, !0)) {
                  if (o && !We(s, t))
                      break;
                  if (n.push(i),
                  o)
                      break
              }
              if (s === this._container)
                  break;
              s = s.parentNode
          }
          return n = n.length || r || o || !this.listens(e, !0) ? n : [this]
      },
      _isClickDisabled: function(t) {
          for (; t && t !== this._container; ) {
              if (t._leaflet_disable_click)
                  return !0;
              t = t.parentNode
          }
      },
      _handleDOMEvent: function(t) {
          var e, i = t.target || t.srcElement;
          !this._loaded || i._leaflet_disable_events || "click" === t.type && this._isClickDisabled(i) || ("mousedown" === (e = t.type) && Me(i),
          this._fireDOMEvent(t, e))
      },
      _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"],
      _fireDOMEvent: function(t, e, i) {
          "click" === t.type && ((a = l({}, t)).type = "preclick",
          this._fireDOMEvent(a, a.type, i));
          var n = this._findEventTargets(t, e);
          if (i) {
              for (var o = [], s = 0; s < i.length; s++)
                  i[s].listens(e, !0) && o.push(i[s]);
              n = o.concat(n)
          }
          if (n.length) {
              "contextmenu" === e && O(t);
              var r, a = n[0], h = {
                  originalEvent: t
              };
              for ("keypress" !== t.type && "keydown" !== t.type && "keyup" !== t.type && (r = a.getLatLng && (!a._radius || a._radius <= 10),
              h.containerPoint = r ? this.latLngToContainerPoint(a.getLatLng()) : this.mouseEventToContainerPoint(t),
              h.layerPoint = this.containerPointToLayerPoint(h.containerPoint),
              h.latlng = r ? a.getLatLng() : this.layerPointToLatLng(h.layerPoint)),
              s = 0; s < n.length; s++)
                  if (n[s].fire(e, h, !0),
                  h.originalEvent._stopped || !1 === n[s].options.bubblingMouseEvents && -1 !== G(this._mouseEvents, e))
                      return
          }
      },
      _draggableMoved: function(t) {
          return (t = t.dragging && t.dragging.enabled() ? t : this).dragging && t.dragging.moved() || this.boxZoom && this.boxZoom.moved()
      },
      _clearHandlers: function() {
          for (var t = 0, e = this._handlers.length; t < e; t++)
              this._handlers[t].disable()
      },
      whenReady: function(t, e) {
          return this._loaded ? t.call(e || this, {
              target: this
          }) : this.on("load", t, e),
          this
      },
      _getMapPanePos: function() {
          return Pe(this._mapPane) || new p(0,0)
      },
      _moved: function() {
          var t = this._getMapPanePos();
          return t && !t.equals([0, 0])
      },
      _getTopLeftPoint: function(t, e) {
          return (t && void 0 !== e ? this._getNewPixelOrigin(t, e) : this.getPixelOrigin()).subtract(this._getMapPanePos())
      },
      _getNewPixelOrigin: function(t, e) {
          var i = this.getSize()._divideBy(2);
          return this.project(t, e)._subtract(i)._add(this._getMapPanePos())._round()
      },
      _latLngToNewLayerPoint: function(t, e, i) {
          i = this._getNewPixelOrigin(i, e);
          return this.project(t, e)._subtract(i)
      },
      _latLngBoundsToNewLayerBounds: function(t, e, i) {
          i = this._getNewPixelOrigin(i, e);
          return _([this.project(t.getSouthWest(), e)._subtract(i), this.project(t.getNorthWest(), e)._subtract(i), this.project(t.getSouthEast(), e)._subtract(i), this.project(t.getNorthEast(), e)._subtract(i)])
      },
      _getCenterLayerPoint: function() {
          return this.containerPointToLayerPoint(this.getSize()._divideBy(2))
      },
      _getCenterOffset: function(t) {
          return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint())
      },
      _limitCenter: function(t, e, i) {
          var n, o;
          return !i || (n = this.project(t, e),
          o = this.getSize().divideBy(2),
          o = new f(n.subtract(o),n.add(o)),
          o = this._getBoundsOffset(o, i, e),
          Math.abs(o.x) <= 1 && Math.abs(o.y) <= 1) ? t : this.unproject(n.add(o), e)
      },
      _limitOffset: function(t, e) {
          var i;
          return e ? (i = new f((i = this.getPixelBounds()).min.add(t),i.max.add(t)),
          t.add(this._getBoundsOffset(i, e))) : t
      },
      _getBoundsOffset: function(t, e, i) {
          e = _(this.project(e.getNorthEast(), i), this.project(e.getSouthWest(), i)),
          i = e.min.subtract(t.min),
          e = e.max.subtract(t.max);
          return new p(this._rebound(i.x, -e.x),this._rebound(i.y, -e.y))
      },
      _rebound: function(t, e) {
          return 0 < t + e ? Math.round(t - e) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(e))
      },
      _limitZoom: function(t) {
          var e = this.getMinZoom()
            , i = this.getMaxZoom()
            , n = b.any3d ? this.options.zoomSnap : 1;
          return n && (t = Math.round(t / n) * n),
          Math.max(e, Math.min(i, t))
      },
      _onPanTransitionStep: function() {
          this.fire("move")
      },
      _onPanTransitionEnd: function() {
          z(this._mapPane, "leaflet-pan-anim"),
          this.fire("moveend")
      },
      _tryAnimatedPan: function(t, e) {
          t = this._getCenterOffset(t)._trunc();
          return !(!0 !== (e && e.animate) && !this.getSize().contains(t)) && (this.panBy(t, e),
          !0)
      },
      _createAnimProxy: function() {
          var t = this._proxy = P("div", "leaflet-proxy leaflet-zoom-animated");
          this._panes.mapPane.appendChild(t),
          this.on("zoomanim", function(t) {
              var e = ue
                , i = this._proxy.style[e];
              be(this._proxy, this.project(t.center, t.zoom), this.getZoomScale(t.zoom, 1)),
              i === this._proxy.style[e] && this._animatingZoom && this._onZoomTransitionEnd()
          }, this),
          this.on("load moveend", this._animMoveEnd, this),
          this._on("unload", this._destroyAnimProxy, this)
      },
      _destroyAnimProxy: function() {
          T(this._proxy),
          this.off("load moveend", this._animMoveEnd, this),
          delete this._proxy
      },
      _animMoveEnd: function() {
          var t = this.getCenter()
            , e = this.getZoom();
          be(this._proxy, this.project(t, e), this.getZoomScale(e, 1))
      },
      _catchTransitionEnd: function(t) {
          this._animatingZoom && 0 <= t.propertyName.indexOf("transform") && this._onZoomTransitionEnd()
      },
      _nothingToAnimate: function() {
          return !this._container.getElementsByClassName("leaflet-zoom-animated").length
      },
      _tryAnimatedZoom: function(t, e, i) {
          if (!this._animatingZoom) {
              if (i = i || {},
              !this._zoomAnimated || !1 === i.animate || this._nothingToAnimate() || Math.abs(e - this._zoom) > this.options.zoomAnimationThreshold)
                  return !1;
              var n = this.getZoomScale(e)
                , n = this._getCenterOffset(t)._divideBy(1 - 1 / n);
              if (!0 !== i.animate && !this.getSize().contains(n))
                  return !1;
              x(function() {
                  this._moveStart(!0, i.noMoveStart || !1)._animateZoom(t, e, !0)
              }, this)
          }
          return !0
      },
      _animateZoom: function(t, e, i, n) {
          this._mapPane && (i && (this._animatingZoom = !0,
          this._animateToCenter = t,
          this._animateToZoom = e,
          M(this._mapPane, "leaflet-zoom-anim")),
          this.fire("zoomanim", {
              center: t,
              zoom: e,
              noUpdate: n
          }),
          this._tempFireZoomEvent || (this._tempFireZoomEvent = this._zoom !== this._animateToZoom),
          this._move(this._animateToCenter, this._animateToZoom, void 0, !0),
          setTimeout(a(this._onZoomTransitionEnd, this), 250))
      },
      _onZoomTransitionEnd: function() {
          this._animatingZoom && (this._mapPane && z(this._mapPane, "leaflet-zoom-anim"),
          this._animatingZoom = !1,
          this._move(this._animateToCenter, this._animateToZoom, void 0, !0),
          this._tempFireZoomEvent && this.fire("zoom"),
          delete this._tempFireZoomEvent,
          this.fire("move"),
          this._moveEnd(!0))
      }
  });
  function Ue(t) {
      return new B(t)
  }
  var B = et.extend({
      options: {
          position: "topright"
      },
      initialize: function(t) {
          c(this, t)
      },
      getPosition: function() {
          return this.options.position
      },
      setPosition: function(t) {
          var e = this._map;
          return e && e.removeControl(this),
          this.options.position = t,
          e && e.addControl(this),
          this
      },
      getContainer: function() {
          return this._container
      },
      addTo: function(t) {
          this.remove(),
          this._map = t;
          var e = this._container = this.onAdd(t)
            , i = this.getPosition()
            , t = t._controlCorners[i];
          return M(e, "leaflet-control"),
          -1 !== i.indexOf("bottom") ? t.insertBefore(e, t.firstChild) : t.appendChild(e),
          this._map.on("unload", this.remove, this),
          this
      },
      remove: function() {
          return this._map && (T(this._container),
          this.onRemove && this.onRemove(this._map),
          this._map.off("unload", this.remove, this),
          this._map = null),
          this
      },
      _refocusOnMap: function(t) {
          this._map && t && 0 < t.screenX && 0 < t.screenY && this._map.getContainer().focus()
      }
  })
    , Ve = (A.include({
      addControl: function(t) {
          return t.addTo(this),
          this
      },
      removeControl: function(t) {
          return t.remove(),
          this
      },
      _initControlPos: function() {
          var i = this._controlCorners = {}
            , n = "leaflet-"
            , o = this._controlContainer = P("div", n + "control-container", this._container);
          function t(t, e) {
              i[t + e] = P("div", n + t + " " + n + e, o)
          }
          t("top", "left"),
          t("top", "right"),
          t("bottom", "left"),
          t("bottom", "right")
      },
      _clearControlPos: function() {
          for (var t in this._controlCorners)
              T(this._controlCorners[t]);
          T(this._controlContainer),
          delete this._controlCorners,
          delete this._controlContainer
      }
  }),
  B.extend({
      options: {
          collapsed: !0,
          position: "topright",
          autoZIndex: !0,
          hideSingleBase: !1,
          sortLayers: !1,
          sortFunction: function(t, e, i, n) {
              return i < n ? -1 : n < i ? 1 : 0
          }
      },
      initialize: function(t, e, i) {
          for (var n in c(this, i),
          this._layerControlInputs = [],
          this._layers = [],
          this._lastZIndex = 0,
          this._handlingClick = !1,
          this._preventClick = !1,
          t)
              this._addLayer(t[n], n);
          for (n in e)
              this._addLayer(e[n], n, !0)
      },
      onAdd: function(t) {
          this._initLayout(),
          this._update(),
          (this._map = t).on("zoomend", this._checkDisabledLayers, this);
          for (var e = 0; e < this._layers.length; e++)
              this._layers[e].layer.on("add remove", this._onLayerChange, this);
          return this._container
      },
      addTo: function(t) {
          return B.prototype.addTo.call(this, t),
          this._expandIfNotCollapsed()
      },
      onRemove: function() {
          this._map.off("zoomend", this._checkDisabledLayers, this);
          for (var t = 0; t < this._layers.length; t++)
              this._layers[t].layer.off("add remove", this._onLayerChange, this)
      },
      addBaseLayer: function(t, e) {
          return this._addLayer(t, e),
          this._map ? this._update() : this
      },
      addOverlay: function(t, e) {
          return this._addLayer(t, e, !0),
          this._map ? this._update() : this
      },
      removeLayer: function(t) {
          t.off("add remove", this._onLayerChange, this);
          t = this._getLayer(h(t));
          return t && this._layers.splice(this._layers.indexOf(t), 1),
          this._map ? this._update() : this
      },
      expand: function() {
          M(this._container, "leaflet-control-layers-expanded"),
          this._section.style.height = null;
          var t = this._map.getSize().y - (this._container.offsetTop + 50);
          return t < this._section.clientHeight ? (M(this._section, "leaflet-control-layers-scrollbar"),
          this._section.style.height = t + "px") : z(this._section, "leaflet-control-layers-scrollbar"),
          this._checkDisabledLayers(),
          this
      },
      collapse: function() {
          return z(this._container, "leaflet-control-layers-expanded"),
          this
      },
      _initLayout: function() {
          var t = "leaflet-control-layers"
            , e = this._container = P("div", t)
            , i = this.options.collapsed
            , n = (e.setAttribute("aria-haspopup", !0),
          Ie(e),
          Be(e),
          this._section = P("section", t + "-list"))
            , o = (i && (this._map.on("click", this.collapse, this),
          S(e, {
              mouseenter: this._expandSafely,
              mouseleave: this.collapse
          }, this)),
          this._layersLink = P("a", t + "-toggle", e));
          o.href = "#",
          o.title = "Layers",
          o.setAttribute("role", "button"),
          S(o, {
              keydown: function(t) {
                  13 === t.keyCode && this._expandSafely()
              },
              click: function(t) {
                  O(t),
                  this._expandSafely()
              }
          }, this),
          i || this.expand(),
          this._baseLayersList = P("div", t + "-base", n),
          this._separator = P("div", t + "-separator", n),
          this._overlaysList = P("div", t + "-overlays", n),
          e.appendChild(n)
      },
      _getLayer: function(t) {
          for (var e = 0; e < this._layers.length; e++)
              if (this._layers[e] && h(this._layers[e].layer) === t)
                  return this._layers[e]
      },
      _addLayer: function(t, e, i) {
          this._map && t.on("add remove", this._onLayerChange, this),
          this._layers.push({
              layer: t,
              name: e,
              overlay: i
          }),
          this.options.sortLayers && this._layers.sort(a(function(t, e) {
              return this.options.sortFunction(t.layer, e.layer, t.name, e.name)
          }, this)),
          this.options.autoZIndex && t.setZIndex && (this._lastZIndex++,
          t.setZIndex(this._lastZIndex)),
          this._expandIfNotCollapsed()
      },
      _update: function() {
          if (this._container) {
              me(this._baseLayersList),
              me(this._overlaysList),
              this._layerControlInputs = [];
              for (var t, e, i, n = 0, o = 0; o < this._layers.length; o++)
                  i = this._layers[o],
                  this._addItem(i),
                  e = e || i.overlay,
                  t = t || !i.overlay,
                  n += i.overlay ? 0 : 1;
              this.options.hideSingleBase && (this._baseLayersList.style.display = (t = t && 1 < n) ? "" : "none"),
              this._separator.style.display = e && t ? "" : "none"
          }
          return this
      },
      _onLayerChange: function(t) {
          this._handlingClick || this._update();
          var e = this._getLayer(h(t.target))
            , t = e.overlay ? "add" === t.type ? "overlayadd" : "overlayremove" : "add" === t.type ? "baselayerchange" : null;
          t && this._map.fire(t, e)
      },
      _createRadioElement: function(t, e) {
          t = '<input type="radio" class="leaflet-control-layers-selector" name="' + t + '"' + (e ? ' checked="checked"' : "") + "/>",
          e = document.createElement("div");
          return e.innerHTML = t,
          e.firstChild
      },
      _addItem: function(t) {
          var e, i = document.createElement("label"), n = this._map.hasLayer(t.layer), n = (t.overlay ? ((e = document.createElement("input")).type = "checkbox",
          e.className = "leaflet-control-layers-selector",
          e.defaultChecked = n) : e = this._createRadioElement("leaflet-base-layers_" + h(this), n),
          this._layerControlInputs.push(e),
          e.layerId = h(t.layer),
          S(e, "click", this._onInputClick, this),
          document.createElement("span")), o = (n.innerHTML = " " + t.name,
          document.createElement("span"));
          return i.appendChild(o),
          o.appendChild(e),
          o.appendChild(n),
          (t.overlay ? this._overlaysList : this._baseLayersList).appendChild(i),
          this._checkDisabledLayers(),
          i
      },
      _onInputClick: function() {
          if (!this._preventClick) {
              var t, e, i = this._layerControlInputs, n = [], o = [];
              this._handlingClick = !0;
              for (var s = i.length - 1; 0 <= s; s--)
                  t = i[s],
                  e = this._getLayer(t.layerId).layer,
                  t.checked ? n.push(e) : t.checked || o.push(e);
              for (s = 0; s < o.length; s++)
                  this._map.hasLayer(o[s]) && this._map.removeLayer(o[s]);
              for (s = 0; s < n.length; s++)
                  this._map.hasLayer(n[s]) || this._map.addLayer(n[s]);
              this._handlingClick = !1,
              this._refocusOnMap()
          }
      },
      _checkDisabledLayers: function() {
          for (var t, e, i = this._layerControlInputs, n = this._map.getZoom(), o = i.length - 1; 0 <= o; o--)
              t = i[o],
              e = this._getLayer(t.layerId).layer,
              t.disabled = void 0 !== e.options.minZoom && n < e.options.minZoom || void 0 !== e.options.maxZoom && n > e.options.maxZoom
      },
      _expandIfNotCollapsed: function() {
          return this._map && !this.options.collapsed && this.expand(),
          this
      },
      _expandSafely: function() {
          var t = this._section
            , e = (this._preventClick = !0,
          S(t, "click", O),
          this.expand(),
          this);
          setTimeout(function() {
              k(t, "click", O),
              e._preventClick = !1
          })
      }
  }))
    , qe = B.extend({
      options: {
          position: "topleft",
          zoomInText: '<span aria-hidden="true">+</span>',
          zoomInTitle: "Zoom in",
          zoomOutText: '<span aria-hidden="true">&#x2212;</span>',
          zoomOutTitle: "Zoom out"
      },
      onAdd: function(t) {
          var e = "leaflet-control-zoom"
            , i = P("div", e + " leaflet-bar")
            , n = this.options;
          return this._zoomInButton = this._createButton(n.zoomInText, n.zoomInTitle, e + "-in", i, this._zoomIn),
          this._zoomOutButton = this._createButton(n.zoomOutText, n.zoomOutTitle, e + "-out", i, this._zoomOut),
          this._updateDisabled(),
          t.on("zoomend zoomlevelschange", this._updateDisabled, this),
          i
      },
      onRemove: function(t) {
          t.off("zoomend zoomlevelschange", this._updateDisabled, this)
      },
      disable: function() {
          return this._disabled = !0,
          this._updateDisabled(),
          this
      },
      enable: function() {
          return this._disabled = !1,
          this._updateDisabled(),
          this
      },
      _zoomIn: function(t) {
          !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1))
      },
      _zoomOut: function(t) {
          !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1))
      },
      _createButton: function(t, e, i, n, o) {
          i = P("a", i, n);
          return i.innerHTML = t,
          i.href = "#",
          i.title = e,
          i.setAttribute("role", "button"),
          i.setAttribute("aria-label", e),
          Ie(i),
          S(i, "click", Re),
          S(i, "click", o, this),
          S(i, "click", this._refocusOnMap, this),
          i
      },
      _updateDisabled: function() {
          var t = this._map
            , e = "leaflet-disabled";
          z(this._zoomInButton, e),
          z(this._zoomOutButton, e),
          this._zoomInButton.setAttribute("aria-disabled", "false"),
          this._zoomOutButton.setAttribute("aria-disabled", "false"),
          !this._disabled && t._zoom !== t.getMinZoom() || (M(this._zoomOutButton, e),
          this._zoomOutButton.setAttribute("aria-disabled", "true")),
          !this._disabled && t._zoom !== t.getMaxZoom() || (M(this._zoomInButton, e),
          this._zoomInButton.setAttribute("aria-disabled", "true"))
      }
  })
    , Ge = (A.mergeOptions({
      zoomControl: !0
  }),
  A.addInitHook(function() {
      this.options.zoomControl && (this.zoomControl = new qe,
      this.addControl(this.zoomControl))
  }),
  B.extend({
      options: {
          position: "bottomleft",
          maxWidth: 100,
          metric: !0,
          imperial: !0
      },
      onAdd: function(t) {
          var e = "leaflet-control-scale"
            , i = P("div", e)
            , n = this.options;
          return this._addScales(n, e + "-line", i),
          t.on(n.updateWhenIdle ? "moveend" : "move", this._update, this),
          t.whenReady(this._update, this),
          i
      },
      onRemove: function(t) {
          t.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this)
      },
      _addScales: function(t, e, i) {
          t.metric && (this._mScale = P("div", e, i)),
          t.imperial && (this._iScale = P("div", e, i))
      },
      _update: function() {
          var t = this._map
            , e = t.getSize().y / 2
            , t = t.distance(t.containerPointToLatLng([0, e]), t.containerPointToLatLng([this.options.maxWidth, e]));
          this._updateScales(t)
      },
      _updateScales: function(t) {
          this.options.metric && t && this._updateMetric(t),
          this.options.imperial && t && this._updateImperial(t)
      },
      _updateMetric: function(t) {
          var e = this._getRoundNum(t);
          this._updateScale(this._mScale, e < 1e3 ? e + " m" : e / 1e3 + " km", e / t)
      },
      _updateImperial: function(t) {
          var e, i, t = 3.2808399 * t;
          5280 < t ? (i = this._getRoundNum(e = t / 5280),
          this._updateScale(this._iScale, i + " mi", i / e)) : (i = this._getRoundNum(t),
          this._updateScale(this._iScale, i + " ft", i / t))
      },
      _updateScale: function(t, e, i) {
          t.style.width = Math.round(this.options.maxWidth * i) + "px",
          t.innerHTML = e
      },
      _getRoundNum: function(t) {
          var e = Math.pow(10, (Math.floor(t) + "").length - 1)
            , t = t / e;
          return e * (t = 10 <= t ? 10 : 5 <= t ? 5 : 3 <= t ? 3 : 2 <= t ? 2 : 1)
      }
  }))
    , Ke = B.extend({
      options: {
          position: "bottomright",
          prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (b.inlineSvg ? '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg> ' : "") + "Leaflet</a>"
      },
      initialize: function(t) {
          c(this, t),
          this._attributions = {}
      },
      onAdd: function(t) {
          for (var e in (t.attributionControl = this)._container = P("div", "leaflet-control-attribution"),
          Ie(this._container),
          t._layers)
              t._layers[e].getAttribution && this.addAttribution(t._layers[e].getAttribution());
          return this._update(),
          t.on("layeradd", this._addAttribution, this),
          this._container
      },
      onRemove: function(t) {
          t.off("layeradd", this._addAttribution, this)
      },
      _addAttribution: function(t) {
          t.layer.getAttribution && (this.addAttribution(t.layer.getAttribution()),
          t.layer.once("remove", function() {
              this.removeAttribution(t.layer.getAttribution())
          }, this))
      },
      setPrefix: function(t) {
          return this.options.prefix = t,
          this._update(),
          this
      },
      addAttribution: function(t) {
          return t && (this._attributions[t] || (this._attributions[t] = 0),
          this._attributions[t]++,
          this._update()),
          this
      },
      removeAttribution: function(t) {
          return t && this._attributions[t] && (this._attributions[t]--,
          this._update()),
          this
      },
      _update: function() {
          if (this._map) {
              var t, e = [];
              for (t in this._attributions)
                  this._attributions[t] && e.push(t);
              var i = [];
              this.options.prefix && i.push(this.options.prefix),
              e.length && i.push(e.join(", ")),
              this._container.innerHTML = i.join(' <span aria-hidden="true">|</span> ')
          }
      }
  })
    , n = (A.mergeOptions({
      attributionControl: !0
  }),
  A.addInitHook(function() {
      this.options.attributionControl && (new Ke).addTo(this)
  }),
  B.Layers = Ve,
  B.Zoom = qe,
  B.Scale = Ge,
  B.Attribution = Ke,
  Ue.layers = function(t, e, i) {
      return new Ve(t,e,i)
  }
  ,
  Ue.zoom = function(t) {
      return new qe(t)
  }
  ,
  Ue.scale = function(t) {
      return new Ge(t)
  }
  ,
  Ue.attribution = function(t) {
      return new Ke(t)
  }
  ,
  et.extend({
      initialize: function(t) {
          this._map = t
      },
      enable: function() {
          return this._enabled || (this._enabled = !0,
          this.addHooks()),
          this
      },
      disable: function() {
          return this._enabled && (this._enabled = !1,
          this.removeHooks()),
          this
      },
      enabled: function() {
          return !!this._enabled
      }
  }))
    , ft = (n.addTo = function(t, e) {
      return t.addHandler(e, this),
      this
  }
  ,
  {
      Events: e
  })
    , Ye = b.touch ? "touchstart mousedown" : "mousedown"
    , Xe = it.extend({
      options: {
          clickTolerance: 3
      },
      initialize: function(t, e, i, n) {
          c(this, n),
          this._element = t,
          this._dragStartTarget = e || t,
          this._preventOutline = i
      },
      enable: function() {
          this._enabled || (S(this._dragStartTarget, Ye, this._onDown, this),
          this._enabled = !0)
      },
      disable: function() {
          this._enabled && (Xe._dragging === this && this.finishDrag(!0),
          k(this._dragStartTarget, Ye, this._onDown, this),
          this._enabled = !1,
          this._moved = !1)
      },
      _onDown: function(t) {
          var e, i;
          this._enabled && (this._moved = !1,
          ve(this._element, "leaflet-zoom-anim") || (t.touches && 1 !== t.touches.length ? Xe._dragging === this && this.finishDrag() : Xe._dragging || t.shiftKey || 1 !== t.which && 1 !== t.button && !t.touches || ((Xe._dragging = this)._preventOutline && Me(this._element),
          Le(),
          re(),
          this._moving || (this.fire("down"),
          i = t.touches ? t.touches[0] : t,
          e = Ce(this._element),
          this._startPoint = new p(i.clientX,i.clientY),
          this._startPos = Pe(this._element),
          this._parentScale = Ze(e),
          i = "mousedown" === t.type,
          S(document, i ? "mousemove" : "touchmove", this._onMove, this),
          S(document, i ? "mouseup" : "touchend touchcancel", this._onUp, this)))))
      },
      _onMove: function(t) {
          var e;
          this._enabled && (t.touches && 1 < t.touches.length ? this._moved = !0 : !(e = new p((e = t.touches && 1 === t.touches.length ? t.touches[0] : t).clientX,e.clientY)._subtract(this._startPoint)).x && !e.y || Math.abs(e.x) + Math.abs(e.y) < this.options.clickTolerance || (e.x /= this._parentScale.x,
          e.y /= this._parentScale.y,
          O(t),
          this._moved || (this.fire("dragstart"),
          this._moved = !0,
          M(document.body, "leaflet-dragging"),
          this._lastTarget = t.target || t.srcElement,
          window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement),
          M(this._lastTarget, "leaflet-drag-target")),
          this._newPos = this._startPos.add(e),
          this._moving = !0,
          this._lastEvent = t,
          this._updatePosition()))
      },
      _updatePosition: function() {
          var t = {
              originalEvent: this._lastEvent
          };
          this.fire("predrag", t),
          Z(this._element, this._newPos),
          this.fire("drag", t)
      },
      _onUp: function() {
          this._enabled && this.finishDrag()
      },
      finishDrag: function(t) {
          z(document.body, "leaflet-dragging"),
          this._lastTarget && (z(this._lastTarget, "leaflet-drag-target"),
          this._lastTarget = null),
          k(document, "mousemove touchmove", this._onMove, this),
          k(document, "mouseup touchend touchcancel", this._onUp, this),
          Te(),
          ae();
          var e = this._moved && this._moving;
          this._moving = !1,
          Xe._dragging = !1,
          e && this.fire("dragend", {
              noInertia: t,
              distance: this._newPos.distanceTo(this._startPos)
          })
      }
  });
  function Je(t, e, i) {
      for (var n, o, s, r, a, h, l, u = [1, 4, 2, 8], c = 0, d = t.length; c < d; c++)
          t[c]._code = si(t[c], e);
      for (s = 0; s < 4; s++) {
          for (h = u[s],
          n = [],
          c = 0,
          o = (d = t.length) - 1; c < d; o = c++)
              r = t[c],
              a = t[o],
              r._code & h ? a._code & h || ((l = oi(a, r, h, e, i))._code = si(l, e),
              n.push(l)) : (a._code & h && ((l = oi(a, r, h, e, i))._code = si(l, e),
              n.push(l)),
              n.push(r));
          t = n
      }
      return t
  }
  function $e(t, e) {
      var i, n, o, s, r, a, h;
      if (!t || 0 === t.length)
          throw new Error("latlngs not passed");
      I(t) || (console.warn("latlngs are not flat! Only the first ring will be used"),
      t = t[0]);
      for (var l = w([0, 0]), u = g(t), c = (u.getNorthWest().distanceTo(u.getSouthWest()) * u.getNorthEast().distanceTo(u.getNorthWest()) < 1700 && (l = Qe(t)),
      t.length), d = [], _ = 0; _ < c; _++) {
          var p = w(t[_]);
          d.push(e.project(w([p.lat - l.lat, p.lng - l.lng])))
      }
      for (_ = r = a = h = 0,
      i = c - 1; _ < c; i = _++)
          n = d[_],
          o = d[i],
          s = n.y * o.x - o.y * n.x,
          a += (n.x + o.x) * s,
          h += (n.y + o.y) * s,
          r += 3 * s;
      u = 0 === r ? d[0] : [a / r, h / r],
      u = e.unproject(m(u));
      return w([u.lat + l.lat, u.lng + l.lng])
  }
  function Qe(t) {
      for (var e = 0, i = 0, n = 0, o = 0; o < t.length; o++) {
          var s = w(t[o]);
          e += s.lat,
          i += s.lng,
          n++
      }
      return w([e / n, i / n])
  }
  var ti, gt = {
      __proto__: null,
      clipPolygon: Je,
      polygonCenter: $e,
      centroid: Qe
  };
  function ei(t, e) {
      if (e && t.length) {
          var i = t = function(t, e) {
              for (var i = [t[0]], n = 1, o = 0, s = t.length; n < s; n++)
                  (function(t, e) {
                      var i = e.x - t.x
                        , e = e.y - t.y;
                      return i * i + e * e
                  }
                  )(t[n], t[o]) > e && (i.push(t[n]),
                  o = n);
              o < s - 1 && i.push(t[s - 1]);
              return i
          }(t, e = e * e)
            , n = i.length
            , o = new (typeof Uint8Array != void 0 + "" ? Uint8Array : Array)(n);
          o[0] = o[n - 1] = 1,
          function t(e, i, n, o, s) {
              var r, a, h, l = 0;
              for (a = o + 1; a <= s - 1; a++)
                  h = ri(e[a], e[o], e[s], !0),
                  l < h && (r = a,
                  l = h);
              n < l && (i[r] = 1,
              t(e, i, n, o, r),
              t(e, i, n, r, s))
          }(i, o, e, 0, n - 1);
          var s, r = [];
          for (s = 0; s < n; s++)
              o[s] && r.push(i[s]);
          return r
      }
      return t.slice()
  }
  function ii(t, e, i) {
      return Math.sqrt(ri(t, e, i, !0))
  }
  function ni(t, e, i, n, o) {
      var s, r, a, h = n ? ti : si(t, i), l = si(e, i);
      for (ti = l; ; ) {
          if (!(h | l))
              return [t, e];
          if (h & l)
              return !1;
          a = si(r = oi(t, e, s = h || l, i, o), i),
          s === h ? (t = r,
          h = a) : (e = r,
          l = a)
      }
  }
  function oi(t, e, i, n, o) {
      var s, r, a = e.x - t.x, e = e.y - t.y, h = n.min, n = n.max;
      return 8 & i ? (s = t.x + a * (n.y - t.y) / e,
      r = n.y) : 4 & i ? (s = t.x + a * (h.y - t.y) / e,
      r = h.y) : 2 & i ? (s = n.x,
      r = t.y + e * (n.x - t.x) / a) : 1 & i && (s = h.x,
      r = t.y + e * (h.x - t.x) / a),
      new p(s,r,o)
  }
  function si(t, e) {
      var i = 0;
      return t.x < e.min.x ? i |= 1 : t.x > e.max.x && (i |= 2),
      t.y < e.min.y ? i |= 4 : t.y > e.max.y && (i |= 8),
      i
  }
  function ri(t, e, i, n) {
      var o = e.x
        , e = e.y
        , s = i.x - o
        , r = i.y - e
        , a = s * s + r * r;
      return 0 < a && (1 < (a = ((t.x - o) * s + (t.y - e) * r) / a) ? (o = i.x,
      e = i.y) : 0 < a && (o += s * a,
      e += r * a)),
      s = t.x - o,
      r = t.y - e,
      n ? s * s + r * r : new p(o,e)
  }
  function I(t) {
      return !d(t[0]) || "object" != typeof t[0][0] && void 0 !== t[0][0]
  }
  function ai(t) {
      return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."),
      I(t)
  }
  function hi(t, e) {
      var i, n, o, s, r, a;
      if (!t || 0 === t.length)
          throw new Error("latlngs not passed");
      I(t) || (console.warn("latlngs are not flat! Only the first ring will be used"),
      t = t[0]);
      for (var h = w([0, 0]), l = g(t), u = (l.getNorthWest().distanceTo(l.getSouthWest()) * l.getNorthEast().distanceTo(l.getNorthWest()) < 1700 && (h = Qe(t)),
      t.length), c = [], d = 0; d < u; d++) {
          var _ = w(t[d]);
          c.push(e.project(w([_.lat - h.lat, _.lng - h.lng])))
      }
      for (i = d = 0; d < u - 1; d++)
          i += c[d].distanceTo(c[d + 1]) / 2;
      if (0 === i)
          a = c[0];
      else
          for (n = d = 0; d < u - 1; d++)
              if (o = c[d],
              s = c[d + 1],
              i < (n += r = o.distanceTo(s))) {
                  a = [s.x - (r = (n - i) / r) * (s.x - o.x), s.y - r * (s.y - o.y)];
                  break
              }
      l = e.unproject(m(a));
      return w([l.lat + h.lat, l.lng + h.lng])
  }
  var vt = {
      __proto__: null,
      simplify: ei,
      pointToSegmentDistance: ii,
      closestPointOnSegment: function(t, e, i) {
          return ri(t, e, i)
      },
      clipSegment: ni,
      _getEdgeIntersection: oi,
      _getBitCode: si,
      _sqClosestPointOnSegment: ri,
      isFlat: I,
      _flat: ai,
      polylineCenter: hi
  }
    , yt = {
      project: function(t) {
          return new p(t.lng,t.lat)
      },
      unproject: function(t) {
          return new v(t.y,t.x)
      },
      bounds: new f([-180, -90],[180, 90])
  }
    , xt = {
      R: 6378137,
      R_MINOR: 6356752.314245179,
      bounds: new f([-20037508.34279, -15496570.73972],[20037508.34279, 18764656.23138]),
      project: function(t) {
          var e = Math.PI / 180
            , i = this.R
            , n = t.lat * e
            , o = this.R_MINOR / i
            , o = Math.sqrt(1 - o * o)
            , s = o * Math.sin(n)
            , s = Math.tan(Math.PI / 4 - n / 2) / Math.pow((1 - s) / (1 + s), o / 2)
            , n = -i * Math.log(Math.max(s, 1e-10));
          return new p(t.lng * e * i,n)
      },
      unproject: function(t) {
          for (var e, i = 180 / Math.PI, n = this.R, o = this.R_MINOR / n, s = Math.sqrt(1 - o * o), r = Math.exp(-t.y / n), a = Math.PI / 2 - 2 * Math.atan(r), h = 0, l = .1; h < 15 && 1e-7 < Math.abs(l); h++)
              e = s * Math.sin(a),
              e = Math.pow((1 - e) / (1 + e), s / 2),
              a += l = Math.PI / 2 - 2 * Math.atan(r * e) - a;
          return new v(a * i,t.x * i / n)
      }
  }
    , wt = {
      __proto__: null,
      LonLat: yt,
      Mercator: xt,
      SphericalMercator: rt
  }
    , Pt = l({}, st, {
      code: "EPSG:3395",
      projection: xt,
      transformation: ht(bt = .5 / (Math.PI * xt.R), .5, -bt, .5)
  })
    , li = l({}, st, {
      code: "EPSG:4326",
      projection: yt,
      transformation: ht(1 / 180, 1, -1 / 180, .5)
  })
    , Lt = l({}, ot, {
      projection: yt,
      transformation: ht(1, 0, -1, 0),
      scale: function(t) {
          return Math.pow(2, t)
      },
      zoom: function(t) {
          return Math.log(t) / Math.LN2
      },
      distance: function(t, e) {
          var i = e.lng - t.lng
            , e = e.lat - t.lat;
          return Math.sqrt(i * i + e * e)
      },
      infinite: !0
  })
    , o = (ot.Earth = st,
  ot.EPSG3395 = Pt,
  ot.EPSG3857 = lt,
  ot.EPSG900913 = ut,
  ot.EPSG4326 = li,
  ot.Simple = Lt,
  it.extend({
      options: {
          pane: "overlayPane",
          attribution: null,
          bubblingMouseEvents: !0
      },
      addTo: function(t) {
          return t.addLayer(this),
          this
      },
      remove: function() {
          return this.removeFrom(this._map || this._mapToAdd)
      },
      removeFrom: function(t) {
          return t && t.removeLayer(this),
          this
      },
      getPane: function(t) {
          return this._map.getPane(t ? this.options[t] || t : this.options.pane)
      },
      addInteractiveTarget: function(t) {
          return this._map._targets[h(t)] = this
      },
      removeInteractiveTarget: function(t) {
          return delete this._map._targets[h(t)],
          this
      },
      getAttribution: function() {
          return this.options.attribution
      },
      _layerAdd: function(t) {
          var e, i = t.target;
          i.hasLayer(this) && (this._map = i,
          this._zoomAnimated = i._zoomAnimated,
          this.getEvents && (e = this.getEvents(),
          i.on(e, this),
          this.once("remove", function() {
              i.off(e, this)
          }, this)),
          this.onAdd(i),
          this.fire("add"),
          i.fire("layeradd", {
              layer: this
          }))
      }
  }))
    , ui = (A.include({
      addLayer: function(t) {
          var e;
          if (t._layerAdd)
              return e = h(t),
              this._layers[e] || ((this._layers[e] = t)._mapToAdd = this,
              t.beforeAdd && t.beforeAdd(this),
              this.whenReady(t._layerAdd, t)),
              this;
          throw new Error("The provided object is not a Layer.")
      },
      removeLayer: function(t) {
          var e = h(t);
          return this._layers[e] && (this._loaded && t.onRemove(this),
          delete this._layers[e],
          this._loaded && (this.fire("layerremove", {
              layer: t
          }),
          t.fire("remove")),
          t._map = t._mapToAdd = null),
          this
      },
      hasLayer: function(t) {
          return h(t)in this._layers
      },
      eachLayer: function(t, e) {
          for (var i in this._layers)
              t.call(e, this._layers[i]);
          return this
      },
      _addLayers: function(t) {
          for (var e = 0, i = (t = t ? d(t) ? t : [t] : []).length; e < i; e++)
              this.addLayer(t[e])
      },
      _addZoomLimit: function(t) {
          isNaN(t.options.maxZoom) && isNaN(t.options.minZoom) || (this._zoomBoundLayers[h(t)] = t,
          this._updateZoomLevels())
      },
      _removeZoomLimit: function(t) {
          t = h(t);
          this._zoomBoundLayers[t] && (delete this._zoomBoundLayers[t],
          this._updateZoomLevels())
      },
      _updateZoomLevels: function() {
          var t, e = 1 / 0, i = -1 / 0, n = this._getZoomSpan();
          for (t in this._zoomBoundLayers)
              var o = this._zoomBoundLayers[t].options
                , e = void 0 === o.minZoom ? e : Math.min(e, o.minZoom)
                , i = void 0 === o.maxZoom ? i : Math.max(i, o.maxZoom);
          this._layersMaxZoom = i === -1 / 0 ? void 0 : i,
          this._layersMinZoom = e === 1 / 0 ? void 0 : e,
          n !== this._getZoomSpan() && this.fire("zoomlevelschange"),
          void 0 === this.options.maxZoom && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom),
          void 0 === this.options.minZoom && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom)
      }
  }),
  o.extend({
      initialize: function(t, e) {
          var i, n;
          if (c(this, e),
          this._layers = {},
          t)
              for (i = 0,
              n = t.length; i < n; i++)
                  this.addLayer(t[i])
      },
      addLayer: function(t) {
          var e = this.getLayerId(t);
          return this._layers[e] = t,
          this._map && this._map.addLayer(t),
          this
      },
      removeLayer: function(t) {
          t = t in this._layers ? t : this.getLayerId(t);
          return this._map && this._layers[t] && this._map.removeLayer(this._layers[t]),
          delete this._layers[t],
          this
      },
      hasLayer: function(t) {
          return ("number" == typeof t ? t : this.getLayerId(t))in this._layers
      },
      clearLayers: function() {
          return this.eachLayer(this.removeLayer, this)
      },
      invoke: function(t) {
          var e, i, n = Array.prototype.slice.call(arguments, 1);
          for (e in this._layers)
              (i = this._layers[e])[t] && i[t].apply(i, n);
          return this
      },
      onAdd: function(t) {
          this.eachLayer(t.addLayer, t)
      },
      onRemove: function(t) {
          this.eachLayer(t.removeLayer, t)
      },
      eachLayer: function(t, e) {
          for (var i in this._layers)
              t.call(e, this._layers[i]);
          return this
      },
      getLayer: function(t) {
          return this._layers[t]
      },
      getLayers: function() {
          var t = [];
          return this.eachLayer(t.push, t),
          t
      },
      setZIndex: function(t) {
          return this.invoke("setZIndex", t)
      },
      getLayerId: h
  }))
    , ci = ui.extend({
      addLayer: function(t) {
          return this.hasLayer(t) ? this : (t.addEventParent(this),
          ui.prototype.addLayer.call(this, t),
          this.fire("layeradd", {
              layer: t
          }))
      },
      removeLayer: function(t) {
          return this.hasLayer(t) ? ((t = t in this._layers ? this._layers[t] : t).removeEventParent(this),
          ui.prototype.removeLayer.call(this, t),
          this.fire("layerremove", {
              layer: t
          })) : this
      },
      setStyle: function(t) {
          return this.invoke("setStyle", t)
      },
      bringToFront: function() {
          return this.invoke("bringToFront")
      },
      bringToBack: function() {
          return this.invoke("bringToBack")
      },
      getBounds: function() {
          var t, e = new s;
          for (t in this._layers) {
              var i = this._layers[t];
              e.extend(i.getBounds ? i.getBounds() : i.getLatLng())
          }
          return e
      }
  })
    , di = et.extend({
      options: {
          popupAnchor: [0, 0],
          tooltipAnchor: [0, 0],
          crossOrigin: !1
      },
      initialize: function(t) {
          c(this, t)
      },
      createIcon: function(t) {
          return this._createIcon("icon", t)
      },
      createShadow: function(t) {
          return this._createIcon("shadow", t)
      },
      _createIcon: function(t, e) {
          var i = this._getIconUrl(t);
          if (i)
              return i = this._createImg(i, e && "IMG" === e.tagName ? e : null),
              this._setIconStyles(i, t),
              !this.options.crossOrigin && "" !== this.options.crossOrigin || (i.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin),
              i;
          if ("icon" === t)
              throw new Error("iconUrl not set in Icon options (see the docs).");
          return null
      },
      _setIconStyles: function(t, e) {
          var i = this.options
            , n = i[e + "Size"]
            , n = m(n = "number" == typeof n ? [n, n] : n)
            , o = m("shadow" === e && i.shadowAnchor || i.iconAnchor || n && n.divideBy(2, !0));
          t.className = "leaflet-marker-" + e + " " + (i.className || ""),
          o && (t.style.marginLeft = -o.x + "px",
          t.style.marginTop = -o.y + "px"),
          n && (t.style.width = n.x + "px",
          t.style.height = n.y + "px")
      },
      _createImg: function(t, e) {
          return (e = e || document.createElement("img")).src = t,
          e
      },
      _getIconUrl: function(t) {
          return b.retina && this.options[t + "RetinaUrl"] || this.options[t + "Url"]
      }
  });
  var _i = di.extend({
      options: {
          iconUrl: "marker-icon.png",
          iconRetinaUrl: "marker-icon-2x.png",
          shadowUrl: "marker-shadow.png",
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          tooltipAnchor: [16, -28],
          shadowSize: [41, 41]
      },
      _getIconUrl: function(t) {
          return "string" != typeof _i.imagePath && (_i.imagePath = this._detectIconPath()),
          (this.options.imagePath || _i.imagePath) + di.prototype._getIconUrl.call(this, t)
      },
      _stripUrl: function(t) {
          function e(t, e, i) {
              return (e = e.exec(t)) && e[i]
          }
          return (t = e(t, /^url\((['"])?(.+)\1\)$/, 2)) && e(t, /^(.*)marker-icon\.png$/, 1)
      },
      _detectIconPath: function() {
          var t = P("div", "leaflet-default-icon-path", document.body)
            , e = pe(t, "background-image") || pe(t, "backgroundImage");
          return document.body.removeChild(t),
          (e = this._stripUrl(e)) ? e : (t = document.querySelector('link[href$="leaflet.css"]')) ? t.href.substring(0, t.href.length - "leaflet.css".length - 1) : ""
      }
  })
    , pi = n.extend({
      initialize: function(t) {
          this._marker = t
      },
      addHooks: function() {
          var t = this._marker._icon;
          this._draggable || (this._draggable = new Xe(t,t,!0)),
          this._draggable.on({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
          }, this).enable(),
          M(t, "leaflet-marker-draggable")
      },
      removeHooks: function() {
          this._draggable.off({
              dragstart: this._onDragStart,
              predrag: this._onPreDrag,
              drag: this._onDrag,
              dragend: this._onDragEnd
          }, this).disable(),
          this._marker._icon && z(this._marker._icon, "leaflet-marker-draggable")
      },
      moved: function() {
          return this._draggable && this._draggable._moved
      },
      _adjustPan: function(t) {
          var e = this._marker
            , i = e._map
            , n = this._marker.options.autoPanSpeed
            , o = this._marker.options.autoPanPadding
            , s = Pe(e._icon)
            , r = i.getPixelBounds()
            , a = i.getPixelOrigin()
            , a = _(r.min._subtract(a).add(o), r.max._subtract(a).subtract(o));
          a.contains(s) || (o = m((Math.max(a.max.x, s.x) - a.max.x) / (r.max.x - a.max.x) - (Math.min(a.min.x, s.x) - a.min.x) / (r.min.x - a.min.x), (Math.max(a.max.y, s.y) - a.max.y) / (r.max.y - a.max.y) - (Math.min(a.min.y, s.y) - a.min.y) / (r.min.y - a.min.y)).multiplyBy(n),
          i.panBy(o, {
              animate: !1
          }),
          this._draggable._newPos._add(o),
          this._draggable._startPos._add(o),
          Z(e._icon, this._draggable._newPos),
          this._onDrag(t),
          this._panRequest = x(this._adjustPan.bind(this, t)))
      },
      _onDragStart: function() {
          this._oldLatLng = this._marker.getLatLng(),
          this._marker.closePopup && this._marker.closePopup(),
          this._marker.fire("movestart").fire("dragstart")
      },
      _onPreDrag: function(t) {
          this._marker.options.autoPan && (r(this._panRequest),
          this._panRequest = x(this._adjustPan.bind(this, t)))
      },
      _onDrag: function(t) {
          var e = this._marker
            , i = e._shadow
            , n = Pe(e._icon)
            , o = e._map.layerPointToLatLng(n);
          i && Z(i, n),
          e._latlng = o,
          t.latlng = o,
          t.oldLatLng = this._oldLatLng,
          e.fire("move", t).fire("drag", t)
      },
      _onDragEnd: function(t) {
          r(this._panRequest),
          delete this._oldLatLng,
          this._marker.fire("moveend").fire("dragend", t)
      }
  })
    , mi = o.extend({
      options: {
          icon: new _i,
          interactive: !0,
          keyboard: !0,
          title: "",
          alt: "Marker",
          zIndexOffset: 0,
          opacity: 1,
          riseOnHover: !1,
          riseOffset: 250,
          pane: "markerPane",
          shadowPane: "shadowPane",
          bubblingMouseEvents: !1,
          autoPanOnFocus: !0,
          draggable: !1,
          autoPan: !1,
          autoPanPadding: [50, 50],
          autoPanSpeed: 10
      },
      initialize: function(t, e) {
          c(this, e),
          this._latlng = w(t)
      },
      onAdd: function(t) {
          this._zoomAnimated = this._zoomAnimated && t.options.markerZoomAnimation,
          this._zoomAnimated && t.on("zoomanim", this._animateZoom, this),
          this._initIcon(),
          this.update()
      },
      onRemove: function(t) {
          this.dragging && this.dragging.enabled() && (this.options.draggable = !0,
          this.dragging.removeHooks()),
          delete this.dragging,
          this._zoomAnimated && t.off("zoomanim", this._animateZoom, this),
          this._removeIcon(),
          this._removeShadow()
      },
      getEvents: function() {
          return {
              zoom: this.update,
              viewreset: this.update
          }
      },
      getLatLng: function() {
          return this._latlng
      },
      setLatLng: function(t) {
          var e = this._latlng;
          return this._latlng = w(t),
          this.update(),
          this.fire("move", {
              oldLatLng: e,
              latlng: this._latlng
          })
      },
      setZIndexOffset: function(t) {
          return this.options.zIndexOffset = t,
          this.update()
      },
      getIcon: function() {
          return this.options.icon
      },
      setIcon: function(t) {
          return this.options.icon = t,
          this._map && (this._initIcon(),
          this.update()),
          this._popup && this.bindPopup(this._popup, this._popup.options),
          this
      },
      getElement: function() {
          return this._icon
      },
      update: function() {
          var t;
          return this._icon && this._map && (t = this._map.latLngToLayerPoint(this._latlng).round(),
          this._setPos(t)),
          this
      },
      _initIcon: function() {
          var t = this.options
            , e = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide")
            , i = t.icon.createIcon(this._icon)
            , n = !1
            , i = (i !== this._icon && (this._icon && this._removeIcon(),
          n = !0,
          t.title && (i.title = t.title),
          "IMG" === i.tagName && (i.alt = t.alt || "")),
          M(i, e),
          t.keyboard && (i.tabIndex = "0",
          i.setAttribute("role", "button")),
          this._icon = i,
          t.riseOnHover && this.on({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
          }),
          this.options.autoPanOnFocus && S(i, "focus", this._panOnFocus, this),
          t.icon.createShadow(this._shadow))
            , o = !1;
          i !== this._shadow && (this._removeShadow(),
          o = !0),
          i && (M(i, e),
          i.alt = ""),
          this._shadow = i,
          t.opacity < 1 && this._updateOpacity(),
          n && this.getPane().appendChild(this._icon),
          this._initInteraction(),
          i && o && this.getPane(t.shadowPane).appendChild(this._shadow)
      },
      _removeIcon: function() {
          this.options.riseOnHover && this.off({
              mouseover: this._bringToFront,
              mouseout: this._resetZIndex
          }),
          this.options.autoPanOnFocus && k(this._icon, "focus", this._panOnFocus, this),
          T(this._icon),
          this.removeInteractiveTarget(this._icon),
          this._icon = null
      },
      _removeShadow: function() {
          this._shadow && T(this._shadow),
          this._shadow = null
      },
      _setPos: function(t) {
          this._icon && Z(this._icon, t),
          this._shadow && Z(this._shadow, t),
          this._zIndex = t.y + this.options.zIndexOffset,
          this._resetZIndex()
      },
      _updateZIndex: function(t) {
          this._icon && (this._icon.style.zIndex = this._zIndex + t)
      },
      _animateZoom: function(t) {
          t = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round();
          this._setPos(t)
      },
      _initInteraction: function() {
          var t;
          this.options.interactive && (M(this._icon, "leaflet-interactive"),
          this.addInteractiveTarget(this._icon),
          pi && (t = this.options.draggable,
          this.dragging && (t = this.dragging.enabled(),
          this.dragging.disable()),
          this.dragging = new pi(this),
          t && this.dragging.enable()))
      },
      setOpacity: function(t) {
          return this.options.opacity = t,
          this._map && this._updateOpacity(),
          this
      },
      _updateOpacity: function() {
          var t = this.options.opacity;
          this._icon && C(this._icon, t),
          this._shadow && C(this._shadow, t)
      },
      _bringToFront: function() {
          this._updateZIndex(this.options.riseOffset)
      },
      _resetZIndex: function() {
          this._updateZIndex(0)
      },
      _panOnFocus: function() {
          var t, e, i = this._map;
          i && (t = (e = this.options.icon.options).iconSize ? m(e.iconSize) : m(0, 0),
          e = e.iconAnchor ? m(e.iconAnchor) : m(0, 0),
          i.panInside(this._latlng, {
              paddingTopLeft: e,
              paddingBottomRight: t.subtract(e)
          }))
      },
      _getPopupAnchor: function() {
          return this.options.icon.options.popupAnchor
      },
      _getTooltipAnchor: function() {
          return this.options.icon.options.tooltipAnchor
      }
  });
  var fi = o.extend({
      options: {
          stroke: !0,
          color: "#3388ff",
          weight: 3,
          opacity: 1,
          lineCap: "round",
          lineJoin: "round",
          dashArray: null,
          dashOffset: null,
          fill: !1,
          fillColor: null,
          fillOpacity: .2,
          fillRule: "evenodd",
          interactive: !0,
          bubblingMouseEvents: !0
      },
      beforeAdd: function(t) {
          this._renderer = t.getRenderer(this)
      },
      onAdd: function() {
          this._renderer._initPath(this),
          this._reset(),
          this._renderer._addPath(this)
      },
      onRemove: function() {
          this._renderer._removePath(this)
      },
      redraw: function() {
          return this._map && this._renderer._updatePath(this),
          this
      },
      setStyle: function(t) {
          return c(this, t),
          this._renderer && (this._renderer._updateStyle(this),
          this.options.stroke && t && Object.prototype.hasOwnProperty.call(t, "weight") && this._updateBounds()),
          this
      },
      bringToFront: function() {
          return this._renderer && this._renderer._bringToFront(this),
          this
      },
      bringToBack: function() {
          return this._renderer && this._renderer._bringToBack(this),
          this
      },
      getElement: function() {
          return this._path
      },
      _reset: function() {
          this._project(),
          this._update()
      },
      _clickTolerance: function() {
          return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0)
      }
  })
    , gi = fi.extend({
      options: {
          fill: !0,
          radius: 10
      },
      initialize: function(t, e) {
          c(this, e),
          this._latlng = w(t),
          this._radius = this.options.radius
      },
      setLatLng: function(t) {
          var e = this._latlng;
          return this._latlng = w(t),
          this.redraw(),
          this.fire("move", {
              oldLatLng: e,
              latlng: this._latlng
          })
      },
      getLatLng: function() {
          return this._latlng
      },
      setRadius: function(t) {
          return this.options.radius = this._radius = t,
          this.redraw()
      },
      getRadius: function() {
          return this._radius
      },
      setStyle: function(t) {
          var e = t && t.radius || this._radius;
          return fi.prototype.setStyle.call(this, t),
          this.setRadius(e),
          this
      },
      _project: function() {
          this._point = this._map.latLngToLayerPoint(this._latlng),
          this._updateBounds()
      },
      _updateBounds: function() {
          var t = this._radius
            , e = this._radiusY || t
            , i = this._clickTolerance()
            , t = [t + i, e + i];
          this._pxBounds = new f(this._point.subtract(t),this._point.add(t))
      },
      _update: function() {
          this._map && this._updatePath()
      },
      _updatePath: function() {
          this._renderer._updateCircle(this)
      },
      _empty: function() {
          return this._radius && !this._renderer._bounds.intersects(this._pxBounds)
      },
      _containsPoint: function(t) {
          return t.distanceTo(this._point) <= this._radius + this._clickTolerance()
      }
  });
  var vi = gi.extend({
      initialize: function(t, e, i) {
          if (c(this, e = "number" == typeof e ? l({}, i, {
              radius: e
          }) : e),
          this._latlng = w(t),
          isNaN(this.options.radius))
              throw new Error("Circle radius cannot be NaN");
          this._mRadius = this.options.radius
      },
      setRadius: function(t) {
          return this._mRadius = t,
          this.redraw()
      },
      getRadius: function() {
          return this._mRadius
      },
      getBounds: function() {
          var t = [this._radius, this._radiusY || this._radius];
          return new s(this._map.layerPointToLatLng(this._point.subtract(t)),this._map.layerPointToLatLng(this._point.add(t)))
      },
      setStyle: fi.prototype.setStyle,
      _project: function() {
          var t, e, i, n, o, s = this._latlng.lng, r = this._latlng.lat, a = this._map, h = a.options.crs;
          h.distance === st.distance ? (n = Math.PI / 180,
          o = this._mRadius / st.R / n,
          t = a.project([r + o, s]),
          e = a.project([r - o, s]),
          e = t.add(e).divideBy(2),
          i = a.unproject(e).lat,
          n = Math.acos((Math.cos(o * n) - Math.sin(r * n) * Math.sin(i * n)) / (Math.cos(r * n) * Math.cos(i * n))) / n,
          !isNaN(n) && 0 !== n || (n = o / Math.cos(Math.PI / 180 * r)),
          this._point = e.subtract(a.getPixelOrigin()),
          this._radius = isNaN(n) ? 0 : e.x - a.project([i, s - n]).x,
          this._radiusY = e.y - t.y) : (o = h.unproject(h.project(this._latlng).subtract([this._mRadius, 0])),
          this._point = a.latLngToLayerPoint(this._latlng),
          this._radius = this._point.x - a.latLngToLayerPoint(o).x),
          this._updateBounds()
      }
  });
  var yi = fi.extend({
      options: {
          smoothFactor: 1,
          noClip: !1
      },
      initialize: function(t, e) {
          c(this, e),
          this._setLatLngs(t)
      },
      getLatLngs: function() {
          return this._latlngs
      },
      setLatLngs: function(t) {
          return this._setLatLngs(t),
          this.redraw()
      },
      isEmpty: function() {
          return !this._latlngs.length
      },
      closestLayerPoint: function(t) {
          for (var e = 1 / 0, i = null, n = ri, o = 0, s = this._parts.length; o < s; o++)
              for (var r = this._parts[o], a = 1, h = r.length; a < h; a++) {
                  var l, u, c = n(t, l = r[a - 1], u = r[a], !0);
                  c < e && (e = c,
                  i = n(t, l, u))
              }
          return i && (i.distance = Math.sqrt(e)),
          i
      },
      getCenter: function() {
          if (this._map)
              return hi(this._defaultShape(), this._map.options.crs);
          throw new Error("Must add layer to map before using getCenter()")
      },
      getBounds: function() {
          return this._bounds
      },
      addLatLng: function(t, e) {
          return e = e || this._defaultShape(),
          t = w(t),
          e.push(t),
          this._bounds.extend(t),
          this.redraw()
      },
      _setLatLngs: function(t) {
          this._bounds = new s,
          this._latlngs = this._convertLatLngs(t)
      },
      _defaultShape: function() {
          return I(this._latlngs) ? this._latlngs : this._latlngs[0]
      },
      _convertLatLngs: function(t) {
          for (var e = [], i = I(t), n = 0, o = t.length; n < o; n++)
              i ? (e[n] = w(t[n]),
              this._bounds.extend(e[n])) : e[n] = this._convertLatLngs(t[n]);
          return e
      },
      _project: function() {
          var t = new f;
          this._rings = [],
          this._projectLatlngs(this._latlngs, this._rings, t),
          this._bounds.isValid() && t.isValid() && (this._rawPxBounds = t,
          this._updateBounds())
      },
      _updateBounds: function() {
          var t = this._clickTolerance()
            , t = new p(t,t);
          this._rawPxBounds && (this._pxBounds = new f([this._rawPxBounds.min.subtract(t), this._rawPxBounds.max.add(t)]))
      },
      _projectLatlngs: function(t, e, i) {
          var n, o, s = t[0]instanceof v, r = t.length;
          if (s) {
              for (o = [],
              n = 0; n < r; n++)
                  o[n] = this._map.latLngToLayerPoint(t[n]),
                  i.extend(o[n]);
              e.push(o)
          } else
              for (n = 0; n < r; n++)
                  this._projectLatlngs(t[n], e, i)
      },
      _clipPoints: function() {
          var t = this._renderer._bounds;
          if (this._parts = [],
          this._pxBounds && this._pxBounds.intersects(t))
              if (this.options.noClip)
                  this._parts = this._rings;
              else
                  for (var e, i, n, o, s = this._parts, r = 0, a = 0, h = this._rings.length; r < h; r++)
                      for (e = 0,
                      i = (o = this._rings[r]).length; e < i - 1; e++)
                          (n = ni(o[e], o[e + 1], t, e, !0)) && (s[a] = s[a] || [],
                          s[a].push(n[0]),
                          n[1] === o[e + 1] && e !== i - 2 || (s[a].push(n[1]),
                          a++))
      },
      _simplifyPoints: function() {
          for (var t = this._parts, e = this.options.smoothFactor, i = 0, n = t.length; i < n; i++)
              t[i] = ei(t[i], e)
      },
      _update: function() {
          this._map && (this._clipPoints(),
          this._simplifyPoints(),
          this._updatePath())
      },
      _updatePath: function() {
          this._renderer._updatePoly(this)
      },
      _containsPoint: function(t, e) {
          var i, n, o, s, r, a, h = this._clickTolerance();
          if (this._pxBounds && this._pxBounds.contains(t))
              for (i = 0,
              s = this._parts.length; i < s; i++)
                  for (n = 0,
                  o = (r = (a = this._parts[i]).length) - 1; n < r; o = n++)
                      if ((e || 0 !== n) && ii(t, a[o], a[n]) <= h)
                          return !0;
          return !1
      }
  });
  yi._flat = ai;
  var xi = yi.extend({
      options: {
          fill: !0
      },
      isEmpty: function() {
          return !this._latlngs.length || !this._latlngs[0].length
      },
      getCenter: function() {
          if (this._map)
              return $e(this._defaultShape(), this._map.options.crs);
          throw new Error("Must add layer to map before using getCenter()")
      },
      _convertLatLngs: function(t) {
          var t = yi.prototype._convertLatLngs.call(this, t)
            , e = t.length;
          return 2 <= e && t[0]instanceof v && t[0].equals(t[e - 1]) && t.pop(),
          t
      },
      _setLatLngs: function(t) {
          yi.prototype._setLatLngs.call(this, t),
          I(this._latlngs) && (this._latlngs = [this._latlngs])
      },
      _defaultShape: function() {
          return (I(this._latlngs[0]) ? this._latlngs : this._latlngs[0])[0]
      },
      _clipPoints: function() {
          var t = this._renderer._bounds
            , e = this.options.weight
            , e = new p(e,e)
            , t = new f(t.min.subtract(e),t.max.add(e));
          if (this._parts = [],
          this._pxBounds && this._pxBounds.intersects(t))
              if (this.options.noClip)
                  this._parts = this._rings;
              else
                  for (var i, n = 0, o = this._rings.length; n < o; n++)
                      (i = Je(this._rings[n], t, !0)).length && this._parts.push(i)
      },
      _updatePath: function() {
          this._renderer._updatePoly(this, !0)
      },
      _containsPoint: function(t) {
          var e, i, n, o, s, r, a, h, l = !1;
          if (!this._pxBounds || !this._pxBounds.contains(t))
              return !1;
          for (o = 0,
          a = this._parts.length; o < a; o++)
              for (s = 0,
              r = (h = (e = this._parts[o]).length) - 1; s < h; r = s++)
                  i = e[s],
                  n = e[r],
                  i.y > t.y != n.y > t.y && t.x < (n.x - i.x) * (t.y - i.y) / (n.y - i.y) + i.x && (l = !l);
          return l || yi.prototype._containsPoint.call(this, t, !0)
      }
  });
  var wi = ci.extend({
      initialize: function(t, e) {
          c(this, e),
          this._layers = {},
          t && this.addData(t)
      },
      addData: function(t) {
          var e, i, n, o = d(t) ? t : t.features;
          if (o) {
              for (e = 0,
              i = o.length; e < i; e++)
                  ((n = o[e]).geometries || n.geometry || n.features || n.coordinates) && this.addData(n);
              return this
          }
          var s, r = this.options;
          return (!r.filter || r.filter(t)) && (s = bi(t, r)) ? (s.feature = Zi(t),
          s.defaultOptions = s.options,
          this.resetStyle(s),
          r.onEachFeature && r.onEachFeature(t, s),
          this.addLayer(s)) : this
      },
      resetStyle: function(t) {
          return void 0 === t ? this.eachLayer(this.resetStyle, this) : (t.options = l({}, t.defaultOptions),
          this._setLayerStyle(t, this.options.style),
          this)
      },
      setStyle: function(e) {
          return this.eachLayer(function(t) {
              this._setLayerStyle(t, e)
          }, this)
      },
      _setLayerStyle: function(t, e) {
          t.setStyle && ("function" == typeof e && (e = e(t.feature)),
          t.setStyle(e))
      }
  });
  function bi(t, e) {
      var i, n, o, s, r = "Feature" === t.type ? t.geometry : t, a = r ? r.coordinates : null, h = [], l = e && e.pointToLayer, u = e && e.coordsToLatLng || Li;
      if (!a && !r)
          return null;
      switch (r.type) {
      case "Point":
          return Pi(l, t, i = u(a), e);
      case "MultiPoint":
          for (o = 0,
          s = a.length; o < s; o++)
              i = u(a[o]),
              h.push(Pi(l, t, i, e));
          return new ci(h);
      case "LineString":
      case "MultiLineString":
          return n = Ti(a, "LineString" === r.type ? 0 : 1, u),
          new yi(n,e);
      case "Polygon":
      case "MultiPolygon":
          return n = Ti(a, "Polygon" === r.type ? 1 : 2, u),
          new xi(n,e);
      case "GeometryCollection":
          for (o = 0,
          s = r.geometries.length; o < s; o++) {
              var c = bi({
                  geometry: r.geometries[o],
                  type: "Feature",
                  properties: t.properties
              }, e);
              c && h.push(c)
          }
          return new ci(h);
      case "FeatureCollection":
          for (o = 0,
          s = r.features.length; o < s; o++) {
              var d = bi(r.features[o], e);
              d && h.push(d)
          }
          return new ci(h);
      default:
          throw new Error("Invalid GeoJSON object.")
      }
  }
  function Pi(t, e, i, n) {
      return t ? t(e, i) : new mi(i,n && n.markersInheritOptions && n)
  }
  function Li(t) {
      return new v(t[1],t[0],t[2])
  }
  function Ti(t, e, i) {
      for (var n, o = [], s = 0, r = t.length; s < r; s++)
          n = e ? Ti(t[s], e - 1, i) : (i || Li)(t[s]),
          o.push(n);
      return o
  }
  function Mi(t, e) {
      return void 0 !== (t = w(t)).alt ? [i(t.lng, e), i(t.lat, e), i(t.alt, e)] : [i(t.lng, e), i(t.lat, e)]
  }
  function zi(t, e, i, n) {
      for (var o = [], s = 0, r = t.length; s < r; s++)
          o.push(e ? zi(t[s], I(t[s]) ? 0 : e - 1, i, n) : Mi(t[s], n));
      return !e && i && 0 < o.length && o.push(o[0].slice()),
      o
  }
  function Ci(t, e) {
      return t.feature ? l({}, t.feature, {
          geometry: e
      }) : Zi(e)
  }
  function Zi(t) {
      return "Feature" === t.type || "FeatureCollection" === t.type ? t : {
          type: "Feature",
          properties: {},
          geometry: t
      }
  }
  Tt = {
      toGeoJSON: function(t) {
          return Ci(this, {
              type: "Point",
              coordinates: Mi(this.getLatLng(), t)
          })
      }
  };
  function Si(t, e) {
      return new wi(t,e)
  }
  mi.include(Tt),
  vi.include(Tt),
  gi.include(Tt),
  yi.include({
      toGeoJSON: function(t) {
          var e = !I(this._latlngs);
          return Ci(this, {
              type: (e ? "Multi" : "") + "LineString",
              coordinates: zi(this._latlngs, e ? 1 : 0, !1, t)
          })
      }
  }),
  xi.include({
      toGeoJSON: function(t) {
          var e = !I(this._latlngs)
            , i = e && !I(this._latlngs[0])
            , t = zi(this._latlngs, i ? 2 : e ? 1 : 0, !0, t);
          return Ci(this, {
              type: (i ? "Multi" : "") + "Polygon",
              coordinates: t = e ? t : [t]
          })
      }
  }),
  ui.include({
      toMultiPoint: function(e) {
          var i = [];
          return this.eachLayer(function(t) {
              i.push(t.toGeoJSON(e).geometry.coordinates)
          }),
          Ci(this, {
              type: "MultiPoint",
              coordinates: i
          })
      },
      toGeoJSON: function(e) {
          var i, n, t = this.feature && this.feature.geometry && this.feature.geometry.type;
          return "MultiPoint" === t ? this.toMultiPoint(e) : (i = "GeometryCollection" === t,
          n = [],
          this.eachLayer(function(t) {
              t.toGeoJSON && (t = t.toGeoJSON(e),
              i ? n.push(t.geometry) : "FeatureCollection" === (t = Zi(t)).type ? n.push.apply(n, t.features) : n.push(t))
          }),
          i ? Ci(this, {
              geometries: n,
              type: "GeometryCollection"
          }) : {
              type: "FeatureCollection",
              features: n
          })
      }
  });
  var Mt = Si
    , Ei = o.extend({
      options: {
          opacity: 1,
          alt: "",
          interactive: !1,
          crossOrigin: !1,
          errorOverlayUrl: "",
          zIndex: 1,
          className: ""
      },
      initialize: function(t, e, i) {
          this._url = t,
          this._bounds = g(e),
          c(this, i)
      },
      onAdd: function() {
          this._image || (this._initImage(),
          this.options.opacity < 1 && this._updateOpacity()),
          this.options.interactive && (M(this._image, "leaflet-interactive"),
          this.addInteractiveTarget(this._image)),
          this.getPane().appendChild(this._image),
          this._reset()
      },
      onRemove: function() {
          T(this._image),
          this.options.interactive && this.removeInteractiveTarget(this._image)
      },
      setOpacity: function(t) {
          return this.options.opacity = t,
          this._image && this._updateOpacity(),
          this
      },
      setStyle: function(t) {
          return t.opacity && this.setOpacity(t.opacity),
          this
      },
      bringToFront: function() {
          return this._map && fe(this._image),
          this
      },
      bringToBack: function() {
          return this._map && ge(this._image),
          this
      },
      setUrl: function(t) {
          return this._url = t,
          this._image && (this._image.src = t),
          this
      },
      setBounds: function(t) {
          return this._bounds = g(t),
          this._map && this._reset(),
          this
      },
      getEvents: function() {
          var t = {
              zoom: this._reset,
              viewreset: this._reset
          };
          return this._zoomAnimated && (t.zoomanim = this._animateZoom),
          t
      },
      setZIndex: function(t) {
          return this.options.zIndex = t,
          this._updateZIndex(),
          this
      },
      getBounds: function() {
          return this._bounds
      },
      getElement: function() {
          return this._image
      },
      _initImage: function() {
          var t = "IMG" === this._url.tagName
            , e = this._image = t ? this._url : P("img");
          M(e, "leaflet-image-layer"),
          this._zoomAnimated && M(e, "leaflet-zoom-animated"),
          this.options.className && M(e, this.options.className),
          e.onselectstart = u,
          e.onmousemove = u,
          e.onload = a(this.fire, this, "load"),
          e.onerror = a(this._overlayOnError, this, "error"),
          !this.options.crossOrigin && "" !== this.options.crossOrigin || (e.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin),
          this.options.zIndex && this._updateZIndex(),
          t ? this._url = e.src : (e.src = this._url,
          e.alt = this.options.alt)
      },
      _animateZoom: function(t) {
          var e = this._map.getZoomScale(t.zoom)
            , t = this._map._latLngBoundsToNewLayerBounds(this._bounds, t.zoom, t.center).min;
          be(this._image, t, e)
      },
      _reset: function() {
          var t = this._image
            , e = new f(this._map.latLngToLayerPoint(this._bounds.getNorthWest()),this._map.latLngToLayerPoint(this._bounds.getSouthEast()))
            , i = e.getSize();
          Z(t, e.min),
          t.style.width = i.x + "px",
          t.style.height = i.y + "px"
      },
      _updateOpacity: function() {
          C(this._image, this.options.opacity)
      },
      _updateZIndex: function() {
          this._image && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._image.style.zIndex = this.options.zIndex)
      },
      _overlayOnError: function() {
          this.fire("error");
          var t = this.options.errorOverlayUrl;
          t && this._url !== t && (this._url = t,
          this._image.src = t)
      },
      getCenter: function() {
          return this._bounds.getCenter()
      }
  })
    , ki = Ei.extend({
      options: {
          autoplay: !0,
          loop: !0,
          keepAspectRatio: !0,
          muted: !1,
          playsInline: !0
      },
      _initImage: function() {
          var t = "VIDEO" === this._url.tagName
            , e = this._image = t ? this._url : P("video");
          if (M(e, "leaflet-image-layer"),
          this._zoomAnimated && M(e, "leaflet-zoom-animated"),
          this.options.className && M(e, this.options.className),
          e.onselectstart = u,
          e.onmousemove = u,
          e.onloadeddata = a(this.fire, this, "load"),
          t) {
              for (var i = e.getElementsByTagName("source"), n = [], o = 0; o < i.length; o++)
                  n.push(i[o].src);
              this._url = 0 < i.length ? n : [e.src]
          } else {
              d(this._url) || (this._url = [this._url]),
              !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(e.style, "objectFit") && (e.style.objectFit = "fill"),
              e.autoplay = !!this.options.autoplay,
              e.loop = !!this.options.loop,
              e.muted = !!this.options.muted,
              e.playsInline = !!this.options.playsInline;
              for (var s = 0; s < this._url.length; s++) {
                  var r = P("source");
                  r.src = this._url[s],
                  e.appendChild(r)
              }
          }
      }
  });
  var Oi = Ei.extend({
      _initImage: function() {
          var t = this._image = this._url;
          M(t, "leaflet-image-layer"),
          this._zoomAnimated && M(t, "leaflet-zoom-animated"),
          this.options.className && M(t, this.options.className),
          t.onselectstart = u,
          t.onmousemove = u
      }
  });
  var Ai = o.extend({
      options: {
          interactive: !1,
          offset: [0, 0],
          className: "",
          pane: void 0,
          content: ""
      },
      initialize: function(t, e) {
          t && (t instanceof v || d(t)) ? (this._latlng = w(t),
          c(this, e)) : (c(this, t),
          this._source = e),
          this.options.content && (this._content = this.options.content)
      },
      openOn: function(t) {
          return (t = arguments.length ? t : this._source._map).hasLayer(this) || t.addLayer(this),
          this
      },
      close: function() {
          return this._map && this._map.removeLayer(this),
          this
      },
      toggle: function(t) {
          return this._map ? this.close() : (arguments.length ? this._source = t : t = this._source,
          this._prepareOpen(),
          this.openOn(t._map)),
          this
      },
      onAdd: function(t) {
          this._zoomAnimated = t._zoomAnimated,
          this._container || this._initLayout(),
          t._fadeAnimated && C(this._container, 0),
          clearTimeout(this._removeTimeout),
          this.getPane().appendChild(this._container),
          this.update(),
          t._fadeAnimated && C(this._container, 1),
          this.bringToFront(),
          this.options.interactive && (M(this._container, "leaflet-interactive"),
          this.addInteractiveTarget(this._container))
      },
      onRemove: function(t) {
          t._fadeAnimated ? (C(this._container, 0),
          this._removeTimeout = setTimeout(a(T, void 0, this._container), 200)) : T(this._container),
          this.options.interactive && (z(this._container, "leaflet-interactive"),
          this.removeInteractiveTarget(this._container))
      },
      getLatLng: function() {
          return this._latlng
      },
      setLatLng: function(t) {
          return this._latlng = w(t),
          this._map && (this._updatePosition(),
          this._adjustPan()),
          this
      },
      getContent: function() {
          return this._content
      },
      setContent: function(t) {
          return this._content = t,
          this.update(),
          this
      },
      getElement: function() {
          return this._container
      },
      update: function() {
          this._map && (this._container.style.visibility = "hidden",
          this._updateContent(),
          this._updateLayout(),
          this._updatePosition(),
          this._container.style.visibility = "",
          this._adjustPan())
      },
      getEvents: function() {
          var t = {
              zoom: this._updatePosition,
              viewreset: this._updatePosition
          };
          return this._zoomAnimated && (t.zoomanim = this._animateZoom),
          t
      },
      isOpen: function() {
          return !!this._map && this._map.hasLayer(this)
      },
      bringToFront: function() {
          return this._map && fe(this._container),
          this
      },
      bringToBack: function() {
          return this._map && ge(this._container),
          this
      },
      _prepareOpen: function(t) {
          if (!(i = this._source)._map)
              return !1;
          if (i instanceof ci) {
              var e, i = null, n = this._source._layers;
              for (e in n)
                  if (n[e]._map) {
                      i = n[e];
                      break
                  }
              if (!i)
                  return !1;
              this._source = i
          }
          if (!t)
              if (i.getCenter)
                  t = i.getCenter();
              else if (i.getLatLng)
                  t = i.getLatLng();
              else {
                  if (!i.getBounds)
                      throw new Error("Unable to get source layer LatLng.");
                  t = i.getBounds().getCenter()
              }
          return this.setLatLng(t),
          this._map && this.update(),
          !0
      },
      _updateContent: function() {
          if (this._content) {
              var t = this._contentNode
                , e = "function" == typeof this._content ? this._content(this._source || this) : this._content;
              if ("string" == typeof e)
                  t.innerHTML = e;
              else {
                  for (; t.hasChildNodes(); )
                      t.removeChild(t.firstChild);
                  t.appendChild(e)
              }
              this.fire("contentupdate")
          }
      },
      _updatePosition: function() {
          var t, e, i;
          this._map && (e = this._map.latLngToLayerPoint(this._latlng),
          t = m(this.options.offset),
          i = this._getAnchor(),
          this._zoomAnimated ? Z(this._container, e.add(i)) : t = t.add(e).add(i),
          e = this._containerBottom = -t.y,
          i = this._containerLeft = -Math.round(this._containerWidth / 2) + t.x,
          this._container.style.bottom = e + "px",
          this._container.style.left = i + "px")
      },
      _getAnchor: function() {
          return [0, 0]
      }
  })
    , Bi = (A.include({
      _initOverlay: function(t, e, i, n) {
          var o = e;
          return o instanceof t || (o = new t(n).setContent(e)),
          i && o.setLatLng(i),
          o
      }
  }),
  o.include({
      _initOverlay: function(t, e, i, n) {
          var o = i;
          return o instanceof t ? (c(o, n),
          o._source = this) : (o = e && !n ? e : new t(n,this)).setContent(i),
          o
      }
  }),
  Ai.extend({
      options: {
          pane: "popupPane",
          offset: [0, 7],
          maxWidth: 300,
          minWidth: 50,
          maxHeight: null,
          autoPan: !0,
          autoPanPaddingTopLeft: null,
          autoPanPaddingBottomRight: null,
          autoPanPadding: [5, 5],
          keepInView: !1,
          closeButton: !0,
          autoClose: !0,
          closeOnEscapeKey: !0,
          className: ""
      },
      openOn: function(t) {
          return !(t = arguments.length ? t : this._source._map).hasLayer(this) && t._popup && t._popup.options.autoClose && t.removeLayer(t._popup),
          t._popup = this,
          Ai.prototype.openOn.call(this, t)
      },
      onAdd: function(t) {
          Ai.prototype.onAdd.call(this, t),
          t.fire("popupopen", {
              popup: this
          }),
          this._source && (this._source.fire("popupopen", {
              popup: this
          }, !0),
          this._source instanceof fi || this._source.on("preclick", Ae))
      },
      onRemove: function(t) {
          Ai.prototype.onRemove.call(this, t),
          t.fire("popupclose", {
              popup: this
          }),
          this._source && (this._source.fire("popupclose", {
              popup: this
          }, !0),
          this._source instanceof fi || this._source.off("preclick", Ae))
      },
      getEvents: function() {
          var t = Ai.prototype.getEvents.call(this);
          return (void 0 !== this.options.closeOnClick ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this.close),
          this.options.keepInView && (t.moveend = this._adjustPan),
          t
      },
      _initLayout: function() {
          var t = "leaflet-popup"
            , e = this._container = P("div", t + " " + (this.options.className || "") + " leaflet-zoom-animated")
            , i = this._wrapper = P("div", t + "-content-wrapper", e);
          this._contentNode = P("div", t + "-content", i),
          Ie(e),
          Be(this._contentNode),
          S(e, "contextmenu", Ae),
          this._tipContainer = P("div", t + "-tip-container", e),
          this._tip = P("div", t + "-tip", this._tipContainer),
          this.options.closeButton && ((i = this._closeButton = P("a", t + "-close-button", e)).setAttribute("role", "button"),
          i.setAttribute("aria-label", "Close popup"),
          i.href = "#close",
          i.innerHTML = '<span aria-hidden="true">&#215;</span>',
          S(i, "click", function(t) {
              O(t),
              this.close()
          }, this))
      },
      _updateLayout: function() {
          var t = this._contentNode
            , e = t.style
            , i = (e.width = "",
          e.whiteSpace = "nowrap",
          t.offsetWidth)
            , i = Math.min(i, this.options.maxWidth)
            , i = (i = Math.max(i, this.options.minWidth),
          e.width = i + 1 + "px",
          e.whiteSpace = "",
          e.height = "",
          t.offsetHeight)
            , n = this.options.maxHeight
            , o = "leaflet-popup-scrolled";
          (n && n < i ? (e.height = n + "px",
          M) : z)(t, o),
          this._containerWidth = this._container.offsetWidth
      },
      _animateZoom: function(t) {
          var t = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center)
            , e = this._getAnchor();
          Z(this._container, t.add(e))
      },
      _adjustPan: function() {
          var t, e, i, n, o, s, r, a;
          this.options.autoPan && (this._map._panAnim && this._map._panAnim.stop(),
          this._autopanning ? this._autopanning = !1 : (t = this._map,
          e = parseInt(pe(this._container, "marginBottom"), 10) || 0,
          e = this._container.offsetHeight + e,
          a = this._containerWidth,
          (i = new p(this._containerLeft,-e - this._containerBottom))._add(Pe(this._container)),
          i = t.layerPointToContainerPoint(i),
          o = m(this.options.autoPanPadding),
          n = m(this.options.autoPanPaddingTopLeft || o),
          o = m(this.options.autoPanPaddingBottomRight || o),
          s = t.getSize(),
          r = 0,
          i.x + a + o.x > s.x && (r = i.x + a - s.x + o.x),
          i.x - r - n.x < (a = 0) && (r = i.x - n.x),
          i.y + e + o.y > s.y && (a = i.y + e - s.y + o.y),
          i.y - a - n.y < 0 && (a = i.y - n.y),
          (r || a) && (this.options.keepInView && (this._autopanning = !0),
          t.fire("autopanstart").panBy([r, a]))))
      },
      _getAnchor: function() {
          return m(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0])
      }
  }))
    , Ii = (A.mergeOptions({
      closePopupOnClick: !0
  }),
  A.include({
      openPopup: function(t, e, i) {
          return this._initOverlay(Bi, t, e, i).openOn(this),
          this
      },
      closePopup: function(t) {
          return (t = arguments.length ? t : this._popup) && t.close(),
          this
      }
  }),
  o.include({
      bindPopup: function(t, e) {
          return this._popup = this._initOverlay(Bi, this._popup, t, e),
          this._popupHandlersAdded || (this.on({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
          }),
          this._popupHandlersAdded = !0),
          this
      },
      unbindPopup: function() {
          return this._popup && (this.off({
              click: this._openPopup,
              keypress: this._onKeyPress,
              remove: this.closePopup,
              move: this._movePopup
          }),
          this._popupHandlersAdded = !1,
          this._popup = null),
          this
      },
      openPopup: function(t) {
          return this._popup && (this instanceof ci || (this._popup._source = this),
          this._popup._prepareOpen(t || this._latlng) && this._popup.openOn(this._map)),
          this
      },
      closePopup: function() {
          return this._popup && this._popup.close(),
          this
      },
      togglePopup: function() {
          return this._popup && this._popup.toggle(this),
          this
      },
      isPopupOpen: function() {
          return !!this._popup && this._popup.isOpen()
      },
      setPopupContent: function(t) {
          return this._popup && this._popup.setContent(t),
          this
      },
      getPopup: function() {
          return this._popup
      },
      _openPopup: function(t) {
          var e;
          this._popup && this._map && (Re(t),
          e = t.layer || t.target,
          this._popup._source !== e || e instanceof fi ? (this._popup._source = e,
          this.openPopup(t.latlng)) : this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(t.latlng))
      },
      _movePopup: function(t) {
          this._popup.setLatLng(t.latlng)
      },
      _onKeyPress: function(t) {
          13 === t.originalEvent.keyCode && this._openPopup(t)
      }
  }),
  Ai.extend({
      options: {
          pane: "tooltipPane",
          offset: [0, 0],
          direction: "auto",
          permanent: !1,
          sticky: !1,
          opacity: .9
      },
      onAdd: function(t) {
          Ai.prototype.onAdd.call(this, t),
          this.setOpacity(this.options.opacity),
          t.fire("tooltipopen", {
              tooltip: this
          }),
          this._source && (this.addEventParent(this._source),
          this._source.fire("tooltipopen", {
              tooltip: this
          }, !0))
      },
      onRemove: function(t) {
          Ai.prototype.onRemove.call(this, t),
          t.fire("tooltipclose", {
              tooltip: this
          }),
          this._source && (this.removeEventParent(this._source),
          this._source.fire("tooltipclose", {
              tooltip: this
          }, !0))
      },
      getEvents: function() {
          var t = Ai.prototype.getEvents.call(this);
          return this.options.permanent || (t.preclick = this.close),
          t
      },
      _initLayout: function() {
          var t = "leaflet-tooltip " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide");
          this._contentNode = this._container = P("div", t),
          this._container.setAttribute("role", "tooltip"),
          this._container.setAttribute("id", "leaflet-tooltip-" + h(this))
      },
      _updateLayout: function() {},
      _adjustPan: function() {},
      _setPosition: function(t) {
          var e, i = this._map, n = this._container, o = i.latLngToContainerPoint(i.getCenter()), i = i.layerPointToContainerPoint(t), s = this.options.direction, r = n.offsetWidth, a = n.offsetHeight, h = m(this.options.offset), l = this._getAnchor(), i = "top" === s ? (e = r / 2,
          a) : "bottom" === s ? (e = r / 2,
          0) : (e = "center" === s ? r / 2 : "right" === s ? 0 : "left" === s ? r : i.x < o.x ? (s = "right",
          0) : (s = "left",
          r + 2 * (h.x + l.x)),
          a / 2);
          t = t.subtract(m(e, i, !0)).add(h).add(l),
          z(n, "leaflet-tooltip-right"),
          z(n, "leaflet-tooltip-left"),
          z(n, "leaflet-tooltip-top"),
          z(n, "leaflet-tooltip-bottom"),
          M(n, "leaflet-tooltip-" + s),
          Z(n, t)
      },
      _updatePosition: function() {
          var t = this._map.latLngToLayerPoint(this._latlng);
          this._setPosition(t)
      },
      setOpacity: function(t) {
          this.options.opacity = t,
          this._container && C(this._container, t)
      },
      _animateZoom: function(t) {
          t = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center);
          this._setPosition(t)
      },
      _getAnchor: function() {
          return m(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0])
      }
  }))
    , Ri = (A.include({
      openTooltip: function(t, e, i) {
          return this._initOverlay(Ii, t, e, i).openOn(this),
          this
      },
      closeTooltip: function(t) {
          return t.close(),
          this
      }
  }),
  o.include({
      bindTooltip: function(t, e) {
          return this._tooltip && this.isTooltipOpen() && this.unbindTooltip(),
          this._tooltip = this._initOverlay(Ii, this._tooltip, t, e),
          this._initTooltipInteractions(),
          this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(),
          this
      },
      unbindTooltip: function() {
          return this._tooltip && (this._initTooltipInteractions(!0),
          this.closeTooltip(),
          this._tooltip = null),
          this
      },
      _initTooltipInteractions: function(t) {
          var e, i;
          !t && this._tooltipHandlersAdded || (e = t ? "off" : "on",
          i = {
              remove: this.closeTooltip,
              move: this._moveTooltip
          },
          this._tooltip.options.permanent ? i.add = this._openTooltip : (i.mouseover = this._openTooltip,
          i.mouseout = this.closeTooltip,
          i.click = this._openTooltip,
          this._map ? this._addFocusListeners() : i.add = this._addFocusListeners),
          this._tooltip.options.sticky && (i.mousemove = this._moveTooltip),
          this[e](i),
          this._tooltipHandlersAdded = !t)
      },
      openTooltip: function(t) {
          return this._tooltip && (this instanceof ci || (this._tooltip._source = this),
          this._tooltip._prepareOpen(t) && (this._tooltip.openOn(this._map),
          this.getElement ? this._setAriaDescribedByOnLayer(this) : this.eachLayer && this.eachLayer(this._setAriaDescribedByOnLayer, this))),
          this
      },
      closeTooltip: function() {
          if (this._tooltip)
              return this._tooltip.close()
      },
      toggleTooltip: function() {
          return this._tooltip && this._tooltip.toggle(this),
          this
      },
      isTooltipOpen: function() {
          return this._tooltip.isOpen()
      },
      setTooltipContent: function(t) {
          return this._tooltip && this._tooltip.setContent(t),
          this
      },
      getTooltip: function() {
          return this._tooltip
      },
      _addFocusListeners: function() {
          this.getElement ? this._addFocusListenersOnLayer(this) : this.eachLayer && this.eachLayer(this._addFocusListenersOnLayer, this)
      },
      _addFocusListenersOnLayer: function(t) {
          var e = "function" == typeof t.getElement && t.getElement();
          e && (S(e, "focus", function() {
              this._tooltip._source = t,
              this.openTooltip()
          }, this),
          S(e, "blur", this.closeTooltip, this))
      },
      _setAriaDescribedByOnLayer: function(t) {
          t = "function" == typeof t.getElement && t.getElement();
          t && t.setAttribute("aria-describedby", this._tooltip._container.id)
      },
      _openTooltip: function(t) {
          var e;
          this._tooltip && this._map && (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag ? (this._openOnceFlag = !0,
          (e = this)._map.once("moveend", function() {
              e._openOnceFlag = !1,
              e._openTooltip(t)
          })) : (this._tooltip._source = t.layer || t.target,
          this.openTooltip(this._tooltip.options.sticky ? t.latlng : void 0)))
      },
      _moveTooltip: function(t) {
          var e = t.latlng;
          this._tooltip.options.sticky && t.originalEvent && (t = this._map.mouseEventToContainerPoint(t.originalEvent),
          t = this._map.containerPointToLayerPoint(t),
          e = this._map.layerPointToLatLng(t)),
          this._tooltip.setLatLng(e)
      }
  }),
  di.extend({
      options: {
          iconSize: [12, 12],
          html: !1,
          bgPos: null,
          className: "leaflet-div-icon"
      },
      createIcon: function(t) {
          var t = t && "DIV" === t.tagName ? t : document.createElement("div")
            , e = this.options;
          return e.html instanceof Element ? (me(t),
          t.appendChild(e.html)) : t.innerHTML = !1 !== e.html ? e.html : "",
          e.bgPos && (e = m(e.bgPos),
          t.style.backgroundPosition = -e.x + "px " + -e.y + "px"),
          this._setIconStyles(t, "icon"),
          t
      },
      createShadow: function() {
          return null
      }
  }));
  di.Default = _i;
  var Ni = o.extend({
      options: {
          tileSize: 256,
          opacity: 1,
          updateWhenIdle: b.mobile,
          updateWhenZooming: !0,
          updateInterval: 200,
          zIndex: 1,
          bounds: null,
          minZoom: 0,
          maxZoom: void 0,
          maxNativeZoom: void 0,
          minNativeZoom: void 0,
          noWrap: !1,
          pane: "tilePane",
          className: "",
          keepBuffer: 2
      },
      initialize: function(t) {
          c(this, t)
      },
      onAdd: function() {
          this._initContainer(),
          this._levels = {},
          this._tiles = {},
          this._resetView()
      },
      beforeAdd: function(t) {
          t._addZoomLimit(this)
      },
      onRemove: function(t) {
          this._removeAllTiles(),
          T(this._container),
          t._removeZoomLimit(this),
          this._container = null,
          this._tileZoom = void 0
      },
      bringToFront: function() {
          return this._map && (fe(this._container),
          this._setAutoZIndex(Math.max)),
          this
      },
      bringToBack: function() {
          return this._map && (ge(this._container),
          this._setAutoZIndex(Math.min)),
          this
      },
      getContainer: function() {
          return this._container
      },
      setOpacity: function(t) {
          return this.options.opacity = t,
          this._updateOpacity(),
          this
      },
      setZIndex: function(t) {
          return this.options.zIndex = t,
          this._updateZIndex(),
          this
      },
      isLoading: function() {
          return this._loading
      },
      redraw: function() {
          var t;
          return this._map && (this._removeAllTiles(),
          (t = this._clampZoom(this._map.getZoom())) !== this._tileZoom && (this._tileZoom = t,
          this._updateLevels()),
          this._update()),
          this
      },
      getEvents: function() {
          var t = {
              viewprereset: this._invalidateAll,
              viewreset: this._resetView,
              zoom: this._resetView,
              moveend: this._onMoveEnd
          };
          return this.options.updateWhenIdle || (this._onMove || (this._onMove = j(this._onMoveEnd, this.options.updateInterval, this)),
          t.move = this._onMove),
          this._zoomAnimated && (t.zoomanim = this._animateZoom),
          t
      },
      createTile: function() {
          return document.createElement("div")
      },
      getTileSize: function() {
          var t = this.options.tileSize;
          return t instanceof p ? t : new p(t,t)
      },
      _updateZIndex: function() {
          this._container && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._container.style.zIndex = this.options.zIndex)
      },
      _setAutoZIndex: function(t) {
          for (var e, i = this.getPane().children, n = -t(-1 / 0, 1 / 0), o = 0, s = i.length; o < s; o++)
              e = i[o].style.zIndex,
              i[o] !== this._container && e && (n = t(n, +e));
          isFinite(n) && (this.options.zIndex = n + t(-1, 1),
          this._updateZIndex())
      },
      _updateOpacity: function() {
          if (this._map && !b.ielt9) {
              C(this._container, this.options.opacity);
              var t, e = +new Date, i = !1, n = !1;
              for (t in this._tiles) {
                  var o, s = this._tiles[t];
                  s.current && s.loaded && (o = Math.min(1, (e - s.loaded) / 200),
                  C(s.el, o),
                  o < 1 ? i = !0 : (s.active ? n = !0 : this._onOpaqueTile(s),
                  s.active = !0))
              }
              n && !this._noPrune && this._pruneTiles(),
              i && (r(this._fadeFrame),
              this._fadeFrame = x(this._updateOpacity, this))
          }
      },
      _onOpaqueTile: u,
      _initContainer: function() {
          this._container || (this._container = P("div", "leaflet-layer " + (this.options.className || "")),
          this._updateZIndex(),
          this.options.opacity < 1 && this._updateOpacity(),
          this.getPane().appendChild(this._container))
      },
      _updateLevels: function() {
          var t = this._tileZoom
            , e = this.options.maxZoom;
          if (void 0 !== t) {
              for (var i in this._levels)
                  i = Number(i),
                  this._levels[i].el.children.length || i === t ? (this._levels[i].el.style.zIndex = e - Math.abs(t - i),
                  this._onUpdateLevel(i)) : (T(this._levels[i].el),
                  this._removeTilesAtZoom(i),
                  this._onRemoveLevel(i),
                  delete this._levels[i]);
              var n = this._levels[t]
                , o = this._map;
              return n || ((n = this._levels[t] = {}).el = P("div", "leaflet-tile-container leaflet-zoom-animated", this._container),
              n.el.style.zIndex = e,
              n.origin = o.project(o.unproject(o.getPixelOrigin()), t).round(),
              n.zoom = t,
              this._setZoomTransform(n, o.getCenter(), o.getZoom()),
              u(n.el.offsetWidth),
              this._onCreateLevel(n)),
              this._level = n
          }
      },
      _onUpdateLevel: u,
      _onRemoveLevel: u,
      _onCreateLevel: u,
      _pruneTiles: function() {
          if (this._map) {
              var t, e, i, n = this._map.getZoom();
              if (n > this.options.maxZoom || n < this.options.minZoom)
                  this._removeAllTiles();
              else {
                  for (t in this._tiles)
                      (i = this._tiles[t]).retain = i.current;
                  for (t in this._tiles)
                      (i = this._tiles[t]).current && !i.active && (e = i.coords,
                      this._retainParent(e.x, e.y, e.z, e.z - 5) || this._retainChildren(e.x, e.y, e.z, e.z + 2));
                  for (t in this._tiles)
                      this._tiles[t].retain || this._removeTile(t)
              }
          }
      },
      _removeTilesAtZoom: function(t) {
          for (var e in this._tiles)
              this._tiles[e].coords.z === t && this._removeTile(e)
      },
      _removeAllTiles: function() {
          for (var t in this._tiles)
              this._removeTile(t)
      },
      _invalidateAll: function() {
          for (var t in this._levels)
              T(this._levels[t].el),
              this._onRemoveLevel(Number(t)),
              delete this._levels[t];
          this._removeAllTiles(),
          this._tileZoom = void 0
      },
      _retainParent: function(t, e, i, n) {
          var t = Math.floor(t / 2)
            , e = Math.floor(e / 2)
            , i = i - 1
            , o = new p(+t,+e)
            , o = (o.z = i,
          this._tileCoordsToKey(o))
            , o = this._tiles[o];
          return o && o.active ? o.retain = !0 : (o && o.loaded && (o.retain = !0),
          n < i && this._retainParent(t, e, i, n))
      },
      _retainChildren: function(t, e, i, n) {
          for (var o = 2 * t; o < 2 * t + 2; o++)
              for (var s = 2 * e; s < 2 * e + 2; s++) {
                  var r = new p(o,s)
                    , r = (r.z = i + 1,
                  this._tileCoordsToKey(r))
                    , r = this._tiles[r];
                  r && r.active ? r.retain = !0 : (r && r.loaded && (r.retain = !0),
                  i + 1 < n && this._retainChildren(o, s, i + 1, n))
              }
      },
      _resetView: function(t) {
          t = t && (t.pinch || t.flyTo);
          this._setView(this._map.getCenter(), this._map.getZoom(), t, t)
      },
      _animateZoom: function(t) {
          this._setView(t.center, t.zoom, !0, t.noUpdate)
      },
      _clampZoom: function(t) {
          var e = this.options;
          return void 0 !== e.minNativeZoom && t < e.minNativeZoom ? e.minNativeZoom : void 0 !== e.maxNativeZoom && e.maxNativeZoom < t ? e.maxNativeZoom : t
      },
      _setView: function(t, e, i, n) {
          var o = Math.round(e)
            , o = void 0 !== this.options.maxZoom && o > this.options.maxZoom || void 0 !== this.options.minZoom && o < this.options.minZoom ? void 0 : this._clampZoom(o)
            , s = this.options.updateWhenZooming && o !== this._tileZoom;
          n && !s || (this._tileZoom = o,
          this._abortLoading && this._abortLoading(),
          this._updateLevels(),
          this._resetGrid(),
          void 0 !== o && this._update(t),
          i || this._pruneTiles(),
          this._noPrune = !!i),
          this._setZoomTransforms(t, e)
      },
      _setZoomTransforms: function(t, e) {
          for (var i in this._levels)
              this._setZoomTransform(this._levels[i], t, e)
      },
      _setZoomTransform: function(t, e, i) {
          var n = this._map.getZoomScale(i, t.zoom)
            , e = t.origin.multiplyBy(n).subtract(this._map._getNewPixelOrigin(e, i)).round();
          b.any3d ? be(t.el, e, n) : Z(t.el, e)
      },
      _resetGrid: function() {
          var t = this._map
            , e = t.options.crs
            , i = this._tileSize = this.getTileSize()
            , n = this._tileZoom
            , o = this._map.getPixelWorldBounds(this._tileZoom);
          o && (this._globalTileRange = this._pxBoundsToTileRange(o)),
          this._wrapX = e.wrapLng && !this.options.noWrap && [Math.floor(t.project([0, e.wrapLng[0]], n).x / i.x), Math.ceil(t.project([0, e.wrapLng[1]], n).x / i.y)],
          this._wrapY = e.wrapLat && !this.options.noWrap && [Math.floor(t.project([e.wrapLat[0], 0], n).y / i.x), Math.ceil(t.project([e.wrapLat[1], 0], n).y / i.y)]
      },
      _onMoveEnd: function() {
          this._map && !this._map._animatingZoom && this._update()
      },
      _getTiledPixelBounds: function(t) {
          var e = this._map
            , i = e._animatingZoom ? Math.max(e._animateToZoom, e.getZoom()) : e.getZoom()
            , i = e.getZoomScale(i, this._tileZoom)
            , t = e.project(t, this._tileZoom).floor()
            , e = e.getSize().divideBy(2 * i);
          return new f(t.subtract(e),t.add(e))
      },
      _update: function(t) {
          var e = this._map;
          if (e) {
              var i = this._clampZoom(e.getZoom());
              if (void 0 === t && (t = e.getCenter()),
              void 0 !== this._tileZoom) {
                  var n, e = this._getTiledPixelBounds(t), o = this._pxBoundsToTileRange(e), s = o.getCenter(), r = [], e = this.options.keepBuffer, a = new f(o.getBottomLeft().subtract([e, -e]),o.getTopRight().add([e, -e]));
                  if (!(isFinite(o.min.x) && isFinite(o.min.y) && isFinite(o.max.x) && isFinite(o.max.y)))
                      throw new Error("Attempted to load an infinite number of tiles");
                  for (n in this._tiles) {
                      var h = this._tiles[n].coords;
                      h.z === this._tileZoom && a.contains(new p(h.x,h.y)) || (this._tiles[n].current = !1)
                  }
                  if (1 < Math.abs(i - this._tileZoom))
                      this._setView(t, i);
                  else {
                      for (var l = o.min.y; l <= o.max.y; l++)
                          for (var u = o.min.x; u <= o.max.x; u++) {
                              var c, d = new p(u,l);
                              d.z = this._tileZoom,
                              this._isValidTile(d) && ((c = this._tiles[this._tileCoordsToKey(d)]) ? c.current = !0 : r.push(d))
                          }
                      if (r.sort(function(t, e) {
                          return t.distanceTo(s) - e.distanceTo(s)
                      }),
                      0 !== r.length) {
                          this._loading || (this._loading = !0,
                          this.fire("loading"));
                          for (var _ = document.createDocumentFragment(), u = 0; u < r.length; u++)
                              this._addTile(r[u], _);
                          this._level.el.appendChild(_)
                      }
                  }
              }
          }
      },
      _isValidTile: function(t) {
          var e = this._map.options.crs;
          if (!e.infinite) {
              var i = this._globalTileRange;
              if (!e.wrapLng && (t.x < i.min.x || t.x > i.max.x) || !e.wrapLat && (t.y < i.min.y || t.y > i.max.y))
                  return !1
          }
          return !this.options.bounds || (e = this._tileCoordsToBounds(t),
          g(this.options.bounds).overlaps(e))
      },
      _keyToBounds: function(t) {
          return this._tileCoordsToBounds(this._keyToTileCoords(t))
      },
      _tileCoordsToNwSe: function(t) {
          var e = this._map
            , i = this.getTileSize()
            , n = t.scaleBy(i)
            , i = n.add(i);
          return [e.unproject(n, t.z), e.unproject(i, t.z)]
      },
      _tileCoordsToBounds: function(t) {
          t = this._tileCoordsToNwSe(t),
          t = new s(t[0],t[1]);
          return t = this.options.noWrap ? t : this._map.wrapLatLngBounds(t)
      },
      _tileCoordsToKey: function(t) {
          return t.x + ":" + t.y + ":" + t.z
      },
      _keyToTileCoords: function(t) {
          var t = t.split(":")
            , e = new p(+t[0],+t[1]);
          return e.z = +t[2],
          e
      },
      _removeTile: function(t) {
          var e = this._tiles[t];
          e && (T(e.el),
          delete this._tiles[t],
          this.fire("tileunload", {
              tile: e.el,
              coords: this._keyToTileCoords(t)
          }))
      },
      _initTile: function(t) {
          M(t, "leaflet-tile");
          var e = this.getTileSize();
          t.style.width = e.x + "px",
          t.style.height = e.y + "px",
          t.onselectstart = u,
          t.onmousemove = u,
          b.ielt9 && this.options.opacity < 1 && C(t, this.options.opacity)
      },
      _addTile: function(t, e) {
          var i = this._getTilePos(t)
            , n = this._tileCoordsToKey(t)
            , o = this.createTile(this._wrapCoords(t), a(this._tileReady, this, t));
          this._initTile(o),
          this.createTile.length < 2 && x(a(this._tileReady, this, t, null, o)),
          Z(o, i),
          this._tiles[n] = {
              el: o,
              coords: t,
              current: !0
          },
          e.appendChild(o),
          this.fire("tileloadstart", {
              tile: o,
              coords: t
          })
      },
      _tileReady: function(t, e, i) {
          e && this.fire("tileerror", {
              error: e,
              tile: i,
              coords: t
          });
          var n = this._tileCoordsToKey(t);
          (i = this._tiles[n]) && (i.loaded = +new Date,
          this._map._fadeAnimated ? (C(i.el, 0),
          r(this._fadeFrame),
          this._fadeFrame = x(this._updateOpacity, this)) : (i.active = !0,
          this._pruneTiles()),
          e || (M(i.el, "leaflet-tile-loaded"),
          this.fire("tileload", {
              tile: i.el,
              coords: t
          })),
          this._noTilesToLoad() && (this._loading = !1,
          this.fire("load"),
          b.ielt9 || !this._map._fadeAnimated ? x(this._pruneTiles, this) : setTimeout(a(this._pruneTiles, this), 250)))
      },
      _getTilePos: function(t) {
          return t.scaleBy(this.getTileSize()).subtract(this._level.origin)
      },
      _wrapCoords: function(t) {
          var e = new p(this._wrapX ? H(t.x, this._wrapX) : t.x,this._wrapY ? H(t.y, this._wrapY) : t.y);
          return e.z = t.z,
          e
      },
      _pxBoundsToTileRange: function(t) {
          var e = this.getTileSize();
          return new f(t.min.unscaleBy(e).floor(),t.max.unscaleBy(e).ceil().subtract([1, 1]))
      },
      _noTilesToLoad: function() {
          for (var t in this._tiles)
              if (!this._tiles[t].loaded)
                  return !1;
          return !0
      }
  });
  var Di = Ni.extend({
      options: {
          minZoom: 0,
          maxZoom: 18,
          subdomains: "abc",
          errorTileUrl: "",
          zoomOffset: 0,
          tms: !1,
          zoomReverse: !1,
          detectRetina: !1,
          crossOrigin: !1,
          referrerPolicy: !1
      },
      initialize: function(t, e) {
          this._url = t,
          (e = c(this, e)).detectRetina && b.retina && 0 < e.maxZoom ? (e.tileSize = Math.floor(e.tileSize / 2),
          e.zoomReverse ? (e.zoomOffset--,
          e.minZoom = Math.min(e.maxZoom, e.minZoom + 1)) : (e.zoomOffset++,
          e.maxZoom = Math.max(e.minZoom, e.maxZoom - 1)),
          e.minZoom = Math.max(0, e.minZoom)) : e.zoomReverse ? e.minZoom = Math.min(e.maxZoom, e.minZoom) : e.maxZoom = Math.max(e.minZoom, e.maxZoom),
          "string" == typeof e.subdomains && (e.subdomains = e.subdomains.split("")),
          this.on("tileunload", this._onTileRemove)
      },
      setUrl: function(t, e) {
          return this._url === t && void 0 === e && (e = !0),
          this._url = t,
          e || this.redraw(),
          this
      },
      createTile: function(t, e) {
          var i = document.createElement("img");
          return S(i, "load", a(this._tileOnLoad, this, e, i)),
          S(i, "error", a(this._tileOnError, this, e, i)),
          !this.options.crossOrigin && "" !== this.options.crossOrigin || (i.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin),
          "string" == typeof this.options.referrerPolicy && (i.referrerPolicy = this.options.referrerPolicy),
          i.alt = "",
          i.src = this.getTileUrl(t),
          i
      },
      getTileUrl: function(t) {
          var e = {
              r: b.retina ? "@2x" : "",
              s: this._getSubdomain(t),
              x: t.x,
              y: t.y,
              z: this._getZoomForUrl()
          };
          return this._map && !this._map.options.crs.infinite && (t = this._globalTileRange.max.y - t.y,
          this.options.tms && (e.y = t),
          e["-y"] = t),
          q(this._url, l(e, this.options))
      },
      _tileOnLoad: function(t, e) {
          b.ielt9 ? setTimeout(a(t, this, null, e), 0) : t(null, e)
      },
      _tileOnError: function(t, e, i) {
          var n = this.options.errorTileUrl;
          n && e.getAttribute("src") !== n && (e.src = n),
          t(i, e)
      },
      _onTileRemove: function(t) {
          t.tile.onload = null
      },
      _getZoomForUrl: function() {
          var t = this._tileZoom
            , e = this.options.maxZoom;
          return (t = this.options.zoomReverse ? e - t : t) + this.options.zoomOffset
      },
      _getSubdomain: function(t) {
          t = Math.abs(t.x + t.y) % this.options.subdomains.length;
          return this.options.subdomains[t]
      },
      _abortLoading: function() {
          var t, e, i;
          for (t in this._tiles)
              this._tiles[t].coords.z !== this._tileZoom && ((i = this._tiles[t].el).onload = u,
              i.onerror = u,
              i.complete || (i.src = K,
              e = this._tiles[t].coords,
              T(i),
              delete this._tiles[t],
              this.fire("tileabort", {
                  tile: i,
                  coords: e
              })))
      },
      _removeTile: function(t) {
          var e = this._tiles[t];
          if (e)
              return e.el.setAttribute("src", K),
              Ni.prototype._removeTile.call(this, t)
      },
      _tileReady: function(t, e, i) {
          if (this._map && (!i || i.getAttribute("src") !== K))
              return Ni.prototype._tileReady.call(this, t, e, i)
      }
  });
  function ji(t, e) {
      return new Di(t,e)
  }
  var Hi = Di.extend({
      defaultWmsParams: {
          service: "WMS",
          request: "GetMap",
          layers: "",
          styles: "",
          format: "image/jpeg",
          transparent: !1,
          version: "1.1.1"
      },
      options: {
          crs: null,
          uppercase: !1
      },
      initialize: function(t, e) {
          this._url = t;
          var i, n = l({}, this.defaultWmsParams);
          for (i in e)
              i in this.options || (n[i] = e[i]);
          var t = (e = c(this, e)).detectRetina && b.retina ? 2 : 1
            , o = this.getTileSize();
          n.width = o.x * t,
          n.height = o.y * t,
          this.wmsParams = n
      },
      onAdd: function(t) {
          this._crs = this.options.crs || t.options.crs,
          this._wmsVersion = parseFloat(this.wmsParams.version);
          var e = 1.3 <= this._wmsVersion ? "crs" : "srs";
          this.wmsParams[e] = this._crs.code,
          Di.prototype.onAdd.call(this, t)
      },
      getTileUrl: function(t) {
          var e = this._tileCoordsToNwSe(t)
            , i = this._crs
            , i = _(i.project(e[0]), i.project(e[1]))
            , e = i.min
            , i = i.max
            , e = (1.3 <= this._wmsVersion && this._crs === li ? [e.y, e.x, i.y, i.x] : [e.x, e.y, i.x, i.y]).join(",")
            , i = Di.prototype.getTileUrl.call(this, t);
          return i + U(this.wmsParams, i, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + e
      },
      setParams: function(t, e) {
          return l(this.wmsParams, t),
          e || this.redraw(),
          this
      }
  });
  Di.WMS = Hi,
  ji.wms = function(t, e) {
      return new Hi(t,e)
  }
  ;
  var Wi = o.extend({
      options: {
          padding: .1
      },
      initialize: function(t) {
          c(this, t),
          h(this),
          this._layers = this._layers || {}
      },
      onAdd: function() {
          this._container || (this._initContainer(),
          M(this._container, "leaflet-zoom-animated")),
          this.getPane().appendChild(this._container),
          this._update(),
          this.on("update", this._updatePaths, this)
      },
      onRemove: function() {
          this.off("update", this._updatePaths, this),
          this._destroyContainer()
      },
      getEvents: function() {
          var t = {
              viewreset: this._reset,
              zoom: this._onZoom,
              moveend: this._update,
              zoomend: this._onZoomEnd
          };
          return this._zoomAnimated && (t.zoomanim = this._onAnimZoom),
          t
      },
      _onAnimZoom: function(t) {
          this._updateTransform(t.center, t.zoom)
      },
      _onZoom: function() {
          this._updateTransform(this._map.getCenter(), this._map.getZoom())
      },
      _updateTransform: function(t, e) {
          var i = this._map.getZoomScale(e, this._zoom)
            , n = this._map.getSize().multiplyBy(.5 + this.options.padding)
            , o = this._map.project(this._center, e)
            , n = n.multiplyBy(-i).add(o).subtract(this._map._getNewPixelOrigin(t, e));
          b.any3d ? be(this._container, n, i) : Z(this._container, n)
      },
      _reset: function() {
          for (var t in this._update(),
          this._updateTransform(this._center, this._zoom),
          this._layers)
              this._layers[t]._reset()
      },
      _onZoomEnd: function() {
          for (var t in this._layers)
              this._layers[t]._project()
      },
      _updatePaths: function() {
          for (var t in this._layers)
              this._layers[t]._update()
      },
      _update: function() {
          var t = this.options.padding
            , e = this._map.getSize()
            , i = this._map.containerPointToLayerPoint(e.multiplyBy(-t)).round();
          this._bounds = new f(i,i.add(e.multiplyBy(1 + 2 * t)).round()),
          this._center = this._map.getCenter(),
          this._zoom = this._map.getZoom()
      }
  })
    , Fi = Wi.extend({
      options: {
          tolerance: 0
      },
      getEvents: function() {
          var t = Wi.prototype.getEvents.call(this);
          return t.viewprereset = this._onViewPreReset,
          t
      },
      _onViewPreReset: function() {
          this._postponeUpdatePaths = !0
      },
      onAdd: function() {
          Wi.prototype.onAdd.call(this),
          this._draw()
      },
      _initContainer: function() {
          var t = this._container = document.createElement("canvas");
          S(t, "mousemove", this._onMouseMove, this),
          S(t, "click dblclick mousedown mouseup contextmenu", this._onClick, this),
          S(t, "mouseout", this._handleMouseOut, this),
          t._leaflet_disable_events = !0,
          this._ctx = t.getContext("2d")
      },
      _destroyContainer: function() {
          r(this._redrawRequest),
          delete this._ctx,
          T(this._container),
          k(this._container),
          delete this._container
      },
      _updatePaths: function() {
          if (!this._postponeUpdatePaths) {
              for (var t in this._redrawBounds = null,
              this._layers)
                  this._layers[t]._update();
              this._redraw()
          }
      },
      _update: function() {
          var t, e, i, n;
          this._map._animatingZoom && this._bounds || (Wi.prototype._update.call(this),
          t = this._bounds,
          e = this._container,
          i = t.getSize(),
          n = b.retina ? 2 : 1,
          Z(e, t.min),
          e.width = n * i.x,
          e.height = n * i.y,
          e.style.width = i.x + "px",
          e.style.height = i.y + "px",
          b.retina && this._ctx.scale(2, 2),
          this._ctx.translate(-t.min.x, -t.min.y),
          this.fire("update"))
      },
      _reset: function() {
          Wi.prototype._reset.call(this),
          this._postponeUpdatePaths && (this._postponeUpdatePaths = !1,
          this._updatePaths())
      },
      _initPath: function(t) {
          this._updateDashArray(t);
          t = (this._layers[h(t)] = t)._order = {
              layer: t,
              prev: this._drawLast,
              next: null
          };
          this._drawLast && (this._drawLast.next = t),
          this._drawLast = t,
          this._drawFirst = this._drawFirst || this._drawLast
      },
      _addPath: function(t) {
          this._requestRedraw(t)
      },
      _removePath: function(t) {
          var e = t._order
            , i = e.next
            , e = e.prev;
          i ? i.prev = e : this._drawLast = e,
          e ? e.next = i : this._drawFirst = i,
          delete t._order,
          delete this._layers[h(t)],
          this._requestRedraw(t)
      },
      _updatePath: function(t) {
          this._extendRedrawBounds(t),
          t._project(),
          t._update(),
          this._requestRedraw(t)
      },
      _updateStyle: function(t) {
          this._updateDashArray(t),
          this._requestRedraw(t)
      },
      _updateDashArray: function(t) {
          if ("string" == typeof t.options.dashArray) {
              for (var e, i = t.options.dashArray.split(/[, ]+/), n = [], o = 0; o < i.length; o++) {
                  if (e = Number(i[o]),
                  isNaN(e))
                      return;
                  n.push(e)
              }
              t.options._dashArray = n
          } else
              t.options._dashArray = t.options.dashArray
      },
      _requestRedraw: function(t) {
          this._map && (this._extendRedrawBounds(t),
          this._redrawRequest = this._redrawRequest || x(this._redraw, this))
      },
      _extendRedrawBounds: function(t) {
          var e;
          t._pxBounds && (e = (t.options.weight || 0) + 1,
          this._redrawBounds = this._redrawBounds || new f,
          this._redrawBounds.extend(t._pxBounds.min.subtract([e, e])),
          this._redrawBounds.extend(t._pxBounds.max.add([e, e])))
      },
      _redraw: function() {
          this._redrawRequest = null,
          this._redrawBounds && (this._redrawBounds.min._floor(),
          this._redrawBounds.max._ceil()),
          this._clear(),
          this._draw(),
          this._redrawBounds = null
      },
      _clear: function() {
          var t, e = this._redrawBounds;
          e ? (t = e.getSize(),
          this._ctx.clearRect(e.min.x, e.min.y, t.x, t.y)) : (this._ctx.save(),
          this._ctx.setTransform(1, 0, 0, 1, 0, 0),
          this._ctx.clearRect(0, 0, this._container.width, this._container.height),
          this._ctx.restore())
      },
      _draw: function() {
          var t, e, i = this._redrawBounds;
          this._ctx.save(),
          i && (e = i.getSize(),
          this._ctx.beginPath(),
          this._ctx.rect(i.min.x, i.min.y, e.x, e.y),
          this._ctx.clip()),
          this._drawing = !0;
          for (var n = this._drawFirst; n; n = n.next)
              t = n.layer,
              (!i || t._pxBounds && t._pxBounds.intersects(i)) && t._updatePath();
          this._drawing = !1,
          this._ctx.restore()
      },
      _updatePoly: function(t, e) {
          if (this._drawing) {
              var i, n, o, s, r = t._parts, a = r.length, h = this._ctx;
              if (a) {
                  for (h.beginPath(),
                  i = 0; i < a; i++) {
                      for (n = 0,
                      o = r[i].length; n < o; n++)
                          s = r[i][n],
                          h[n ? "lineTo" : "moveTo"](s.x, s.y);
                      e && h.closePath()
                  }
                  this._fillStroke(h, t)
              }
          }
      },
      _updateCircle: function(t) {
          var e, i, n, o;
          this._drawing && !t._empty() && (e = t._point,
          i = this._ctx,
          n = Math.max(Math.round(t._radius), 1),
          1 != (o = (Math.max(Math.round(t._radiusY), 1) || n) / n) && (i.save(),
          i.scale(1, o)),
          i.beginPath(),
          i.arc(e.x, e.y / o, n, 0, 2 * Math.PI, !1),
          1 != o && i.restore(),
          this._fillStroke(i, t))
      },
      _fillStroke: function(t, e) {
          var i = e.options;
          i.fill && (t.globalAlpha = i.fillOpacity,
          t.fillStyle = i.fillColor || i.color,
          t.fill(i.fillRule || "evenodd")),
          i.stroke && 0 !== i.weight && (t.setLineDash && t.setLineDash(e.options && e.options._dashArray || []),
          t.globalAlpha = i.opacity,
          t.lineWidth = i.weight,
          t.strokeStyle = i.color,
          t.lineCap = i.lineCap,
          t.lineJoin = i.lineJoin,
          t.stroke())
      },
      _onClick: function(t) {
          for (var e, i, n = this._map.mouseEventToLayerPoint(t), o = this._drawFirst; o; o = o.next)
              (e = o.layer).options.interactive && e._containsPoint(n) && (("click" === t.type || "preclick" === t.type) && this._map._draggableMoved(e) || (i = e));
          this._fireEvent(!!i && [i], t)
      },
      _onMouseMove: function(t) {
          var e;
          !this._map || this._map.dragging.moving() || this._map._animatingZoom || (e = this._map.mouseEventToLayerPoint(t),
          this._handleMouseHover(t, e))
      },
      _handleMouseOut: function(t) {
          var e = this._hoveredLayer;
          e && (z(this._container, "leaflet-interactive"),
          this._fireEvent([e], t, "mouseout"),
          this._hoveredLayer = null,
          this._mouseHoverThrottled = !1)
      },
      _handleMouseHover: function(t, e) {
          if (!this._mouseHoverThrottled) {
              for (var i, n, o = this._drawFirst; o; o = o.next)
                  (i = o.layer).options.interactive && i._containsPoint(e) && (n = i);
              n !== this._hoveredLayer && (this._handleMouseOut(t),
              n && (M(this._container, "leaflet-interactive"),
              this._fireEvent([n], t, "mouseover"),
              this._hoveredLayer = n)),
              this._fireEvent(!!this._hoveredLayer && [this._hoveredLayer], t),
              this._mouseHoverThrottled = !0,
              setTimeout(a(function() {
                  this._mouseHoverThrottled = !1
              }, this), 32)
          }
      },
      _fireEvent: function(t, e, i) {
          this._map._fireDOMEvent(e, i || e.type, t)
      },
      _bringToFront: function(t) {
          var e, i, n = t._order;
          n && (e = n.next,
          i = n.prev,
          e && ((e.prev = i) ? i.next = e : e && (this._drawFirst = e),
          n.prev = this._drawLast,
          (this._drawLast.next = n).next = null,
          this._drawLast = n,
          this._requestRedraw(t)))
      },
      _bringToBack: function(t) {
          var e, i, n = t._order;
          n && (e = n.next,
          (i = n.prev) && ((i.next = e) ? e.prev = i : i && (this._drawLast = i),
          n.prev = null,
          n.next = this._drawFirst,
          this._drawFirst.prev = n,
          this._drawFirst = n,
          this._requestRedraw(t)))
      }
  });
  function Ui(t) {
      return b.canvas ? new Fi(t) : null
  }
  var Vi = function() {
      try {
          return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"),
          function(t) {
              return document.createElement("<lvml:" + t + ' class="lvml">')
          }
      } catch (t) {}
      return function(t) {
          return document.createElement("<" + t + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')
      }
  }()
    , zt = {
      _initContainer: function() {
          this._container = P("div", "leaflet-vml-container")
      },
      _update: function() {
          this._map._animatingZoom || (Wi.prototype._update.call(this),
          this.fire("update"))
      },
      _initPath: function(t) {
          var e = t._container = Vi("shape");
          M(e, "leaflet-vml-shape " + (this.options.className || "")),
          e.coordsize = "1 1",
          t._path = Vi("path"),
          e.appendChild(t._path),
          this._updateStyle(t),
          this._layers[h(t)] = t
      },
      _addPath: function(t) {
          var e = t._container;
          this._container.appendChild(e),
          t.options.interactive && t.addInteractiveTarget(e)
      },
      _removePath: function(t) {
          var e = t._container;
          T(e),
          t.removeInteractiveTarget(e),
          delete this._layers[h(t)]
      },
      _updateStyle: function(t) {
          var e = t._stroke
            , i = t._fill
            , n = t.options
            , o = t._container;
          o.stroked = !!n.stroke,
          o.filled = !!n.fill,
          n.stroke ? (e = e || (t._stroke = Vi("stroke")),
          o.appendChild(e),
          e.weight = n.weight + "px",
          e.color = n.color,
          e.opacity = n.opacity,
          n.dashArray ? e.dashStyle = d(n.dashArray) ? n.dashArray.join(" ") : n.dashArray.replace(/( *, *)/g, " ") : e.dashStyle = "",
          e.endcap = n.lineCap.replace("butt", "flat"),
          e.joinstyle = n.lineJoin) : e && (o.removeChild(e),
          t._stroke = null),
          n.fill ? (i = i || (t._fill = Vi("fill")),
          o.appendChild(i),
          i.color = n.fillColor || n.color,
          i.opacity = n.fillOpacity) : i && (o.removeChild(i),
          t._fill = null)
      },
      _updateCircle: function(t) {
          var e = t._point.round()
            , i = Math.round(t._radius)
            , n = Math.round(t._radiusY || i);
          this._setPath(t, t._empty() ? "M0 0" : "AL " + e.x + "," + e.y + " " + i + "," + n + " 0,23592600")
      },
      _setPath: function(t, e) {
          t._path.v = e
      },
      _bringToFront: function(t) {
          fe(t._container)
      },
      _bringToBack: function(t) {
          ge(t._container)
      }
  }
    , qi = b.vml ? Vi : ct
    , Gi = Wi.extend({
      _initContainer: function() {
          this._container = qi("svg"),
          this._container.setAttribute("pointer-events", "none"),
          this._rootGroup = qi("g"),
          this._container.appendChild(this._rootGroup)
      },
      _destroyContainer: function() {
          T(this._container),
          k(this._container),
          delete this._container,
          delete this._rootGroup,
          delete this._svgSize
      },
      _update: function() {
          var t, e, i;
          this._map._animatingZoom && this._bounds || (Wi.prototype._update.call(this),
          e = (t = this._bounds).getSize(),
          i = this._container,
          this._svgSize && this._svgSize.equals(e) || (this._svgSize = e,
          i.setAttribute("width", e.x),
          i.setAttribute("height", e.y)),
          Z(i, t.min),
          i.setAttribute("viewBox", [t.min.x, t.min.y, e.x, e.y].join(" ")),
          this.fire("update"))
      },
      _initPath: function(t) {
          var e = t._path = qi("path");
          t.options.className && M(e, t.options.className),
          t.options.interactive && M(e, "leaflet-interactive"),
          this._updateStyle(t),
          this._layers[h(t)] = t
      },
      _addPath: function(t) {
          this._rootGroup || this._initContainer(),
          this._rootGroup.appendChild(t._path),
          t.addInteractiveTarget(t._path)
      },
      _removePath: function(t) {
          T(t._path),
          t.removeInteractiveTarget(t._path),
          delete this._layers[h(t)]
      },
      _updatePath: function(t) {
          t._project(),
          t._update()
      },
      _updateStyle: function(t) {
          var e = t._path
            , t = t.options;
          e && (t.stroke ? (e.setAttribute("stroke", t.color),
          e.setAttribute("stroke-opacity", t.opacity),
          e.setAttribute("stroke-width", t.weight),
          e.setAttribute("stroke-linecap", t.lineCap),
          e.setAttribute("stroke-linejoin", t.lineJoin),
          t.dashArray ? e.setAttribute("stroke-dasharray", t.dashArray) : e.removeAttribute("stroke-dasharray"),
          t.dashOffset ? e.setAttribute("stroke-dashoffset", t.dashOffset) : e.removeAttribute("stroke-dashoffset")) : e.setAttribute("stroke", "none"),
          t.fill ? (e.setAttribute("fill", t.fillColor || t.color),
          e.setAttribute("fill-opacity", t.fillOpacity),
          e.setAttribute("fill-rule", t.fillRule || "evenodd")) : e.setAttribute("fill", "none"))
      },
      _updatePoly: function(t, e) {
          this._setPath(t, dt(t._parts, e))
      },
      _updateCircle: function(t) {
          var e = t._point
            , i = Math.max(Math.round(t._radius), 1)
            , n = "a" + i + "," + (Math.max(Math.round(t._radiusY), 1) || i) + " 0 1,0 "
            , e = t._empty() ? "M0 0" : "M" + (e.x - i) + "," + e.y + n + 2 * i + ",0 " + n + 2 * -i + ",0 ";
          this._setPath(t, e)
      },
      _setPath: function(t, e) {
          t._path.setAttribute("d", e)
      },
      _bringToFront: function(t) {
          fe(t._path)
      },
      _bringToBack: function(t) {
          ge(t._path)
      }
  });
  function Ki(t) {
      return b.svg || b.vml ? new Gi(t) : null
  }
  b.vml && Gi.include(zt),
  A.include({
      getRenderer: function(t) {
          t = (t = t.options.renderer || this._getPaneRenderer(t.options.pane) || this.options.renderer || this._renderer) || (this._renderer = this._createRenderer());
          return this.hasLayer(t) || this.addLayer(t),
          t
      },
      _getPaneRenderer: function(t) {
          var e;
          return "overlayPane" !== t && void 0 !== t && (void 0 === (e = this._paneRenderers[t]) && (e = this._createRenderer({
              pane: t
          }),
          this._paneRenderers[t] = e),
          e)
      },
      _createRenderer: function(t) {
          return this.options.preferCanvas && Ui(t) || Ki(t)
      }
  });
  var Yi = xi.extend({
      initialize: function(t, e) {
          xi.prototype.initialize.call(this, this._boundsToLatLngs(t), e)
      },
      setBounds: function(t) {
          return this.setLatLngs(this._boundsToLatLngs(t))
      },
      _boundsToLatLngs: function(t) {
          return [(t = g(t)).getSouthWest(), t.getNorthWest(), t.getNorthEast(), t.getSouthEast()]
      }
  });
  Gi.create = qi,
  Gi.pointsToPath = dt,
  wi.geometryToLayer = bi,
  wi.coordsToLatLng = Li,
  wi.coordsToLatLngs = Ti,
  wi.latLngToCoords = Mi,
  wi.latLngsToCoords = zi,
  wi.getFeature = Ci,
  wi.asFeature = Zi,
  A.mergeOptions({
      boxZoom: !0
  });
  var _t = n.extend({
      initialize: function(t) {
          this._map = t,
          this._container = t._container,
          this._pane = t._panes.overlayPane,
          this._resetStateTimeout = 0,
          t.on("unload", this._destroy, this)
      },
      addHooks: function() {
          S(this._container, "mousedown", this._onMouseDown, this)
      },
      removeHooks: function() {
          k(this._container, "mousedown", this._onMouseDown, this)
      },
      moved: function() {
          return this._moved
      },
      _destroy: function() {
          T(this._pane),
          delete this._pane
      },
      _resetState: function() {
          this._resetStateTimeout = 0,
          this._moved = !1
      },
      _clearDeferredResetState: function() {
          0 !== this._resetStateTimeout && (clearTimeout(this._resetStateTimeout),
          this._resetStateTimeout = 0)
      },
      _onMouseDown: function(t) {
          if (!t.shiftKey || 1 !== t.which && 1 !== t.button)
              return !1;
          this._clearDeferredResetState(),
          this._resetState(),
          re(),
          Le(),
          this._startPoint = this._map.mouseEventToContainerPoint(t),
          S(document, {
              contextmenu: Re,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
          }, this)
      },
      _onMouseMove: function(t) {
          this._moved || (this._moved = !0,
          this._box = P("div", "leaflet-zoom-box", this._container),
          M(this._container, "leaflet-crosshair"),
          this._map.fire("boxzoomstart")),
          this._point = this._map.mouseEventToContainerPoint(t);
          var t = new f(this._point,this._startPoint)
            , e = t.getSize();
          Z(this._box, t.min),
          this._box.style.width = e.x + "px",
          this._box.style.height = e.y + "px"
      },
      _finish: function() {
          this._moved && (T(this._box),
          z(this._container, "leaflet-crosshair")),
          ae(),
          Te(),
          k(document, {
              contextmenu: Re,
              mousemove: this._onMouseMove,
              mouseup: this._onMouseUp,
              keydown: this._onKeyDown
          }, this)
      },
      _onMouseUp: function(t) {
          1 !== t.which && 1 !== t.button || (this._finish(),
          this._moved && (this._clearDeferredResetState(),
          this._resetStateTimeout = setTimeout(a(this._resetState, this), 0),
          t = new s(this._map.containerPointToLatLng(this._startPoint),this._map.containerPointToLatLng(this._point)),
          this._map.fitBounds(t).fire("boxzoomend", {
              boxZoomBounds: t
          })))
      },
      _onKeyDown: function(t) {
          27 === t.keyCode && (this._finish(),
          this._clearDeferredResetState(),
          this._resetState())
      }
  })
    , Ct = (A.addInitHook("addHandler", "boxZoom", _t),
  A.mergeOptions({
      doubleClickZoom: !0
  }),
  n.extend({
      addHooks: function() {
          this._map.on("dblclick", this._onDoubleClick, this)
      },
      removeHooks: function() {
          this._map.off("dblclick", this._onDoubleClick, this)
      },
      _onDoubleClick: function(t) {
          var e = this._map
            , i = e.getZoom()
            , n = e.options.zoomDelta
            , i = t.originalEvent.shiftKey ? i - n : i + n;
          "center" === e.options.doubleClickZoom ? e.setZoom(i) : e.setZoomAround(t.containerPoint, i)
      }
  }))
    , Zt = (A.addInitHook("addHandler", "doubleClickZoom", Ct),
  A.mergeOptions({
      dragging: !0,
      inertia: !0,
      inertiaDeceleration: 3400,
      inertiaMaxSpeed: 1 / 0,
      easeLinearity: .2,
      worldCopyJump: !1,
      maxBoundsViscosity: 0
  }),
  n.extend({
      addHooks: function() {
          var t;
          this._draggable || (t = this._map,
          this._draggable = new Xe(t._mapPane,t._container),
          this._draggable.on({
              dragstart: this._onDragStart,
              drag: this._onDrag,
              dragend: this._onDragEnd
          }, this),
          this._draggable.on("predrag", this._onPreDragLimit, this),
          t.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this),
          t.on("zoomend", this._onZoomEnd, this),
          t.whenReady(this._onZoomEnd, this))),
          M(this._map._container, "leaflet-grab leaflet-touch-drag"),
          this._draggable.enable(),
          this._positions = [],
          this._times = []
      },
      removeHooks: function() {
          z(this._map._container, "leaflet-grab"),
          z(this._map._container, "leaflet-touch-drag"),
          this._draggable.disable()
      },
      moved: function() {
          return this._draggable && this._draggable._moved
      },
      moving: function() {
          return this._draggable && this._draggable._moving
      },
      _onDragStart: function() {
          var t, e = this._map;
          e._stop(),
          this._map.options.maxBounds && this._map.options.maxBoundsViscosity ? (t = g(this._map.options.maxBounds),
          this._offsetLimit = _(this._map.latLngToContainerPoint(t.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(t.getSouthEast()).multiplyBy(-1).add(this._map.getSize())),
          this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity))) : this._offsetLimit = null,
          e.fire("movestart").fire("dragstart"),
          e.options.inertia && (this._positions = [],
          this._times = [])
      },
      _onDrag: function(t) {
          var e, i;
          this._map.options.inertia && (e = this._lastTime = +new Date,
          i = this._lastPos = this._draggable._absPos || this._draggable._newPos,
          this._positions.push(i),
          this._times.push(e),
          this._prunePositions(e)),
          this._map.fire("move", t).fire("drag", t)
      },
      _prunePositions: function(t) {
          for (; 1 < this._positions.length && 50 < t - this._times[0]; )
              this._positions.shift(),
              this._times.shift()
      },
      _onZoomEnd: function() {
          var t = this._map.getSize().divideBy(2)
            , e = this._map.latLngToLayerPoint([0, 0]);
          this._initialWorldOffset = e.subtract(t).x,
          this._worldWidth = this._map.getPixelWorldBounds().getSize().x
      },
      _viscousLimit: function(t, e) {
          return t - (t - e) * this._viscosity
      },
      _onPreDragLimit: function() {
          var t, e;
          this._viscosity && this._offsetLimit && (t = this._draggable._newPos.subtract(this._draggable._startPos),
          e = this._offsetLimit,
          t.x < e.min.x && (t.x = this._viscousLimit(t.x, e.min.x)),
          t.y < e.min.y && (t.y = this._viscousLimit(t.y, e.min.y)),
          t.x > e.max.x && (t.x = this._viscousLimit(t.x, e.max.x)),
          t.y > e.max.y && (t.y = this._viscousLimit(t.y, e.max.y)),
          this._draggable._newPos = this._draggable._startPos.add(t))
      },
      _onPreDragWrap: function() {
          var t = this._worldWidth
            , e = Math.round(t / 2)
            , i = this._initialWorldOffset
            , n = this._draggable._newPos.x
            , o = (n - e + i) % t + e - i
            , n = (n + e + i) % t - e - i
            , t = Math.abs(o + i) < Math.abs(n + i) ? o : n;
          this._draggable._absPos = this._draggable._newPos.clone(),
          this._draggable._newPos.x = t
      },
      _onDragEnd: function(t) {
          var e, i, n, o, s = this._map, r = s.options, a = !r.inertia || t.noInertia || this._times.length < 2;
          s.fire("dragend", t),
          !a && (this._prunePositions(+new Date),
          t = this._lastPos.subtract(this._positions[0]),
          a = (this._lastTime - this._times[0]) / 1e3,
          e = r.easeLinearity,
          a = (t = t.multiplyBy(e / a)).distanceTo([0, 0]),
          i = Math.min(r.inertiaMaxSpeed, a),
          t = t.multiplyBy(i / a),
          n = i / (r.inertiaDeceleration * e),
          (o = t.multiplyBy(-n / 2).round()).x || o.y) ? (o = s._limitOffset(o, s.options.maxBounds),
          x(function() {
              s.panBy(o, {
                  duration: n,
                  easeLinearity: e,
                  noMoveStart: !0,
                  animate: !0
              })
          })) : s.fire("moveend")
      }
  }))
    , St = (A.addInitHook("addHandler", "dragging", Zt),
  A.mergeOptions({
      keyboard: !0,
      keyboardPanDelta: 80
  }),
  n.extend({
      keyCodes: {
          left: [37],
          right: [39],
          down: [40],
          up: [38],
          zoomIn: [187, 107, 61, 171],
          zoomOut: [189, 109, 54, 173]
      },
      initialize: function(t) {
          this._map = t,
          this._setPanDelta(t.options.keyboardPanDelta),
          this._setZoomDelta(t.options.zoomDelta)
      },
      addHooks: function() {
          var t = this._map._container;
          t.tabIndex <= 0 && (t.tabIndex = "0"),
          S(t, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
          }, this),
          this._map.on({
              focus: this._addHooks,
              blur: this._removeHooks
          }, this)
      },
      removeHooks: function() {
          this._removeHooks(),
          k(this._map._container, {
              focus: this._onFocus,
              blur: this._onBlur,
              mousedown: this._onMouseDown
          }, this),
          this._map.off({
              focus: this._addHooks,
              blur: this._removeHooks
          }, this)
      },
      _onMouseDown: function() {
          var t, e, i;
          this._focused || (i = document.body,
          t = document.documentElement,
          e = i.scrollTop || t.scrollTop,
          i = i.scrollLeft || t.scrollLeft,
          this._map._container.focus(),
          window.scrollTo(i, e))
      },
      _onFocus: function() {
          this._focused = !0,
          this._map.fire("focus")
      },
      _onBlur: function() {
          this._focused = !1,
          this._map.fire("blur")
      },
      _setPanDelta: function(t) {
          for (var e = this._panKeys = {}, i = this.keyCodes, n = 0, o = i.left.length; n < o; n++)
              e[i.left[n]] = [-1 * t, 0];
          for (n = 0,
          o = i.right.length; n < o; n++)
              e[i.right[n]] = [t, 0];
          for (n = 0,
          o = i.down.length; n < o; n++)
              e[i.down[n]] = [0, t];
          for (n = 0,
          o = i.up.length; n < o; n++)
              e[i.up[n]] = [0, -1 * t]
      },
      _setZoomDelta: function(t) {
          for (var e = this._zoomKeys = {}, i = this.keyCodes, n = 0, o = i.zoomIn.length; n < o; n++)
              e[i.zoomIn[n]] = t;
          for (n = 0,
          o = i.zoomOut.length; n < o; n++)
              e[i.zoomOut[n]] = -t
      },
      _addHooks: function() {
          S(document, "keydown", this._onKeyDown, this)
      },
      _removeHooks: function() {
          k(document, "keydown", this._onKeyDown, this)
      },
      _onKeyDown: function(t) {
          if (!(t.altKey || t.ctrlKey || t.metaKey)) {
              var e, i, n = t.keyCode, o = this._map;
              if (n in this._panKeys)
                  o._panAnim && o._panAnim._inProgress || (i = this._panKeys[n],
                  t.shiftKey && (i = m(i).multiplyBy(3)),
                  o.options.maxBounds && (i = o._limitOffset(m(i), o.options.maxBounds)),
                  o.options.worldCopyJump ? (e = o.wrapLatLng(o.unproject(o.project(o.getCenter()).add(i))),
                  o.panTo(e)) : o.panBy(i));
              else if (n in this._zoomKeys)
                  o.setZoom(o.getZoom() + (t.shiftKey ? 3 : 1) * this._zoomKeys[n]);
              else {
                  if (27 !== n || !o._popup || !o._popup.options.closeOnEscapeKey)
                      return;
                  o.closePopup()
              }
              Re(t)
          }
      }
  }))
    , Et = (A.addInitHook("addHandler", "keyboard", St),
  A.mergeOptions({
      scrollWheelZoom: !0,
      wheelDebounceTime: 40,
      wheelPxPerZoomLevel: 60
  }),
  n.extend({
      addHooks: function() {
          S(this._map._container, "wheel", this._onWheelScroll, this),
          this._delta = 0
      },
      removeHooks: function() {
          k(this._map._container, "wheel", this._onWheelScroll, this)
      },
      _onWheelScroll: function(t) {
          var e = He(t)
            , i = this._map.options.wheelDebounceTime
            , e = (this._delta += e,
          this._lastMousePos = this._map.mouseEventToContainerPoint(t),
          this._startTime || (this._startTime = +new Date),
          Math.max(i - (+new Date - this._startTime), 0));
          clearTimeout(this._timer),
          this._timer = setTimeout(a(this._performZoom, this), e),
          Re(t)
      },
      _performZoom: function() {
          var t = this._map
            , e = t.getZoom()
            , i = this._map.options.zoomSnap || 0
            , n = (t._stop(),
          this._delta / (4 * this._map.options.wheelPxPerZoomLevel))
            , n = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(n)))) / Math.LN2
            , i = i ? Math.ceil(n / i) * i : n
            , n = t._limitZoom(e + (0 < this._delta ? i : -i)) - e;
          this._delta = 0,
          this._startTime = null,
          n && ("center" === t.options.scrollWheelZoom ? t.setZoom(e + n) : t.setZoomAround(this._lastMousePos, e + n))
      }
  }))
    , kt = (A.addInitHook("addHandler", "scrollWheelZoom", Et),
  A.mergeOptions({
      tapHold: b.touchNative && b.safari && b.mobile,
      tapTolerance: 15
  }),
  n.extend({
      addHooks: function() {
          S(this._map._container, "touchstart", this._onDown, this)
      },
      removeHooks: function() {
          k(this._map._container, "touchstart", this._onDown, this)
      },
      _onDown: function(t) {
          var e;
          clearTimeout(this._holdTimeout),
          1 === t.touches.length && (e = t.touches[0],
          this._startPos = this._newPos = new p(e.clientX,e.clientY),
          this._holdTimeout = setTimeout(a(function() {
              this._cancel(),
              this._isTapValid() && (S(document, "touchend", O),
              S(document, "touchend touchcancel", this._cancelClickPrevent),
              this._simulateEvent("contextmenu", e))
          }, this), 600),
          S(document, "touchend touchcancel contextmenu", this._cancel, this),
          S(document, "touchmove", this._onMove, this))
      },
      _cancelClickPrevent: function t() {
          k(document, "touchend", O),
          k(document, "touchend touchcancel", t)
      },
      _cancel: function() {
          clearTimeout(this._holdTimeout),
          k(document, "touchend touchcancel contextmenu", this._cancel, this),
          k(document, "touchmove", this._onMove, this)
      },
      _onMove: function(t) {
          t = t.touches[0];
          this._newPos = new p(t.clientX,t.clientY)
      },
      _isTapValid: function() {
          return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance
      },
      _simulateEvent: function(t, e) {
          t = new MouseEvent(t,{
              bubbles: !0,
              cancelable: !0,
              view: window,
              screenX: e.screenX,
              screenY: e.screenY,
              clientX: e.clientX,
              clientY: e.clientY
          });
          t._simulated = !0,
          e.target.dispatchEvent(t)
      }
  }))
    , Ot = (A.addInitHook("addHandler", "tapHold", kt),
  A.mergeOptions({
      touchZoom: b.touch,
      bounceAtZoomLimits: !0
  }),
  n.extend({
      addHooks: function() {
          M(this._map._container, "leaflet-touch-zoom"),
          S(this._map._container, "touchstart", this._onTouchStart, this)
      },
      removeHooks: function() {
          z(this._map._container, "leaflet-touch-zoom"),
          k(this._map._container, "touchstart", this._onTouchStart, this)
      },
      _onTouchStart: function(t) {
          var e, i, n = this._map;
          !t.touches || 2 !== t.touches.length || n._animatingZoom || this._zooming || (e = n.mouseEventToContainerPoint(t.touches[0]),
          i = n.mouseEventToContainerPoint(t.touches[1]),
          this._centerPoint = n.getSize()._divideBy(2),
          this._startLatLng = n.containerPointToLatLng(this._centerPoint),
          "center" !== n.options.touchZoom && (this._pinchStartLatLng = n.containerPointToLatLng(e.add(i)._divideBy(2))),
          this._startDist = e.distanceTo(i),
          this._startZoom = n.getZoom(),
          this._moved = !1,
          this._zooming = !0,
          n._stop(),
          S(document, "touchmove", this._onTouchMove, this),
          S(document, "touchend touchcancel", this._onTouchEnd, this),
          O(t))
      },
      _onTouchMove: function(t) {
          if (t.touches && 2 === t.touches.length && this._zooming) {
              var e = this._map
                , i = e.mouseEventToContainerPoint(t.touches[0])
                , n = e.mouseEventToContainerPoint(t.touches[1])
                , o = i.distanceTo(n) / this._startDist;
              if (this._zoom = e.getScaleZoom(o, this._startZoom),
              !e.options.bounceAtZoomLimits && (this._zoom < e.getMinZoom() && o < 1 || this._zoom > e.getMaxZoom() && 1 < o) && (this._zoom = e._limitZoom(this._zoom)),
              "center" === e.options.touchZoom) {
                  if (this._center = this._startLatLng,
                  1 == o)
                      return
              } else {
                  i = i._add(n)._divideBy(2)._subtract(this._centerPoint);
                  if (1 == o && 0 === i.x && 0 === i.y)
                      return;
                  this._center = e.unproject(e.project(this._pinchStartLatLng, this._zoom).subtract(i), this._zoom)
              }
              this._moved || (e._moveStart(!0, !1),
              this._moved = !0),
              r(this._animRequest);
              n = a(e._move, e, this._center, this._zoom, {
                  pinch: !0,
                  round: !1
              }, void 0);
              this._animRequest = x(n, this, !0),
              O(t)
          }
      },
      _onTouchEnd: function() {
          this._moved && this._zooming ? (this._zooming = !1,
          r(this._animRequest),
          k(document, "touchmove", this._onTouchMove, this),
          k(document, "touchend touchcancel", this._onTouchEnd, this),
          this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom))) : this._zooming = !1
      }
  }))
    , Xi = (A.addInitHook("addHandler", "touchZoom", Ot),
  A.BoxZoom = _t,
  A.DoubleClickZoom = Ct,
  A.Drag = Zt,
  A.Keyboard = St,
  A.ScrollWheelZoom = Et,
  A.TapHold = kt,
  A.TouchZoom = Ot,
  t.Bounds = f,
  t.Browser = b,
  t.CRS = ot,
  t.Canvas = Fi,
  t.Circle = vi,
  t.CircleMarker = gi,
  t.Class = et,
  t.Control = B,
  t.DivIcon = Ri,
  t.DivOverlay = Ai,
  t.DomEvent = mt,
  t.DomUtil = pt,
  t.Draggable = Xe,
  t.Evented = it,
  t.FeatureGroup = ci,
  t.GeoJSON = wi,
  t.GridLayer = Ni,
  t.Handler = n,
  t.Icon = di,
  t.ImageOverlay = Ei,
  t.LatLng = v,
  t.LatLngBounds = s,
  t.Layer = o,
  t.LayerGroup = ui,
  t.LineUtil = vt,
  t.Map = A,
  t.Marker = mi,
  t.Mixin = ft,
  t.Path = fi,
  t.Point = p,
  t.PolyUtil = gt,
  t.Polygon = xi,
  t.Polyline = yi,
  t.Popup = Bi,
  t.PosAnimation = Fe,
  t.Projection = wt,
  t.Rectangle = Yi,
  t.Renderer = Wi,
  t.SVG = Gi,
  t.SVGOverlay = Oi,
  t.TileLayer = Di,
  t.Tooltip = Ii,
  t.Transformation = at,
  t.Util = tt,
  t.VideoOverlay = ki,
  t.bind = a,
  t.bounds = _,
  t.canvas = Ui,
  t.circle = function(t, e, i) {
      return new vi(t,e,i)
  }
  ,
  t.circleMarker = function(t, e) {
      return new gi(t,e)
  }
  ,
  t.control = Ue,
  t.divIcon = function(t) {
      return new Ri(t)
  }
  ,
  t.extend = l,
  t.featureGroup = function(t, e) {
      return new ci(t,e)
  }
  ,
  t.geoJSON = Si,
  t.geoJson = Mt,
  t.gridLayer = function(t) {
      return new Ni(t)
  }
  ,
  t.icon = function(t) {
      return new di(t)
  }
  ,
  t.imageOverlay = function(t, e, i) {
      return new Ei(t,e,i)
  }
  ,
  t.latLng = w,
  t.latLngBounds = g,
  t.layerGroup = function(t, e) {
      return new ui(t,e)
  }
  ,
  t.map = function(t, e) {
      return new A(t,e)
  }
  ,
  t.marker = function(t, e) {
      return new mi(t,e)
  }
  ,
  t.point = m,
  t.polygon = function(t, e) {
      return new xi(t,e)
  }
  ,
  t.polyline = function(t, e) {
      return new yi(t,e)
  }
  ,
  t.popup = function(t, e) {
      return new Bi(t,e)
  }
  ,
  t.rectangle = function(t, e) {
      return new Yi(t,e)
  }
  ,
  t.setOptions = c,
  t.stamp = h,
  t.svg = Ki,
  t.svgOverlay = function(t, e, i) {
      return new Oi(t,e,i)
  }
  ,
  t.tileLayer = ji,
  t.tooltip = function(t, e) {
      return new Ii(t,e)
  }
  ,
  t.transformation = ht,
  t.version = "1.9.4",
  t.videoOverlay = function(t, e, i) {
      return new ki(t,e,i)
  }
  ,
  window.L);
  t.noConflict = function() {
      return window.L = Xi,
      this
  }
  ,
  window.L = t
});
//# sourceMappingURL=leaflet.js.map;
// Leaflet.TileLayer.Fallback
// (c) 2015-2018 Boris Seang
// License Apache-2.0
!function(i, e) {
  "function" == typeof define && define.amd ? define(["leaflet"], e) : e("object" == typeof module && module.exports ? require("leaflet") : i.L)
}(this, function(i) {
  i.TileLayer.Fallback = i.TileLayer.extend({
      options: {
          minNativeZoom: 0
      },
      initialize: function(e, r) {
          i.TileLayer.prototype.initialize.call(this, e, r)
      },
      createTile: function(e, r) {
          var t = i.TileLayer.prototype.createTile.call(this, e, r);
          return t._originalCoords = e,
          t._originalSrc = t.src,
          t
      },
      _createCurrentCoords: function(i) {
          var e = this._wrapCoords(i);
          return e.fallback = !0,
          e
      },
      _originalTileOnError: i.TileLayer.prototype._tileOnError,
      _tileOnError: function(i, e, r) {
          var t, l, o, a = this, n = e._originalCoords, c = e._currentCoords = e._currentCoords || a._createCurrentCoords(n), s = e._fallbackZoom = void 0 === e._fallbackZoom ? n.z - 1 : e._fallbackZoom - 1, f = e._fallbackScale = 2 * (e._fallbackScale || 1), p = a.getTileSize(), u = e.style;
          if (s < a.options.minNativeZoom)
              return this._originalTileOnError(i, e, r);
          c.z = s,
          c.x = Math.floor(c.x / 2),
          c.y = Math.floor(c.y / 2),
          t = a.getTileUrl(c),
          u.width = p.x * f + "px",
          u.height = p.y * f + "px",
          l = (n.y - c.y * f) * p.y,
          u.marginTop = -l + "px",
          o = (n.x - c.x * f) * p.x,
          u.marginLeft = -o + "px",
          u.clip = "rect(" + l + "px " + (o + p.x) + "px " + (l + p.y) + "px " + o + "px)",
          a.fire("tilefallback", {
              tile: e,
              url: e._originalSrc,
              urlMissing: e.src,
              urlFallback: t
          }),
          e.src = t
      },
      getTileUrl: function(e) {
          var r = e.z = e.fallback ? e.z : this._getZoomForUrl()
            , t = {
              r: i.Browser.retina ? "@2x" : "",
              s: this._getSubdomain(e),
              x: e.x,
              y: e.y,
              z: r
          };
          if (this._map && !this._map.options.crs.infinite) {
              var l = this._globalTileRange.max.y - e.y;
              this.options.tms && (t.y = l),
              t["-y"] = l
          }
          return i.Util.template(this._url, i.extend(t, this.options))
      }
  }),
  i.tileLayer.fallback = function(e, r) {
      return new i.TileLayer.Fallback(e,r)
  }
});
;'use strict';

(function(root, factory) {
  if (typeof define === 'function' && define.amd) {
      define(['leaflet'], factory);
  } else if (typeof exports === 'object') {
      module.exports = factory(require('leaflet'));
  } else {
      factory(window.L);
  }
}(this, function(L) {
  L.Canvas.include({
      _updateImg(layer) {
          const {img} = layer.options;
          const p = layer._point.round();
          p.x += img.offset.x;
          p.y += img.offset.y;
          if (img.rotate) {
              this._ctx.save();
              this._ctx.translate(p.x, p.y);
              this._ctx.rotate(img.rotate * Math.PI / 180);
              this._ctx.drawImage(img.el, -img.size[0] / 2, -img.size[1] / 2, img.size[0], img.size[1]);
              this._ctx.restore();
          } else {
              this._ctx.drawImage(img.el, p.x - img.size[0] / 2, p.y - img.size[1] / 2, img.size[0], img.size[1]);
          }
      },
  });

  const angleCrds = (map, prevLatlng, latlng) => {
      if (!latlng || !prevLatlng)
          return 0;
      const pxStart = map.project(prevLatlng);
      const pxEnd = map.project(latlng);
      return Math.atan2(pxStart.y - pxEnd.y, pxStart.x - pxEnd.x) / Math.PI * 180 - 90;
  }
  ;

  const defaultImgOptions = {
      rotate: 0,
      size: [40, 40],
      offset: {
          x: 0,
          y: 0
      },
  };

  const CanvasMarker = L.CircleMarker.extend({
      _updatePath() {
          if (!this.options.img || !this.options.img.url)
              return;
          if (!this.options.img.el) {
              this.options.img = {
                  ...defaultImgOptions,
                  ...this.options.img
              };
              this.options.img.rotate += angleCrds(this._map, this.options.prevLatlng, this._latlng);
              const img = document.createElement('img');
              img.src = this.options.img.url;
              this.options.img.el = img;
              img.onload = () => {
                  this.redraw();
              }
              ;
              img.onerror = () => {
                  this.options.img = null;
              }
              ;
          } else {
              this._renderer._updateImg(this);
          }
      },
  });

  L.canvasMarker = function(...opt) {
      try {
          const i = opt.findIndex(o => typeof o === 'object' && o.img);
          if (i + 1) {
              if (!opt[i].radius && opt[i].img && opt[i].img.size)
                  opt[i].radius = Math.ceil(Math.max(...opt[i].img.size) / 2);
              if (opt[i].pane)
                  delete opt[i].pane;
          }
      } catch (e) {}
      return new CanvasMarker(...opt);
  }
  ;
}));
;!function(t, e) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define("leaflet-arc", [], e) : "object" == typeof exports ? exports["leaflet-arc"] = e() : t["leaflet-arc"] = e()
}(this, function() {
  return function(t) {
      function e(o) {
          if (r[o])
              return r[o].exports;
          var s = r[o] = {
              exports: {},
              id: o,
              loaded: !1
          };
          return t[o].call(s.exports, s, s.exports, e),
          s.loaded = !0,
          s.exports
      }
      var r = {};
      return e.m = t,
      e.c = r,
      e.p = "",
      e(0)
  }([function(t, e, r) {
      "use strict";
      function o(t) {
          return t && t.__esModule ? t : {
              "default": t
          }
      }
      function s(t, e) {
          if (!t.geometries[0] || !t.geometries[0].coords[0])
              return [];
          var r = function() {
              var r = e.lng - t.geometries[0].coords[0][0] - 360;
              return {
                  v: t.geometries.map(function(t) {
                      return r += 360,
                      t.coords.map(function(t) {
                          return L.latLng([t[1], t[0] + r])
                      })
                  }).reduce(function(t, e) {
                      return t.concat(e)
                  })
              }
          }();
          return "object" === ("undefined" == typeof r ? "undefined" : n(r)) ? r.v : void 0
      }
      var i = Object.assign || function(t) {
          for (var e = 1; e < arguments.length; e++) {
              var r = arguments[e];
              for (var o in r)
                  Object.prototype.hasOwnProperty.call(r, o) && (t[o] = r[o])
          }
          return t
      }
        , n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
          return typeof t
      }
      : function(t) {
          return t && "function" == typeof Symbol && t.constructor === Symbol ? "symbol" : typeof t
      }
        , a = r(2)
        , h = o(a)
        , p = function(t) {
          return {
              x: t.lng,
              y: t.lat
          }
      };
      if (!L)
          throw new Error("Leaflet is not defined");
      L.Polyline.Arc = function(t, e, r) {
          var o = L.latLng(t)
            , n = L.latLng(e)
            , a = i({
              vertices: 10,
              offset: 10
          }, r)
            , u = new h["default"].GreatCircle(p(o),p(n))
            , c = u.Arc(a.vertices, {
              offset: a.offset
          })
            , f = s(c, o);
          return L.polyline(f, a)
      }
  }
  , function(t, e) {
      "use strict";
      var r = Math.PI / 180
        , o = 180 / Math.PI
        , s = function(t, e) {
          this.lon = t,
          this.lat = e,
          this.x = r * t,
          this.y = r * e
      };
      s.prototype.view = function() {
          return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4)
      }
      ,
      s.prototype.antipode = function() {
          var t = -1 * this.lat
            , e = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
          return new s(e,t)
      }
      ;
      var i = function() {
          this.coords = [],
          this.length = 0
      };
      i.prototype.move_to = function(t) {
          this.length++,
          this.coords.push(t)
      }
      ;
      var n = function(t) {
          this.properties = t || {},
          this.geometries = []
      };
      n.prototype.json = function() {
          if (this.geometries.length <= 0)
              return {
                  geometry: {
                      type: "LineString",
                      coordinates: null
                  },
                  type: "Feature",
                  properties: this.properties
              };
          if (1 == this.geometries.length)
              return {
                  geometry: {
                      type: "LineString",
                      coordinates: this.geometries[0].coords
                  },
                  type: "Feature",
                  properties: this.properties
              };
          for (var t = [], e = 0; e < this.geometries.length; e++)
              t.push(this.geometries[e].coords);
          return {
              geometry: {
                  type: "MultiLineString",
                  coordinates: t
              },
              type: "Feature",
              properties: this.properties
          }
      }
      ,
      n.prototype.wkt = function() {
          for (var t = "", e = "LINESTRING(", r = function(t) {
              e += t[0] + " " + t[1] + ","
          }, o = 0; o < this.geometries.length; o++) {
              if (0 === this.geometries[o].coords.length)
                  return "LINESTRING(empty)";
              var s = this.geometries[o].coords;
              s.forEach(r),
              t += e.substring(0, e.length - 1) + ")"
          }
          return t
      }
      ;
      var a = function(t, e, r) {
          if (!t || void 0 === t.x || void 0 === t.y)
              throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
          if (!e || void 0 === e.x || void 0 === e.y)
              throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
          this.start = new s(t.x,t.y),
          this.end = new s(e.x,e.y),
          this.properties = r || {};
          var o = this.start.x - this.end.x
            , i = this.start.y - this.end.y
            , n = Math.pow(Math.sin(i / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(o / 2), 2);
          if (this.g = 2 * Math.asin(Math.sqrt(n)),
          this.g == Math.PI)
              throw new Error("it appears " + t.view() + " and " + e.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite");
          if (isNaN(this.g))
              throw new Error("could not calculate great circle between " + t + " and " + e)
      };
      if (a.prototype.interpolate = function(t) {
          var e = Math.sin((1 - t) * this.g) / Math.sin(this.g)
            , r = Math.sin(t * this.g) / Math.sin(this.g)
            , s = e * Math.cos(this.start.y) * Math.cos(this.start.x) + r * Math.cos(this.end.y) * Math.cos(this.end.x)
            , i = e * Math.cos(this.start.y) * Math.sin(this.start.x) + r * Math.cos(this.end.y) * Math.sin(this.end.x)
            , n = e * Math.sin(this.start.y) + r * Math.sin(this.end.y)
            , a = o * Math.atan2(n, Math.sqrt(Math.pow(s, 2) + Math.pow(i, 2)))
            , h = o * Math.atan2(i, s);
          return [h, a]
      }
      ,
      a.prototype.Arc = function(t, e) {
          var r = [];
          if (!t || t <= 2)
              r.push([this.start.lon, this.start.lat]),
              r.push([this.end.lon, this.end.lat]);
          else
              for (var o = 1 / (t - 1), s = 0; s < t; ++s) {
                  var a = o * s
                    , h = this.interpolate(a);
                  r.push(h)
              }
          for (var p = !1, u = 0, c = e && e.offset ? e.offset : 10, f = 180 - c, l = -180 + c, d = 360 - c, y = 1; y < r.length; ++y) {
              var g = r[y - 1][0]
                , v = r[y][0]
                , M = Math.abs(v - g);
              M > d && (v > f && g < l || g > f && v < l) ? p = !0 : M > u && (u = M)
          }
          var m = [];
          if (p && u < c) {
              var w = [];
              m.push(w);
              for (var x = 0; x < r.length; ++x) {
                  var b = parseFloat(r[x][0]);
                  if (x > 0 && Math.abs(b - r[x - 1][0]) > d) {
                      var L = parseFloat(r[x - 1][0])
                        , S = parseFloat(r[x - 1][1])
                        , j = parseFloat(r[x][0])
                        , E = parseFloat(r[x][1]);
                      if (L > -180 && L < l && 180 == j && x + 1 < r.length && r[x - 1][0] > -180 && r[x - 1][0] < l) {
                          w.push([-180, r[x][1]]),
                          x++,
                          w.push([r[x][0], r[x][1]]);
                          continue
                      }
                      if (L > f && L < 180 && j == -180 && x + 1 < r.length && r[x - 1][0] > f && r[x - 1][0] < 180) {
                          w.push([180, r[x][1]]),
                          x++,
                          w.push([r[x][0], r[x][1]]);
                          continue
                      }
                      if (L < l && j > f) {
                          var F = L;
                          L = j,
                          j = F;
                          var C = S;
                          S = E,
                          E = C
                      }
                      if (L > f && j < l && (j += 360),
                      L <= 180 && j >= 180 && L < j) {
                          var G = (180 - L) / (j - L)
                            , I = G * E + (1 - G) * S;
                          w.push([r[x - 1][0] > f ? 180 : -180, I]),
                          w = [],
                          w.push([r[x - 1][0] > f ? -180 : 180, I]),
                          m.push(w)
                      } else
                          w = [],
                          m.push(w);
                      w.push([b, r[x][1]])
                  } else
                      w.push([r[x][0], r[x][1]])
              }
          } else {
              var N = [];
              m.push(N);
              for (var A = 0; A < r.length; ++A)
                  N.push([r[A][0], r[A][1]])
          }
          for (var P = new n(this.properties), _ = 0; _ < m.length; ++_) {
              var O = new i;
              P.geometries.push(O);
              for (var q = m[_], R = 0; R < q.length; ++R)
                  O.move_to(q[R])
          }
          return P
      }
      ,
      "undefined" != typeof t && "undefined" != typeof t.exports)
          t.exports.Coord = s,
          t.exports.Arc = n,
          t.exports.GreatCircle = a;
      else {
          var h = {};
          h.Coord = s,
          h.Arc = n,
          h.GreatCircle = a
      }
  }
  , function(t, e, r) {
      "use strict";
      t.exports = r(1)
  }
  ])
});
;/*! Hammer.JS - v2.0.8 - 2016-04-23
* http://hammerjs.github.io/
*
* Copyright (c) 2016 Jorik Tangelder;
* Licensed under the MIT license */
!function(a, b, c, d) {
  "use strict";
  function e(a, b, c) {
      return setTimeout(j(a, c), b)
  }
  function f(a, b, c) {
      return Array.isArray(a) ? (g(a, c[b], c),
      !0) : !1
  }
  function g(a, b, c) {
      var e;
      if (a)
          if (a.forEach)
              a.forEach(b, c);
          else if (a.length !== d)
              for (e = 0; e < a.length; )
                  b.call(c, a[e], e, a),
                  e++;
          else
              for (e in a)
                  a.hasOwnProperty(e) && b.call(c, a[e], e, a)
  }
  function h(b, c, d) {
      var e = "DEPRECATED METHOD: " + c + "\n" + d + " AT \n";
      return function() {
          var c = new Error("get-stack-trace")
            , d = c && c.stack ? c.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace"
            , f = a.console && (a.console.warn || a.console.log);
          return f && f.call(a.console, e, d),
          b.apply(this, arguments)
      }
  }
  function i(a, b, c) {
      var d, e = b.prototype;
      d = a.prototype = Object.create(e),
      d.constructor = a,
      d._super = e,
      c && la(d, c)
  }
  function j(a, b) {
      return function() {
          return a.apply(b, arguments)
      }
  }
  function k(a, b) {
      return typeof a == oa ? a.apply(b ? b[0] || d : d, b) : a
  }
  function l(a, b) {
      return a === d ? b : a
  }
  function m(a, b, c) {
      g(q(b), function(b) {
          a.addEventListener(b, c, !1)
      })
  }
  function n(a, b, c) {
      g(q(b), function(b) {
          a.removeEventListener(b, c, !1)
      })
  }
  function o(a, b) {
      for (; a; ) {
          if (a == b)
              return !0;
          a = a.parentNode
      }
      return !1
  }
  function p(a, b) {
      return a.indexOf(b) > -1
  }
  function q(a) {
      return a.trim().split(/\s+/g)
  }
  function r(a, b, c) {
      if (a.indexOf && !c)
          return a.indexOf(b);
      for (var d = 0; d < a.length; ) {
          if (c && a[d][c] == b || !c && a[d] === b)
              return d;
          d++
      }
      return -1
  }
  function s(a) {
      return Array.prototype.slice.call(a, 0)
  }
  function t(a, b, c) {
      for (var d = [], e = [], f = 0; f < a.length; ) {
          var g = b ? a[f][b] : a[f];
          r(e, g) < 0 && d.push(a[f]),
          e[f] = g,
          f++
      }
      return c && (d = b ? d.sort(function(a, c) {
          return a[b] > c[b]
      }) : d.sort()),
      d
  }
  function u(a, b) {
      for (var c, e, f = b[0].toUpperCase() + b.slice(1), g = 0; g < ma.length; ) {
          if (c = ma[g],
          e = c ? c + f : b,
          e in a)
              return e;
          g++
      }
      return d
  }
  function v() {
      return ua++
  }
  function w(b) {
      var c = b.ownerDocument || b;
      return c.defaultView || c.parentWindow || a
  }
  function x(a, b) {
      var c = this;
      this.manager = a,
      this.callback = b,
      this.element = a.element,
      this.target = a.options.inputTarget,
      this.domHandler = function(b) {
          k(a.options.enable, [a]) && c.handler(b)
      }
      ,
      this.init()
  }
  function y(a) {
      var b, c = a.options.inputClass;
      return new (b = c ? c : xa ? M : ya ? P : wa ? R : L)(a,z)
  }
  function z(a, b, c) {
      var d = c.pointers.length
        , e = c.changedPointers.length
        , f = b & Ea && d - e === 0
        , g = b & (Ga | Ha) && d - e === 0;
      c.isFirst = !!f,
      c.isFinal = !!g,
      f && (a.session = {}),
      c.eventType = b,
      A(a, c),
      a.emit("hammer.input", c),
      a.recognize(c),
      a.session.prevInput = c
  }
  function A(a, b) {
      var c = a.session
        , d = b.pointers
        , e = d.length;
      c.firstInput || (c.firstInput = D(b)),
      e > 1 && !c.firstMultiple ? c.firstMultiple = D(b) : 1 === e && (c.firstMultiple = !1);
      var f = c.firstInput
        , g = c.firstMultiple
        , h = g ? g.center : f.center
        , i = b.center = E(d);
      b.timeStamp = ra(),
      b.deltaTime = b.timeStamp - f.timeStamp,
      b.angle = I(h, i),
      b.distance = H(h, i),
      B(c, b),
      b.offsetDirection = G(b.deltaX, b.deltaY);
      var j = F(b.deltaTime, b.deltaX, b.deltaY);
      b.overallVelocityX = j.x,
      b.overallVelocityY = j.y,
      b.overallVelocity = qa(j.x) > qa(j.y) ? j.x : j.y,
      b.scale = g ? K(g.pointers, d) : 1,
      b.rotation = g ? J(g.pointers, d) : 0,
      b.maxPointers = c.prevInput ? b.pointers.length > c.prevInput.maxPointers ? b.pointers.length : c.prevInput.maxPointers : b.pointers.length,
      C(c, b);
      var k = a.element;
      o(b.srcEvent.target, k) && (k = b.srcEvent.target),
      b.target = k
  }
  function B(a, b) {
      var c = b.center
        , d = a.offsetDelta || {}
        , e = a.prevDelta || {}
        , f = a.prevInput || {};
      b.eventType !== Ea && f.eventType !== Ga || (e = a.prevDelta = {
          x: f.deltaX || 0,
          y: f.deltaY || 0
      },
      d = a.offsetDelta = {
          x: c.x,
          y: c.y
      }),
      b.deltaX = e.x + (c.x - d.x),
      b.deltaY = e.y + (c.y - d.y)
  }
  function C(a, b) {
      var c, e, f, g, h = a.lastInterval || b, i = b.timeStamp - h.timeStamp;
      if (b.eventType != Ha && (i > Da || h.velocity === d)) {
          var j = b.deltaX - h.deltaX
            , k = b.deltaY - h.deltaY
            , l = F(i, j, k);
          e = l.x,
          f = l.y,
          c = qa(l.x) > qa(l.y) ? l.x : l.y,
          g = G(j, k),
          a.lastInterval = b
      } else
          c = h.velocity,
          e = h.velocityX,
          f = h.velocityY,
          g = h.direction;
      b.velocity = c,
      b.velocityX = e,
      b.velocityY = f,
      b.direction = g
  }
  function D(a) {
      for (var b = [], c = 0; c < a.pointers.length; )
          b[c] = {
              clientX: pa(a.pointers[c].clientX),
              clientY: pa(a.pointers[c].clientY)
          },
          c++;
      return {
          timeStamp: ra(),
          pointers: b,
          center: E(b),
          deltaX: a.deltaX,
          deltaY: a.deltaY
      }
  }
  function E(a) {
      var b = a.length;
      if (1 === b)
          return {
              x: pa(a[0].clientX),
              y: pa(a[0].clientY)
          };
      for (var c = 0, d = 0, e = 0; b > e; )
          c += a[e].clientX,
          d += a[e].clientY,
          e++;
      return {
          x: pa(c / b),
          y: pa(d / b)
      }
  }
  function F(a, b, c) {
      return {
          x: b / a || 0,
          y: c / a || 0
      }
  }
  function G(a, b) {
      return a === b ? Ia : qa(a) >= qa(b) ? 0 > a ? Ja : Ka : 0 > b ? La : Ma
  }
  function H(a, b, c) {
      c || (c = Qa);
      var d = b[c[0]] - a[c[0]]
        , e = b[c[1]] - a[c[1]];
      return Math.sqrt(d * d + e * e)
  }
  function I(a, b, c) {
      c || (c = Qa);
      var d = b[c[0]] - a[c[0]]
        , e = b[c[1]] - a[c[1]];
      return 180 * Math.atan2(e, d) / Math.PI
  }
  function J(a, b) {
      return I(b[1], b[0], Ra) + I(a[1], a[0], Ra)
  }
  function K(a, b) {
      return H(b[0], b[1], Ra) / H(a[0], a[1], Ra)
  }
  function L() {
      this.evEl = Ta,
      this.evWin = Ua,
      this.pressed = !1,
      x.apply(this, arguments)
  }
  function M() {
      this.evEl = Xa,
      this.evWin = Ya,
      x.apply(this, arguments),
      this.store = this.manager.session.pointerEvents = []
  }
  function N() {
      this.evTarget = $a,
      this.evWin = _a,
      this.started = !1,
      x.apply(this, arguments)
  }
  function O(a, b) {
      var c = s(a.touches)
        , d = s(a.changedTouches);
      return b & (Ga | Ha) && (c = t(c.concat(d), "identifier", !0)),
      [c, d]
  }
  function P() {
      this.evTarget = bb,
      this.targetIds = {},
      x.apply(this, arguments)
  }
  function Q(a, b) {
      var c = s(a.touches)
        , d = this.targetIds;
      if (b & (Ea | Fa) && 1 === c.length)
          return d[c[0].identifier] = !0,
          [c, c];
      var e, f, g = s(a.changedTouches), h = [], i = this.target;
      if (f = c.filter(function(a) {
          return o(a.target, i)
      }),
      b === Ea)
          for (e = 0; e < f.length; )
              d[f[e].identifier] = !0,
              e++;
      for (e = 0; e < g.length; )
          d[g[e].identifier] && h.push(g[e]),
          b & (Ga | Ha) && delete d[g[e].identifier],
          e++;
      return h.length ? [t(f.concat(h), "identifier", !0), h] : void 0
  }
  function R() {
      x.apply(this, arguments);
      var a = j(this.handler, this);
      this.touch = new P(this.manager,a),
      this.mouse = new L(this.manager,a),
      this.primaryTouch = null,
      this.lastTouches = []
  }
  function S(a, b) {
      a & Ea ? (this.primaryTouch = b.changedPointers[0].identifier,
      T.call(this, b)) : a & (Ga | Ha) && T.call(this, b)
  }
  function T(a) {
      var b = a.changedPointers[0];
      if (b.identifier === this.primaryTouch) {
          var c = {
              x: b.clientX,
              y: b.clientY
          };
          this.lastTouches.push(c);
          var d = this.lastTouches
            , e = function() {
              var a = d.indexOf(c);
              a > -1 && d.splice(a, 1)
          };
          setTimeout(e, cb)
      }
  }
  function U(a) {
      for (var b = a.srcEvent.clientX, c = a.srcEvent.clientY, d = 0; d < this.lastTouches.length; d++) {
          var e = this.lastTouches[d]
            , f = Math.abs(b - e.x)
            , g = Math.abs(c - e.y);
          if (db >= f && db >= g)
              return !0
      }
      return !1
  }
  function V(a, b) {
      this.manager = a,
      this.set(b)
  }
  function W(a) {
      if (p(a, jb))
          return jb;
      var b = p(a, kb)
        , c = p(a, lb);
      return b && c ? jb : b || c ? b ? kb : lb : p(a, ib) ? ib : hb
  }
  function X() {
      if (!fb)
          return !1;
      var b = {}
        , c = a.CSS && a.CSS.supports;
      return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(d) {
          b[d] = c ? a.CSS.supports("touch-action", d) : !0
      }),
      b
  }
  function Y(a) {
      this.options = la({}, this.defaults, a || {}),
      this.id = v(),
      this.manager = null,
      this.options.enable = l(this.options.enable, !0),
      this.state = nb,
      this.simultaneous = {},
      this.requireFail = []
  }
  function Z(a) {
      return a & sb ? "cancel" : a & qb ? "end" : a & pb ? "move" : a & ob ? "start" : ""
  }
  function $(a) {
      return a == Ma ? "down" : a == La ? "up" : a == Ja ? "left" : a == Ka ? "right" : ""
  }
  function _(a, b) {
      var c = b.manager;
      return c ? c.get(a) : a
  }
  function aa() {
      Y.apply(this, arguments)
  }
  function ba() {
      aa.apply(this, arguments),
      this.pX = null,
      this.pY = null
  }
  function ca() {
      aa.apply(this, arguments)
  }
  function da() {
      Y.apply(this, arguments),
      this._timer = null,
      this._input = null
  }
  function ea() {
      aa.apply(this, arguments)
  }
  function fa() {
      aa.apply(this, arguments)
  }
  function ga() {
      Y.apply(this, arguments),
      this.pTime = !1,
      this.pCenter = !1,
      this._timer = null,
      this._input = null,
      this.count = 0
  }
  function ha(a, b) {
      return b = b || {},
      b.recognizers = l(b.recognizers, ha.defaults.preset),
      new ia(a,b)
  }
  function ia(a, b) {
      this.options = la({}, ha.defaults, b || {}),
      this.options.inputTarget = this.options.inputTarget || a,
      this.handlers = {},
      this.session = {},
      this.recognizers = [],
      this.oldCssProps = {},
      this.element = a,
      this.input = y(this),
      this.touchAction = new V(this,this.options.touchAction),
      ja(this, !0),
      g(this.options.recognizers, function(a) {
          var b = this.add(new a[0](a[1]));
          a[2] && b.recognizeWith(a[2]),
          a[3] && b.requireFailure(a[3])
      }, this)
  }
  function ja(a, b) {
      var c = a.element;
      if (c.style) {
          var d;
          g(a.options.cssProps, function(e, f) {
              d = u(c.style, f),
              b ? (a.oldCssProps[d] = c.style[d],
              c.style[d] = e) : c.style[d] = a.oldCssProps[d] || ""
          }),
          b || (a.oldCssProps = {})
      }
  }
  function ka(a, c) {
      var d = b.createEvent("Event");
      d.initEvent(a, !0, !0),
      d.gesture = c,
      c.target.dispatchEvent(d)
  }
  var la, ma = ["", "webkit", "Moz", "MS", "ms", "o"], na = b.createElement("div"), oa = "function", pa = Math.round, qa = Math.abs, ra = Date.now;
  la = "function" != typeof Object.assign ? function(a) {
      if (a === d || null === a)
          throw new TypeError("Cannot convert undefined or null to object");
      for (var b = Object(a), c = 1; c < arguments.length; c++) {
          var e = arguments[c];
          if (e !== d && null !== e)
              for (var f in e)
                  e.hasOwnProperty(f) && (b[f] = e[f])
      }
      return b
  }
  : Object.assign;
  var sa = h(function(a, b, c) {
      for (var e = Object.keys(b), f = 0; f < e.length; )
          (!c || c && a[e[f]] === d) && (a[e[f]] = b[e[f]]),
          f++;
      return a
  }, "extend", "Use `assign`.")
    , ta = h(function(a, b) {
      return sa(a, b, !0)
  }, "merge", "Use `assign`.")
    , ua = 1
    , va = /mobile|tablet|ip(ad|hone|od)|android/i
    , wa = "ontouchstart"in a
    , xa = u(a, "PointerEvent") !== d
    , ya = wa && va.test(navigator.userAgent)
    , za = "touch"
    , Aa = "pen"
    , Ba = "mouse"
    , Ca = "kinect"
    , Da = 25
    , Ea = 1
    , Fa = 2
    , Ga = 4
    , Ha = 8
    , Ia = 1
    , Ja = 2
    , Ka = 4
    , La = 8
    , Ma = 16
    , Na = Ja | Ka
    , Oa = La | Ma
    , Pa = Na | Oa
    , Qa = ["x", "y"]
    , Ra = ["clientX", "clientY"];
  x.prototype = {
      handler: function() {},
      init: function() {
          this.evEl && m(this.element, this.evEl, this.domHandler),
          this.evTarget && m(this.target, this.evTarget, this.domHandler),
          this.evWin && m(w(this.element), this.evWin, this.domHandler)
      },
      destroy: function() {
          this.evEl && n(this.element, this.evEl, this.domHandler),
          this.evTarget && n(this.target, this.evTarget, this.domHandler),
          this.evWin && n(w(this.element), this.evWin, this.domHandler)
      }
  };
  var Sa = {
      mousedown: Ea,
      mousemove: Fa,
      mouseup: Ga
  }
    , Ta = "mousedown"
    , Ua = "mousemove mouseup";
  i(L, x, {
      handler: function(a) {
          var b = Sa[a.type];
          b & Ea && 0 === a.button && (this.pressed = !0),
          b & Fa && 1 !== a.which && (b = Ga),
          this.pressed && (b & Ga && (this.pressed = !1),
          this.callback(this.manager, b, {
              pointers: [a],
              changedPointers: [a],
              pointerType: Ba,
              srcEvent: a
          }))
      }
  });
  var Va = {
      pointerdown: Ea,
      pointermove: Fa,
      pointerup: Ga,
      pointercancel: Ha,
      pointerout: Ha
  }
    , Wa = {
      2: za,
      3: Aa,
      4: Ba,
      5: Ca
  }
    , Xa = "pointerdown"
    , Ya = "pointermove pointerup pointercancel";
  a.MSPointerEvent && !a.PointerEvent && (Xa = "MSPointerDown",
  Ya = "MSPointerMove MSPointerUp MSPointerCancel"),
  i(M, x, {
      handler: function(a) {
          var b = this.store
            , c = !1
            , d = a.type.toLowerCase().replace("ms", "")
            , e = Va[d]
            , f = Wa[a.pointerType] || a.pointerType
            , g = f == za
            , h = r(b, a.pointerId, "pointerId");
          e & Ea && (0 === a.button || g) ? 0 > h && (b.push(a),
          h = b.length - 1) : e & (Ga | Ha) && (c = !0),
          0 > h || (b[h] = a,
          this.callback(this.manager, e, {
              pointers: b,
              changedPointers: [a],
              pointerType: f,
              srcEvent: a
          }),
          c && b.splice(h, 1))
      }
  });
  var Za = {
      touchstart: Ea,
      touchmove: Fa,
      touchend: Ga,
      touchcancel: Ha
  }
    , $a = "touchstart"
    , _a = "touchstart touchmove touchend touchcancel";
  i(N, x, {
      handler: function(a) {
          var b = Za[a.type];
          if (b === Ea && (this.started = !0),
          this.started) {
              var c = O.call(this, a, b);
              b & (Ga | Ha) && c[0].length - c[1].length === 0 && (this.started = !1),
              this.callback(this.manager, b, {
                  pointers: c[0],
                  changedPointers: c[1],
                  pointerType: za,
                  srcEvent: a
              })
          }
      }
  });
  var ab = {
      touchstart: Ea,
      touchmove: Fa,
      touchend: Ga,
      touchcancel: Ha
  }
    , bb = "touchstart touchmove touchend touchcancel";
  i(P, x, {
      handler: function(a) {
          var b = ab[a.type]
            , c = Q.call(this, a, b);
          c && this.callback(this.manager, b, {
              pointers: c[0],
              changedPointers: c[1],
              pointerType: za,
              srcEvent: a
          })
      }
  });
  var cb = 2500
    , db = 25;
  i(R, x, {
      handler: function(a, b, c) {
          var d = c.pointerType == za
            , e = c.pointerType == Ba;
          if (!(e && c.sourceCapabilities && c.sourceCapabilities.firesTouchEvents)) {
              if (d)
                  S.call(this, b, c);
              else if (e && U.call(this, c))
                  return;
              this.callback(a, b, c)
          }
      },
      destroy: function() {
          this.touch.destroy(),
          this.mouse.destroy()
      }
  });
  var eb = u(na.style, "touchAction")
    , fb = eb !== d
    , gb = "compute"
    , hb = "auto"
    , ib = "manipulation"
    , jb = "none"
    , kb = "pan-x"
    , lb = "pan-y"
    , mb = X();
  V.prototype = {
      set: function(a) {
          a == gb && (a = this.compute()),
          fb && this.manager.element.style && mb[a] && (this.manager.element.style[eb] = a),
          this.actions = a.toLowerCase().trim()
      },
      update: function() {
          this.set(this.manager.options.touchAction)
      },
      compute: function() {
          var a = [];
          return g(this.manager.recognizers, function(b) {
              k(b.options.enable, [b]) && (a = a.concat(b.getTouchAction()))
          }),
          W(a.join(" "))
      },
      preventDefaults: function(a) {
          var b = a.srcEvent
            , c = a.offsetDirection;
          if (this.manager.session.prevented)
              return void b.preventDefault();
          var d = this.actions
            , e = p(d, jb) && !mb[jb]
            , f = p(d, lb) && !mb[lb]
            , g = p(d, kb) && !mb[kb];
          if (e) {
              var h = 1 === a.pointers.length
                , i = a.distance < 2
                , j = a.deltaTime < 250;
              if (h && i && j)
                  return
          }
          return g && f ? void 0 : e || f && c & Na || g && c & Oa ? this.preventSrc(b) : void 0
      },
      preventSrc: function(a) {
          this.manager.session.prevented = !0,
          a.preventDefault()
      }
  };
  var nb = 1
    , ob = 2
    , pb = 4
    , qb = 8
    , rb = qb
    , sb = 16
    , tb = 32;
  Y.prototype = {
      defaults: {},
      set: function(a) {
          return la(this.options, a),
          this.manager && this.manager.touchAction.update(),
          this
      },
      recognizeWith: function(a) {
          if (f(a, "recognizeWith", this))
              return this;
          var b = this.simultaneous;
          return a = _(a, this),
          b[a.id] || (b[a.id] = a,
          a.recognizeWith(this)),
          this
      },
      dropRecognizeWith: function(a) {
          return f(a, "dropRecognizeWith", this) ? this : (a = _(a, this),
          delete this.simultaneous[a.id],
          this)
      },
      requireFailure: function(a) {
          if (f(a, "requireFailure", this))
              return this;
          var b = this.requireFail;
          return a = _(a, this),
          -1 === r(b, a) && (b.push(a),
          a.requireFailure(this)),
          this
      },
      dropRequireFailure: function(a) {
          if (f(a, "dropRequireFailure", this))
              return this;
          a = _(a, this);
          var b = r(this.requireFail, a);
          return b > -1 && this.requireFail.splice(b, 1),
          this
      },
      hasRequireFailures: function() {
          return this.requireFail.length > 0
      },
      canRecognizeWith: function(a) {
          return !!this.simultaneous[a.id]
      },
      emit: function(a) {
          function b(b) {
              c.manager.emit(b, a)
          }
          var c = this
            , d = this.state;
          qb > d && b(c.options.event + Z(d)),
          b(c.options.event),
          a.additionalEvent && b(a.additionalEvent),
          d >= qb && b(c.options.event + Z(d))
      },
      tryEmit: function(a) {
          return this.canEmit() ? this.emit(a) : void (this.state = tb)
      },
      canEmit: function() {
          for (var a = 0; a < this.requireFail.length; ) {
              if (!(this.requireFail[a].state & (tb | nb)))
                  return !1;
              a++
          }
          return !0
      },
      recognize: function(a) {
          var b = la({}, a);
          return k(this.options.enable, [this, b]) ? (this.state & (rb | sb | tb) && (this.state = nb),
          this.state = this.process(b),
          void (this.state & (ob | pb | qb | sb) && this.tryEmit(b))) : (this.reset(),
          void (this.state = tb))
      },
      process: function(a) {},
      getTouchAction: function() {},
      reset: function() {}
  },
  i(aa, Y, {
      defaults: {
          pointers: 1
      },
      attrTest: function(a) {
          var b = this.options.pointers;
          return 0 === b || a.pointers.length === b
      },
      process: function(a) {
          var b = this.state
            , c = a.eventType
            , d = b & (ob | pb)
            , e = this.attrTest(a);
          return d && (c & Ha || !e) ? b | sb : d || e ? c & Ga ? b | qb : b & ob ? b | pb : ob : tb
      }
  }),
  i(ba, aa, {
      defaults: {
          event: "pan",
          threshold: 10,
          pointers: 1,
          direction: Pa
      },
      getTouchAction: function() {
          var a = this.options.direction
            , b = [];
          return a & Na && b.push(lb),
          a & Oa && b.push(kb),
          b
      },
      directionTest: function(a) {
          var b = this.options
            , c = !0
            , d = a.distance
            , e = a.direction
            , f = a.deltaX
            , g = a.deltaY;
          return e & b.direction || (b.direction & Na ? (e = 0 === f ? Ia : 0 > f ? Ja : Ka,
          c = f != this.pX,
          d = Math.abs(a.deltaX)) : (e = 0 === g ? Ia : 0 > g ? La : Ma,
          c = g != this.pY,
          d = Math.abs(a.deltaY))),
          a.direction = e,
          c && d > b.threshold && e & b.direction
      },
      attrTest: function(a) {
          return aa.prototype.attrTest.call(this, a) && (this.state & ob || !(this.state & ob) && this.directionTest(a))
      },
      emit: function(a) {
          this.pX = a.deltaX,
          this.pY = a.deltaY;
          var b = $(a.direction);
          b && (a.additionalEvent = this.options.event + b),
          this._super.emit.call(this, a)
      }
  }),
  i(ca, aa, {
      defaults: {
          event: "pinch",
          threshold: 0,
          pointers: 2
      },
      getTouchAction: function() {
          return [jb]
      },
      attrTest: function(a) {
          return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold || this.state & ob)
      },
      emit: function(a) {
          if (1 !== a.scale) {
              var b = a.scale < 1 ? "in" : "out";
              a.additionalEvent = this.options.event + b
          }
          this._super.emit.call(this, a)
      }
  }),
  i(da, Y, {
      defaults: {
          event: "press",
          pointers: 1,
          time: 251,
          threshold: 9
      },
      getTouchAction: function() {
          return [hb]
      },
      process: function(a) {
          var b = this.options
            , c = a.pointers.length === b.pointers
            , d = a.distance < b.threshold
            , f = a.deltaTime > b.time;
          if (this._input = a,
          !d || !c || a.eventType & (Ga | Ha) && !f)
              this.reset();
          else if (a.eventType & Ea)
              this.reset(),
              this._timer = e(function() {
                  this.state = rb,
                  this.tryEmit()
              }, b.time, this);
          else if (a.eventType & Ga)
              return rb;
          return tb
      },
      reset: function() {
          clearTimeout(this._timer)
      },
      emit: function(a) {
          this.state === rb && (a && a.eventType & Ga ? this.manager.emit(this.options.event + "up", a) : (this._input.timeStamp = ra(),
          this.manager.emit(this.options.event, this._input)))
      }
  }),
  i(ea, aa, {
      defaults: {
          event: "rotate",
          threshold: 0,
          pointers: 2
      },
      getTouchAction: function() {
          return [jb]
      },
      attrTest: function(a) {
          return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & ob)
      }
  }),
  i(fa, aa, {
      defaults: {
          event: "swipe",
          threshold: 10,
          velocity: .3,
          direction: Na | Oa,
          pointers: 1
      },
      getTouchAction: function() {
          return ba.prototype.getTouchAction.call(this)
      },
      attrTest: function(a) {
          var b, c = this.options.direction;
          return c & (Na | Oa) ? b = a.overallVelocity : c & Na ? b = a.overallVelocityX : c & Oa && (b = a.overallVelocityY),
          this._super.attrTest.call(this, a) && c & a.offsetDirection && a.distance > this.options.threshold && a.maxPointers == this.options.pointers && qa(b) > this.options.velocity && a.eventType & Ga
      },
      emit: function(a) {
          var b = $(a.offsetDirection);
          b && this.manager.emit(this.options.event + b, a),
          this.manager.emit(this.options.event, a)
      }
  }),
  i(ga, Y, {
      defaults: {
          event: "tap",
          pointers: 1,
          taps: 1,
          interval: 300,
          time: 250,
          threshold: 9,
          posThreshold: 10
      },
      getTouchAction: function() {
          return [ib]
      },
      process: function(a) {
          var b = this.options
            , c = a.pointers.length === b.pointers
            , d = a.distance < b.threshold
            , f = a.deltaTime < b.time;
          if (this.reset(),
          a.eventType & Ea && 0 === this.count)
              return this.failTimeout();
          if (d && f && c) {
              if (a.eventType != Ga)
                  return this.failTimeout();
              var g = this.pTime ? a.timeStamp - this.pTime < b.interval : !0
                , h = !this.pCenter || H(this.pCenter, a.center) < b.posThreshold;
              this.pTime = a.timeStamp,
              this.pCenter = a.center,
              h && g ? this.count += 1 : this.count = 1,
              this._input = a;
              var i = this.count % b.taps;
              if (0 === i)
                  return this.hasRequireFailures() ? (this._timer = e(function() {
                      this.state = rb,
                      this.tryEmit()
                  }, b.interval, this),
                  ob) : rb
          }
          return tb
      },
      failTimeout: function() {
          return this._timer = e(function() {
              this.state = tb
          }, this.options.interval, this),
          tb
      },
      reset: function() {
          clearTimeout(this._timer)
      },
      emit: function() {
          this.state == rb && (this._input.tapCount = this.count,
          this.manager.emit(this.options.event, this._input))
      }
  }),
  ha.VERSION = "2.0.8",
  ha.defaults = {
      domEvents: !1,
      touchAction: gb,
      enable: !0,
      inputTarget: null,
      inputClass: null,
      preset: [[ea, {
          enable: !1
      }], [ca, {
          enable: !1
      }, ["rotate"]], [fa, {
          direction: Na
      }], [ba, {
          direction: Na
      }, ["swipe"]], [ga], [ga, {
          event: "doubletap",
          taps: 2
      }, ["tap"]], [da]],
      cssProps: {
          userSelect: "none",
          touchSelect: "none",
          touchCallout: "none",
          contentZooming: "none",
          userDrag: "none",
          tapHighlightColor: "rgba(0,0,0,0)"
      }
  };
  var ub = 1
    , vb = 2;
  ia.prototype = {
      set: function(a) {
          return la(this.options, a),
          a.touchAction && this.touchAction.update(),
          a.inputTarget && (this.input.destroy(),
          this.input.target = a.inputTarget,
          this.input.init()),
          this
      },
      stop: function(a) {
          this.session.stopped = a ? vb : ub
      },
      recognize: function(a) {
          var b = this.session;
          if (!b.stopped) {
              this.touchAction.preventDefaults(a);
              var c, d = this.recognizers, e = b.curRecognizer;
              (!e || e && e.state & rb) && (e = b.curRecognizer = null);
              for (var f = 0; f < d.length; )
                  c = d[f],
                  b.stopped === vb || e && c != e && !c.canRecognizeWith(e) ? c.reset() : c.recognize(a),
                  !e && c.state & (ob | pb | qb) && (e = b.curRecognizer = c),
                  f++
          }
      },
      get: function(a) {
          if (a instanceof Y)
              return a;
          for (var b = this.recognizers, c = 0; c < b.length; c++)
              if (b[c].options.event == a)
                  return b[c];
          return null
      },
      add: function(a) {
          if (f(a, "add", this))
              return this;
          var b = this.get(a.options.event);
          return b && this.remove(b),
          this.recognizers.push(a),
          a.manager = this,
          this.touchAction.update(),
          a
      },
      remove: function(a) {
          if (f(a, "remove", this))
              return this;
          if (a = this.get(a)) {
              var b = this.recognizers
                , c = r(b, a);
              -1 !== c && (b.splice(c, 1),
              this.touchAction.update())
          }
          return this
      },
      on: function(a, b) {
          if (a !== d && b !== d) {
              var c = this.handlers;
              return g(q(a), function(a) {
                  c[a] = c[a] || [],
                  c[a].push(b)
              }),
              this
          }
      },
      off: function(a, b) {
          if (a !== d) {
              var c = this.handlers;
              return g(q(a), function(a) {
                  b ? c[a] && c[a].splice(r(c[a], b), 1) : delete c[a]
              }),
              this
          }
      },
      emit: function(a, b) {
          this.options.domEvents && ka(a, b);
          var c = this.handlers[a] && this.handlers[a].slice();
          if (c && c.length) {
              b.type = a,
              b.preventDefault = function() {
                  b.srcEvent.preventDefault()
              }
              ;
              for (var d = 0; d < c.length; )
                  c[d](b),
                  d++
          }
      },
      destroy: function() {
          this.element && ja(this, !1),
          this.handlers = {},
          this.session = {},
          this.input.destroy(),
          this.element = null
      }
  },
  la(ha, {
      INPUT_START: Ea,
      INPUT_MOVE: Fa,
      INPUT_END: Ga,
      INPUT_CANCEL: Ha,
      STATE_POSSIBLE: nb,
      STATE_BEGAN: ob,
      STATE_CHANGED: pb,
      STATE_ENDED: qb,
      STATE_RECOGNIZED: rb,
      STATE_CANCELLED: sb,
      STATE_FAILED: tb,
      DIRECTION_NONE: Ia,
      DIRECTION_LEFT: Ja,
      DIRECTION_RIGHT: Ka,
      DIRECTION_UP: La,
      DIRECTION_DOWN: Ma,
      DIRECTION_HORIZONTAL: Na,
      DIRECTION_VERTICAL: Oa,
      DIRECTION_ALL: Pa,
      Manager: ia,
      Input: x,
      TouchAction: V,
      TouchInput: P,
      MouseInput: L,
      PointerEventInput: M,
      TouchMouseInput: R,
      SingleTouchInput: N,
      Recognizer: Y,
      AttrRecognizer: aa,
      Tap: ga,
      Pan: ba,
      Swipe: fa,
      Pinch: ca,
      Rotate: ea,
      Press: da,
      on: m,
      off: n,
      each: g,
      merge: ta,
      extend: sa,
      assign: la,
      inherit: i,
      bindFn: j,
      prefixed: u
  });
  var wb = "undefined" != typeof a ? a : "undefined" != typeof self ? self : {};
  wb.Hammer = ha,
  "function" == typeof define && define.amd ? define(function() {
      return ha
  }) : "undefined" != typeof module && module.exports ? module.exports = ha : a[c] = ha
}(window, document, "Hammer");
//# sourceMappingURL=hammer.min.js.map;
// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// 2016-07-07, Brian Grinstead, MIT License
!function(a) {
  function b(a, d) {
      if (a = a ? a : "",
      d = d || {},
      a instanceof b)
          return a;
      if (!(this instanceof b))
          return new b(a,d);
      var e = c(a);
      this._originalInput = a,
      this._r = e.r,
      this._g = e.g,
      this._b = e.b,
      this._a = e.a,
      this._roundA = P(100 * this._a) / 100,
      this._format = d.format || e.format,
      this._gradientType = d.gradientType,
      this._r < 1 && (this._r = P(this._r)),
      this._g < 1 && (this._g = P(this._g)),
      this._b < 1 && (this._b = P(this._b)),
      this._ok = e.ok,
      this._tc_id = O++
  }
  function c(a) {
      var b = {
          r: 0,
          g: 0,
          b: 0
      }
        , c = 1
        , e = null
        , g = null
        , i = null
        , j = !1
        , k = !1;
      return "string" == typeof a && (a = K(a)),
      "object" == typeof a && (J(a.r) && J(a.g) && J(a.b) ? (b = d(a.r, a.g, a.b),
      j = !0,
      k = "%" === String(a.r).substr(-1) ? "prgb" : "rgb") : J(a.h) && J(a.s) && J(a.v) ? (e = G(a.s),
      g = G(a.v),
      b = h(a.h, e, g),
      j = !0,
      k = "hsv") : J(a.h) && J(a.s) && J(a.l) && (e = G(a.s),
      i = G(a.l),
      b = f(a.h, e, i),
      j = !0,
      k = "hsl"),
      a.hasOwnProperty("a") && (c = a.a)),
      c = z(c),
      {
          ok: j,
          format: a.format || k,
          r: Q(255, R(b.r, 0)),
          g: Q(255, R(b.g, 0)),
          b: Q(255, R(b.b, 0)),
          a: c
      }
  }
  function d(a, b, c) {
      return {
          r: 255 * A(a, 255),
          g: 255 * A(b, 255),
          b: 255 * A(c, 255)
      }
  }
  function e(a, b, c) {
      a = A(a, 255),
      b = A(b, 255),
      c = A(c, 255);
      var d, e, f = R(a, b, c), g = Q(a, b, c), h = (f + g) / 2;
      if (f == g)
          d = e = 0;
      else {
          var i = f - g;
          switch (e = h > .5 ? i / (2 - f - g) : i / (f + g),
          f) {
          case a:
              d = (b - c) / i + (c > b ? 6 : 0);
              break;
          case b:
              d = (c - a) / i + 2;
              break;
          case c:
              d = (a - b) / i + 4
          }
          d /= 6
      }
      return {
          h: d,
          s: e,
          l: h
      }
  }
  function f(a, b, c) {
      function d(a, b, c) {
          return 0 > c && (c += 1),
          c > 1 && (c -= 1),
          1 / 6 > c ? a + 6 * (b - a) * c : .5 > c ? b : 2 / 3 > c ? a + 6 * (b - a) * (2 / 3 - c) : a
      }
      var e, f, g;
      if (a = A(a, 360),
      b = A(b, 100),
      c = A(c, 100),
      0 === b)
          e = f = g = c;
      else {
          var h = .5 > c ? c * (1 + b) : c + b - c * b
            , i = 2 * c - h;
          e = d(i, h, a + 1 / 3),
          f = d(i, h, a),
          g = d(i, h, a - 1 / 3)
      }
      return {
          r: 255 * e,
          g: 255 * f,
          b: 255 * g
      }
  }
  function g(a, b, c) {
      a = A(a, 255),
      b = A(b, 255),
      c = A(c, 255);
      var d, e, f = R(a, b, c), g = Q(a, b, c), h = f, i = f - g;
      if (e = 0 === f ? 0 : i / f,
      f == g)
          d = 0;
      else {
          switch (f) {
          case a:
              d = (b - c) / i + (c > b ? 6 : 0);
              break;
          case b:
              d = (c - a) / i + 2;
              break;
          case c:
              d = (a - b) / i + 4
          }
          d /= 6
      }
      return {
          h: d,
          s: e,
          v: h
      }
  }
  function h(b, c, d) {
      b = 6 * A(b, 360),
      c = A(c, 100),
      d = A(d, 100);
      var e = a.floor(b)
        , f = b - e
        , g = d * (1 - c)
        , h = d * (1 - f * c)
        , i = d * (1 - (1 - f) * c)
        , j = e % 6
        , k = [d, h, g, g, i, d][j]
        , l = [i, d, d, h, g, g][j]
        , m = [g, g, i, d, d, h][j];
      return {
          r: 255 * k,
          g: 255 * l,
          b: 255 * m
      }
  }
  function i(a, b, c, d) {
      var e = [F(P(a).toString(16)), F(P(b).toString(16)), F(P(c).toString(16))];
      return d && e[0].charAt(0) == e[0].charAt(1) && e[1].charAt(0) == e[1].charAt(1) && e[2].charAt(0) == e[2].charAt(1) ? e[0].charAt(0) + e[1].charAt(0) + e[2].charAt(0) : e.join("")
  }
  function j(a, b, c, d, e) {
      var f = [F(P(a).toString(16)), F(P(b).toString(16)), F(P(c).toString(16)), F(H(d))];
      return e && f[0].charAt(0) == f[0].charAt(1) && f[1].charAt(0) == f[1].charAt(1) && f[2].charAt(0) == f[2].charAt(1) && f[3].charAt(0) == f[3].charAt(1) ? f[0].charAt(0) + f[1].charAt(0) + f[2].charAt(0) + f[3].charAt(0) : f.join("")
  }
  function k(a, b, c, d) {
      var e = [F(H(d)), F(P(a).toString(16)), F(P(b).toString(16)), F(P(c).toString(16))];
      return e.join("")
  }
  function l(a, c) {
      c = 0 === c ? 0 : c || 10;
      var d = b(a).toHsl();
      return d.s -= c / 100,
      d.s = B(d.s),
      b(d)
  }
  function m(a, c) {
      c = 0 === c ? 0 : c || 10;
      var d = b(a).toHsl();
      return d.s += c / 100,
      d.s = B(d.s),
      b(d)
  }
  function n(a) {
      return b(a).desaturate(100)
  }
  function o(a, c) {
      c = 0 === c ? 0 : c || 10;
      var d = b(a).toHsl();
      return d.l += c / 100,
      d.l = B(d.l),
      b(d)
  }
  function p(a, c) {
      c = 0 === c ? 0 : c || 10;
      var d = b(a).toRgb();
      return d.r = R(0, Q(255, d.r - P(255 * -(c / 100)))),
      d.g = R(0, Q(255, d.g - P(255 * -(c / 100)))),
      d.b = R(0, Q(255, d.b - P(255 * -(c / 100)))),
      b(d)
  }
  function q(a, c) {
      c = 0 === c ? 0 : c || 10;
      var d = b(a).toHsl();
      return d.l -= c / 100,
      d.l = B(d.l),
      b(d)
  }
  function r(a, c) {
      var d = b(a).toHsl()
        , e = (d.h + c) % 360;
      return d.h = 0 > e ? 360 + e : e,
      b(d)
  }
  function s(a) {
      var c = b(a).toHsl();
      return c.h = (c.h + 180) % 360,
      b(c)
  }
  function t(a) {
      var c = b(a).toHsl()
        , d = c.h;
      return [b(a), b({
          h: (d + 120) % 360,
          s: c.s,
          l: c.l
      }), b({
          h: (d + 240) % 360,
          s: c.s,
          l: c.l
      })]
  }
  function u(a) {
      var c = b(a).toHsl()
        , d = c.h;
      return [b(a), b({
          h: (d + 90) % 360,
          s: c.s,
          l: c.l
      }), b({
          h: (d + 180) % 360,
          s: c.s,
          l: c.l
      }), b({
          h: (d + 270) % 360,
          s: c.s,
          l: c.l
      })]
  }
  function v(a) {
      var c = b(a).toHsl()
        , d = c.h;
      return [b(a), b({
          h: (d + 72) % 360,
          s: c.s,
          l: c.l
      }), b({
          h: (d + 216) % 360,
          s: c.s,
          l: c.l
      })]
  }
  function w(a, c, d) {
      c = c || 6,
      d = d || 30;
      var e = b(a).toHsl()
        , f = 360 / d
        , g = [b(a)];
      for (e.h = (e.h - (f * c >> 1) + 720) % 360; --c; )
          e.h = (e.h + f) % 360,
          g.push(b(e));
      return g
  }
  function x(a, c) {
      c = c || 6;
      for (var d = b(a).toHsv(), e = d.h, f = d.s, g = d.v, h = [], i = 1 / c; c--; )
          h.push(b({
              h: e,
              s: f,
              v: g
          })),
          g = (g + i) % 1;
      return h
  }
  function y(a) {
      var b = {};
      for (var c in a)
          a.hasOwnProperty(c) && (b[a[c]] = c);
      return b
  }
  function z(a) {
      return a = parseFloat(a),
      (isNaN(a) || 0 > a || a > 1) && (a = 1),
      a
  }
  function A(b, c) {
      D(b) && (b = "100%");
      var d = E(b);
      return b = Q(c, R(0, parseFloat(b))),
      d && (b = parseInt(b * c, 10) / 100),
      a.abs(b - c) < 1e-6 ? 1 : b % c / parseFloat(c)
  }
  function B(a) {
      return Q(1, R(0, a))
  }
  function C(a) {
      return parseInt(a, 16)
  }
  function D(a) {
      return "string" == typeof a && -1 != a.indexOf(".") && 1 === parseFloat(a)
  }
  function E(a) {
      return "string" == typeof a && -1 != a.indexOf("%")
  }
  function F(a) {
      return 1 == a.length ? "0" + a : "" + a
  }
  function G(a) {
      return 1 >= a && (a = 100 * a + "%"),
      a
  }
  function H(b) {
      return a.round(255 * parseFloat(b)).toString(16)
  }
  function I(a) {
      return C(a) / 255
  }
  function J(a) {
      return !!V.CSS_UNIT.exec(a)
  }
  function K(a) {
      a = a.replace(M, "").replace(N, "").toLowerCase();
      var b = !1;
      if (T[a])
          a = T[a],
          b = !0;
      else if ("transparent" == a)
          return {
              r: 0,
              g: 0,
              b: 0,
              a: 0,
              format: "name"
          };
      var c;
      return (c = V.rgb.exec(a)) ? {
          r: c[1],
          g: c[2],
          b: c[3]
      } : (c = V.rgba.exec(a)) ? {
          r: c[1],
          g: c[2],
          b: c[3],
          a: c[4]
      } : (c = V.hsl.exec(a)) ? {
          h: c[1],
          s: c[2],
          l: c[3]
      } : (c = V.hsla.exec(a)) ? {
          h: c[1],
          s: c[2],
          l: c[3],
          a: c[4]
      } : (c = V.hsv.exec(a)) ? {
          h: c[1],
          s: c[2],
          v: c[3]
      } : (c = V.hsva.exec(a)) ? {
          h: c[1],
          s: c[2],
          v: c[3],
          a: c[4]
      } : (c = V.hex8.exec(a)) ? {
          r: C(c[1]),
          g: C(c[2]),
          b: C(c[3]),
          a: I(c[4]),
          format: b ? "name" : "hex8"
      } : (c = V.hex6.exec(a)) ? {
          r: C(c[1]),
          g: C(c[2]),
          b: C(c[3]),
          format: b ? "name" : "hex"
      } : (c = V.hex4.exec(a)) ? {
          r: C(c[1] + "" + c[1]),
          g: C(c[2] + "" + c[2]),
          b: C(c[3] + "" + c[3]),
          a: I(c[4] + "" + c[4]),
          format: b ? "name" : "hex8"
      } : (c = V.hex3.exec(a)) ? {
          r: C(c[1] + "" + c[1]),
          g: C(c[2] + "" + c[2]),
          b: C(c[3] + "" + c[3]),
          format: b ? "name" : "hex"
      } : !1
  }
  function L(a) {
      var b, c;
      return a = a || {
          level: "AA",
          size: "small"
      },
      b = (a.level || "AA").toUpperCase(),
      c = (a.size || "small").toLowerCase(),
      "AA" !== b && "AAA" !== b && (b = "AA"),
      "small" !== c && "large" !== c && (c = "small"),
      {
          level: b,
          size: c
      }
  }
  var M = /^\s+/
    , N = /\s+$/
    , O = 0
    , P = a.round
    , Q = a.min
    , R = a.max
    , S = a.random;
  b.prototype = {
      isDark: function() {
          return this.getBrightness() < 128
      },
      isLight: function() {
          return !this.isDark()
      },
      isValid: function() {
          return this._ok
      },
      getOriginalInput: function() {
          return this._originalInput
      },
      getFormat: function() {
          return this._format
      },
      getAlpha: function() {
          return this._a
      },
      getBrightness: function() {
          var a = this.toRgb();
          return (299 * a.r + 587 * a.g + 114 * a.b) / 1e3
      },
      getLuminance: function() {
          var b, c, d, e, f, g, h = this.toRgb();
          return b = h.r / 255,
          c = h.g / 255,
          d = h.b / 255,
          e = .03928 >= b ? b / 12.92 : a.pow((b + .055) / 1.055, 2.4),
          f = .03928 >= c ? c / 12.92 : a.pow((c + .055) / 1.055, 2.4),
          g = .03928 >= d ? d / 12.92 : a.pow((d + .055) / 1.055, 2.4),
          .2126 * e + .7152 * f + .0722 * g
      },
      setAlpha: function(a) {
          return this._a = z(a),
          this._roundA = P(100 * this._a) / 100,
          this
      },
      toHsv: function() {
          var a = g(this._r, this._g, this._b);
          return {
              h: 360 * a.h,
              s: a.s,
              v: a.v,
              a: this._a
          }
      },
      toHsvString: function() {
          var a = g(this._r, this._g, this._b)
            , b = P(360 * a.h)
            , c = P(100 * a.s)
            , d = P(100 * a.v);
          return 1 == this._a ? "hsv(" + b + ", " + c + "%, " + d + "%)" : "hsva(" + b + ", " + c + "%, " + d + "%, " + this._roundA + ")"
      },
      toHsl: function() {
          var a = e(this._r, this._g, this._b);
          return {
              h: 360 * a.h,
              s: a.s,
              l: a.l,
              a: this._a
          }
      },
      toHslString: function() {
          var a = e(this._r, this._g, this._b)
            , b = P(360 * a.h)
            , c = P(100 * a.s)
            , d = P(100 * a.l);
          return 1 == this._a ? "hsl(" + b + ", " + c + "%, " + d + "%)" : "hsla(" + b + ", " + c + "%, " + d + "%, " + this._roundA + ")"
      },
      toHex: function(a) {
          return i(this._r, this._g, this._b, a)
      },
      toHexString: function(a) {
          return "#" + this.toHex(a)
      },
      toHex8: function(a) {
          return j(this._r, this._g, this._b, this._a, a)
      },
      toHex8String: function(a) {
          return "#" + this.toHex8(a)
      },
      toRgb: function() {
          return {
              r: P(this._r),
              g: P(this._g),
              b: P(this._b),
              a: this._a
          }
      },
      toRgbString: function() {
          return 1 == this._a ? "rgb(" + P(this._r) + ", " + P(this._g) + ", " + P(this._b) + ")" : "rgba(" + P(this._r) + ", " + P(this._g) + ", " + P(this._b) + ", " + this._roundA + ")"
      },
      toPercentageRgb: function() {
          return {
              r: P(100 * A(this._r, 255)) + "%",
              g: P(100 * A(this._g, 255)) + "%",
              b: P(100 * A(this._b, 255)) + "%",
              a: this._a
          }
      },
      toPercentageRgbString: function() {
          return 1 == this._a ? "rgb(" + P(100 * A(this._r, 255)) + "%, " + P(100 * A(this._g, 255)) + "%, " + P(100 * A(this._b, 255)) + "%)" : "rgba(" + P(100 * A(this._r, 255)) + "%, " + P(100 * A(this._g, 255)) + "%, " + P(100 * A(this._b, 255)) + "%, " + this._roundA + ")"
      },
      toName: function() {
          return 0 === this._a ? "transparent" : this._a < 1 ? !1 : U[i(this._r, this._g, this._b, !0)] || !1
      },
      toFilter: function(a) {
          var c = "#" + k(this._r, this._g, this._b, this._a)
            , d = c
            , e = this._gradientType ? "GradientType = 1, " : "";
          if (a) {
              var f = b(a);
              d = "#" + k(f._r, f._g, f._b, f._a)
          }
          return "progid:DXImageTransform.Microsoft.gradient(" + e + "startColorstr=" + c + ",endColorstr=" + d + ")"
      },
      toString: function(a) {
          var b = !!a;
          a = a || this._format;
          var c = !1
            , d = this._a < 1 && this._a >= 0
            , e = !b && d && ("hex" === a || "hex6" === a || "hex3" === a || "hex4" === a || "hex8" === a || "name" === a);
          return e ? "name" === a && 0 === this._a ? this.toName() : this.toRgbString() : ("rgb" === a && (c = this.toRgbString()),
          "prgb" === a && (c = this.toPercentageRgbString()),
          ("hex" === a || "hex6" === a) && (c = this.toHexString()),
          "hex3" === a && (c = this.toHexString(!0)),
          "hex4" === a && (c = this.toHex8String(!0)),
          "hex8" === a && (c = this.toHex8String()),
          "name" === a && (c = this.toName()),
          "hsl" === a && (c = this.toHslString()),
          "hsv" === a && (c = this.toHsvString()),
          c || this.toHexString())
      },
      clone: function() {
          return b(this.toString())
      },
      _applyModification: function(a, b) {
          var c = a.apply(null, [this].concat([].slice.call(b)));
          return this._r = c._r,
          this._g = c._g,
          this._b = c._b,
          this.setAlpha(c._a),
          this
      },
      lighten: function() {
          return this._applyModification(o, arguments)
      },
      brighten: function() {
          return this._applyModification(p, arguments)
      },
      darken: function() {
          return this._applyModification(q, arguments)
      },
      desaturate: function() {
          return this._applyModification(l, arguments)
      },
      saturate: function() {
          return this._applyModification(m, arguments)
      },
      greyscale: function() {
          return this._applyModification(n, arguments)
      },
      spin: function() {
          return this._applyModification(r, arguments)
      },
      _applyCombination: function(a, b) {
          return a.apply(null, [this].concat([].slice.call(b)))
      },
      analogous: function() {
          return this._applyCombination(w, arguments)
      },
      complement: function() {
          return this._applyCombination(s, arguments)
      },
      monochromatic: function() {
          return this._applyCombination(x, arguments)
      },
      splitcomplement: function() {
          return this._applyCombination(v, arguments)
      },
      triad: function() {
          return this._applyCombination(t, arguments)
      },
      tetrad: function() {
          return this._applyCombination(u, arguments)
      }
  },
  b.fromRatio = function(a, c) {
      if ("object" == typeof a) {
          var d = {};
          for (var e in a)
              a.hasOwnProperty(e) && (d[e] = "a" === e ? a[e] : G(a[e]));
          a = d
      }
      return b(a, c)
  }
  ,
  b.equals = function(a, c) {
      return a && c ? b(a).toRgbString() == b(c).toRgbString() : !1
  }
  ,
  b.random = function() {
      return b.fromRatio({
          r: S(),
          g: S(),
          b: S()
      })
  }
  ,
  b.mix = function(a, c, d) {
      d = 0 === d ? 0 : d || 50;
      var e = b(a).toRgb()
        , f = b(c).toRgb()
        , g = d / 100
        , h = {
          r: (f.r - e.r) * g + e.r,
          g: (f.g - e.g) * g + e.g,
          b: (f.b - e.b) * g + e.b,
          a: (f.a - e.a) * g + e.a
      };
      return b(h)
  }
  ,
  b.readability = function(c, d) {
      var e = b(c)
        , f = b(d);
      return (a.max(e.getLuminance(), f.getLuminance()) + .05) / (a.min(e.getLuminance(), f.getLuminance()) + .05)
  }
  ,
  b.isReadable = function(a, c, d) {
      var e, f, g = b.readability(a, c);
      switch (f = !1,
      e = L(d),
      e.level + e.size) {
      case "AAsmall":
      case "AAAlarge":
          f = g >= 4.5;
          break;
      case "AAlarge":
          f = g >= 3;
          break;
      case "AAAsmall":
          f = g >= 7
      }
      return f
  }
  ,
  b.mostReadable = function(a, c, d) {
      var e, f, g, h, i = null, j = 0;
      d = d || {},
      f = d.includeFallbackColors,
      g = d.level,
      h = d.size;
      for (var k = 0; k < c.length; k++)
          e = b.readability(a, c[k]),
          e > j && (j = e,
          i = b(c[k]));
      return b.isReadable(a, i, {
          level: g,
          size: h
      }) || !f ? i : (d.includeFallbackColors = !1,
      b.mostReadable(a, ["#fff", "#000"], d))
  }
  ;
  var T = b.names = {
      aliceblue: "f0f8ff",
      antiquewhite: "faebd7",
      aqua: "0ff",
      aquamarine: "7fffd4",
      azure: "f0ffff",
      beige: "f5f5dc",
      bisque: "ffe4c4",
      black: "000",
      blanchedalmond: "ffebcd",
      blue: "00f",
      blueviolet: "8a2be2",
      brown: "a52a2a",
      burlywood: "deb887",
      burntsienna: "ea7e5d",
      cadetblue: "5f9ea0",
      chartreuse: "7fff00",
      chocolate: "d2691e",
      coral: "ff7f50",
      cornflowerblue: "6495ed",
      cornsilk: "fff8dc",
      crimson: "dc143c",
      cyan: "0ff",
      darkblue: "00008b",
      darkcyan: "008b8b",
      darkgoldenrod: "b8860b",
      darkgray: "a9a9a9",
      darkgreen: "006400",
      darkgrey: "a9a9a9",
      darkkhaki: "bdb76b",
      darkmagenta: "8b008b",
      darkolivegreen: "556b2f",
      darkorange: "ff8c00",
      darkorchid: "9932cc",
      darkred: "8b0000",
      darksalmon: "e9967a",
      darkseagreen: "8fbc8f",
      darkslateblue: "483d8b",
      darkslategray: "2f4f4f",
      darkslategrey: "2f4f4f",
      darkturquoise: "00ced1",
      darkviolet: "9400d3",
      deeppink: "ff1493",
      deepskyblue: "00bfff",
      dimgray: "696969",
      dimgrey: "696969",
      dodgerblue: "1e90ff",
      firebrick: "b22222",
      floralwhite: "fffaf0",
      forestgreen: "228b22",
      fuchsia: "f0f",
      gainsboro: "dcdcdc",
      ghostwhite: "f8f8ff",
      gold: "ffd700",
      goldenrod: "daa520",
      gray: "808080",
      green: "008000",
      greenyellow: "adff2f",
      grey: "808080",
      honeydew: "f0fff0",
      hotpink: "ff69b4",
      indianred: "cd5c5c",
      indigo: "4b0082",
      ivory: "fffff0",
      khaki: "f0e68c",
      lavender: "e6e6fa",
      lavenderblush: "fff0f5",
      lawngreen: "7cfc00",
      lemonchiffon: "fffacd",
      lightblue: "add8e6",
      lightcoral: "f08080",
      lightcyan: "e0ffff",
      lightgoldenrodyellow: "fafad2",
      lightgray: "d3d3d3",
      lightgreen: "90ee90",
      lightgrey: "d3d3d3",
      lightpink: "ffb6c1",
      lightsalmon: "ffa07a",
      lightseagreen: "20b2aa",
      lightskyblue: "87cefa",
      lightslategray: "789",
      lightslategrey: "789",
      lightsteelblue: "b0c4de",
      lightyellow: "ffffe0",
      lime: "0f0",
      limegreen: "32cd32",
      linen: "faf0e6",
      magenta: "f0f",
      maroon: "800000",
      mediumaquamarine: "66cdaa",
      mediumblue: "0000cd",
      mediumorchid: "ba55d3",
      mediumpurple: "9370db",
      mediumseagreen: "3cb371",
      mediumslateblue: "7b68ee",
      mediumspringgreen: "00fa9a",
      mediumturquoise: "48d1cc",
      mediumvioletred: "c71585",
      midnightblue: "191970",
      mintcream: "f5fffa",
      mistyrose: "ffe4e1",
      moccasin: "ffe4b5",
      navajowhite: "ffdead",
      navy: "000080",
      oldlace: "fdf5e6",
      olive: "808000",
      olivedrab: "6b8e23",
      orange: "ffa500",
      orangered: "ff4500",
      orchid: "da70d6",
      palegoldenrod: "eee8aa",
      palegreen: "98fb98",
      paleturquoise: "afeeee",
      palevioletred: "db7093",
      papayawhip: "ffefd5",
      peachpuff: "ffdab9",
      peru: "cd853f",
      pink: "ffc0cb",
      plum: "dda0dd",
      powderblue: "b0e0e6",
      purple: "800080",
      rebeccapurple: "663399",
      red: "f00",
      rosybrown: "bc8f8f",
      royalblue: "4169e1",
      saddlebrown: "8b4513",
      salmon: "fa8072",
      sandybrown: "f4a460",
      seagreen: "2e8b57",
      seashell: "fff5ee",
      sienna: "a0522d",
      silver: "c0c0c0",
      skyblue: "87ceeb",
      slateblue: "6a5acd",
      slategray: "708090",
      slategrey: "708090",
      snow: "fffafa",
      springgreen: "00ff7f",
      steelblue: "4682b4",
      tan: "d2b48c",
      teal: "008080",
      thistle: "d8bfd8",
      tomato: "ff6347",
      turquoise: "40e0d0",
      violet: "ee82ee",
      wheat: "f5deb3",
      white: "fff",
      whitesmoke: "f5f5f5",
      yellow: "ff0",
      yellowgreen: "9acd32"
  }
    , U = b.hexNames = y(T)
    , V = function() {
      var a = "[-\\+]?\\d+%?"
        , b = "[-\\+]?\\d*\\.\\d+%?"
        , c = "(?:" + b + ")|(?:" + a + ")"
        , d = "[\\s|\\(]+(" + c + ")[,|\\s]+(" + c + ")[,|\\s]+(" + c + ")\\s*\\)?"
        , e = "[\\s|\\(]+(" + c + ")[,|\\s]+(" + c + ")[,|\\s]+(" + c + ")[,|\\s]+(" + c + ")\\s*\\)?";
      return {
          CSS_UNIT: new RegExp(c),
          rgb: new RegExp("rgb" + d),
          rgba: new RegExp("rgba" + e),
          hsl: new RegExp("hsl" + d),
          hsla: new RegExp("hsla" + e),
          hsv: new RegExp("hsv" + d),
          hsva: new RegExp("hsva" + e),
          hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
          hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
      }
  }();
  "undefined" != typeof module && module.exports ? module.exports = b : "function" == typeof define && define.amd ? define(function() {
      return b
  }) : window.tinycolor = b
}(Math);
;// https://github.com/otto-dev/coordinate-parser
// Copyright (C) 2016 WEPROG GmbH

// Was based on Require so I just concatenated the whole thing

// Validator Class
var Validator;

Validator = class Validator {
  isValid(coordinates) {
      var isValid, validationError;
      isValid = true;
      try {
          this.validate(coordinates);
          return isValid;
      } catch (error) {
          validationError = error;
          isValid = false;
          return isValid;
      }
  }

  validate(coordinates) {
      this.checkContainsNoLetters(coordinates);
      this.checkValidOrientation(coordinates);
      return this.checkNumbers(coordinates);
  }

  checkContainsNoLetters(coordinates) {
      var containsLetters;
      containsLetters = /(?![neswd])[a-z]/i.test(coordinates);
      if (containsLetters) {
          throw new Error('Coordinate contains invalid alphanumeric characters.');
      }
  }

  checkValidOrientation(coordinates) {
      var validOrientation;
      validOrientation = /^[^nsew]*[ns]?[^nsew]*[ew]?[^nsew]*$/i.test(coordinates);
      if (!validOrientation) {
          throw new Error('Invalid cardinal direction.');
      }
  }

  checkNumbers(coordinates) {
      var coordinateNumbers;
      coordinateNumbers = coordinates.match(/-?\d+(\.\d+)?/g);
      this.checkAnyCoordinateNumbers(coordinateNumbers);
      this.checkEvenCoordinateNumbers(coordinateNumbers);
      return this.checkMaximumCoordinateNumbers(coordinateNumbers);
  }

  checkAnyCoordinateNumbers(coordinateNumbers) {
      if (coordinateNumbers.length === 0) {
          throw new Error('Could not find any coordinate number');
      }
  }

  checkEvenCoordinateNumbers(coordinateNumbers) {
      var isUnevenNumbers;
      isUnevenNumbers = coordinateNumbers.length % 2;
      if (isUnevenNumbers) {
          throw new Error('Uneven count of latitude/longitude numbers');
      }
  }

  checkMaximumCoordinateNumbers(coordinateNumbers) {
      if (coordinateNumbers.length > 6) {
          throw new Error('Too many coordinate numbers');
      }
  }

}
;

// CoordinateNumber class

var CoordinateNumber = class CoordinateNumber {
  constructor(coordinateNumbers) {
      coordinateNumbers = this.normalizeCoordinateNumbers(coordinateNumbers);
      this.sign = this.normalizedSignOf(coordinateNumbers[0]);
      [this.degrees,this.minutes,this.seconds,this.milliseconds] = coordinateNumbers.map(Math.abs);
  }

  normalizeCoordinateNumbers(coordinateNumbers) {
      var currentNumber, i, j, len, normalizedNumbers;
      normalizedNumbers = [0, 0, 0, 0];
      for (i = j = 0,
      len = coordinateNumbers.length; j < len; i = ++j) {
          currentNumber = coordinateNumbers[i];
          normalizedNumbers[i] = parseFloat(currentNumber);
      }
      return normalizedNumbers;
  }

  normalizedSignOf(number) {
      if (number >= 0) {
          return 1;
      } else {
          return -1;
      }
  }

  detectSpecialFormats() {
      if (this.degreesCanBeSpecial()) {
          if (this.degreesCanBeMilliseconds()) {
              return this.degreesAsMilliseconds();
          } else if (this.degreesCanBeDegreesMinutesAndSeconds()) {
              return this.degreesAsDegreesMinutesAndSeconds();
          } else if (this.degreesCanBeDegreesAndMinutes()) {
              return this.degreesAsDegreesAndMinutes();
          }
      }
  }

  degreesCanBeSpecial() {
      var canBe;
      canBe = false;
      if (!this.minutes && !this.seconds) {
          canBe = true;
      }
      return canBe;
  }

  degreesCanBeMilliseconds() {
      var canBe;
      if (this.degrees > 909090) {
          canBe = true;
      } else {
          canBe = false;
      }
      return canBe;
  }

  degreesAsMilliseconds() {
      this.milliseconds = this.degrees;
      return this.degrees = 0;
  }

  degreesCanBeDegreesMinutesAndSeconds() {
      var canBe;
      if (this.degrees > 9090) {
          canBe = true;
      } else {
          canBe = false;
      }
      return canBe;
  }

  degreesAsDegreesMinutesAndSeconds() {
      var newDegrees;
      newDegrees = Math.floor(this.degrees / 10000);
      this.minutes = Math.floor((this.degrees - newDegrees * 10000) / 100);
      this.seconds = Math.floor(this.degrees - newDegrees * 10000 - this.minutes * 100);
      return this.degrees = newDegrees;
  }

  degreesCanBeDegreesAndMinutes() {
      var canBe;
      if (this.degrees > 360) {
          canBe = true;
      } else {
          canBe = false;
      }
      return canBe;
  }

  degreesAsDegreesAndMinutes() {
      var newDegrees;
      newDegrees = Math.floor(this.degrees / 100);
      this.minutes = this.degrees - newDegrees * 100;
      return this.degrees = newDegrees;
  }

  toDecimal() {
      var decimalCoordinate;
      decimalCoordinate = this.sign * (this.degrees + this.minutes / 60 + this.seconds / 3600 + this.milliseconds / 3600000);
      return decimalCoordinate;
  }

}
;

// Coordinates Class

var Coordinates = class Coordinates {
  constructor(coordinateString) {
      this.coordinates = coordinateString;
      this.latitudeNumbers = null;
      this.longitudeNumbers = null;
      this.validate();
      this.parse();
  }

  validate() {
      var validator;
      validator = new Validator();
      return validator.validate(this.coordinates);
  }

  parse() {
      this.groupCoordinateNumbers();
      this.latitude = this.extractLatitude();
      return this.longitude = this.extractLongitude();
  }

  groupCoordinateNumbers() {
      var coordinateNumbers, numberCountEachCoordinate;
      coordinateNumbers = this.extractCoordinateNumbers(this.coordinates);
      numberCountEachCoordinate = coordinateNumbers.length / 2;
      this.latitudeNumbers = coordinateNumbers.slice(0, numberCountEachCoordinate);
      return this.longitudeNumbers = coordinateNumbers.slice((0 - numberCountEachCoordinate));
  }

  extractCoordinateNumbers(coordinates) {
      return coordinates.match(/-?\d+(\.\d+)?/g);
  }

  extractLatitude() {
      var latitude;
      latitude = this.coordinateNumbersToDecimal(this.latitudeNumbers);
      if (this.latitudeIsNegative()) {
          latitude = latitude * -1;
      }
      return latitude;
  }

  extractLongitude() {
      var longitude;
      longitude = this.coordinateNumbersToDecimal(this.longitudeNumbers);
      if (this.longitudeIsNegative()) {
          longitude = longitude * -1;
      }
      return longitude;
  }

  coordinateNumbersToDecimal(coordinateNumbers) {
      var coordinate, decimalCoordinate;
      coordinate = new CoordinateNumber(coordinateNumbers);
      coordinate.detectSpecialFormats();
      decimalCoordinate = coordinate.toDecimal();
      return decimalCoordinate;
  }

  latitudeIsNegative() {
      var isNegative;
      isNegative = this.coordinates.match(/s/i);
      return isNegative;
  }

  longitudeIsNegative() {
      var isNegative;
      isNegative = this.coordinates.match(/w/i);
      return isNegative;
  }

  getLatitude() {
      return this.latitude;
  }

  getLongitude() {
      return this.longitude;
  }

}
;
;window.geofsShaders = window.geofsShaders || {};
geofsShaders["atmosphereCommon.glsl"] = "precision highp float;\nuniform float planetRadius;\nuniform float realPlanetRadius;\nuniform float atmoRadiusSquared;\n#ifdef VOLUMETRIC_CLOUDS\nconst float windSpeedRatio = 0.0002;\nuniform float cloudCover;\nuniform float cloudBase;\nuniform float cloudTop;\nuniform vec3 windVector;\nuniform float cloudThickness;\nuniform float layerPosition;\nuniform float baseThickness;\nuniform float layer;\nuniform float cloudBaseRadius;\nuniform float cloudTopRadius;\n#ifdef REALTIME_CLOUDS\nuniform sampler2D coverageTexture;\n#endif\n#endif\n/*\nfloat cloudThickness = cloudTop - cloudBase;\nfloat layerPosition = 0.1; // set the layer base to 10% of the cloud height\nfloat baseThickness = cloudThickness * layerPosition;\nfloat layer = cloudBase + baseThickness;\nfloat cloudBase_radius = realPlanetRadius + cloudBase;\nfloat cloudTop_radius = cloudBase_radius + cloudThickness;\n*/\nconst float PI = 3.14159265359;\nconst float TWO_PI = 6.28318530718;\nconst float FOUR_PI = 12.5663706144;\n#ifdef QUALITY_7\n#define PRIMARY_STEPS 16\n#define LIGHT_STEPS 4\n#define CLOUDS_MAX_LOD 1\n#define CLOUDS_MARCH_STEP 500.0\n#define CLOUDS_DENS_MARCH_STEP 100.0\n#define MAXIMUM_CLOUDS_STEPS 300\n#define DISTANCE_QUALITY_RATIO 0.00003\n#define CLOUD_SHADOWS\n#elif defined QUALITY_6\n#define PRIMARY_STEPS 12\n#define LIGHT_STEPS 4\n#define CLOUDS_MAX_LOD 1\n#define CLOUDS_MARCH_STEP 500.0\n#define CLOUDS_DENS_MARCH_STEP 100.0\n#define MAXIMUM_CLOUDS_STEPS 200\n#define DISTANCE_QUALITY_RATIO 0.00004\n#define CLOUD_SHADOWS\n#elif defined QUALITY_5\n#define PRIMARY_STEPS 9\n#define LIGHT_STEPS 3\n#define CLOUDS_MAX_LOD 1\n#define CLOUDS_MARCH_STEP 750.0\n#define CLOUDS_DENS_MARCH_STEP 150.0\n#define MAXIMUM_CLOUDS_STEPS 150\n#define DISTANCE_QUALITY_RATIO 0.00005\n#define CLOUD_SHADOWS\n#elif defined QUALITY_4\n#define PRIMARY_STEPS 9\n#define LIGHT_STEPS 3\n#define CLOUDS_MAX_LOD 1\n#define CLOUDS_MARCH_STEP 750.0\n#define CLOUDS_DENS_MARCH_STEP 150.0\n#define MAXIMUM_CLOUDS_STEPS 100\n#define DISTANCE_QUALITY_RATIO 0.00007\n#define CLOUD_SHADOWS\n#elif defined QUALITY_3\n#define PRIMARY_STEPS 6\n#define LIGHT_STEPS 2\n#define CLOUDS_MAX_LOD 0\n#define CLOUDS_MARCH_STEP 750.0\n#define CLOUDS_DENS_MARCH_STEP 150.0\n#define MAXIMUM_CLOUDS_STEPS 75\n#define DISTANCE_QUALITY_RATIO 0.0001\n#define CLOUD_SHADOWS\n#elif defined QUALITY_2\n#define PRIMARY_STEPS 6\n#define LIGHT_STEPS 1\n#define CLOUDS_MAX_LOD 0\n#define CLOUDS_MARCH_STEP 1000.0\n#define CLOUDS_DENS_MARCH_STEP 200.0\n#define MAXIMUM_CLOUDS_STEPS 50\n#define DISTANCE_QUALITY_RATIO 0.0002\n#define CLOUD_SHADOWS\n#elif defined QUALITY_1\n#define PRIMARY_STEPS 3\n#define LIGHT_STEPS 1\n#define CLOUDS_MAX_LOD 0\n#define CLOUDS_MARCH_STEP 1000.0\n#define CLOUDS_DENS_MARCH_STEP 200.0\n#define MAXIMUM_CLOUDS_STEPS 20\n#define DISTANCE_QUALITY_RATIO 0.0004\n#elif defined QUALITY_0\n#define PRIMARY_STEPS 3\n#define LIGHT_STEPS 1\n#define CLOUDS_MAX_LOD 0\n#define CLOUDS_MARCH_STEP 1000.0\n#define CLOUDS_DENS_MARCH_STEP 200.0\n#define MAXIMUM_CLOUDS_STEPS 10\n#define DISTANCE_QUALITY_RATIO 0.0004\n#else //DEFAULT\n#define PRIMARY_STEPS 9\n#define LIGHT_STEPS 2\n#define CLOUDS_MAX_LOD 1\n#define CLOUDS_MARCH_STEP 750.0\n#define CLOUDS_DENS_MARCH_STEP 150.0\n#define MAXIMUM_CLOUDS_STEPS 40\n#define DISTANCE_QUALITY_RATIO 0.0002\n#define CLOUD_SHADOWS\n#endif\n#define CLOUDS_MAX_VIEWING_DISTANCE 250000.0\nvec2 raySphereIntersect(vec3 r0, vec3 rd, float sr) {\nfloat a = dot(rd, rd);\nfloat b = 2.0 * dot(rd, r0);\nfloat c = dot(r0, r0) - (sr * sr);\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) return vec2(-1.0, -1.0);\nfloat squaredD = sqrt(d);\nreturn vec2(\n(-b - squaredD) / (2.0 * a),\n(-b + squaredD) / (2.0 * a)\n);\n}\nfloat reMap (float value, float old_low, float old_high, float new_low, float new_high ) {\nreturn new_low + (value - old_low) * (new_high - new_low) / (old_high - old_low);\n}\nfloat saturate (float value) {\nreturn clamp(value, 0.0, 1.0);\n}\nfloat isotropic() {\nreturn 0.07957747154594767; //1.0 / (4.0 * PI);\n}\nfloat rayleigh(float costh) {\nreturn (3.0 / (16.0 * PI)) * (1.0 + pow(costh, 2.0));\n}\nfloat HenyeyGreenstein(float g, float costh)\n{\nreturn (1.0 - g * g) / (FOUR_PI * pow(1.0 + g * g - 2.0 * g * costh, 3.0 / 2.0));\n}\nfloat Schlick(float k, float costh) {\nreturn (1.0 - k * k) / (FOUR_PI * pow(1.0 - k * costh, 2.0));\n}\nvec3 light_intensity = vec3(60.0);//vec3(100.0); // how bright the light is, affects the brightness of the atmosphere\nvec3 beta_ray = vec3(5.5e-6, 13.0e-6, 22.4e-6);//vec3(5.5e-6, 13.0e-6, 22.4e-6); // the amount rayleigh scattering scatters the colors (for earth: causes the blue atmosphere)\nvec3 beta_mie = vec3(21e-6); // vec3(21e-6);// the amount mie scattering scatters colors\nvec3 beta_ambient = vec3(0.0); // the amount of scattering that always occurs, can help make the back side of the atmosphere a bit brighter\nfloat g = 0.8; // the direction mie scatters the light in (like a cone). closer to -1 means more towards a single direction\nfloat height_ray = 10e3; // how high do you have to go before there is no rayleigh scattering?\nfloat height_mie = 3.2e3; // the same, but for mie\nfloat density_multiplier = 2.0; // 1.0 - how much extra the atmosphere blocks light\n#ifdef ADVANCED_ATMOSPHERE\nvec4 calculate_scattering(\nvec3 start, 			// the start of the ray (the camera position)\nvec3 dir, 				// the direction of the ray (the camera vector)\nfloat maxDistance, 		// the maximum distance the ray can travel (because something is in the way, like an object)\nvec3 light_dir\n) {\nfloat a = dot(dir, dir);\nfloat b = 2.0 * dot(dir, start);\nfloat c = dot(start, start) - atmoRadiusSquared;\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) return vec4(0.0);\nfloat squaredD = sqrt(d);\nvec2 ray_length = vec2(\nmax((-b - squaredD) / (2.0 * a), 0.0),\nmin((-b + squaredD) / (2.0 * a), maxDistance)\n);\nif (ray_length.x > ray_length.y) return vec4(0.0);\nbool allow_mie = maxDistance > ray_length.y;\nfloat step_size_i = (ray_length.y - ray_length.x) / float(PRIMARY_STEPS);\nfloat ray_pos_i = ray_length.x;\nvec3 total_ray = vec3(0.0); // for rayleigh\nvec3 total_mie = vec3(0.0); // for mie\nvec2 opt_i = vec2(0.0);\nvec2 scale_height = vec2(height_ray, height_mie);\nfloat mu = dot(dir, light_dir);\nfloat mumu = mu * mu;\nfloat gg = g * g;\nfloat phase_ray = 3.0 / (50.2654824574 ) * (1.0 + mumu);\nfloat phase_mie = (allow_mie ? 3.0 : 0.5 ) / (25.1327412287 ) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg));\nfor (int i = 0; i < PRIMARY_STEPS; ++i) {\nvec3 pos_i = start + dir * (ray_pos_i + step_size_i);\nfloat height_i = length(pos_i) - planetRadius;\nvec2 density = exp(-height_i / scale_height) * step_size_i;\nopt_i += density;\na = dot(light_dir, light_dir);\nb = 2.0 * dot(light_dir, pos_i);\nc = dot(pos_i, pos_i) - atmoRadiusSquared;\nd = (b * b) - 4.0 * a * c;\nif (d <= 0.0) d = 1.0; // not supposed to be required but this avoids the black singularity line at dusk and dawn\nfloat step_size_l = (-b + sqrt(d)) / (2.0 * a * float(LIGHT_STEPS));\nfloat ray_pos_l = 0.0;\nvec2 opt_l = vec2(0.0);\nfor (int l = 0; l < LIGHT_STEPS; ++l) {\nvec3 pos_l = pos_i + light_dir * (ray_pos_l + step_size_l * 0.5);\nfloat height_l = length(pos_l) - planetRadius;\nopt_l += exp(-height_l / scale_height) * step_size_l;\nray_pos_l += step_size_l;\n}\nvec3 attn = exp(-((beta_mie * (opt_i.y + opt_l.y)) + (beta_ray * (opt_i.x + opt_l.x))));\ntotal_ray += density.x * attn;\ntotal_mie += density.y * attn;\nray_pos_i += step_size_i;\n}\nfloat opacity = length(exp(-((beta_mie * opt_i.y) + (beta_ray * opt_i.x)) * density_multiplier));\nreturn vec4((\nphase_ray * beta_ray * total_ray // rayleigh color\n+ phase_mie * beta_mie * total_mie // mie\n+ opt_i.x * beta_ambient // and ambient\n) * light_intensity, 1.0 - opacity);\n}\n#endif\n#ifdef VOLUMETRIC_CLOUDS\nfloat hash(float p)\n{\np = fract(p * .1031);\np *= p + 33.33;\np *= p + p;\nreturn fract(p);\n}\nfloat noise(in vec3 x) {\nvec3 p = floor(x);\nvec3 f = fract(x);\nf = f*f*(3.0 - 2.0*f);\nfloat n = p.x + p.y*157.0 + 113.0*p.z;\nreturn mix(mix(mix( hash(n+ 0.0), hash(n+ 1.0),f.x),\nmix( hash(n+157.0), hash(n+158.0),f.x),f.y),\nmix(mix( hash(n+113.0), hash(n+114.0),f.x),\nmix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nint lastFlooredPosition;\nfloat lastLiveCoverageValue = 0.0;\nfloat cloudDensity(vec3 p, vec3 wind, int lod, inout float heightRatio) {\nfloat finalCoverage = cloudCover;\n#ifdef REALTIME_CLOUDS\nvec3 sphericalNormal = normalize(p);\nvec2 positionSurfaceC = czm_ellipsoidWgs84TextureCoordinates(sphericalNormal);\nfloat sampledValue = texture(coverageTexture, positionSurfaceC).r;\nlastLiveCoverageValue = clamp((sampledValue - 0.4) * 10.0, 0.0, 1.0);\nfinalCoverage *= lastLiveCoverageValue;\n#endif\nif (finalCoverage <= 0.1) return 0.0;\nfloat height = length(p) - realPlanetRadius;\nheightRatio = (height - cloudBase) / cloudThickness;\nfloat positionResolution = 0.002;\np = p * positionResolution + wind;\nfloat shape = noise(p * 0.3);\nfloat shapeHeight = noise(p * 0.05);\nfloat bn = 0.50000 * noise(p); p = p * 2.0;\nif( lod>=1 ) bn += 0.20000 * noise(p); p = p * 2.11;\nfloat cumuloNimbus = saturate((shapeHeight - 0.5) * 2.0);\ncumuloNimbus *= saturate(1.0 - pow(heightRatio - 0.5, 2.0) * 4.0);\nfloat cumulus = saturate(1.0 - pow(heightRatio - 0.25, 2.0) * 25.0) * shapeHeight;\nfloat stratoCumulus = saturate(1.0 - pow(heightRatio - 0.12, 2.0) * 60.0) * (1.0 - shapeHeight);\nfloat dens = saturate(stratoCumulus + cumulus + cumuloNimbus) * 2.0 * finalCoverage;\ndens -= 1.0 - shape;\ndens -= bn;\nreturn clamp(dens, 0.0, 1.0);\n}\n#endif\n";
;window.geofsShaders = window.geofsShaders || {};
geofsShaders["atmosphereOnlyFS.glsl"] = "precision highp float;\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\n#ifdef VOLUMETRIC_CLOUDS\nuniform sampler2D volumetricCloudsTexture;\n#endif\nuniform float backgroundFogDensity;\nuniform vec4 backgroundFogColor;\nuniform float volumetricFogDensity;\nuniform float volumetricFogBottom;\nuniform float volumetricFogTop;\nin vec2 v_textureCoordinates;\nvoid main() {\nvec4 color = texture(colorTexture, v_textureCoordinates);\nvec4 rawDepthColor = texture(depthTexture, v_textureCoordinates);\nfloat depth = rawDepthColor.r;// depth packing algo appears to be buggy on mobile so only use the most significant element for now\nvec4 positionEC = czm_windowToEyeCoordinates(gl_FragCoord.xy, depth);\nvec4 worldCoordinate = czm_inverseView * positionEC;\nvec3 vWorldPosition = worldCoordinate.xyz / worldCoordinate.w;\nvec3 posToEye = vWorldPosition - czm_viewerPositionWC;\nvec3 direction = normalize(posToEye);\nvec3 lightDirection = normalize(czm_sunPositionWC);\nfloat distance = length(posToEye);\nfloat elevation;\n#ifdef RETRO\nif (depth >= 0.9) {\ngl_FragColor = color;\nreturn;\n}\n#endif\nif (depth >= 1.0) {\nelevation = length(czm_viewerPositionWC) - (realPlanetRadius);\ndistance = max(distance, 10000000.0); // max out the distance when looking at the sky to avoid clamp/arc artefact\n}\nelse {\nelevation = length(vWorldPosition) - (realPlanetRadius);\n}\nfloat fragFogDensity;\nfragFogDensity = clamp((volumetricFogTop - elevation) / (volumetricFogTop - volumetricFogBottom), 0.0, 1.0) * volumetricFogDensity * depth; // volumetric\ncolor = mix(color, vec4(czm_lightColor, 1.0), clamp(fragFogDensity, 0.0, 1.0));\n#if defined(VOLUMETRIC_CLOUDS)\nfloat depthMaskDistance = 0.5;\nif (length(czm_viewerPositionWC) < cloudBaseRadius) {\ndepthMaskDistance = 0.9; // try to include distant trees and object in the mask\n}\n#if defined(CLOUD_SHADOWS)\nfloat baseDistance = cloudBaseRadius + baseThickness;\nif (depth < 1.0 && czm_lightColor.z > 0.15 && length(vWorldPosition) < baseDistance) {\nvec3 wind = windVector * czm_frameNumber * windSpeedRatio;\nfloat mask = 1.0;\nvec2 toClouds = raySphereIntersect(vWorldPosition, -lightDirection, baseDistance);\nvec3 position = vWorldPosition + (-lightDirection * toClouds.x);\nfloat hr;\nfloat dens = cloudDensity(position, wind, 0, hr);\nmask = clamp(1.0 - dens * 2.0, 0.2, 1.0);\ncolor *= mask;\n}\n#endif\n#endif\n#ifdef ADVANCED_ATMOSPHERE\nvec4 atmosphereColor = calculate_scattering(\nczm_viewerPositionWC,\ndirection,\ndistance,\nlightDirection\n);\ncolor = atmosphereColor + color * (1.0 - atmosphereColor.a);\n#ifdef VOLUMETRIC_CLOUDS\nvec4 clouds = texture(volumetricCloudsTexture, v_textureCoordinates);\nclouds.rgb *= 3.0;\ncolor = mix(color, clouds, clouds.a * clouds.a * clamp((depth - depthMaskDistance) * 100.0, 0.0, 1.0));\n#endif\nfloat exposure = 1.2;\ncolor = vec4(1.0 - exp(-exposure * color));\n#endif\nfloat backFogDensity;\nbackFogDensity += backgroundFogDensity * depth;\ncolor = mix(color, vec4(backgroundFogColor.rgb, 1.0), clamp(backFogDensity, 0.0, 1.0));\ngl_FragColor = color;\n}\n";
;window.geofsShaders = window.geofsShaders || {};
geofsShaders["volumetricCloudsFS.glsl"] = "precision highp float;\nuniform sampler2D noiseTexture;\nin vec2 v_textureCoordinates;\nvec3 skyAmbientColor = vec3(0.705, 0.850, 0.952); //0.219, 0.380, 0.541\nvec3 groundAmbientColor = vec3(0.5, 0.55, 0.5); //vec3(0.741, 0.898, 0.823); //0.639, 0.858, 0.721\nfloat distanceQualityR = 0.00005; // LOD/quality ratio\nfloat minDistance = 10.0; // avoid cloud in cockpit\n#undef PRIMARY_STEPS\n#undef LIGHT_STEPS\n#define PRIMARY_STEPS 1\n#define LIGHT_STEPS 0\nvec4 calculate_clouds(\nvec3 start,\nvec3 dir,\nfloat maxDistance,\nvec3 light_dir,\nvec3 wind\n) {\nvec4 cloud = vec4(0.0, 0.0, 0.0, 1.0);\nvec2 toTop = raySphereIntersect(start, dir, cloudTopRadius);\nvec2 toCloudBase = raySphereIntersect(start, dir, cloudBaseRadius);\nfloat startHeight = length(start) - realPlanetRadius;\nfloat absoluteMaxDistance = CLOUDS_MAX_VIEWING_DISTANCE;\nfloat tmin = minDistance;\nfloat tmax = maxDistance;\nif (startHeight > cloudTop) {\nif (toTop.x < 0.0) return vec4(0.0); // no intersection with cloud layer\ntmin = toTop.x;\nif (toCloudBase.x > 0.0) {\ntmax = min(toCloudBase.x, maxDistance);\n}\nelse {\ntmax = min(toTop.y, maxDistance);\n}\n}\nelse if (startHeight < cloudBase) {\ntmin = toCloudBase.y;\ntmax = min(toTop.y, maxDistance);\n}\nelse {\nif (toCloudBase.x > 0.0) {\ntmax = min(toCloudBase.x, maxDistance);\n}\nelse {\ntmax = min(toTop.y, maxDistance);\n}\n}\ntmin = max(tmin, minDistance);\ntmax = min(tmax, absoluteMaxDistance);\nif (tmax < tmin) return vec4(0.0); // object obstruction\nfloat rayLength = tmax - tmin;\nfloat longMarchStep = rayLength / float(MAXIMUM_CLOUDS_STEPS);\nlongMarchStep = max(longMarchStep, CLOUDS_MARCH_STEP);\nfloat shortMarchStep = CLOUDS_DENS_MARCH_STEP;\nfloat numberApproachSteps = (CLOUDS_MARCH_STEP / CLOUDS_DENS_MARCH_STEP) * 2.0;\nfloat ditherAmount = texture(noiseTexture, mod(gl_FragCoord.xy / 512.0, 1.0)).r * 2.0 - 1.0;\nfloat ditherDistance = ditherAmount * shortMarchStep;\nfloat distance = tmin + ditherDistance;\nfloat dens = 0.0;\nfloat marchStep;\nfloat distanceToFirstCloud = 0.0;\nfloat lastDensity;\nfloat gInScattering = 0.9;\nfloat gOutScattering = 0.0;\nfloat kInScattering = 0.99;\nfloat dotLightRay = dot(dir, light_dir);\nfloat inScattering = Schlick(kInScattering, dotLightRay); //HenyeyGreenstein(gInScattering, dotLightRay);\nfloat outScattering = isotropic(); //HenyeyGreenstein(gOutScattering, dotLightRay);\nfloat sunScatteringPhase = mix(outScattering, inScattering, dotLightRay);\nfloat ambientScatteringPhase = isotropic();\nbool inCloud = false;\nbool rayComplete = false;\nfloat stepsBeforeExitingCloud = 0.0;\nfor (int i = 0; i < MAXIMUM_CLOUDS_STEPS; i++) {\nvec3 position = start + dir * distance;\nfloat depth = distance / CLOUDS_MAX_VIEWING_DISTANCE;\nint qualityRatio = int(distance * distanceQualityR);\nint lod = CLOUDS_MAX_LOD - qualityRatio;\nfloat heightRatio;\nif (inCloud == true) {\nmarchStep = shortMarchStep;\n}\nelse {\nmarchStep = longMarchStep;\nlod = 0;\n}\ndens = cloudDensity(position, wind, lod, heightRatio);\nif(dens > 0.01) {\nif (inCloud != true) {\ninCloud = true;\nstepsBeforeExitingCloud = numberApproachSteps;\ndistance = clamp(distance - CLOUDS_MARCH_STEP, tmin, tmax); // take one step back\ncontinue;\n}\nfloat deltaDens = clamp((dens - lastDensity) * 10.0, -1.0, 1.0);\nfloat lighting = (abs(deltaDens - dotLightRay) / 2.0) * clamp((heightRatio - 0.02) * 20.0, 0.5, 1.0);\nlastDensity = dens;\nfloat scatteringCoeff = 0.25 * dens;\nfloat extinctionCoeff = 0.01 * dens;\ncloud.a *= exp(-extinctionCoeff * marchStep);\nfloat sunIntensityAtSurface = clamp(0.2 - dens, 0.0, 1.0);\nvec3 sunLight = lighting * czm_lightColor * sunIntensityAtSurface * czm_lightColor.z;\nvec3 ambientSun = czm_lightColor * sunIntensityAtSurface * czm_lightColor.z * isotropic();\nvec3 skyAmbientLight = (skyAmbientColor * czm_lightColor.z + ambientSun);\nvec3 groundAmbientLight = (groundAmbientColor * czm_lightColor.z * 0.5 + ambientSun);\nvec3 ambientLight = mix(groundAmbientLight, skyAmbientLight, heightRatio);\nvec3 stepScattering = scatteringCoeff * marchStep * (sunScatteringPhase * sunLight + ambientScatteringPhase * ambientLight);\ncloud.rgb += cloud.a * stepScattering;\nif (cloud.a < 0.01) {\ncloud.a = 0.0;\nbreak;\n}\nif (distanceToFirstCloud == 0.0) {\ndistanceToFirstCloud = distance;\n}\n}\nelse {\nif (stepsBeforeExitingCloud > 0.0) {\nstepsBeforeExitingCloud--;\n}\nelse {\ninCloud = false;\n}\n}\ndistance += marchStep;\nif (distance > tmax) {\nif (rayComplete == true) {\nbreak;\n}\nelse {\nrayComplete = true;\ndistance = tmax;\n}\n}\n}\nvec4 atmosphereAtDistance = calculate_scattering(\nczm_viewerPositionWC,\ndir,\ndistanceToFirstCloud,\nlight_dir\n) * 0.2; // account for tone mapping\ncloud.rgb = cloud.rgb * (1.0 - atmosphereAtDistance.a) + atmosphereAtDistance.rgb;\ncloud.a = (1.0 - cloud.a);\nreturn cloud;\n}\nvoid main() {\nvec4 color = vec4(0.0);\nif (cloudCover < 0.1) {\ngl_FragColor = color;\nreturn;\n}\nvec4 rawDepthColor = texture(czm_globeDepthTexture, v_textureCoordinates);\n#if !defined(GL_EXT_frag_depth)\nfloat depth = rawDepthColor.r; // depth packing algo appears to be buggy on mobile so only use the most significant element for now\n#else\nfloat depth = czm_unpackDepth(rawDepthColor);\n#endif\nif (depth == 0.0) {\ndepth = 1.0;\n}\n#ifdef VOLUMETRIC_CLOUDS\nvec4 positionEC = czm_windowToEyeCoordinates(gl_FragCoord.xy, depth);\nvec4 worldCoordinate = czm_inverseView * positionEC;\nvec3 vWorldPosition = worldCoordinate.xyz / worldCoordinate.w;\nvec3 posToEye = vWorldPosition - czm_viewerPositionWC;\nvec3 direction = normalize(posToEye);\nvec3 lightDirection = normalize(czm_sunPositionWC);\nfloat distance = length(posToEye);\nif (depth == 1.0) {\ndistance = CLOUDS_MAX_VIEWING_DISTANCE;\n}\nvec3 wind = windVector * czm_frameNumber * windSpeedRatio;\ncolor = calculate_clouds(\nczm_viewerPositionWC, // the position of the camera\ndirection, // the camera vector (ray direction of this pixel)\ndistance, // max dist, essentially the scene depth\nlightDirection, // light direction\nwind\n);\n#endif\ngl_FragColor = color;\n}\n";
;window.geofsShaders = window.geofsShaders || {};
geofsShaders["oceanFS.glsl"] = "precision highp float;\nconst float specularShininess = 200.0;\nconst float specularPower = 2.0;\nconst float animationSpeed = 0.00005;\nfloat waveAmplitude;\nvec3 positionMC;\nczm_material czm_getMaterial(czm_materialInput materialInput) {\nczm_material material;\nvec4 layerColor = materialInput.layerColor;\nif (layerColor.r > 0.46 && layerColor.r < 0.54 && czm_lightColor.z < 0.13) {\npositionMC = (czm_inverseModelView * vec4(-materialInput.positionToEyeEC, 1.0)).xyz;\nvec3 sphericalNormal = normalize(positionMC);\nvec2 positionSurfaceC = czm_ellipsoidWgs84TextureCoordinates(sphericalNormal) * 3000.0;\nmaterial.diffuse = texture(lightsTexture, fract(positionSurfaceC)).rgb * 1.5;\nmaterial.alpha = material.diffuse.r * layerColor.r;\n}\nif (layerColor.b > 0.0) {\nvec4 czm_lightColorV4 = vec4(czm_lightColor, 1.0);\npositionMC = (czm_inverseModelView * vec4(-materialInput.positionToEyeEC, 1.0)).xyz;\nfloat seaRatio = 1.0 - clamp(materialInput.height / 10.0, 0.0, 0.8);\nwaveAmplitude = layerColor.b * seaRatio;\nfloat shoreRatio = 0.0;\nif (layerColor.b < 0.95) {\nshoreRatio = 0.01;\n}\nfloat windFactor = windSpeed * 0.05;\nwaveAmplitude *= windFactor + 0.88;\nvec3 normalTangentSpace = vec3(1.0, 1.0, 1.0 / waveAmplitude);\n#if !defined(GL_EXT_frag_depth)\nvec2 positionSurfaceC = materialInput.st * 128.0;\n#else\nvec3 sphericalNormal = czm_geodeticSurfaceNormal(positionMC, vec3(0.0), vec3(1.0));\nvec2 positionSurfaceC = czm_ellipsoidWgs84TextureCoordinates(sphericalNormal);\n#endif\nfloat time = geofsTime * animationSpeed * (windFactor + 0.9);\nvec4 noise = czm_getWaterNoise(normalMap, positionSurfaceC * 500000.0, time, 0.0);\nnormalTangentSpace = noise.xyz * normalTangentSpace;\nnormalTangentSpace = normalize(normalTangentSpace);\nvec3 normalEC = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);\nvec3 up = normalize(materialInput.tangentToEyeMatrix * vec3(0.0, 0.0, 1.0));\nvec3 surfaceToLight = normalize(mat3(czm_view) * (czm_sunPositionWC - positionMC));\nvec3 surfaceToCamera = normalize(mat3(czm_view) * (czm_viewerPositionWC - positionMC));\nvec3 reflectedSun = normalize(-reflect(surfaceToLight, normalEC));\nfloat specularCoefficient = pow(max(dot(reflectedSun, surfaceToCamera), 0.0), specularShininess * waveAmplitude) * specularPower;\nfloat waveHeight = clamp((0.99 + shoreRatio - dot(normalEC, up)) * 500.0, 0.0, 1.0);\nvec2 positionSurfaceC2 = vec2(fract(positionSurfaceC * 50000.0));\nvec4 foam = texture(foamTexture, positionSurfaceC2) * waveHeight * czm_lightColorV4; // uv from geo coords (noisy)\nfloat reflectionCoefficient = dot(surfaceToCamera, normalEC);\nvec4 reflectionColor = mix(horizonColor, azimutColor, reflectionCoefficient);\nreflectionColor = reflectionColor + czm_lightColorV4 * specularCoefficient;//mix(waterColor, czm_lightColorV4, specularCoefficient);\nfloat Eta = 0.15;\nfloat fresnel = Eta + (1.0 - Eta) * pow(max(0.0, 1.0 - dot(surfaceToCamera, normalEC)), 5.0);\nmaterial.diffuse = reflectionColor.rgb + foam.rgb;\nmaterial.alpha = layerColor.b * (fresnel * 0.5 + specularCoefficient + foam.r);\n}\nreturn material;\n}\n";
;window.geofsShaders = window.geofsShaders || {};
geofsShaders["wireFS.glsl"] = "precision highp float;\nczm_material czm_getMaterial(czm_materialInput materialInput) {\nczm_material material;\nvec3 positionMC = (czm_inverseModelView * vec4(-materialInput.positionToEyeEC, 1.0)).xyz;\nvec3 sphericalNormal = normalize(positionMC);\nvec2 positionSurfaceC = abs(fract(czm_ellipsoidWgs84TextureCoordinates(sphericalNormal) * 500000.0) - vec2(0.5, 0.5)) * 2.0;\nfloat value = 1.0 - min(positionSurfaceC.x, positionSurfaceC.y);\nif (value > 0.95) {\nmaterial.diffuse = mix(backgroundColor.rgb, wireframeColor.rgb, (value - 0.95) * 4.0);\nif (value > 0.99) {\nmaterial.diffuse = wireframeColor.rgb;\n}\n}\nelse {\nmaterial.diffuse = backgroundColor.rgb;\n}\nmaterial.alpha = 1.0;\nreturn material;\n}\n";
;window.geofsShaders = window.geofsShaders || {};
geofsShaders["buildingsFS.glsl"] = "void fragmentMain(\nFragmentInput fsInput,\ninout czm_modelMaterial material) {\nmaterial.alpha = 1.0;\nvec3 emission = vec3(0.0);\nvec4 baseColor = texture(u_buildingTexture, fsInput.attributes.texCoord_0);\nvec4 buildingColor = fsInput.attributes.color_0;//min((fsInput.attributes.color_0 + vec4(0.2)) * 0.8, vec4(1.0)); // desaturated vertex color\n#ifdef BUILDINGS_REFLECTION\nvec4 reflection;\nvec4 specularColor = texture(u_specularTexture, fsInput.attributes.texCoord_0);\nfloat specularTexLevel = specularColor.r;\nvec3 surfaceToLight = normalize((mat3(czm_view) * czm_sunPositionWC) - fsInput.attributes.positionEC);\nvec3 surfaceToCamera = normalize(-fsInput.attributes.positionEC); // we are in Eye Coordinates, so EyePos is (0,0,0)\nvec3 reflected = normalize(-reflect(surfaceToLight, fsInput.attributes.normalEC));\n#endif\nif (u_retro) {\nfloat gamma = 2.08;\nvec3 retroColor = baseColor.xyz;//vec3(0.051, 0.145, 0.231);\nretroColor = pow(retroColor, vec3(gamma));\nbaseColor.rgb = retroColor;\n/*\nfloat ambientCoefficient = 0.8;\nfloat diffuseCoefficient = max(0.0, dot(fsInput.attributes.normalEC, czm_sunDirectionEC) * 1.0);\nbaseColor.xyz *= min(diffuseCoefficient + ambientCoefficient, 1.0);\n*/\nmaterial.diffuse = baseColor.xyz;\n}\nelse if (czm_lightColor.z < 0.20) {\nemission = baseColor.xyz;\nfloat gamma = 0.4;\n#ifdef BUILDINGS_REFLECTION\nfloat reflectionLevel = 0.6 * specularTexLevel;\nvec3 coord = normalize(vec3(czm_inverseViewRotation * reflect(surfaceToCamera, fsInput.attributes.normalEC)));\nreflection = texture(u_environmentTexture, vec2(coord.x, (coord.z - coord.y) / 3.0));\nreflection *= reflectionLevel;\nmaterial.diffuse = pow(emission.rgb + reflection.rgb, vec3(1.0/gamma));\n#else\nmaterial.diffuse = pow(emission.rgb, vec3(1.0/gamma));\n#endif\n}\nelse {\nif (!u_isSnowy) {\nbaseColor *= buildingColor;\n}\nfloat ambientCoefficient = 0.1;\nfloat diffuseCoefficient = max(0.0, dot(fsInput.attributes.normalEC, czm_sunDirectionEC) * 1.0);\nbaseColor.xyz *= min(diffuseCoefficient + ambientCoefficient, 1.0);\n#ifdef BUILDINGS_REFLECTION\nfloat specularLevel = 200.0 * specularTexLevel;\nfloat specularCoefficient = pow(max(dot(reflected, surfaceToCamera), 0.0), 50.0);\nvec3 specular = czm_lightColor * specularCoefficient * specularLevel;\nfloat reflectionLevel = 0.2 * specularTexLevel;\nvec3 coord = normalize(vec3(czm_inverseViewRotation * reflect(surfaceToCamera, fsInput.attributes.normalEC)));\nreflection = texture(u_environmentTexture, vec2(coord.x, (coord.z - coord.y) / 3.0));\nreflection *= reflectionLevel;\nmaterial.diffuse = (baseColor.xyz + reflection.xyz + specular) * czm_lightColor;\n#else\nmaterial.diffuse = baseColor.xyz * czm_lightColor;\n#endif\n}\n}\n";
;window.geofsShaders = window.geofsShaders || {};
geofsShaders["treesFS.glsl"] = "void fragmentMain(\nFragmentInput fsInput,\ninout czm_modelMaterial material) {\nvec4 baseColor = texture(u_treeTexture, fsInput.attributes.texCoord_0);\nmaterial.alpha = baseColor.a;\nif (material.alpha < 0.5) {\ndiscard;\n}\nfloat expo = 2.2;\nbaseColor.rgb = pow(baseColor.rgb, vec3(expo));\nif (czm_lightColor.z < 0.20) {\nmaterial.diffuse = baseColor.rgb * czm_lightColor * 0.1;\n}\nelse {\nmaterial.diffuse = baseColor.xyz * czm_lightColor;\n}\n}\n";
;
"use strict";
L.Polyline.plotter = L.Polyline.extend({
  _lineMarkers: [],
  _editIcon: L.divIcon({
      className: "leaflet-div-icon leaflet-editing-icon"
  }),
  _halfwayPointMarkers: [],
  _existingLatLngs: [],
  options: {
      weight: 2,
      color: "#000",
      readOnly: !1
  },
  initialize: function(e, t) {
      this._lineMarkers = [],
      this._halfwayPointMarkers = [],
      this._setExistingLatLngs(e),
      L.Polyline.prototype.initialize.call(this, [], t)
  },
  onAdd: function(e) {
      L.Polyline.prototype.onAdd.call(this, e),
      this._map = e,
      this._plotExisting(),
      this.options.readOnly || this._bindMapClick()
  },
  onRemove: function(e) {
      this._halfwayPointMarkers.forEach(e => {
          e.remove()
      }
      ),
      this._lineMarkers.forEach(e => {
          e.remove()
      }
      ),
      this._halfwayPointMarkers = this._lineMarkers = [],
      this._unbindMapClick(),
      L.Polyline.prototype.onRemove.call(this, e)
  },
  setLatLngs: function(e) {
      L.Polyline.prototype.setLatLngs.call(this, e)
  },
  setReadOnly: function(e) {
      if (e && !this.options.readOnly) {
          var t = "_unbindMarkerEvents"
            , a = "_unbindHalfwayMarker";
          this._unbindMapClick()
      } else if (!e && this.options.readOnly) {
          var t = "_bindMarkerEvents"
            , a = "_bindMarkerEvents";
          this._bindMapClick()
      }
      if (void 0 !== t) {
          for (index in this.options.readOnly = e,
          this._halfwayPointMarkers)
              this[a](this._halfwayPointMarkers[index]);
          for (index in this._lineMarkers)
              this[t](this._lineMarkers[index])
      }
  },
  _bindMapClick: function() {
      this._map.on("click", this._onMapClick, this)
  },
  _unbindMapClick: function() {
      this._map.off("click", this._onMapClick, this)
  },
  _setExistingLatLngs: function(e) {
      this._existingLatLngs = e
  },
  _replot: function() {
      this._redraw(),
      this._redrawHalfwayPoints()
  },
  _getNewMarker: function(e, t) {
      return new L.marker(e,t)
  },
  _unbindMarkerEvents: function(e) {
      e.off("click", this._removePoint, this),
      e.off("drag", this._replot, this),
      e.dragging.disable()
  },
  _bindMarkerEvents: function(e) {
      e.on("mousedown", () => {
          this._screwedUpLeafletEventsBubblingCancellation = !0
      }
      , this),
      e.on("click", this._removePoint, this),
      e.on("drag", this._replot, this),
      e.dragging.enable()
  },
  _bindHalfwayMarker: function(e) {
      e.on("click", this._addHalfwayPoint, this)
  },
  _unbindHalfwayMarker: function(e) {
      e.off("click", this._addHalfwayPoint, this)
  },
  _addToMapAndBindMarker: function(e) {
      e.addTo(this._map),
      this.options.readOnly || this._bindMarkerEvents(e)
  },
  _removePoint: function(e) {
      this._map.removeLayer(this._lineMarkers[this._lineMarkers.indexOf(e.target)]),
      this._lineMarkers.splice(this._lineMarkers.indexOf(e.target), 1),
      this._replot()
  },
  _onMapClick: function(e) {
      if (this._screwedUpLeafletEventsBubblingCancellation) {
          this._screwedUpLeafletEventsBubblingCancellation = !1;
          return
      }
      this._addNewMarker(e),
      this._replot()
  },
  _addNewMarker: function(e) {
      var t = this._getNewMarker(e.latlng, {
          icon: this._editIcon
      });
      this._addToMapAndBindMarker(t),
      this._lineMarkers.push(t)
  },
  _redrawHalfwayPoints: function() {
      for (index in this._halfwayPointMarkers)
          this._map.removeLayer(this._halfwayPointMarkers[index]);
      for (index in this._halfwayPointMarkers = [],
      this._lineMarkers) {
          if (index = parseInt(index),
          void 0 === this._lineMarkers[index + 1])
              return;
          var e = new L.Marker([(this._lineMarkers[index].getLatLng().lat + this._lineMarkers[index + 1].getLatLng().lat) / 2, (this._lineMarkers[index].getLatLng().lng + this._lineMarkers[index + 1].getLatLng().lng) / 2, ],{
              icon: this._editIcon,
              opacity: .5
          }).addTo(this._map);
          e.index = index,
          this.options.readOnly || this._bindHalfwayMarker(e),
          this._halfwayPointMarkers.push(e)
      }
  },
  _addHalfwayPoint: function(e) {
      var t = this._getNewMarker(e.latlng, {
          icon: this._editIcon
      });
      this._addToMapAndBindMarker(t),
      this._lineMarkers.splice(e.target.index + 1, 0, t),
      this._replot()
  },
  _plotExisting: function() {
      for (index in this._existingLatLngs)
          this._addNewMarker({
              latlng: new L.LatLng(this._existingLatLngs[index][0],this._existingLatLngs[index][1])
          });
      this._replot()
  },
  _redraw: function() {
      for (index in this.setLatLngs([]),
      this.redraw(),
      this._lineMarkers)
          this.addLatLng(this._lineMarkers[index].getLatLng());
      this.redraw()
  }
}),
L.Polyline.Plotter = function(e, t) {
  return new L.Polyline.plotter(e,t)
}
,
geofs.configuration = {
  google: {
      physics: {
          degradedCollisions: [!0, !0, !0, !0, !0, !0, !0, !0]
      }
  },
  defaults: {
      screenSpacePresets: {
          maximumScreenSpaceError: [10, 6, 4, 2, 2, 2, 2, 1],
          fogScreenSpaceErrorFactor: [2, 2, 2, 2, 1.8, 1.7, 1.5, 1],
          fogDensity: [5e-4, 32e-5, 3e-4, 25e-5, 2e-4, 15e-5, 1e-4, 5e-5],
          google: {
              dynamicScreenSpaceErrorDensity: [1, 1, 1, .1, .01, .001, 1e-4, 1e-5],
              dynamicScreenSpaceErrorFactor: [32, 32, 24, 24, 24, 24, 24, 24],
              maximumScreenSpaceError: [256, 128, 64, 48, 32, 24, 20, 12]
          }
      },
      physics: {
          deltaMs: [20, 20, 20, 10, 10, 10, 10, 10],
          degradedCollisions: [!0, !0, !0, !0, !1, !1, !1, !1]
      },
      renderingQualityLevels: {
          0: {
              resolutionScale: .7,
              tileCacheSize: 0,
              fxaa: !1,
              msaaSamples: 1,
              globeLighting: !1,
              dropShadow: !1,
              cloudCoverToCloudNumber: 15,
              scatteringQuality: 0,
              shadowMapSize: 1024,
              shadowDistance: 1e3,
              viewingDistance: 0,
              degradedCollisions: !1,
              lowResRunways: !1
          },
          1: {
              resolutionScale: .8,
              tileCacheSize: 100,
              fxaa: !1,
              msaaSamples: 1,
              globeLighting: !0,
              dropShadow: !1,
              cloudCoverToCloudNumber: 1,
              scatteringQuality: 0,
              shadowMapSize: 1024,
              shadowDistance: 1e3,
              viewingDistance: 1,
              degradedCollisions: !0,
              lowResRunways: !0
          },
          2: {
              resolutionScale: .9,
              tileCacheSize: 150,
              fxaa: !0,
              msaaSamples: 1,
              globeLighting: !0,
              dropShadow: !1,
              cloudCoverToCloudNumber: 5,
              scatteringQuality: 1,
              shadowMapSize: 1024,
              shadowDistance: 1e3,
              viewingDistance: 2,
              degradedCollisions: !0,
              lowResRunways: !0
          },
          3: {
              resolutionScale: 1,
              tileCacheSize: 250,
              fxaa: !0,
              msaaSamples: 1,
              globeLighting: !0,
              dropShadow: !0,
              cloudCoverToCloudNumber: 10,
              scatteringQuality: 2,
              shadowMapSize: 1024,
              shadowDistance: 1e3,
              viewingDistance: 3,
              degradedCollisions: !0,
              lowResRunways: !0
          },
          4: {
              resolutionScale: 1,
              tileCacheSize: 500,
              fxaa: !0,
              msaaSamples: 1,
              globeLighting: !0,
              dropShadow: !0,
              cloudCoverToCloudNumber: 12,
              scatteringQuality: 3,
              shadowMapSize: 2048,
              shadowDistance: 2e3,
              viewingDistance: 4,
              degradedCollisions: !1,
              lowResRunways: !1
          },
          5: {
              resolutionScale: 1,
              tileCacheSize: 1e3,
              fxaa: !0,
              msaaSamples: 1,
              globeLighting: !0,
              dropShadow: !0,
              cloudCoverToCloudNumber: 14,
              scatteringQuality: 4,
              shadowMapSize: 2048,
              shadowDistance: 2e3,
              viewingDistance: 5,
              degradedCollisions: !1,
              lowResRunways: !1
          },
          6: {
              resolutionScale: 1,
              tileCacheSize: 2e3,
              fxaa: !0,
              msaaSamples: 1,
              globeLighting: !0,
              dropShadow: !0,
              cloudCoverToCloudNumber: 15,
              scatteringQuality: 5,
              shadowMapSize: 2048,
              shadowDistance: 3e3,
              viewingDistance: 6,
              degradedCollisions: !1,
              lowResRunways: !1
          }
      },
      qualityToBuildingTexture: {
          1: "low",
          2: "low",
          3: "low",
          4: "med",
          5: "med",
          6: "high",
          7: "high"
      }
  },
  applyConfiguration: function(e) {
      geofs.configuration.current = $.extend(!0, {}, geofs.configuration.defaults, e || {})
  }
},
geofs.configuration.applyConfiguration(),
window.geofs = window.geofs || {};
const GRAVITY = 9.81
, DEGREES_TO_RAD = Math.PI / 180
, RAD_TO_DEGREES = 180 / Math.PI
, KMH_TO_MS = 1 / 3.6
, METERS_TO_FEET = 3.2808399
, METERS_TO_NM = 539957e-9
, FEET_TO_METERS = .3048
, LONGITUDE_TO_HOURS = .0666
, EPSILON = 1e-7
, ONE_MINUS_EPSILON = 1 - EPSILON
, MERIDIONAL_RADIUS = 6378137
, EARTH_CIRCUMFERENCE = 2 * MERIDIONAL_RADIUS * Math.PI
, METERS_TO_LOCAL_LAT = 1 / (EARTH_CIRCUMFERENCE / 360)
, STANDARD_GLIDE_ANGLE = 3
, GLIDE_SLOPE = .052359
, PI = Math.PI
, HALF_PI = PI / 2
, TWO_PI = 2 * PI
, ONE_OVER_TWO_PI = 1 / TWO_PI
, ONE_OVER_PI = 1 / PI
, MS_TO_FEETMINUTE = 196.85
, MS_TO_KNOTS = 1.94384449
, KNOTS_TO_MS = .514444444
, KMH_TO_KNOTS = .539956803
, AXIS_TO_INDEX = {
  X: 0,
  Y: 1,
  Z: 2
}
, AXIS_TO_VECTOR = {
  X: [1, 0, 0],
  Y: [0, 1, 0],
  Z: [0, 0, 1]
}
, KELVIN_OFFSET = 273.15
, TEMPERATURE_LAPSE_RATE = .0065
, ZUPAxis = {
  X: "X",
  Y: "Y",
  Z: "Z"
}
, YUPAxis = {
  X: "X",
  Y: "Z",
  Z: "Y"
}
, AIR_DENSITY_SL = 1.22
, AIR_PRESSURE_SL = 101325
, AIR_TEMP_SL = 15
, DRAG_CONSTANT = .07
, MIN_DRAG_COEF = .02
, PLANFORM_EFFICIENCY_FACTOR = .7
, TOTAL_DRAG_CONSTANT = DRAG_CONSTANT + MIN_DRAG_COEF
, IDEAL_GAS_CONSTANT = 8.31447
, MOLAR_MASS_DRY_AIR = .0289644
, GAS_CONSTANT = IDEAL_GAS_CONSTANT / MOLAR_MASS_DRY_AIR
, GM_RL = GRAVITY * MOLAR_MASS_DRY_AIR / (IDEAL_GAS_CONSTANT * TEMPERATURE_LAPSE_RATE)
, DEFAULT_AIRFOIL_ASPECT_RATIO = 7
, WATER_DENSITY = 997
, FOV = 60
, VIEWPORT_REFERENCE_WIDTH = 1800
, VIEWPORT_REFERENCE_HEIGHT = 800
, SMOOTH_BUFFER = {}
, SMOOTHING_FACTOR = .2
, SIX_STEP_WARNING = ["#18a400", "#2b9100", "#487300", "#835b00", "#933700", "#a71500"];
var SHADOWS_NONE = 0
, SHADOWS_ALL = 1
, SHADOWS_CAST = 2
, SHADOWS_RECEIVE = 3;
const V2 = {
  add: function(e, t) {
      return [e[0] + t[0], e[1] + t[1]]
  },
  sub: function(e, t) {
      return [e[0] - t[0], e[1] - t[1]]
  },
  length: function(e) {
      return Math.sqrt(e[0] * e[0] + e[1] * e[1])
  },
  fastLengthApprox: function(e) {
      var t = e[0]
        , a = e[1];
      return Math.max(t, a) + Math.min(t, a) / 2
  },
  scale: function(e, t) {
      return [e[0] * t, e[1] * t]
  },
  parseInt: function(e) {
      return [parseInt(e[0]), parseInt(e[1])]
  },
  round: function(e) {
      return [Math.round(e[0]), Math.round(e[1])]
  },
  div: function(e, t) {
      return [e[0] / t[0], e[1] / t[1]]
  }
}
, V3 = {
  isValid: function(e) {
      if (!e)
          return !1;
      for (var t = 0; t <= 2; t++)
          if (null === e[t] || isNaN(e[t]))
              return !1;
      return !0
  },
  dup: function(e) {
      return [e[0], e[1], e[2]]
  },
  toString: function(e) {
      return "[" + e[0] + ", " + e[1] + ", " + e[2] + "]"
  },
  nearlyEqual: function(e, t, a) {
      return a || (a = 1e-6),
      Math.abs(e[0] - t[0]) <= a && Math.abs(e[1] - t[1]) <= a && Math.abs(e[2] - t[2]) <= a
  },
  abs: function(e) {
      return [Math.abs(e[0]), Math.abs(e[1]), Math.abs(e[2])]
  },
  cross: function(e, t) {
      var a = e[0]
        , o = e[1]
        , r = e[2]
        , n = t[0]
        , s = t[1]
        , c = t[2];
      return [o * c - r * s, r * n - a * c, a * s - o * n]
  },
  dot: function(e, t) {
      return e[0] * t[0] + e[1] * t[1] + e[2] * t[2]
  },
  add: function(e, t) {
      return [e[0] + t[0], e[1] + t[1], e[2] + t[2]]
  },
  addAngles: function(e, t) {
      return [fixAngle(e[0] + t[0]), fixAngle(e[1] + t[1]), fixAngle(e[2] + t[2])]
  },
  sub: function(e, t) {
      return [e[0] - t[0], e[1] - t[1], e[2] - t[2]]
  },
  mult: function(e, t) {
      return [e[0] * t[0], e[1] * t[1], e[2] * t[2]]
  },
  scale: function(e, t) {
      return [e[0] * t, e[1] * t, e[2] * t]
  },
  length: function(e) {
      return Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2])
  },
  normalize: function(e) {
      var t = V3.length(e);
      return t <= 0 ? [NaN, NaN, NaN] : V3.scale(e, 1 / t)
  },
  bisect: function(e, t) {
      return [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2, (e[2] + t[2]) / 2]
  },
  rotate: function(e, t, a) {
      var o = V3.dot(e, t)
        , r = V3.sub(e, V3.scale(t, o))
        , n = V3.cross(t, r);
      return V3.add(V3.scale(t, o), V3.add(V3.scale(r, Math.cos(a)), V3.scale(n, Math.sin(a))))
  },
  toRadians: function(e) {
      return [e[0] * DEGREES_TO_RAD, e[1] * DEGREES_TO_RAD, e[2] * DEGREES_TO_RAD]
  },
  toDegrees: function(e) {
      return [e[0] * RAD_TO_DEGREES, e[1] * RAD_TO_DEGREES, e[2] * RAD_TO_DEGREES]
  },
  clamp: function(e, t, a) {
      return [clamp(e[0], t, a), clamp(e[1], t, a), clamp(e[2], t, a)]
  },
  span: function(e, t, a) {
      return [span(e[0], t, a), span(e[1], t, a), span(e[2], t, a)]
  },
  exponentialSmoothing: function(e, t, a, o) {
      return [exponentialSmoothing(e + "0", t[0], a, o), exponentialSmoothing(e + "1", t[1], a, o), exponentialSmoothing(e + "2", t[2], a, o)]
  },
  sqrt: function(e) {
      return [Math.sqrt(Math.abs(e[0])) * Math.sign(e[0]), Math.sqrt(Math.abs(e[1])) * Math.sign(e[1]), Math.sqrt(Math.abs(e[2])) * Math.sign(e[2]), ]
  }
}
, M33 = {
  toString: function(e) {
      return "[" + V3.toString(e[0]) + ", " + V3.toString(e[1]) + ", " + V3.toString(e[2]) + "]"
  },
  toM4: function(e) {
      return [e[0][0], e[0][1], e[0][2], 0, e[1][0], e[1][1], e[1][2], 0, e[2][0], e[2][1], e[2][2], 0, 0, 0, 0, 0]
  },
  toArray: function(e) {
      return [e[0][0], e[0][1], e[0][2], e[1][0], e[1][1], e[1][2], e[2][0], e[2][1], e[2][2]]
  },
  toRowMajorArray: function(e) {
      return [e[0][0], e[1][0], e[2][0], e[0][1], e[1][1], e[2][1], e[0][2], e[1][2], e[2][2]]
  },
  fromColumnMajorArray: function(e) {
      return [[e[0], e[3], e[6]], [e[1], e[4], e[7]], [e[2], e[5], e[8]]]
  },
  fromRowMajorArray: function(e) {
      return [[e[0], e[1], e[2]], [e[3], e[4], e[5]], [e[6], e[7], e[8]]]
  },
  identity: function() {
      return [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
  },
  dup: function(e) {
      return [V3.dup(e[0]), V3.dup(e[1]), V3.dup(e[2])]
  },
  nearlyEqual: function(e, t) {
      return V3.nearlyEqual(e[0], t[0]) && V3.nearlyEqual(e[1], t[1]) && V3.nearlyEqual(e[2], t[2])
  },
  transpose: function(e) {
      return [[e[0][0], e[1][0], e[2][0]], [e[0][1], e[1][1], e[2][1]], [e[0][2], e[1][2], e[2][2]]]
  },
  add: function(e, t) {
      return [V3.add(e[0], t[0]), V3.add(e[1], t[1]), V3.add(e[2], t[2])]
  },
  multiplyV: function(e, t) {
      var a = t[0]
        , o = t[1]
        , r = t[2]
        , n = e[0]
        , s = e[1]
        , c = e[2];
      return [n[0] * a + n[1] * o + n[2] * r, s[0] * a + s[1] * o + s[2] * r, c[0] * a + c[1] * o + c[2] * r]
  },
  multiply: function(e, t) {
      var a = e[0][0]
        , o = e[0][1]
        , r = e[0][2]
        , n = e[1][0]
        , s = e[1][1]
        , c = e[1][2]
        , d = e[2][0]
        , u = e[2][1]
        , p = e[2][2]
        , h = t[0][0]
        , m = t[0][1]
        , f = t[0][2]
        , g = t[1][0]
        , y = t[1][1]
        , v = t[1][2]
        , _ = t[2][0]
        , b = t[2][1]
        , x = t[2][2];
      return [[a * h + n * m + d * f, o * h + s * m + u * f, r * h + c * m + p * f], [a * g + n * y + d * v, o * g + s * y + u * v, r * g + c * y + p * v], [a * _ + n * b + d * x, o * _ + s * b + u * x, r * _ + c * b + p * x]]
  },
  scaled: function(e, t) {
      return [[e[0][0] * t[0], e[0][1] * t[1], e[0][2] * t[2]], [e[1][0] * t[0], e[1][1] * t[1], e[1][2] * t[2]], [e[2][0] * t[0], e[2][1] * t[1], e[2][2] * t[2]]]
  },
  transform: function(e, t) {
      var a = e[0]
        , o = e[1]
        , r = e[2]
        , n = t[0]
        , s = t[1]
        , c = t[2];
      return [a[0] * n + o[0] * s + r[0] * c, a[1] * n + o[1] * s + r[1] * c, a[2] * n + o[2] * s + r[2] * c]
  },
  rotationXYZ: function(e, t) {
      var a = M33.setFromEuler(t);
      return M33.multiply(e, a)
  },
  rotationX: function(e, t) {
      var a = Math.cos(t)
        , o = Math.sin(t);
      return M33.multiply(e, [[1, 0, 0], [0, a, -o], [0, o, a]])
  },
  rotationY: function(e, t) {
      var a = Math.cos(t)
        , o = Math.sin(t);
      return M33.multiply(e, [[a, 0, o], [0, 1, 0], [-o, 0, a]])
  },
  rotationZ: function(e, t) {
      var a = Math.cos(t)
        , o = Math.sin(t);
      return M33.multiply(e, [[a, -o, 0], [o, a, 0], [0, 0, 1]])
  },
  rotationParentFrameX: function(e, t) {
      var a = Math.cos(t)
        , o = Math.sin(t);
      return M33.multiply([[1, 0, 0], [0, a, -o], [0, o, a]], e)
  },
  rotationParentFrameY: function(e, t) {
      var a = Math.cos(t)
        , o = Math.sin(t);
      return M33.multiply([[a, 0, o], [0, 1, 0], [-o, 0, a]], e)
  },
  rotationParentFrameZ: function(e, t) {
      var a = Math.cos(t)
        , o = Math.sin(t);
      return M33.multiply([[a, -o, 0], [o, a, 0], [0, 0, 1]], e)
  },
  rotate: function(e, t, a) {
      var o = t[0]
        , r = t[1]
        , n = t[2]
        , s = Math.cos(a)
        , c = 1 - s
        , d = Math.sin(a);
      return M33.multiply(e, [[o * o * c + s, r * o * c + n * d, n * o * c - r * d], [o * r * c - n * d, r * r * c + s, r * n * c + o * d], [o * n * c + r * d, r * n * c - o * d, n * n * c + s]])
  },
  transformByTranspose: function(e, t) {
      return [e[0][0] * t[0] + e[0][1] * t[1] + e[0][2] * t[2], e[1][0] * t[0] + e[1][1] * t[1] + e[1][2] * t[2], e[2][0] * t[0] + e[2][1] * t[1] + e[2][2] * t[2]]
  },
  makeOrthonormalFrame: function(e, t) {
      var a = V3.normalize(e)
        , o = V3.normalize(V3.cross(t, a))
        , r = V3.cross(o, a);
      return [o, a, r]
  },
  setFromEuler: function(e) {
      var t = Math.cos(e[0])
        , a = Math.sin(e[0])
        , o = Math.cos(e[1])
        , r = Math.sin(e[1])
        , n = Math.cos(e[2])
        , s = Math.sin(e[2]);
      return [[n * o + s * a * r, -s * o + n * a * r, t * r], [s * t, n * t, -a], [-(n * r) + s * a * o, -(-s * r) + n * a * o, t * o]]
  },
  getOrientation: function(e) {
      if (e[1][2] > .998)
          t = Math.atan2(-e[2][0], -e[2][1]),
          a = -HALF_PI,
          o = 0;
      else if (e[1][2] < -.998)
          t = Math.atan2(e[2][0], e[2][1]),
          a = HALF_PI,
          o = 0;
      else
          var t, a, o, t = Math.atan2(e[1][0], e[1][1]), a = Math.asin(-e[1][2]), o = Math.atan2(e[0][2], e[2][2]);
      return [t * RAD_TO_DEGREES, a * RAD_TO_DEGREES, o * RAD_TO_DEGREES]
  },
  toMatrix: function(e) {
      return e
  },
  toYup: function(e) {
      let t = e[1]
        , a = e[2];
      e[2] = [t[0], t[1], t[2]],
      e[1] = [a[0], a[1], a[2]];
      let o = [e[0][1], e[1][1], e[2][1]]
        , r = [e[0][2], e[1][2], e[2][2]];
      return e[0][1] = r[0],
      e[1][1] = r[1],
      e[2][1] = r[2],
      e[0][2] = o[0],
      e[1][2] = o[1],
      e[2][2] = o[2],
      e
  }
};
M33.toEuler = M33.getOrientation;
const M3 = {
  identity: function() {
      return [0, 0, 0, 0, 0, 0, 0, 0, 0]
  },
  sub: function(e, t) {
      for (var a = [], o = 0; o < 9; o++)
          a[o] = e[o] - t[o];
      return a
  },
  add: function(e, t) {
      for (var a = [], o = 0; o < 9; o++)
          a[o] = e[o] + t[o];
      return a
  },
  dup: function(e) {
      return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]]
  },
  scale: function(e, t) {
      for (var a = [], o = 0; o < 9; o++)
          a[o] = e[o] * t;
      return a
  },
  toM33: function(e) {
      return [[e[0], e[1], e[2]], [e[3], e[4], e[5]], [e[6], e[7], e[8]]]
  },
  snapToUnit: function(e) {
      for (var t = 0; t < 9; t++)
          e[t] < EPSILON && (e[t] = 0),
          e[t] > ONE_MINUS_EPSILON && (e[t] = 1);
      return e
  }
}
, M4 = {
  fromRowMajorArray: function(e) {
      return [[e[0], e[1], e[2], e[4]], [e[5], e[6], e[7], e[8]], [e[9], e[10], e[11], e[12]], [e[13], e[14], e[15], e[16]]]
  },
  fromColumnMajorArray: function(e) {
      return [[e[0], e[4], e[8], e[12]], [e[1], e[5], e[9], e[13]], [e[2], e[6], e[10], e[14]], [e[3], e[7], e[11], e[15]]]
  }
};
var SMALL_NUM = 1e-8;
function intersect_RayTriangle(e, t) {
  if (o = t.u,
  r = t.v,
  n = t.n,
  s = V3.sub(e[1], e[0]),
  c = V3.sub(e[0], t[0]),
  p = -V3.dot(n, c),
  Math.abs(h = V3.dot(n, s)) < SMALL_NUM)
      return null;
  if ((u = p / h) < 0 || u > 1)
      return null;
  var a, o, r, n, s, c, d, u, p, h, m, f, g, y, v, _, b, x, S = V3.scale(s, u);
  return (a = V3.add(e[0], S),
  m = V3.dot(o, o),
  f = V3.dot(o, r),
  g = V3.dot(r, r),
  d = V3.sub(a, t[0]),
  y = V3.dot(d, o),
  v = V3.dot(d, r),
  _ = f * f - m * g,
  (b = (f * v - g * y) / _) < 0 || b > 1 || (x = (f * y - m * v) / _) < 0 || b + x > 1) ? null : {
      point: a
  }
}
const S2 = {
  identity: function() {
      return {
          x: 1,
          y: 1
      }
  },
  mult: function(e, t) {
      return {
          x: e.x * t.x,
          y: e.y * t.y
      }
  },
  add: function(e, t) {
      return {
          x: e.x + t.x,
          y: e.y + t.y
      }
  },
  scale: function(e, t) {
      return {
          x: e.x * t,
          y: e.y * t
      }
  }
};
Math.sign = function(e) {
  return e < 0 ? -1 : 1
}
,
Math.maxAbsValue = function(e, t) {
  return Math.abs(e) > Math.abs(t) ? e : t
}
,
Math.arrayToPrecision = function(e, t) {
  for (var a = e.length; a >= 0; a--)
      e[a] && e[a].toFixed && (e[a] = parseFloat(e[a].toFixed(t)));
  return e
}
,
Math.parity = function(e) {
  return e % 2 == 0
}
;
var Object3D = function(e) {
  e = e || {},
  this._name = e.name,
  this._nodeName = e.node,
  this._children = [],
  e["3dmodel"] && this.setModel(e["3dmodel"]),
  this.setLight(e),
  this._points = e.points || {},
  this._collisionPoints = e.collisionPoints || [];
  var t = this._points;
  for (var a in t)
      t[a].worldPosition = [0, 0, 0];
  var t = this._collisionPoints;
  for (var a in t)
      t[a].worldPosition = [0, 0, 0];
  this.setInitialRotation(e.rotation),
  e.modelOnlyRotation && this.setModelOnlyRotation(e.modelOnlyRotation),
  this.setInitialPosition(e.position),
  this.setInitialScale(e.scale),
  this.setScale(e.scale),
  this.visible = !0,
  this._options = Object.assign({}, e)
};
function absMin(e, t) {
  return (asbA = Math.abs(e)) < (asbB = Math.abs(t)) ? e : t
}
function span(e, t, a) {
  return void 0 == t || void 0 == a ? e : e > t && e < a ? e - t > a - e ? t : a : e
}
function boundHours24(e) {
  var t = e % 24;
  return t < 0 && (t = 24 + t),
  t
}
function fixAngle(e) {
  return fixAngle360(e + 180) - 180
}
function fixAngle360(e) {
  return (e %= 360) >= 0 ? e : e + 360
}
function fixAngles360(e) {
  for (var t = e.length - 1; t >= 0; t--)
      e[t] = fixAngle(e[t]);
  return e
}
function fixAngles(e) {
  for (var t = e.length - 1; t >= 0; t--)
      e[t] = fixAngle(e[t]);
  return e
}
function exponentialSmoothing(e, t, a, o, r) {
  SMOOTH_BUFFER[e] || (SMOOTH_BUFFER[e] = {
      Stm1: o || 0,
      Xtm1: o || 0
  },
  a ? (SMOOTH_BUFFER[e].smoothingFactor = a,
  SMOOTH_BUFFER[e].invSmoothingFactor = 1 - a) : (SMOOTH_BUFFER[e].smoothingFactor = SMOOTHING_FACTOR,
  SMOOTH_BUFFER[e].invSmoothingFactor = 1 - SMOOTHING_FACTOR));
  var n = SMOOTH_BUFFER[e];
  void 0 != r && a && (n.smoothingFactor = a * r,
  n.invSmoothingFactor = 1 - n.smoothingFactor);
  var s = n.Xtm1 * n.smoothingFactor + n.invSmoothingFactor * n.Stm1;
  return n.Stm1 = s,
  n.Xtm1 = t,
  s
}
function getBuildingCollision(e) {
  return null
}
function xyz2lla(e, t) {
  return geofs.api.xyz2lla(e, t)
}
function xy2ll(e, t) {
  var a = [];
  a[0] = e[1] * METERS_TO_LOCAL_LAT;
  var o = Math.cos((t[0] + a[0]) * DEGREES_TO_RAD) * MERIDIONAL_RADIUS * DEGREES_TO_RAD;
  return a[1] = e[0] / o,
  a
}
function lla2xyz(e, t) {
  var a = ll2xy(e, t);
  return a[2] = e[2],
  a
}
function ll2xy(e, t) {
  var a = [];
  a[1] = e[0] / METERS_TO_LOCAL_LAT;
  var o = 1 / (Math.cos((t[0] + e[0]) * DEGREES_TO_RAD) * MERIDIONAL_RADIUS * DEGREES_TO_RAD);
  return a[0] = e[1] / o,
  a
}
function clamp(e, t, a) {
  return e > a ? a : e < t ? t : e
}
function snapToUnit(e) {
  return e < EPSILON ? 0 : e > ONE_MINUS_EPSILON ? 1 : e
}
function geoDecodeLocation(e, t) {
  if (e) {
      if ((e += "").toUpperCase() == e && e.length <= 4 && e.length >= 2) {
          let a = geofs.mainAirportList[e.toUpperCase()];
          if (a)
              return t(a[0], a[1])
      }
      try {
          let o = new Coordinates(e);
          return t(o.getLatitude(), o.getLongitude())
      } catch (r) {
          geofs.api.reverserGeocode(e, t)
      }
  }
}
function lookAt(e, t, a) {
  return geofs.utils.lookAt(e, t, a)
}
function getURLParameters() {
  var e = {};
  if (window.location.search) {
      var t = window.location.search.substring(1, window.location.search.length);
      t = t.split("&");
      for (var a = 0; a < t.length; a++) {
          var o = t[a].split("=");
          e[o[0]] = o[1]
      }
  }
  return e
}
function clone(e) {
  var t;
  if ("object" == typeof e) {
      if (geofs.isArray(e)) {
          t = [];
          for (var a = 0; a < e.length; a++)
              t[a] = clone(e[a])
      } else
          for (var a in t = {},
          e)
              t[a] = clone(e[a])
  } else
      t = e;
  return t
}
Object3D.prototype = {
  reset: function() {
      this.setInitialPosition(this._options.position),
      this.worldRotation = this._rotation,
      this.worldPosition = this._position,
      this.worldScale = this._scale
  },
  setInitialRotation: function(e) {
      this._initialRotation = M33.identity(),
      this._initialRotation = M33.rotationXYZ(this._initialRotation, e || [0, 0, 0]),
      this._rotation = M33.dup(this._initialRotation)
  },
  setModelOnlyRotation: function(e) {
      this._modeOnlyRotation = M33.identity(),
      this._modeOnlyRotation = M33.rotationXYZ(this._modeOnlyRotation, e || [0, 0, 0])
  },
  rotateInitialRotation: function(e) {
      this._initialRotation = M33.rotationXYZ(this._initialRotation, e || [0, 0, 0]),
      this._rotation = M33.dup(this._initialRotation)
  },
  rotate: function(e) {
      this._rotation = M33.rotationXYZ(this._rotation, e)
  },
  rotateX: function(e) {
      this._rotation = M33.rotationX(this._rotation, e)
  },
  rotateY: function(e) {
      this._rotation = M33.rotationY(this._rotation, e)
  },
  rotateZ: function(e) {
      this._rotation = M33.rotationZ(this._rotation, e)
  },
  setRotationX: function(e) {
      this._rotation = M33.rotationX(this._initialRotation, e)
  },
  setRotationY: function(e) {
      this._rotation = M33.rotationY(this._initialRotation, e)
  },
  setRotationZ: function(e) {
      this._rotation = M33.rotationZ(this._initialRotation, e)
  },
  rotateParentFrameX: function(e) {
      this._rotation = M33.rotationParentFrameX(this._rotation, e)
  },
  rotateParentFrameY: function(e) {
      this._rotation = M33.rotationParentFrameY(this._rotation, e)
  },
  rotateParentFrameZ: function(e) {
      this._rotation = M33.rotationParentFrameZ(this._rotation, e)
  },
  getRotation: function() {
      return this._rotation
  },
  setInitialPosition: function(e) {
      this._nodeName && (this._nodeOrigin = e,
      e = [0, 0, 0]),
      e = e || [0, 0, 0],
      this._initialPosition = V3.dup(e),
      this._position = V3.dup(this._initialPosition)
  },
  setInitialScale: function(e) {
      (e = e || 1).length || (e = [e, e, e]),
      this._initialScale = e
  },
  scale: function(e, t) {
      (e = e || 1).length || (e = [e, e, e]),
      this._scale = V3.mult(this._initialScale, e),
      t && this.propagateToTree("scale", [e, t])
  },
  setPosition: function(e) {
      this._position = e
  },
  translate: function(e) {
      this._position = V3.add(this._position, e)
  },
  setTranslation: function(e) {
      this._position = V3.add(this._initialPosition, e)
  },
  setScale: function(e, t) {
      (e = e || 1).length || (e = [e, e, e]),
      this._scale = e,
      t && this.propagateToTree("setScale", [e, t])
  },
  getScale: function() {
      return this._scale
  },
  setOpacity: function(e) {
      e = e || 1,
      this.model.setOpacity(e)
  },
  setScaleOffset: function(e, t) {
      this._scaleOffset = e,
      t && this.propagateToTree("setScaleOffset", [e, t])
  },
  getPosition: function() {
      return this._position
  },
  getLocalPosition: function() {
      var e = this._position;
      return this._parent && (e = V3.add(e, this._parent.getLocalPosition())),
      e
  },
  resetAnimatedTransform: function() {
      this._rotation = M33.dup(this._initialRotation),
      this._position = V3.dup(this._initialPosition)
  },
  resetRotationMatrix: function() {
      if (this.htr) {
          var e = V3.toRadians(this.htr);
          this.setInitialRotation([e[1], e[2], e[0]])
      }
  },
  setPoint: function(e, t) {
      this._points[e] = t,
      this.setVectorWorldPosition(this._points[e])
  },
  setVectorWorldPosition: function(e) {
      return e.worldPosition = M33.transform(this.worldRotation, e),
      e.worldPosition = V3.add(this.worldPosition, e.worldPosition),
      e.worldPosition = V3.mult(e.worldPosition, this.worldScale),
      e.worldPosition
  },
  compute: function(e) {
      if (geofs.debugOn && $(".debugBreakOnPartName")[0].checked && $(".debugPartName").val() == this._name,
      this._parent) {
          this.worldRotation = M33.multiply(this._parent.worldRotation, this._rotation);
          var t, a = this._position;
          this._nodeName && (this._nodeOrigin = this.getNodePosition(),
          this._nodeOrigin && (a = V3.add(this._position, this._nodeOrigin))),
          this.worldPosition = M33.transform(this._parent.worldRotation, a),
          this.worldPosition = V3.add(this.worldPosition, this._parent.worldPosition),
          this.worldScale = V3.mult(this._scale, this._parent.worldScale)
      } else
          this.worldRotation = this._initialRotation,
          this.worldPosition = M33.transform(this._initialRotation, this._position),
          this.worldScale = this._initialScale;
      var o = this._points;
      for (var r in o)
          this.setVectorWorldPosition(o[r]);
      for (var o = this._collisionPoints, r = 0, n = o.length; r < n; r++)
          this.setVectorWorldPosition(o[r]);
      if (!this._nodeName && (t = this._scaleOffset ? V3.scale(this.worldPosition, this._scaleOffset) : this.worldPosition,
      this.model || "root" == this._name)) {
          let s = this.worldRotation;
          this._modeOnlyRotation && (s = M33.multiply(s, this._modeOnlyRotation)),
          this.htr = M33.toEuler(s),
          this.lla = V3.add(e, xyz2lla(t, e))
      }
      this.propagateToTree("compute", [e])
  },
  render: function(e) {
      var t;
      if (t = this._scaleOffset ? V3.scale(this.worldPosition, this._scaleOffset) : this.worldPosition,
      this.visible) {
          if (this.model) {
              if (this._nodeName) {
                  var a = this.getNode();
                  a && geofs.api.setNodeRotationTranslationScale(a, this.getRotation(), this.getPosition(), this.getScale(), this.model.forceZup)
              } else
                  this.model.setPositionOrientationAndScale(this.lla, this.htr, this._scale, this)
          }
          this._light && (this.lla = V3.add(e, xyz2lla(t, e)),
          this._light && this._light.setLocation(this.lla))
      }
      this.propagateToTree("render", [e])
  },
  setModel: function(e) {
      this.model = e
  },
  getModel: function(e) {
      return this.model
  },
  getNode: function() {
      return this._node || (this._node = this.model.getNode(this._nodeName)),
      this._node
  },
  getNodePosition: function() {
      var e = this.getNode();
      return this._nodeOrigin ? this._nodeOrigin : e ? (this._nodeOrigin = geofs.api.getNodePosition(e, this.model.forceZup),
      this._nodeOrigin) : null
  },
  getNodeRotation: function() {
      var e = this.getNode();
      return e ? geofs.api.getNodeRotation(e) : M33.identity()
  },
  setLight: function(e) {
      e.lightBillboard && (this._light = e.lightBillboard)
  },
  getWorldFrame: function() {
      return this.worldRotation
  },
  getWorldPosition: function() {
      return this.worldPosition
  },
  getLlaLocation: function() {
      return this.lla
  },
  addChild: function(e) {
      e._parent = this,
      this._children.push(e)
  },
  setVisibility: function(e, t) {
      var a = !0;
      if (e && !t)
          for (var o = this._parent; o && "root" != o._options.type; )
              a = a && o.visible,
              o = o._parent;
      var r = !0;
      a && (this.model && (r = this._nodeName ? this.model.setNodeVisibilityByName(this._nodeName, e) : this.model.setVisibility(e)),
      this._light && (r = this._light.setVisibility(e)),
      this.propagateToTree("setVisibility", [e, !0])),
      r && (this.visible = e)
  },
  findModelInAncestry: function() {
      for (var e = this; e; ) {
          var t = e.getModel();
          if (t)
              return t;
          e = e.getParent()
      }
  },
  getParent: function() {
      return this._parent
  },
  propagateToTree: function(e, t) {
      for (var a = this._children, o = 0, r = a.length; o < r; o++) {
          var n = a[o];
          n[e].apply(n, t)
      }
  },
  destroy: function() {
      this._node = null,
      this.model && !this.model.detroyed && (this.model.destroy(),
      this.model = null)
  }
},
Object3D.utilities = {
  getPointLla: function(e, t) {
      return e.lla ? e.lla : e.worldPosition ? V3.add(t, xyz2lla(e.worldPosition, t)) : e
  }
},
window.geofs = window.geofs || {},
geofs.trees = {
  qualityLevels: {
      1: {
          10: {
              range: 1,
              altitude: 1e3
          }
      },
      2: {
          10: {
              range: 1,
              altitude: 2e3
          },
          11: {
              range: 1,
              altitude: 1e3
          }
      },
      3: {
          10: {
              range: 1,
              altitude: 3e3
          },
          11: {
              range: 1,
              altitude: 2e3
          },
          12: {
              range: 1,
              altitude: 1e3
          }
      },
      4: {
          10: {
              range: 1,
              altitude: 4e3
          },
          11: {
              range: 1,
              altitude: 3e3
          },
          12: {
              range: 2,
              altitude: 2e3
          }
      },
      5: {
          10: {
              range: 1,
              altitude: 5e3
          },
          11: {
              range: 1,
              altitude: 4e3
          },
          12: {
              range: 2,
              altitude: 3e3
          }
      },
      6: {
          10: {
              range: 2,
              altitude: 6e3
          },
          11: {
              range: 2,
              altitude: 5e3
          },
          12: {
              range: 2,
              altitude: 4e3
          }
      },
      7: {
          10: {
              range: 2,
              altitude: 7e3
          },
          11: {
              range: 2,
              altitude: 6e3
          },
          12: {
              range: 3,
              altitude: 5e3
          }
      }
  },
  init: function() {
      if (this.simple3DTileProvider)
          return;
      geofs.trees.shader = new Cesium.CustomShader({
          uniforms: {
              u_treeTexture: {
                  value: new Cesium.TextureUniform({
                      url: this.makeTextureURL(),
                      minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR
                  }),
                  type: Cesium.UniformType.SAMPLER_2D
              }
          },
          varyings: {},
          mode: Cesium.CustomShaderMode.REPLACE_MATERIAL,
          lightingModel: Cesium.LightingModel.UNLIT,
          translucencyMode: Cesium.CustomShaderTranslucencyMode.OPAQUE,
          vertexShaderText: "void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput) {}",
          fragmentShaderText: geofsShaders["treesFS.glsl"]
      });
      let e = {
          tilingScheme: new Cesium.WebMercatorTilingScheme({
              numberOfLevelZeroTilesX: 1,
              numberOfLevelZeroTilesY: 1
          }),
          qualityLevels: geofs.trees.qualityLevels,
          url: geofs.treeServer,
          extension: geofs.treeServerExtension || ".glb",
          location: null,
          rotation: geofs.version >= 4 ? [0, 0, 0] : [90, 0, 0],
          customShader: geofs.trees.shader,
          experimental: !0,
          shadows: SHADOWS_ALL
      };
      this.simple3DTileProvider = new geofs.simple3DTileProvider(e),
      geofs.trees.seasonChangeHandlerSet = $("body").on("seasonChange", () => {
          geofs.trees.updateSeasonTextures(geofs.season)
      }
      ),
      geofs.trees.updateSeasonTextures(geofs.season)
  },
  makeTextureURL: function() {
      let e = geofs.season || "summer";
      return "winter" != e || weather.isSnowable || (e = "autumn"),
      "shaders/trees/" + e + ".png"
  },
  updateSeasonTextures: function() {
      geofs.trees.shader.setUniform("u_treeTexture", new Cesium.TextureUniform({
          url: this.makeTextureURL(),
          minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR
      }))
  },
  update: function(e) {
      this.simple3DTileProvider && this.simple3DTileProvider.update(e)
  },
  destroy: function() {
      this.simple3DTileProvider && (this.simple3DTileProvider.destroy(),
      this.simple3DTileProvider = null,
      geofs.trees.seasonChangeHandlerSet && (geofs.trees.seasonChangeHandlerSet.off(),
      geofs.trees.seasonChangeHandlerSet = null))
  }
},
geofs.buildings = {
  GLSLReflection: !0,
  qualityLevels: {
      1: {
          10: {
              range: 1,
              altitude: 1e4
          }
      },
      2: {
          10: {
              range: 2,
              altitude: 1e4
          },
          11: {
              range: 2,
              altitude: 8e3
          }
      },
      3: {
          10: {
              range: 3,
              altitude: 1e4
          },
          11: {
              range: 3,
              altitude: 8e3
          },
          12: {
              range: 3,
              altitude: 6e3
          }
      },
      4: {
          10: {
              range: 4,
              altitude: 1e4
          },
          11: {
              range: 4,
              altitude: 9e3
          },
          12: {
              range: 4,
              altitude: 8e3
          },
          13: {
              range: 4,
              altitude: 7e3
          }
      },
      5: {
          10: {
              range: 5,
              altitude: 12e3
          },
          11: {
              range: 5,
              altitude: 1e4
          },
          12: {
              range: 5,
              altitude: 9e3
          },
          13: {
              range: 5,
              altitude: 8e3
          }
      },
      6: {
          10: {
              range: 6,
              altitude: 15e3
          },
          11: {
              range: 6,
              altitude: 12e3
          },
          12: {
              range: 6,
              altitude: 1e4
          },
          13: {
              range: 6,
              altitude: 8e3
          }
      },
      7: {
          10: {
              range: 6,
              altitude: 15e3
          },
          11: {
              range: 6,
              altitude: 12e3
          },
          12: {
              range: 6,
              altitude: 1e4
          },
          13: {
              range: 6,
              altitude: 8e3
          }
      }
  },
  init: function() {
      let e = {
          u_retro: {
              value: !1,
              type: Cesium.UniformType.BOOL
          },
          u_buildingTexture: {
              value: new Cesium.TextureUniform({
                  url: this.makeTextureURL(),
                  minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR
              }),
              type: Cesium.UniformType.SAMPLER_2D
          },
          u_isSnowy: {
              value: geofs.isSnowy,
              type: Cesium.UniformType.BOOL
          },
          u_isNight: {
              value: geofs.isNight,
              type: Cesium.UniformType.BOOL
          }
      };
      geofs.buildings.GLSLReflection && (e.u_specularTexture = {
          value: new Cesium.TextureUniform({
              url: "shaders/buildings/specular-" + geofs.configuration.current.qualityToBuildingTexture[geofs.preferences.graphics.quality || geofs.preferences.graphics.advanced.viewingDistance || 0] + ".jpg",
              minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR
          }),
          type: Cesium.UniformType.SAMPLER_2D
      },
      e.u_environmentTexture = {
          value: new Cesium.TextureUniform({
              url: "shaders/reflection_city.jpg",
              minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR
          }),
          type: Cesium.UniformType.SAMPLER_2D
      }),
      geofs.buildings.buildingsShader = new Cesium.CustomShader({
          uniforms: e,
          varyings: {},
          mode: Cesium.CustomShaderMode.REPLACE_MATERIAL,
          lightingModel: Cesium.LightingModel.UNLIT,
          vertexShaderText: "void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput) {}",
          fragmentShaderText: (geofs.buildings.GLSLReflection ? "#define BUILDINGS_REFLECTION\n" : "") + geofsShaders["buildingsFS.glsl"]
      });
      let t = {
          tilingScheme: new Cesium.GeographicTilingScheme,
          qualityLevels: geofs.buildings.qualityLevels,
          extension: geofs.buildingServerExtension || ".glb",
          url: geofs.buildingServer,
          location: null,
          rotation: geofs.version >= 4 ? [0, 0, 0] : [90, 0, 0],
          customShader: geofs.buildings.buildingsShader,
          experimental: !0,
          shadows: SHADOWS_ALL
      };
      this.simple3DTileProvider = new geofs.simple3DTileProvider(t),
      geofs.buildings.seasonChangeHandler = $("body").on("seasonChange", () => {
          geofs.buildings.buildingsShader.setUniform("u_isSnowy", geofs.isSnowy),
          geofs.buildings.buildingsShader.setUniform("u_isNight", geofs.isNight),
          geofs.utils.executeOnceWithinTime(geofs.buildings.updateTextures, 1e3)
      }
      ),
      geofs.buildings.nightChangeHandler = $("body").on("nightChange", () => {
          geofs.buildings.buildingsShader.setUniform("u_isNight", geofs.isNight),
          geofs.utils.executeOnceWithinTime(geofs.buildings.updateTextures, 1e3)
      }
      ),
      geofs.buildings.qualityChangeHandler = $("body").on("qualityChange", () => {
          geofs.utils.executeOnceWithinTime(geofs.buildings.updateTextures, 1e3)
      }
      )
  },
  update: function(e) {
      this.simple3DTileProvider && this.simple3DTileProvider.update(e)
  },
  makeTextureURL: function() {
      return "shaders/buildings/texture" + (geofs.isNight ? "-night" : "") + (geofs.isSnowy ? "-snow" : "") + "-" + geofs.configuration.current.qualityToBuildingTexture[geofs.preferences.graphics.quality || geofs.preferences.graphics.advanced.viewingDistance || 0] + ".jpg"
  },
  updateTextures: function() {
      geofs.buildings.buildingsShader.setUniform("u_buildingTexture", new Cesium.TextureUniform({
          url: geofs.buildings.makeTextureURL(),
          minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR
      })),
      geofs.buildings.GLSLReflection && (geofs.buildings.buildingsShader.setUniform("u_specularTexture", new Cesium.TextureUniform({
          url: "shaders/buildings/specular-" + geofs.configuration.current.qualityToBuildingTexture[geofs.preferences.graphics.quality || geofs.preferences.graphics.advanced.viewingDistance || 0] + ".jpg",
          minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR
      })),
      geofs.buildings.buildingsShader.setUniform("u_environmentTexture", new Cesium.TextureUniform({
          url: "shaders/reflection_city" + (geofs.isNight ? "-night" : "") + ".jpg",
          minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR
      })))
  },
  destroy: function() {
      this.simple3DTileProvider && (this.simple3DTileProvider.destroy(),
      this.simple3DTileProvider = null,
      geofs.buildings.nightChangeHandler && (geofs.buildings.nightChangeHandler.off(),
      geofs.buildings.nightChangeHandler = null),
      geofs.buildings.qualityChangeHandler && (geofs.buildings.qualityChangeHandler.off(),
      geofs.buildings.qualityChangeHandler = null),
      geofs.buildings.seasonChangeHandler && (geofs.buildings.seasonChangeHandler.off(),
      geofs.buildings.seasonChangeHandler = null))
  }
},
geofs.simple3DTileProvider = function(e) {
  this.tilingScheme = e.tilingScheme,
  this.options = e,
  this.tiles = {}
}
,
geofs.simple3DTileProvider.prototype = {
  update: function(e) {
      let t = {}
        , a = this.options.qualityLevels[geofs.preferences.graphics.quality || geofs.preferences.graphics.advanced.viewingDistance];
      for (var o in a) {
          let r = a[o];
          if (e[2] > r.altitude)
              continue;
          let n = this.coords2tile(e[0], e[1], parseInt(o));
          geofs.tile2Grid(r.range, n).forEach(e => {
              let a = o + "_" + e.x + "_" + e.y;
              e.id = a,
              e.z = o,
              t[a] = e
          }
          )
      }
      for (var s in this.tiles)
          t[s] || this.unloadTile(s);
      if (!geofs.cautiousWithTerrain)
          for (var s in t)
              this.tiles[s] || (this.loadTile(t[s]),
              this.tiles[s] = t[s])
  },
  loadTile: function(e) {
      let t = this.tile2coords(e.x, e.y, e.z);
      t[2] = 0;
      let a = {
          url: this.options.url + e.id + (this.options.extension || ".glb"),
          location: t,
          rotation: this.options.rotation,
          customShader: this.options.customShader,
          experimental: this.options.experimental,
          shadows: this.options.shadows,
          environmentMapOptions: {
              enabled: !1
          },
          releaseGltfJson: !0
      };
      e.model = new geofs.api.Model(null,a)
  },
  unloadTile: function(e) {
      this.tiles[e].model && this.tiles[e].model.destroy(),
      delete this.tiles[e]
  },
  destroy: function() {
      for (var e in this.tiles)
          this.unloadTile(e)
  },
  coords2tile: function(e, t, a) {
      let o = new Cesium.Cartographic(t * DEGREES_TO_RAD,e * DEGREES_TO_RAD,0);
      return this.tilingScheme.positionToTileXY(o, a)
  },
  tile2coords: function(e, t, a) {
      let o = this.tilingScheme.tileXYToRectangle(e, t, a, new Cesium.Rectangle);
      return [o.south * RAD_TO_DEGREES, o.west * RAD_TO_DEGREES]
  }
},
window.geofs = window.geofs || {},
geofs.api = {},
geofs.api.march2019theTwentyFirst = 2458563,
geofs.api.halfADayInSeconds = 43200,
geofs.api.overlayBaseZIndex = 60,
geofs.api.ALTITUDE_RELATIVE = "ALTITUDE_RELATIVE",
geofs.api.CLAMP_TO_GROUND = "CLAMP_TO_GROUND",
geofs.api.nativeMouseHandling = !1,
geofs.api.maximumUpsamplingResolution = 20,
geofs.api.initWorld = function(e, t) {
  t = t || {},
  Cesium.Ion.defaultAccessToken = geofs.ionkey;
  var a = {
      animation: !1,
      geocoder: !1,
      homeButton: !1,
      infoBox: !1,
      selectionIndicator: !1,
      sceneModePicker: !1,
      baseLayerPicker: !1,
      timeline: !1,
      navigationHelpButton: !1,
      navigationInstructionsInitiallyVisible: !1,
      fullscreenButton: !1,
      scene3DOnly: !0,
      clock: new Cesium.Clock({
          currentTime: new Cesium.JulianDate(geofs.api.march2019theTwentyFirst,43200)
      }),
      showRenderLoopErrors: geofs.debugOn,
      requestRenderMode: !0,
      maximumUpsamplingResolution: geofs.api.maximumUpsamplingResolution,
      useBrowserRecommendedResolution: !1,
      contextOptions: {
          requestWebgl2: !0,
          webgl: {}
      },
      msaaSamples: 1,
      orderIndependentTranslucency: !1,
      useDefaultRenderLoop: !0
  };
  geofs.version >= 4 ? a.baseLayer = new Cesium.ImageryLayer(new Cesium.UrlTemplateImageryProvider({
      url: Cesium.buildModuleUrl("Assets/Textures/NaturalEarthII/{z}/{x}/{reverseY}.jpg"),
      tilingScheme: new Cesium.GeographicTilingScheme({
          numberOfLevelZeroTilesX: 2,
          numberOfLevelZeroTilesY: 1
      }),
      maximumLevel: 2
  })) : a.imageryProvider = new Cesium.UrlTemplateImageryProvider({
      url: Cesium.buildModuleUrl("Assets/Textures/NaturalEarthII/{z}/{x}/{reverseY}.jpg"),
      tilingScheme: new Cesium.GeographicTilingScheme({
          numberOfLevelZeroTilesX: 2,
          numberOfLevelZeroTilesY: 1
      }),
      maximumLevel: 2
  }),
  geofs.PRODUCTION || (a.contextOptions.webgl.preserveDrawingBuffer = !0),
  geofs.androidViewerOptions = geofs.androidViewerOptions || {},
  geofs.iosViewerOptions = geofs.iosViewerOptions || {},
  Object.assign(a, geofs.androidViewerOptions, geofs.iosViewerOptions, t);
  try {
      geofs.api.viewer = new Cesium.Viewer(e,a),
      a.useDefaultRenderLoop || (geofs.renderLoop = () => {
          geofs.pause || geofs.api.viewer.render(),
          requestAnimationFrame(geofs.renderLoop)
      }
      ,
      geofs.renderLoop())
  } catch (o) {
      geofs.debug.error(o, "geofs.api.initWorld");
      var r = 'An error occured while creating the WebGL environment. Please visit the <a href="/pages/instructions.php">instructions page</a> or contact support@geo-fs.com for more details';
      geofs.api.notify(r);
      return
  }
  geofs.version >= 4 ? ((async () => {
      geofs.api.setTerrainProvider(new geofs.api.FlatRunwayTerrainProvider({
          baseProvider: await Cesium.CesiumTerrainProvider.fromUrl(geofs.srtmServer, {
              requestWaterMask: !1,
              requestVertexNormals: !0,
              requestMetadata: !1
          }),
          bypass: !1,
          maximumLevel: 12
      }), "geofs")
  }
  )(),
  geofs.api.viewer.scene.atmosphere.dynamicLighting = Cesium.DynamicAtmosphereLightingType.SUNLIGHT) : geofs.api.setTerrainProvider(new geofs.api.FlatRunwayTerrainProvider({
      baseProvider: new Cesium.CesiumTerrainProvider({
          url: geofs.srtmServer,
          requestWaterMask: !1,
          requestVertexNormals: !0
      }),
      bypass: !1,
      maximumLevel: 12
  }), "geofs"),
  geofs.api.viewer.scene.skyBox = new Cesium.SkyBox({
      sources: {
          positiveX: "images/skybox/tycho2t3_80_px.png",
          negativeX: "images/skybox/tycho2t3_80_mx.png",
          positiveY: "images/skybox/tycho2t3_80_py.png",
          negativeY: "images/skybox/tycho2t3_80_my.png",
          positiveZ: "images/skybox/tycho2t3_80_pz.png",
          negativeZ: "images/skybox/tycho2t3_80_mz.png"
      }
  }),
  geofs.api.viewer.scene.moon.textureUrl = "images/moonSmall.jpg",
  geofs.api.viewer.scene.globe.enableLighting = !1,
  geofs.api.viewer.scene.globe.lambertDiffuseMultiplier = 10,
  geofs.api.viewer.scene.sun.show = !0,
  geofs.api.viewer.scene.globe.maximumUpsamplingLevel = 22,
  geofs.api.viewer.scene.globe.depthTestAgainstTerrain = !0,
  geofs.api.viewer.scene.globe.showWaterEffect = !1,
  geofs.api.viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString("#4b5e27"),
  geofs.api.labels = geofs.api.viewer.scene.primitives.add(new Cesium.LabelCollection),
  geofs.api.billboards = {
      default: geofs.api.viewer.scene.primitives.add(new Cesium.BillboardCollection({
          scene: geofs.api.viewer.scene,
          blendOption: Cesium.BlendOption.OPAQUE_AND_TRANSLUCENT
      })),
      opaque: geofs.api.viewer.scene.primitives.add(new Cesium.BillboardCollection({
          scene: geofs.api.viewer.scene,
          blendOption: Cesium.BlendOption.OPAQUE
      })),
      translucent: geofs.api.viewer.scene.primitives.add(new Cesium.BillboardCollection({
          scene: geofs.api.viewer.scene,
          blendOption: Cesium.BlendOption.TRANSLUCENT
      }))
  },
  geofs.api.models = geofs.api.viewer.scene.primitives.add(new Cesium.PrimitiveCollection({
      destroyPrimitives: !1
  })),
  geofs.api.viewer.scene.preRender.addEventListener(geofs.api.frameCallbackWrapper),
  $(".geofs-ui-3dview").trigger("rendererInitDone"),
  geofs.api.viewer.scene.renderError.addEventListener(e => {
      geofs.debug.error(e, "geofs.api.viewer.scene.renderError"),
      geofs.api.notify("GeoFS encountered an error. If this persists, try to reset preferences to default and refresh the page.")
  }
  )
}
,
geofs.api.destroyWorld = function() {
  geofs.api.viewer.scene.preRender.removeEventListener(geofs.api.frameCallbackWrapper)
}
,
geofs.api.triggerExplicitRendering = function() {
  geofs.api.viewer.scene.requestRender()
}
,
geofs.frameCallbackStack = {},
geofs.api.addFrameCallback = function(e, t, a) {
  return t = t || "global",
  geofs.frameCallbackStack[t] || (geofs.frameCallbackStack[t] = {
      callbacks: {},
      lastId: 0,
      maxExecutionTime: a,
      lastIndex: 1
  }),
  geofs.frameCallbackStack[t].lastId++,
  geofs.frameCallbackStack[t].callbacks[geofs.frameCallbackStack[t].lastId] = e,
  geofs.frameCallbackStack[t].lastId
}
,
geofs.api.removeFrameCallback = function(e, t) {
  t = t || "global",
  geofs.frameCallbackStack[t] && delete geofs.frameCallbackStack[t].callbacks[e]
}
,
geofs.api.frameCallbackWrapper = function(e, t) {
  for (var a in geofs.api.precisionTime = geofs.utils.now(),
  geofs.frameCallbackStack) {
      var o = geofs.frameCallbackStack[a];
      if (o.maxExecutionTime > 0) {
          var r = o.lastIndex;
          do {
              try {
                  o.callbacks[r](geofs.api.precisionTime)
              } catch (n) {
                  geofs.debug.error(n, "geofs.api.frameCallbackWrapper maxExecutionTime"),
                  geofs.debug.throw(n)
              }
              ++r > o.lastId && (r = 1)
          } while (geofs.api.precisionTime + o.maxExecutionTime > geofs.utils.now());
          o.lastIndex = r
      } else
          for (var r in o.callbacks)
              try {
                  o.callbacks[r](geofs.api.precisionTime)
              } catch (s) {
                  geofs.debug.error(s, "geofs.api.frameCallbackWrapper general"),
                  geofs.debug.throw(s)
              }
  }
}
,
geofs.api.setOutsideShadowDistance = function(e) {
  geofs.camera.currentDefinition.insideView || (geofs.api.viewer.shadowMap.maximumDistance = e)
}
,
geofs.api.configureOutsideView = function() {
  geofs.api.viewer.shadowMap.maximumDistance = geofs.api.renderingSettings.shadowDistance || 1e3,
  geofs.api.viewer.shadowMap.darkness = .5,
  geofs.api.camera.frustum.near = 1
}
,
geofs.api.configureInsideView = function() {
  geofs.api.viewer.shadowMap.maximumDistance = geofs.aircraft.instance.definition.cockpitShadowMapMaxDistance || 100,
  geofs.api.viewer.shadowMap.darkness = .5,
  geofs.api.camera.frustum.near = .1
}
,
geofs.api.setGlobeLighting = function(e) {
  if (geofs.api.viewer.scene.globe.enableLighting = e,
  !e) {
      geofs.api.viewer.scene.globe.shadows = Cesium.ShadowMode.DISABLED;
      return
  }
  geofs.api.renderingSettings.dropShadow && (geofs.api.viewer.scene.globe.shadows = Cesium.ShadowMode.RECEIVE_ONLY)
}
,
geofs.api.setSceneLight = function(e, t) {
  geofs.api.viewer.scene.light.color = e || geofs.api.viewer.scene.light.color,
  geofs.api.viewer.scene.light.intensity = 2 * (t || geofs.api.viewer.scene.light.intensity),
  geofs.api.googleTileset && geofs.api.googleTileset.customShader.setUniform("u_lightIntensity", t || 1)
}
,
geofs.api.setWaterEffect = function(e) {
  e ? (geofs.fx.water.create(),
  geofs.api.waterDetection.create(),
  geofs.fx.wake.create()) : (geofs.fx.water.destroy(),
  geofs.api.waterDetection.destroy(),
  geofs.fx.wake.destroy())
}
,
geofs.api.setVegetation = function(e) {
  e ? geofs.trees.init() : geofs.trees.destroy()
}
,
geofs.api.setBuildings = function(e) {
  e ? geofs.buildings.init() : geofs.buildings.destroy()
}
,
geofs.api.setHD = function(e) {
  geofs.api.hdOn !== e && (geofs.api.hdOn = e,
  geofs.api.setDataProvider(e ? "hd" : "sr"))
}
,
geofs.api.setDataProvider = function(e) {
  if (geofs.api.dataProvider != e) {
      var t = {
          method: "doGeoIp",
          dataprovider: e
      };
      $(".geofs-apiResponse").htmlView("load", "/backend/accounts/hd.php", t)
  }
}
,
geofs.api.setTerrainProvider = function(e, t) {
  t && geofs.api.terrainProviderName == t || (geofs.api.viewer.terrainProvider = e,
  geofs.api.terrainProviderName = t)
}
,
geofs.api.setImageryProvider = function(e, t, a, o, r, n) {
  if (n && geofs.api.imageryProviderName == n)
      return;
  let s = geofs.api.viewer.imageryLayers;
  s.remove(s.get(0), !0);
  let c = s.addImageryProvider(e, 0);
  return geofs.runways.setRunwayModelVisibility(t || geofs.preferences.graphics.runways && "sr" == geofs.api.dataProvider),
  geofs.api.setImageryColorModifier("multiplier", {
      brightness: a || 1,
      contrast: o || 1,
      saturation: r || 1
  }),
  geofs.preferences && geofs.preferences.graphics && geofs.api.enhanceColors(geofs.preferences.graphics.enhanceColors),
  geofs.api.imageryProviderName = n,
  c
}
,
geofs.api.setGoogleTiles = async function(e) {
  if (!1 === e && geofs.api.googleTileset) {
      geofs.api.googleTileset.tileLoadListener(),
      geofs.api.viewer.scene.primitives.remove(geofs.api.googleTileset),
      geofs.api.googleTileset = null,
      geofs.api.setVegetation(geofs.preferences.graphics.vegetation),
      geofs.api.setBuildings(geofs.preferences.graphics.buildings),
      geofs.objects.init(),
      geofs.api.viewer.scene.globe.show = !0;
      return
  }
  if (e && !geofs.api.googleTileset) {
      Cesium.GoogleMaps.defaultApiKey = geofs.googleAPIKey,
      geofs.api.setVegetation(!1),
      geofs.api.setBuildings(!1),
      geofs.api.viewer.scene.globe.show = !1,
      geofs.api.viewer.terrainProvider = null,
      geofs.api.hdOn = null,
      geofs.api.terrainProviderName = "google",
      geofs.api.imageryProviderName = "google",
      geofs.configuration.applyConfiguration(geofs.configuration.google),
      geofs.api.renderingQuality(),
      geofs.objects.destroy();
      try {
          geofs.api.googleTileset = await Cesium.createGooglePhotorealistic3DTileset(),
          geofs.api.viewer.scene.primitives.add(geofs.api.googleTileset),
          geofs.api.googleTileset.tileLoadListener = geofs.api.googleTileset.tileVisible.addEventListener(e => {
              geofs.fx.globeLoaded = !0,
              $("body").trigger("globeLoaded"),
              geofs.api.googleTileset.tileLoadListener()
          }
          ),
          geofs.api.googleTileset.enableCollision = !1,
          geofs.api.googleTileset.foveatedScreenSpaceError = !1,
          geofs.api.googleTileset.cullRequestsWhileMoving = !1,
          geofs.api.googleTileset.cacheBytes = 536870912,
          geofs.api.googleTileset.maximumCacheOverflowBytes = 536870912,
          geofs.api.googleTileset.dynamicScreenSpaceError = !0,
          geofs.api.googleTileset.dynamicScreenSpaceErrorDensity = 1,
          geofs.api.googleTileset.dynamicScreenSpaceErrorFactor = 24,
          geofs.api.googleTileset.shadows = Cesium.ShadowMode.RECEIVE_ONLY,
          geofs.api.renderingSettings.adaptativeRenderingQuality = !1,
          geofs.api.googleTileset.customShader = new Cesium.CustomShader({
              varyings: {},
              uniforms: {
                  u_normalMap: {
                      value: new Cesium.TextureUniform({
                          url: "/shaders/oceannormal2.jpg"
                      }),
                      type: Cesium.UniformType.SAMPLER_2D
                  },
                  u_foamTexture: {
                      value: new Cesium.TextureUniform({
                          url: "/shaders/seafoam.jpg"
                      }),
                      type: Cesium.UniformType.SAMPLER_2D
                  },
                  u_horizonColor: {
                      value: Cesium.Color.fromCssColorString("#f1f9fbff"),
                      type: Cesium.UniformType.VEC4
                  },
                  u_azimutColor: {
                      value: Cesium.Color.fromCssColorString("#38618aff"),
                      type: Cesium.UniformType.VEC4
                  },
                  u_geofsTime: {
                      value: 0,
                      type: Cesium.UniformType.FLOAT
                  },
                  u_windSpeed: {
                      value: weather.currentWindSpeedMs || 0,
                      type: Cesium.UniformType.FLOAT
                  },
                  u_earthRadius: {
                      value: 6378137,
                      type: Cesium.UniformType.FLOAT
                  },
                  u_lightIntensity: {
                      value: 1,
                      type: Cesium.UniformType.FLOAT
                  }
              },
              mode: Cesium.CustomShaderMode.MODIFY_MATERIAL,
              lightingModel: Cesium.LightingModel.UNLIT,
              translucencyMode: Cesium.CustomShaderTranslucencyMode.OPAQUE,
              vertexShaderText: geofsShaders["googleVS.glsl"],
              fragmentShaderText: geofsShaders["googleFS.glsl"]
          })
      } catch (t) {
          console.log("Failed to load tileset")
      }
  }
}
,
geofs.api.updateGoogleTiles = function(e) {
  if (!geofs.api.googleTileset)
      return;
  let t = geofs.api.viewer.scene.globe.ellipsoid.cartographicToCartesian(new Cesium.Cartographic(e[1] * DEGREES_TO_RAD,e[0] * DEGREES_TO_RAD,0))
    , a = Cesium.Cartesian3.magnitude(t);
  geofs.api.googleTileset.customShader.setUniform("u_earthRadius", a)
}
,
geofs.api.setDebugImageryProvider = function() {
  geofs.api.viewer.imageryLayers.addImageryProvider(new Cesium.TileCoordinatesImageryProvider({
      tilingScheme: new Cesium.WebMercatorTilingScheme({
          numberOfLevelZeroTilesX: 1,
          numberOfLevelZeroTilesY: 1
      })
  }))
}
,
geofs.api.setTimeAndDate = function(e, t) {
  geofs.api.viewer.clock.shouldAnimate = !0,
  geofs.api.viewer.clock.currentTime = new Cesium.JulianDate(geofs.api.march2019theTwentyFirst + (t || 0),e - geofs.api.halfADayInSeconds)
}
,
geofs.api.setClock = function(e) {
  geofs.api.viewer.clock.multiplier = 1,
  geofs.api.viewer.clock.currentTime = Cesium.JulianDate.fromDate(e),
  geofs.api.viewer.clock.shouldAnimate = !0
}
,
geofs.api.isWebXRAvailable = function() {
  return !!navigator.xr
}
,
geofs.api.toggleVr = function() {
  if (!navigator.xr)
      return;
  if (geofs.vrOn) {
      geofs.vrOn = !1,
      geofs.api.viewer.scene.useWebVR = !1,
      geofs.api.XRSession && geofs.api.XRSession.end();
      return
  }
  geofs.vrOn = !0,
  geofs.api.viewer.scene.useWebVR = !0,
  geofs.camera.set(null, "cockpit");
  let e, t;
  function a(o, r) {
      let n = r.session;
      n.requestAnimationFrame(a);
      let s = r.getViewerPose(e);
      if (s) {
          !geofs.XRFov && s.views && s.views[0] && (geofs.XRFov = 2 * Math.atan(1 / s.views[0].projectionMatrix[5]) * 180 / PI,
          geofs.api.setFOV(geofs.camera.cam, geofs.XRFov));
          let c = n.renderState.baseLayer;
          t.bindFramebuffer(t.FRAMEBUFFER, c.framebuffer),
          t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT),
          geofs.api.viewer.scene._defaultView.passState.XRViews = s.views,
          geofs.api.viewer.scene._defaultView.passState.XRglLayer = c,
          geofs.api.viewer.scene.render()
      }
  }
  navigator.xr.requestSession("immersive-vr").then(function(o) {
      t = geofs.api.viewer.scene._context._gl,
      geofs.api.XRSession = o,
      o.addEventListener("end", () => {
          geofs.XRFov = null
      }
      ),
      o.updateRenderState({
          baseLayer: new XRWebGLLayer(o,t)
      }),
      o.requestReferenceSpace("local").then(t => {
          e = t,
          o.requestAnimationFrame(a)
      }
      )
  })
}
,
geofs.api.enhanceColors = function(e) {
  e = e || 0,
  geofs.api.setImageryColorModifier("enhancement", {
      contrast: 1 + .5 * e,
      saturation: 1 + .5 * e
  })
}
,
geofs.api.defaultImageryColorModifier = {
  brightness: 1,
  contrast: 1,
  saturation: 1,
  gamma: 1,
  hue: 0
},
geofs.api.imageryColorModifiers = {},
geofs.api.setImageryColorModifier = function(e, t) {
  t = Object.assign({}, geofs.api.defaultImageryColorModifier, t),
  geofs.api.imageryColorModifiers[e || "base"] = t,
  geofs.api.applyImageryColorModifiers()
}
,
geofs.api.removeImageryColorModifier = function(e) {
  delete geofs.api.imageryColorModifiers[e],
  geofs.api.applyImageryColorModifiers()
}
,
geofs.api.applyImageryColorModifiers = function() {
  for (var e in geofs.api.imageryColors = Object.assign({}, geofs.api.defaultImageryColorModifier),
  geofs.api.imageryColorModifiers)
      geofs.api.imageryColors.brightness *= geofs.api.imageryColorModifiers[e].brightness,
      geofs.api.imageryColors.contrast *= geofs.api.imageryColorModifiers[e].contrast,
      geofs.api.imageryColors.saturation *= geofs.api.imageryColorModifiers[e].saturation,
      geofs.api.imageryColors.gamma *= geofs.api.imageryColorModifiers[e].gamma,
      geofs.api.imageryColors.hue += geofs.api.imageryColorModifiers[e].hue;
  geofs.api.setImageryBrightness(geofs.api.imageryColors.brightness),
  geofs.api.setImageryContrast(geofs.api.imageryColors.contrast),
  geofs.api.setImagerySaturation(geofs.api.imageryColors.saturation),
  geofs.api.setImageryGamma(geofs.api.imageryColors.gamma),
  geofs.api.setImageryHue(geofs.api.imageryColors.hue)
}
,
geofs.api.setImageryBrightness = function(e) {
  var t = geofs.api.viewer.imageryLayers.get(0);
  return e && (t.brightness = e),
  t.brightness
}
,
geofs.api.setImageryContrast = function(e) {
  var t = geofs.api.viewer.imageryLayers.get(0);
  return e && (t.contrast = e),
  t.contrast
}
,
geofs.api.setImagerySaturation = function(e) {
  var t = geofs.api.viewer.imageryLayers.get(0);
  return e && (t.saturation = e),
  t.saturation
}
,
geofs.api.setImageryHue = function(e) {
  var t = geofs.api.viewer.imageryLayers.get(0);
  return t.hue = e || 0,
  t.hue
}
,
geofs.api.setImageryGamma = function(e) {
  var t = geofs.api.viewer.imageryLayers.get(0);
  return e && (t.gamma = e),
  t.gamma
}
,
geofs.api.defaultAtmosphereColorModifier = {
  brightnessShift: 0,
  saturationShift: 0,
  hueShift: 0,
  groundBrightnessShift: 0,
  groundSaturationShift: 0,
  groundHueShift: 0,
  fogBrightness: 1,
  cloudsBrightness: 1
},
geofs.api.atmosphereColorModifiers = {},
geofs.api.setAtmosphereColorModifier = function(e, t) {
  e = e || "base";
  var a = geofs.api.atmosphereColorModifiers[e] || {};
  t = Object.assign({}, geofs.api.defaultAtmosphereColorModifier, a, t),
  geofs.api.atmosphereColorModifiers[e] = t,
  geofs.api.applyAtmosphereColorModifiers()
}
,
geofs.api.removeAtmosphereColorModifier = function(e) {
  delete geofs.api.atmosphereColorModifiers[e],
  geofs.api.applyAtmosphereColorModifiers()
}
,
geofs.api.applyAtmosphereColorModifiers = function() {
  for (var e in geofs.api.atmosphereColors = Object.assign({}, geofs.api.defaultAtmosphereColorModifier),
  geofs.api.atmosphereColorModifiers)
      geofs.api.atmosphereColors.brightnessShift += geofs.api.atmosphereColorModifiers[e].brightnessShift,
      geofs.api.atmosphereColors.saturationShift += geofs.api.atmosphereColorModifiers[e].saturationShift,
      geofs.api.atmosphereColors.hueShift += geofs.api.atmosphereColorModifiers[e].hueShift,
      geofs.api.atmosphereColors.groundBrightnessShift += geofs.api.atmosphereColorModifiers[e].groundBrightnessShift,
      geofs.api.atmosphereColors.groundHueShift += geofs.api.atmosphereColorModifiers[e].groundHueShift,
      geofs.api.atmosphereColors.groundSaturationShift += geofs.api.atmosphereColorModifiers[e].groundSaturationShift,
      geofs.api.atmosphereColors.fogBrightness *= geofs.api.atmosphereColorModifiers[e].fogBrightness,
      geofs.api.atmosphereColors.cloudsBrightness *= geofs.api.atmosphereColorModifiers[e].cloudsBrightness;
  geofs.api.viewer.scene.skyAtmosphere.brightnessShift = geofs.api.atmosphereColors.brightnessShift,
  geofs.api.viewer.scene.skyAtmosphere.saturationShift = geofs.api.atmosphereColors.saturationShift,
  geofs.api.viewer.scene.skyAtmosphere.hueShift = geofs.api.atmosphereColors.hueShift,
  geofs.api.viewer.scene.globe.atmosphereBrightnessShift = clamp(geofs.api.atmosphereColors.groundBrightnessShift, -1, 1),
  geofs.api.viewer.scene.globe.atmosphereHueShift = clamp(geofs.api.atmosphereColors.groundHueShift, -1, 1),
  geofs.api.viewer.scene.globe.atmosphereSaturationShift = clamp(geofs.api.atmosphereColors.groundSaturationShift, -1, 1),
  geofs.api.viewer.scene.fog.minimumBrightness = geofs.api.atmosphereColors.fogBrightness,
  geofs.fx.cloudManager.setCloudsBrightness(geofs.api.atmosphereColors.cloudsBrightness)
}
,
geofs.api.showSun = function() {}
,
geofs.api.hideSun = function() {}
,
geofs.api.advancedRenderingQuality = function() {
  geofs.api.renderingQuality(null, !0)
}
,
geofs.api.renderingSettings = Object.assign({}, geofs.configuration.current.renderingQualityLevels[0]),
geofs.api.renderingQuality = function(e, t) {
  if (!geofs.api.viewer)
      return;
  geofs.api.viewer.scene.highDynamicRange = !1;
  let a = !1;
  e = e || geofs.preferences.graphics.quality,
  (t || e != geofs.preferences.graphics.quality) && (a = !0),
  geofs.preferences.graphics.quality = e,
  0 == e && (t = !0),
  geofs.configuration.current.renderingQualityLevels[e] || (geofs.api.notify("An error occurred while applying preferences. Settings are reset to default."),
  geofs.resetPreferences()),
  geofs.api.renderingSettings.viewingDistance = geofs.configuration.current.renderingQualityLevels[e].viewingDistance,
  geofs.api.renderingSettings.resolutionScale = geofs.configuration.current.renderingQualityLevels[e].resolutionScale,
  geofs.api.renderingSettings.tileCacheSize = geofs.configuration.current.renderingQualityLevels[e].tileCacheSize,
  geofs.api.renderingSettings.fxaa = geofs.configuration.current.renderingQualityLevels[e].fxaa,
  geofs.api.renderingSettings.msaaSamples = geofs.configuration.current.renderingQualityLevels[e].msaaSamples,
  geofs.api.renderingSettings.globeLighting = geofs.configuration.current.renderingQualityLevels[e].globeLighting,
  geofs.api.renderingSettings.dropShadow = geofs.configuration.current.renderingQualityLevels[e].dropShadow,
  geofs.api.renderingSettings.cloudCoverToCloudNumber = geofs.configuration.current.renderingQualityLevels[e].cloudCoverToCloudNumber,
  geofs.api.renderingSettings.shadowMapSize = geofs.configuration.current.renderingQualityLevels[e].shadowMapSize,
  geofs.api.renderingSettings.shadowDistance = geofs.configuration.current.renderingQualityLevels[e].shadowDistance,
  geofs.api.renderingSettings.advancedAtmosphere = geofs.preferences.graphics.advancedAtmosphere,
  geofs.api.renderingSettings.scatteringQuality = geofs.configuration.current.renderingQualityLevels[e].scatteringQuality,
  geofs.api.renderingSettings.volumetricClouds = geofs.preferences.graphics.volumetricClouds && geofs.api.renderingSettings.advancedAtmosphere,
  geofs.api.renderingSettings.lowResRunways = geofs.configuration.current.renderingQualityLevels[e].lowResRunways,
  t ? ($('[data-gespref="geofs.preferences.graphics.quality"]').addClass("geofs-disabled"),
  $(".geofs-advancedGraphics .slider").removeClass("geofs-disabled"),
  $(".geofs-advancedGraphics.geofs-advanced").addClass("geofs-expanded"),
  geofs.preferences.graphics.quality = 0,
  geofs.api.renderingSettings.resolutionScale = geofs.preferences.graphics.advanced.resolutionScale,
  geofs.api.renderingSettings.viewingDistance = geofs.preferences.graphics.advanced.viewingDistance,
  (geofs.api.renderingSettings.viewingDistance < 1 || geofs.api.renderingSettings.viewingDistance > 7) && (geofs.api.renderingSettings.viewingDistance = 3),
  geofs.api.renderingSettings.lowResRunways = geofs.api.renderingSettings.viewingDistance <= 3,
  geofs.api.renderingSettings.fxaa = geofs.preferences.graphics.advanced.fxaa,
  geofs.api.renderingSettings.msaaSamples = geofs.preferences.graphics.advanced.msaaSamples,
  1 == geofs.preferences.graphics.advanced.msaaSamples && $('[data-gespref="geofs.preferences.graphics.advanced.msaaSamples"] .slider-input').val("OFF"),
  geofs.api.renderingSettings.tileCacheSize = geofs.preferences.graphics.advanced.tileCacheSize,
  geofs.api.renderingSettings.globeLighting = geofs.preferences.graphics.advanced.globeLighting,
  geofs.api.renderingSettings.dropShadow = geofs.preferences.graphics.advanced.dropShadow,
  geofs.api.renderingSettings.softShadows = geofs.preferences.graphics.advanced.softShadows,
  geofs.api.renderingSettings.scatteringQuality = geofs.preferences.graphics.advanced.scatteringQuality,
  geofs.api.renderingSettings.cloudCoverToCloudNumber = geofs.configuration.current.renderingQualityLevels[0].cloudCoverToCloudNumber * geofs.preferences.graphics.advanced.cloudDensity,
  geofs.api.renderingSettings.shadowMapSize = geofs.configuration.current.renderingQualityLevels[0].shadowMapSize * geofs.preferences.graphics.advanced.shadowQuality,
  geofs.api.renderingSettings.shadowDistance = geofs.configuration.current.renderingQualityLevels[0].shadowDistance * geofs.preferences.graphics.advanced.shadowQuality) : ($('[data-gespref="geofs.preferences.graphics.quality"]').removeClass("geofs-disabled"),
  $(".geofs-advancedGraphics .slider").addClass("geofs-disabled"),
  geofs.preferences.graphics.advanced.resolutionScale = geofs.api.renderingSettings.resolutionScale,
  geofs.preferences.graphics.advanced.viewingDistance = geofs.configuration.current.renderingQualityLevels[e].viewingDistance,
  geofs.preferences.graphics.advanced.tileCacheSize = geofs.api.renderingSettings.tileCacheSize,
  geofs.preferences.graphics.advanced.fxaa = geofs.api.renderingSettings.fxaa,
  geofs.preferences.graphics.advanced.msaaSamples = geofs.api.renderingSettings.msaaSamples,
  geofs.preferences.graphics.advanced.globeLighting = geofs.api.renderingSettings.globeLighting,
  geofs.preferences.graphics.advanced.dropShadow = geofs.api.renderingSettings.dropShadow,
  geofs.preferences.graphics.advanced.softShadows = !1,
  geofs.api.renderingSettings.softShadows = !1,
  geofs.preferences.graphics.advanced.shadowQuality = geofs.api.renderingSettings.shadowMapSize / geofs.configuration.current.renderingQualityLevels[0].shadowMapSize,
  geofs.preferences.graphics.advanced.scatteringQuality = geofs.api.renderingSettings.scatteringQuality,
  geofs.preferences.graphics.advanced.cloudDensity = geofs.api.renderingSettings.cloudCoverToCloudNumber / geofs.configuration.current.renderingQualityLevels[0].cloudCoverToCloudNumber,
  geofs.setPreferenceValues($(".geofs-advancedGraphics"), !0)),
  geofs.preferences.graphics.advancedAtmosphere ? $('[for="volumetricClouds"]').show() : $('[for="volumetricClouds"]').hide(),
  geofs.api.renderingSettings.volumetricClouds ? $('[data-gespref="geofs.preferences.graphics.advanced.cloudDensity"]').hide() : $('[data-gespref="geofs.preferences.graphics.advanced.cloudDensity"]').show(),
  geofs.fx.atmosphere.create(geofs.api.renderingSettings.advancedAtmosphere, geofs.api.renderingSettings.scatteringQuality, geofs.api.renderingSettings.volumetricClouds, !geofs.preferences.weather.manual),
  geofs.api.viewer.scene.fog.enabled = !0,
  geofs.api.renderingSettings.physicsDeltaMs = geofs.configuration.current.physics.deltaMs[geofs.api.renderingSettings.viewingDistance],
  geofs.api.renderingSettings.degradedCollisions = geofs.configuration.current.physics.degradedCollisions[geofs.api.renderingSettings.viewingDistance],
  geofs.api.renderingSettings.fogDensity = geofs.configuration.current.screenSpacePresets.fogDensity[geofs.api.renderingSettings.viewingDistance],
  geofs.api.renderingSettings.maximumScreenSpaceError = geofs.configuration.current.screenSpacePresets.maximumScreenSpaceError[geofs.api.renderingSettings.viewingDistance],
  geofs.api.renderingSettings.fogScreenSpaceErrorFactor = geofs.configuration.current.screenSpacePresets.fogScreenSpaceErrorFactor[geofs.api.renderingSettings.viewingDistance],
  geofs.api.renderingSettings.buildingCollision && (geofs.api.renderingSettings.degradedCollisions = !0),
  geofs.api.viewer.scene.fog.density = geofs.api.renderingSettings.fogDensity,
  geofs.api.viewer.scene.globe.maximumScreenSpaceError = geofs.api.renderingSettings.maximumScreenSpaceError,
  geofs.api.viewer.scene.fog.screenSpaceErrorFactor = geofs.api.renderingSettings.fogScreenSpaceErrorFactor;
  let o = 0;
  geofs.preferences.mobile && (o = clamp(window.devicePixelRatio, 0, 4) / 10),
  geofs.api.viewer.resolutionScale = geofs.api.renderingSettings.resolutionScale - o,
  geofs.api.viewer.scene.globe.tileCacheSize = geofs.api.renderingSettings.tileCacheSize,
  geofs.api.viewer.scene.postProcessStages.fxaa.enabled = geofs.api.renderingSettings.fxaa,
  geofs.api.setGlobeLighting(geofs.api.renderingSettings.globeLighting),
  geofs.api.viewer.shadowMap.size = geofs.api.renderingSettings.shadowMapSize,
  geofs.api.renderingSettings.adaptativeRenderingQuality = geofs.api.renderingSettings.viewingDistance <= 6,
  geofs.fx.cloudManager.setCloudCoverToCloudNumber(geofs.api.renderingSettings.cloudCoverToCloudNumber),
  geofs.useSimpleShadow(!geofs.api.renderingSettings.dropShadow),
  geofs.api.viewer.shadowMap.softShadows = geofs.api.renderingSettings.softShadows,
  geofs.api.setOutsideShadowDistance(geofs.api.renderingSettings.shadowDistance),
  geofs.api.viewer.scene.msaaSamples = geofs.api.renderingSettings.msaaSamples,
  geofs.api.googleTileset && (geofs.api.googleTileset.dynamicScreenSpaceErrorDensity = geofs.configuration.current.screenSpacePresets.google.dynamicScreenSpaceErrorDensity[geofs.api.renderingSettings.viewingDistance],
  geofs.api.googleTileset.dynamicScreenSpaceErrorFactor = geofs.configuration.current.screenSpacePresets.google.dynamicScreenSpaceErrorFactor[geofs.api.renderingSettings.viewingDistance],
  geofs.api.googleTileset.maximumScreenSpaceError = geofs.configuration.current.screenSpacePresets.google.maximumScreenSpaceError[geofs.api.renderingSettings.viewingDistance],
  geofs.api.renderingSettings.degradedCollisions = !0,
  geofs.api.renderingSettings.adaptativeRenderingQuality = !1),
  geofs.runways.redraw(),
  geofs.api.viewer.resize(),
  a && $("body").trigger("qualityChange")
}
,
geofs.api.adaptativeMaxMaximumScreenSpaceError = 6,
geofs.api.adaptativeTopSpeed = 100,
geofs.api.adaptativeTopAltitude = 500,
geofs.api.adaptativeTurnrateRatio = 5e-4,
geofs.api.adaptativeRenderingQuality = function() {
  var e = geofs.relativeAltitude || 0
    , t = 0
    , a = geofs.api.renderingSettings.maximumScreenSpaceError
    , o = geofs.animation.values.kias / geofs.api.adaptativeTopSpeed
    , r = clamp((geofs.api.adaptativeTopAltitude - e) / geofs.api.adaptativeTopAltitude, 0, 1);
  a += o * r + t * geofs.api.adaptativeTurnrateRatio,
  geofs.api.viewer.scene.globe.maximumScreenSpaceError = exponentialSmoothing("adaptativeRenderingQuality", clamp(a, geofs.api.renderingSettings.maximumScreenSpaceError, geofs.api.adaptativeMaxMaximumScreenSpaceError), null, geofs.api.renderingSettings.maximumScreenSpaceError)
}
,
geofs.api.useNativeShadows = function(e) {
  geofs.api.viewer.shadows = e
}
,
geofs.api.useNativeAtmosphere = function(e) {
  geofs.api.viewer.scene.globe.showGroundAtmosphere = e,
  geofs.api.viewer.scene.skyAtmosphere.show = e,
  geofs.api.viewer.scene.fog.renderable = e
}
,
geofs.api.addLabel = function(e, t, a) {
  if (t = t || [0, 0, 0],
  a = a || {},
  !V3.isValid(t)) {
      geofs.debug.debugger();
      return
  }
  return a = Object.assign(a, {
      position: new Cesium.Cartesian3.fromDegrees(t[1],t[0],t[2]),
      text: geofs.api.makeLabelTextSafe(e)
  }),
  geofs.api.labels.add(a)
}
,
geofs.api.updateLabelText = function(e, t) {
  e.text = geofs.api.makeLabelTextSafe(t)
}
,
geofs.api.makeLabelTextSafe = function(e) {
  return e.replace(/[^\x20-\x7E]+/g, "")
}
,
geofs.api.removeLabel = function(e) {
  e && geofs.api.labels.remove(e)
}
,
geofs.api.setLabelPosition = function(e, t) {
  if (e) {
      if (!V3.isValid(t)) {
          geofs.debug.debugger();
          return
      }
      e.position = new Cesium.Cartesian3.fromDegrees(t[1],t[0],t[2])
  }
}
,
geofs.api.getGuarantiedGroundAltitude = function(e) {
  var t = geofs.objects.getAltitudeAtLocation(e, !0);
  if (t)
      return new Promise( (e, a) => {
          e([{
              height: t.location[2]
          }])
      }
      );
  {
      let a = [Cesium.Cartographic.fromDegrees(e[1], e[0])];
      return geofs.api.googleTileset ? geofs.api.viewer.scene.sampleHeightMostDetailed(a, null, 1) : geofs.api.viewer.terrainProvider ? Cesium.sampleTerrain(geofs.api.viewer.terrainProvider, geofs.api.viewer.terrainProvider.maximumLevel, a) : new Promise( (e, t) => {
          e([{
              height: 0
          }])
      }
      )
  }
}
,
geofs.api.getFastTerrainElevation = function(e) {
  let t = new Cesium.Cartographic.fromDegrees(e[1],e[0],e[2]);
  return geofs.api.googleTileset ? geofs.api.googleTileset.getHeight(t, geofs.api.viewer.scene) || 0 : geofs.api.viewer.scene.globe.getHeight(t) || 0
}
,
geofs.api.contactAltitudeErrorThreshold = .2,
geofs.api.generalAltitudeErrorThreshold = 10,
geofs.api.wrongAltitudeAllowedTries = 5,
geofs.api.getGroundAltitude = function(e, t) {
  geofs.debugOn && V3.isValid(e);
  var a = geofs.groundElevation || 0;
  let o;
  if (geofs.api.googleTileset) {
      let r = new Cesium.Cartographic.fromDegrees(e[1],e[0],a);
      o = geofs.api.googleTileset.getHeight(r, geofs.api.viewer.scene)
  } else if (geofs.api.renderingSettings.buildingCollision) {
      let n = new Cesium.Cartographic.fromDegrees(e[1] + 1e-4,e[0] + 1e-4,0);
      o = geofs.api.viewer.scene.sampleHeight(n, geofs.aircraft.instance.models),
      geofs.debug.watch("groundAltitude", o)
  } else {
      let s = new Cesium.Cartographic.fromDegrees(e[1],e[0],a);
      o = geofs.api.viewer.scene.globe.getHeight(s)
  }
  if (o < -1e3 && (o = void 0),
  void 0 == o)
      t && t.lastGroundAltitude ? (o = a || t.lastGroundAltitude,
      t.wrongValue = "undefined") : o = a;
  else if (t) {
      t.lastGroundAltitude = a || t.lastGroundAltitude;
      var c = Math.abs(t.lastGroundAltitude - o);
      if (t.groundContact) {
          if (c > geofs.api.contactAltitudeErrorThreshold && (t.wrongAltitudeTries = t.wrongAltitudeTries || 0,
          t.wrongAltitudeTries <= geofs.api.wrongAltitudeAllowedTries))
              return t.wrongAltitudeTries++,
              t.wrongValue = o,
              t.lastGroundAltitude || 0
      } else if (c > geofs.api.generalAltitudeErrorThreshold && (t.wrongAltitudeTries = t.wrongAltitudeTries || 0,
      t.wrongAltitudeTries <= geofs.api.wrongAltitudeAllowedTries))
          return t.wrongAltitudeTries++,
          t.wrongValue = o,
          t.lastGroundAltitude || 0;
      t.wrongAltitudeTries = 0,
      t.lastGroundAltitude = o
  }
  return o
}
,
geofs.api.oldNormal = [0, 0, 1],
geofs.api.normalDotThreshold = .95,
geofs.api.wrongNormalTries = 3,
geofs.api.getGroundNormal = function(e, t) {
  (t = t || {}).oldNormal = t.oldNormal || [0, 0, 1];
  var a = V3.dup(e)
    , o = xyz2lla([1, 1, a[2]], a)
    , r = V3.add(a, [o[0], 0, a[2]])
    , n = V3.add(a, [0, o[1], a[2]]);
  a[2] = geofs.api.getGroundAltitude(a),
  r[2] = geofs.api.getGroundAltitude(r),
  n[2] = geofs.api.getGroundAltitude(n);
  var s = V3.sub(r, a)
    , c = V3.sub(n, a);
  s = lla2xyz(s, a),
  c = lla2xyz(c, a);
  var d = V3.normalize(V3.cross(c, s));
  return V3.dot(d, t.oldNormal) < geofs.api.normalDotThreshold && t.wrongNormal < geofs.api.wrongNormalTries ? (t.wrongNormal += 1,
  t.oldNormal) : (t.wrongNormal = 0,
  t.oldNormal = d,
  geofs.api.oldNormal = d,
  d)
}
,
geofs.api.Model = function(e, t) {
  (t = t || {}).url = t.url || e,
  t.scene = t.scene || geofs.api.viewer.scene,
  this.loadedPromise = new Promise(async e => {
      this.readyPromise = new Promise(async a => {
          if (this._model = await geofs.api.loadModel(t),
          this._model) {
              if (e(),
              this.forceZup = t.forceZup,
              this.detroyed || this._model.isDestroyed()) {
                  this.destroy();
                  return
              }
              t.modelMatrix || this.setPositionOrientationAndScale(t.location, t.rotation, null),
              t.justLoad || this.addToWorld(),
              this._model.ready ? (this.ready = !0,
              a()) : this._model.readyPromise ? this._model.readyPromise.then( () => {
                  this.ready = !0,
                  a()
              }
              ) : this._model.readyEvent && this._model.readyEvent.addEventListener( () => {
                  this.ready = !0,
                  a()
              }
              )
          }
      }
      )
  }
  )
}
,
geofs.api.Model.prototype.addToWorld = function() {
  this.loadedPromise.then( () => {
      geofs.api.addModelToWorld(this._model)
  }
  )
}
,
geofs.api.Model.prototype.removeFromWorld = function() {
  geofs.api.removeModelFromWorld(this._model)
}
,
geofs.api.Model.prototype.getReadyPromise = function() {
  return this._model && this._model.readyPromise ? this._model.readyPromise : this.readyPromise
}
,
geofs.api.Model.prototype.isReady = function() {
  return !!this._model && this._model.ready
}
,
geofs.api.Model.prototype.getNode = function(e) {
  return geofs.api.getModelNode(this._model, e)
}
,
geofs.api.Model.prototype.setOpacity = function(e) {
  this.ready && (this._model.color.alpha = e,
  this._opacity = e)
}
,
geofs.api.Model.prototype.setRotation = function(e, t) {
  var a = [0, 0, 0];
  a[t = t || 0] = e,
  this.setPositionOrientationAndScale(null, a, null)
}
,
geofs.api.Model.prototype.setScale = function(e) {
  this.setPositionOrientationAndScale(null, null, e)
}
,
geofs.api.Model.prototype.setPositionOrientationAndScale = function(e, t, a) {
  return geofs.api.setModelPositionOrientationAndScale(this._model, e, t, a)
}
,
geofs.api.Model.prototype.setLocation = function(e) {
  this.setPositionOrientationAndScale(e)
}
,
geofs.api.Model.prototype.translate = function(e) {
  this.setPositionOrientationAndScale(V3.add(this._model._apiLla, e))
}
,
geofs.api.Model.prototype.rotate = function(e) {
  this.setPositionOrientationAndScale(null, V3.add(this._model._apiHtr, e))
}
,
geofs.api.Model.prototype.scale = function(e) {
  Array.isArray(e) || (e = [e, e, e]),
  this.setPositionOrientationAndScale(null, null, V3.add(this._model._apiScale, e))
}
,
geofs.api.Model.prototype.setColor = function(e) {
  this._model && (this._model.color = Cesium.Color.clone(e),
  this._model.color.alpha = this._opacity || e.alpha)
}
,
geofs.api.Model.prototype.setShadows = function(e) {
  this._model.shadows = e
}
,
geofs.api.Model.prototype.setCssColor = function(e) {
  this._model.color = Cesium.Color.fromCssColorString(e)
}
,
geofs.api.Model.prototype.addShader = function(e, t) {
  return geofs.api.addShaderToModel(this._model, e, t)
}
,
geofs.api.Model.prototype.setTextureFromCanvas = function(e, t) {
  return geofs.api.setModelTextureFromCanvas(this._model, e, t)
}
,
geofs.api.Model.prototype.changeTexture = function(e, t) {
  return geofs.api.changeModelTexture(this._model, e, t)
}
,
geofs.api.Model.prototype.setVisibility = function(e) {
  return geofs.api.setModelVisibility(this._model, e)
}
,
geofs.api.Model.prototype.hide = function() {
  geofs.api.setModelVisibility(this._model, !1)
}
,
geofs.api.Model.prototype.show = function() {
  geofs.api.setModelVisibility(this._model, !0)
}
,
geofs.api.Model.prototype.setNodeVisibilityByName = function(e, t) {
  if (!this.ready)
      return this.readyPromise.then( () => {
          if (this._model && this._model.ready) {
              let a = this._model.getNode(e);
              return geofs.api.setNodeVisibility(a, t)
          }
      }
      ),
      !0;
  {
      let a = this._model.getNode(e);
      return geofs.api.setNodeVisibility(a, t)
  }
}
,
geofs.api.Model.prototype.destroy = function() {
  geofs.api.destroyModel(this._model),
  this.detroyed = !0
}
,
geofs.api.Model.prototype.remove = function() {
  geofs.api.removeFromWorld(this._model)
}
,
geofs.api.generateShader = function(e, t) {
  return t = t || "",
  new Cesium.CustomShader({
      uniforms: geofs.api.generateUniforms(e, t),
      varyings: {},
      mode: Cesium.CustomShaderMode.REPLACE_MATERIAL,
      lightingModel: Cesium.LightingModel.UNLIT,
      translucencyMode: e.translucent ? Cesium.CustomShaderTranslucencyMode.TRANSLUCENT : Cesium.CustomShaderTranslucencyMode.OPAQUE,
      vertexShaderText: geofsShaders[e.name + "VS.glsl"] || "void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput) {}",
      fragmentShaderText: geofsShaders[e.name + "FS.glsl"]
  })
}
,
geofs.api.getShaderTextureList = function(e, t) {
  switch (e.textures = e.textures || {},
  e.name) {
  case "mappedReflective":
      e.textures.diffuse = e.textures.diffuse || t + "/texture_0.jpg",
      e.textures.reflective = e.textures.reflective || "/shaders/reflection.jpg",
      e.textures.normal = e.textures.normal || t + "/normal.jpg",
      e.textures.specular = e.textures.specular || t + "/specular.jpg";
      break;
  case "glass":
      e.textures.reflective = e.textures.reflective || "/shaders/reflection.jpg"
  }
  return e.textures
}
,
geofs.api.generateUniforms = function(e, t) {
  let a = geofs.api.getShaderTextureList(e, t)
    , o = {};
  for (var r in a)
      o["u_" + r] = {
          value: new Cesium.TextureUniform({
              url: a[r],
              minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR
          }),
          type: Cesium.UniformType.SAMPLER_2D
      };
  for (var r in e.uniforms)
      o["u_" + r] = {
          value: e.uniforms[r],
          type: Cesium.UniformType.FLOAT
      };
  return o
}
,
geofs.api.loadModel = async function(e) {
  "string" == typeof e && (e = {
      url: e
  }),
  (e = Object.assign({}, {
      shadows: SHADOWS_NONE,
      environmentMapOptions: {
          maximumPositionEpsilon: 1e3,
          maximumSecondsDifference: 60
      }
  }, e)).scene = geofs.api.viewer.scene,
  e.altitudeMode == geofs.api.ALTITUDE_RELATIVE && (e.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND),
  e.altitudeMode == geofs.api.CLAMP_TO_GROUND && (e.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND);
  let t;
  if (e.asCesiumInstance)
      t = {
          collectionId: e.collectionId,
          instance: !0,
          url: e.url
      };
  else if (e.asCesiumEntity)
      (t = new Cesium.ModelGraphics(e)).entity = new Cesium.Entity({
          model: t
      });
  else if (geofs.version >= 4) {
      e.upAxis = Cesium.Axis.Y,
      e.forwardAxis = Cesium.Axis.X;
      try {
          t = await Cesium.Model.fromGltfAsync(e)
      } catch (a) {
          return geofs.debug.log("geofs.api.loadModel fromGltfAsync exception"),
          geofs.debug.log(a),
          null
      }
  } else
      e.experimental ? (e.retryCallback = function(e, t) {
          return !1
      }
      ,
      e.url = new Cesium.Resource(e),
      t = Cesium.ModelExperimental.fromGltf(e)) : t = Cesium.Model.fromGltf(e);
  return t
}
,
geofs.api.addModelToWorld = function(e) {
  !(!e || e.isDestroyed && e.isDestroyed()) && (e.instance ? geofs.api.addModelInstance(e.collectionId, {
      modelMatrix: e.modelMatrix
  }, e.url) : e.entity ? geofs.api.viewer.entities.add(e.entity) : geofs.api.models.add(e))
}
,
geofs.api.instanceCollections = {},
geofs.api.modelInstances = {},
geofs.api.addModelInstance = function(e, t, a) {
  geofs.api.modelInstances[e] || (geofs.api.modelInstances[e] = [],
  geofs.api.modelInstances[e].url = a),
  geofs.api.modelInstances[e].push(t)
}
,
geofs.api.commitInstanceCollection = function(e) {
  geofs.api.modelInstances[e] && (geofs.api.instanceCollections[e] = geofs.api.viewer.scene.primitives.add(new Cesium.ModelInstanceCollection({
      url: geofs.api.modelInstances[e].url,
      instances: geofs.api.modelInstances[e],
      incrementallyLoadTextures: !1,
      dynamic: !1,
      allowPicking: !1,
      shadows: 0
  })))
}
,
geofs.api.destroyInstanceCollection = function(e) {
  geofs.api.instanceCollections[e] && geofs.api.instanceCollections[e].destroy(),
  delete geofs.api.instanceCollections[e],
  delete geofs.api.modelInstances[e]
}
,
geofs.api.setModelTextureFromCanvas = function(e, t, a) {
  if (e) {
      if (e.customShader) {
          if (e.geofsTexUniform) {
              let o = e.customShader._textureManager._textures.u_diffuse;
              o && o._initialized && o._width > 1 ? (o.copyFrom({
                  source: t.canvas
              }),
              o.generateMipmap()) : e.customShader.setUniform("u_diffuse", e.geofsTexUniform)
          } else
              e.geofsTexUniform = new Cesium.TextureUniform({
                  typedArray: t.context.getImageData(0, 0, t.width, t.height).data,
                  width: t.width,
                  height: t.height,
                  repeat: !1,
                  minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
                  magnificationFilter: Cesium.TextureMinificationFilter.LINEAR
              }),
              e.customShader.setUniform("u_diffuse", e.geofsTexUniform)
      } else {
          var r = e._rendererResources.textures[a || 0];
          r && (r.copyFrom({
              source: t.canvas
          }),
          r.generateMipmap())
      }
  }
}
,
geofs.api.changeModelTexture = function(e, t, a) {
  if (e) {
      if (e.customShader)
          e.customShader.setUniform("u_diffuse", new Cesium.TextureUniform({
              url: t,
              minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR
          }));
      else {
          let o;
          o = geofs.version >= 4 ? e._nodesByName[a.node || ""]._runtimeNode.runtimePrimitives[0].primitive.material.metallicRoughness.baseColorTexture.texture : e._rendererResources.textures[a.index || 0],
          Cesium.Resource.fetchImage({
              url: t
          }).then(function(e) {
              o.copyFrom({
                  source: e
              }),
              o.generateMipmap()
          })
      }
  }
}
,
geofs.api.toggleModelShadow = function(e, t) {
  !(!geofs.api.viewer.shadows || !e || e.isDestroyed && e.isDestroyed()) && (t ? e.shadows = Cesium.ShadowMode.CAST_ONLY : e.shadows = Cesium.ShadowMode.DISABLED)
}
,
geofs.api.removeModelFromWorld = function(e) {
  !(!e || e.isDestroyed && e.isDestroyed()) && (e.entity ? geofs.api.viewer.entities.remove(e.entity) : geofs.api.models.remove(e))
}
,
geofs.api.setModelVisibility = function(e, t) {
  return !(!e || e.isDestroyed && e.isDestroyed()) && (e.entity ? e.entity.show = t : e.show = t,
  !0)
}
,
geofs.api.setModelColor = function(e, t, a, o, r) {
  if (!e || e.isDestroyed && e.isDestroyed())
      return !1;
  e.color.red = t,
  e.color.green = a,
  e.color.blue = o,
  e.color.alpha = r
}
,
geofs.api.setModelOpacity = function(e, t) {
  return !(!e || e.isDestroyed && e.isDestroyed()) && (e.color.alpha = t,
  !0)
}
,
geofs.api.destroyModel = function(e) {
  e && (geofs.api.removeModelFromWorld(e),
  e.destroy && !e.isDestroyed() && e.destroy())
}
,
geofs.fromHeadingPitchRoll = function(e, t, a) {
  var o = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_X, -t)
    , r = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_Y, -a);
  let n = Cesium.Quaternion.multiply(o, r, r);
  var s = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_Z, -e);
  return Cesium.Quaternion.multiply(s, n, n)
}
,
geofs.headingPitchRollScaleToFixedFrame = function(e, t, a, o, r) {
  var n = new Cesium.Cartesian3(r[0],r[1],r[2])
    , s = geofs.fromHeadingPitchRoll(t, a, o)
    , c = new Cesium.Matrix4
    , d = Cesium.Matrix4.fromTranslationQuaternionRotationScale(Cesium.Cartesian3.ZERO, s, n, c)
    , u = Cesium.Transforms.eastNorthUpToFixedFrame(e);
  return Cesium.Matrix4.multiply(u, d, u)
}
,
geofs.api.setModelElevation = function(e, t) {
  geofs.api.setModelPositionOrientationAndScale(e, [e._apiLla[0], e._apiLla[1], t])
}
,
geofs.api.setModelPositionOrientationAndScale = function(e, t, a, o) {
  if (!(!e || e.isDestroyed && e.isDestroyed())) {
      if (Array.isArray(o = o || e._apiScale || [1, 1, 1]) || (o = [o, o, o]),
      a = a ? a.slice() : e._apiHtr || [0, 0, 0],
      t = t ? t.slice() : e._apiLla || [0, 0, 0],
      !V3.isValid(a) || !V3.isValid(o) || !V3.isValid(t)) {
          geofs.debug.debugger();
          return
      }
      var r = Cesium.Cartesian3.fromDegrees(t[1], t[0], t[2]);
      if (e.entity) {
          e.entity.position = r;
          let n = new Cesium.HeadingPitchRoll(a[0] * DEGREES_TO_RAD,a[1] * DEGREES_TO_RAD,a[2] * DEGREES_TO_RAD);
          e.entity.orientation = Cesium.Transforms.headingPitchRollQuaternion(r, n)
      } else
          e.modelMatrix = geofs.headingPitchRollScaleToFixedFrame(r, a[0] * DEGREES_TO_RAD, a[1] * DEGREES_TO_RAD, a[2] * DEGREES_TO_RAD, o);
      e._apiScale = o,
      e._apiHtr = a,
      e._apiLla = t
  }
}
,
geofs.api.getModelNode = function(e, t) {
  if (e) {
      if (e._geofsNodes = e._geofsNodes || {},
      !e._geofsNodes[t]) {
          if (!e || !e.ready)
              return !1;
          e._geofsNodes[t] = e.getNode(t)
      }
      return e._geofsNodes[t]
  }
}
,
geofs.api.setModelRotationPosition = function(e, t, a) {
  if (e.originalTransform || (e.originalTransform = e.modelMatrix.clone(e.originalTransform)),
  t)
      var o = Cesium.Matrix3.fromColumnMajorArray(M33.toArray(t));
  if (a)
      var r = Cesium.Cartesian3.fromDegrees(a[1], a[0], a[2]);
  e.modelMatrix = Cesium.Matrix4.fromRotationTranslation(o, r);
  var n = Cesium.Transforms.eastNorthUpToFixedFrame(r);
  e.modelMatrix = Cesium.Matrix4.multiply(n, e.modelMatrix, n)
}
,
geofs.api.setNodeRotationTranslationScale = function(e, t, a, o, r) {
  if (t) {
      var n = Cesium.Matrix3.fromColumnMajorArray(M33.toArray(t));
      r && (n = Cesium.Matrix3.multiply(n, Cesium.Matrix4.getRotation(Cesium.Axis.Y_UP_TO_Z_UP, new Cesium.Matrix3), n))
  }
  if (a)
      var s = new Cesium.Cartesian3(a[0],a[1],a[2]);
  var c = Cesium.Matrix4.fromRotationTranslation(n, s);
  if (o && 1 != o[0] || 1 != o[1] || 1 != o[2]) {
      var d = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(o[0],o[1],o[2]));
      c = Cesium.Matrix4.multiply(c, d, c)
  }
  r && (c = Cesium.Matrix4.multiply(Cesium.Axis.Z_UP_TO_Y_UP, c, c)),
  e.matrix = Cesium.Matrix4.multiply(e.originalMatrix, c, e.matrix)
}
,
geofs.api.setNodeScale = function(e, t) {
  var a = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(t[0],t[1],t[2]));
  e.matrix = Cesium.Matrix4.multiply(e.matrix, a, e.matrix)
}
,
geofs.api.setNodeVisibility = function(e, t) {
  return !!e && (e.show = t,
  !0)
}
,
geofs.api.getNodePosition = function(e, t) {
  var a = geofs.api.getNodeOriginalMatrix(e, t)
    , o = Cesium.Matrix4.getTranslation(a, new Cesium.Cartesian3);
  return [o.x, o.y, o.z]
}
,
geofs.api.getNodeOriginalMatrix = function(e, t) {
  if (!e.geofsOriginalMatrix && (e.geofsOriginalMatrix = e.originalMatrix,
  t)) {
      let a = Cesium.Axis.Y_UP_TO_Z_UP;
      e.geofsOriginalMatrix = Cesium.Matrix4.multiply(a, e.geofsOriginalMatrix, new Cesium.Matrix4)
  }
  return e.geofsOriginalMatrix
}
,
geofs.api.getNodeRotation = function(e) {
  return M33.identity()
}
,
geofs.api.initAndGetCamera = function() {
  return geofs.api.camera = geofs.api.viewer.camera,
  geofs.api.camera
}
,
geofs.api.getFOV = function(e) {
  return e.frustum.fov
}
,
geofs.api.setFOV = function(e, t) {
  e.frustum.fov = t
}
,
geofs.api.setCameraPositionAndOrientation = function(e, t, a) {
  if (!V3.isValid(t) || !V3.isValid(a)) {
      geofs.debug.debugger();
      return
  }
  e.position = Cesium.Cartesian3.fromDegrees(t[1], t[0], t[2]),
  e.setView({
      orientation: {
          heading: Cesium.Math.toRadians(a[0]),
          pitch: Cesium.Math.toRadians(a[1]),
          roll: Cesium.Math.toRadians(a[2])
      }
  })
}
,
geofs.api.getCameraLla = function(e) {
  var t = e.positionCartographic;
  return [t.latitude * RAD_TO_DEGREES, t.longitude * RAD_TO_DEGREES, t.height]
}
,
geofs.api.setCameraLookAt = function(e, t) {
  e.lookAt(Cesium.Cartesian3.fromDegrees(t[1], t[0], t[2]))
}
,
geofs.api.getHeading = function(e) {
  return e.heading * RAD_TO_DEGREES
}
,
geofs.api.getTilt = function(e) {
  return e.pitch * RAD_TO_DEGREES
}
,
geofs.api.debug = function(e) {
  geofs.api.viewer && (e ? geofs.api.viewer.scene.debugShowFramesPerSecond = !0 : geofs.api.viewer.scene.debugShowFramesPerSecond = !1)
}
,
geofs.api.getPositionFromScreenCoords = function(e, t) {
  return geofs.api.viewer.scene.pickPosition(new Cesium.Cartesian2(e,t), new Cesium.Cartesian3)
}
,
geofs.api.getDistanceFromScreenCoords = function(e, t, a) {
  let o = geofs.api.viewer.scene.pickPosition(new Cesium.Cartesian2(e,t), new Cesium.Cartesian3);
  if (o)
      return Cesium.Cartesian3.distance(a, o)
}
,
geofs.api.getModelFromScreenCoords = function(e, t) {
  return geofs.api.viewer.scene.pick(new Cesium.Cartesian2(e,t))
}
,
geofs.api.getNodeNameFromScreenCoords = function(e, t) {
  let a = geofs.api.getModelFromScreenCoords(e, t);
  return a && a.node ? a.node.name : null
}
,
geofs.api.getLlaFromScreencoordDepth = function(e, t, a) {
  var o = geofs.camera.cam.getPickRay(new Cesium.Cartesian2(e,t))
    , r = Cesium.Ray.getPoint(o, a);
  if (!isNaN(r.x)) {
      var n = Cesium.Cartographic.fromCartesian(r, null, new Cesium.Cartographic);
      return [n.latitude * RAD_TO_DEGREES, n.longitude * RAD_TO_DEGREES, n.height]
  }
}
,
geofs.api.getScreenCoordFromLla = function(e) {
  return Cesium.SceneTransforms.wgs84ToWindowCoordinates(geofs.api.viewer.scene, Cesium.Cartesian3.fromDegrees(e[1], e[0], e[2]))
}
,
geofs.api.xyz2lla = function(e, t) {
  var a = new Cesium.Matrix4
    , o = geofs.api.viewer.scene.globe.ellipsoid
    , r = Cesium.Cartesian3.fromDegrees(t[1], t[0], t[2]);
  Cesium.Transforms.eastNorthUpToFixedFrame(r, o, a);
  var n = new Cesium.Cartesian3(e[0],e[1],e[2])
    , s = Cesium.Matrix4.multiplyByPoint(a, n, new Cesium.Cartesian3)
    , c = Cesium.Cartographic.fromCartesian(s, o, new Cesium.Cartographic);
  return c ? [c.latitude * RAD_TO_DEGREES - t[0], c.longitude * RAD_TO_DEGREES - t[1], c.height - t[2]] : [0, 0, 0]
}
,
geofs.api.takeCanvasScreenShot = function(e) {
  let t = geofs.api.viewer.canvas.toDataURL("image/jpg");
  e.href = t
}
,
geofs.api.preferredCompositor = "css",
geofs.api.compositors = {},
geofs.api.compositors.css = function(e, t) {}
,
geofs.api.compositors.css.prototype = {
  name: "css",
  createLayer: function(e, t) {
      return new geofs.api.cssCompositorLayer(e,t)
  },
  render: function() {},
  destroy: function() {}
},
geofs.api.cssCompositorLayer = function(e, t) {
  let a = t ? "geofs-inline-overlay" : "geofs-overlay";
  this.container = e || ".geofs-overlay-container",
  this._$element = $('<div class="' + a + '"></div>').appendTo(this.container),
  this.inline = t,
  this.rotation = 0,
  this.positionX = 0,
  this.positionY = 0,
  this.frame = {
      x: 0,
      y: 0
  },
  this.size = {
      x: 0,
      y: 0
  },
  this.offset = {
      x: 0,
      y: 0
  }
}
,
geofs.api.cssCompositorLayer.prototype = {
  setDrawOrder: function(e) {
      (this._$mask || this._$element).css("z-index", e + geofs.api.overlayBaseZIndex)
  },
  setUrl: function(e) {
      e && (this.image = new Image,
      this.image.src = e,
      this.image.onload = () => {
          this.loaded()
      }
      ,
      this._$element.css("background-image", 'url("' + e + '")'))
  },
  setMask: function(e) {
      e && (this._$mask = $('<div class="geofs-overlay geofs-overlay-mask"></div>').appendTo(this.container),
      this._$mask.css("mask-image", 'url("' + e + '")'),
      this._$element.appendTo(this._$mask))
  },
  setText: function(e) {
      this._$element.html(e),
      this._$element.addClass("geofs-textOverlay")
  },
  setTitle: function(e) {
      this._$element.attr("title", e)
  },
  setClass: function(e) {
      this._$element.addClass(e)
  },
  setStyle: function(e) {
      this._$element.attr("style", e)
  },
  loaded: function() {
      this.naturalSize = {
          x: this.image.width,
          y: this.image.height
      },
      $(this).trigger("load")
  },
  setFrameSize: function(e) {
      this._$mask && (this._$mask.css("mask-size", e.x + "px " + e.y + "px"),
      this._$mask.css("width", e.x + "px"),
      this._$mask.css("height", e.y + "px")),
      this._$element.css("width", e.x + "px"),
      this._$element.css("height", e.y + "px"),
      this.frame = e
  },
  setVisibility: function(e) {
      e ? (this._$mask || this._$element).addClass("geofs-visible").removeClass("geofs-hidden") : (this._$mask || this._$element).addClass("geofs-hidden").removeClass("geofs-visible")
  },
  setAnchor: function(e) {
      let t = this._$mask || this._$element;
      t.css("margin-left", -e.x + "px "),
      t.css("margin-bottom", -e.y + "px ")
  },
  setRotationCenter: function(e) {
      var t = e.x + "px " + e.y + "px";
      this._$element.css("transform-origin", t)
  },
  setSize: function(e) {
      this._$element.css("background-size", e.x + "px " + e.y + "px"),
      this.size = e
  },
  setPosition: function(e) {
      if (this.inline)
          return;
      let t = this._$mask || this._$element;
      t.css("left", e.x + "px"),
      t.css("bottom", e.y + "px")
  },
  setPositionX: function(e) {
      this.inline || ((this._$mask || this._$element).css("left", e + "px"),
      this.positionX = e)
  },
  setPositionY: function(e) {
      this.inline || ((this._$mask || this._$element).css("bottom", e + "px"),
      this.positionY = e)
  },
  setOffset: function(e) {
      this.offset = e
  },
  setTranslation: function(e) {
      this._$element.css("background-position", this.offset.x + e.x + "px " + (this.offset.y + e.y) + "px")
  },
  setOpacity: function(e) {
      (this._$mask || this._$element).css("opacity", e)
  },
  setRotation: function(e) {
      var t = "rotate(" + fixAngle360(-e) + "deg)";
      this._$element.css("transform", t),
      this.rotation = e
  },
  getElement: function() {
      return this._$element[0]
  },
  destroy: function() {
      this.image && (this.image.onload = null,
      this.image = null),
      this._$mask && (this._$mask.remove(),
      this._$mask = null),
      this._$element.remove(),
      this._$element = null
  }
},
geofs.api.compositors.canvas = function(e, t) {
  let a = {
      width: t.size.x,
      height: t.size.y
  };
  this.container = e || ".geofs-overlay-container",
  this._$element = $('<div class="geofs-canvas-overlay"></div>').appendTo(this.container),
  this.canvasAPI = new geofs.api.Canvas(a),
  $(this.canvasAPI.canvas).appendTo(this._$element),
  this.layers = []
}
,
geofs.api.compositors.canvas.prototype = {
  name: "canvas",
  createLayer: function(e, t) {
      let a = new geofs.api.canvasCompositorLayer(this,t);
      return this.layers.push(a),
      a
  },
  render: function() {
      let e = this.canvasAPI.context;
      this.canvasAPI.clear("#00000000"),
      this.layers.forEach(t => {
          t.visibility && (e.globalAlpha = t.opacity,
          t.clip && (e.save(),
          e.beginPath(),
          e.arc(t.clip[0], t.clip[1], t.clip[2], 0, TWO_PI, !0),
          e.clip()),
          t.image && t.image.complete && this.canvasAPI.drawRotatedSprite({
              sprite: t.sprite,
              image: t.image,
              origin: t.origin,
              size: t.size,
              center: t.anchor,
              destination: t.position,
              rotation: t.rotation,
              translation: t.translation
          }),
          t.clip && e.restore(),
          e.globalAlpha = 1)
      }
      )
  },
  destroy: function() {
      this.canvasAPI.destroy(),
      this._$element && (this._$element.remove(),
      this._$element = null)
  }
},
geofs.api.canvasCompositorLayer = function(e, t) {
  this.compositor = e,
  this.rotation = 0,
  this.opacity = 1,
  this.anchor = {
      x: 0,
      y: 0
  },
  this.origin = [0, 0],
  this.position = [0, 0],
  this.size = [0, 0],
  this.frameSize = [0, 0],
  this.anchor = [0, 0],
  this.rotationCenter = [0, 0],
  this.offset = [0, 0]
}
,
geofs.api.canvasCompositorLayer.prototype = {
  setDrawOrder: function(e) {
      this.drawOrder = e
  },
  setUrl: function(e) {
      e && (this.image = this.compositor.canvasAPI.loadImage(e),
      this.image.onload = () => {
          this.loaded()
      }
      )
  },
  setMask: function(e, t) {
      e && (t ? this.clip = t : (this.mask = this.compositor.canvasAPI.loadImage(e),
      this.mask.onload = () => {
          this.maskNaturalSize = [this.mask.width, this.mask.height],
          this.maskCenter = [this.mask.width / 2, this.mask.height / 2]
      }
      ))
  },
  setText: function(e) {
      this.text = e
  },
  setTitle: function(e) {
      this.title = e
  },
  setClass: function(e) {},
  setStyle: function(e) {},
  loaded: function() {
      this.naturalSize = {
          x: this.image.width,
          y: this.image.height
      },
      this.sprite = [this.image.width, this.image.height],
      $(this).trigger("load")
  },
  setFrameSize: function(e) {
      this.frameSize = [e.x, e.y]
  },
  setVisibility: function(e) {
      void 0 !== e && (this.visibility = e)
  },
  setAnchor: function(e) {
      this.anchor = [e.x, this.frameSize[1] - e.y],
      this.anchor = V2.sub(this.anchor, this.offset)
  },
  setRotationCenter: function(e) {
      this.rotationCenter = [e.x, e.y]
  },
  setSize: function(e) {
      this.size = [e.x, e.y]
  },
  setPosition: function(e) {
      this.position = [e.x, e.y]
  },
  setPositionX: function(e) {
      this.position[0] = e
  },
  setPositionY: function(e) {
      this.position[1] = e
  },
  setOffset: function(e) {
      this.offset = [e.x, e.y],
      this.anchor = V2.sub(this.anchor, this.offset)
  },
  setTranslation: function(e) {
      this.translation = [-e.x, -e.y]
  },
  setOpacity: function(e) {
      this.opacity = e
  },
  setRotation: function(e) {
      this.rotation = -e * DEGREES_TO_RAD
  },
  getElement: function() {
      return this.compositor._$element
  },
  destroy: function() {
      this.image && (this.image.onload = null,
      this.image = null),
      this._$mask && (this._$mask.remove(),
      this._$mask = null),
      this._$element && (this._$element.remove(),
      this._$element = null)
  }
},
geofs.api.billboard = function(e, t, a) {
  a = Object.assign({
      collection: "default"
  }, a),
  e = e || [0, 0, 0],
  a.image = a.image || t,
  a.image += geofs.killCache,
  a.position = Cesium.Cartesian3.fromDegrees(e[1], e[0], e[2]),
  geofs.api.billboards[a.collection] || (geofs.api.billboards[a.collection] = geofs.api.viewer.scene.primitives.add(new Cesium.BillboardCollection({
      scene: geofs.api.viewer.scene,
      blendOption: Cesium.BlendOption.TRANSLUCENT
  }))),
  this._billboard = geofs.api.billboards[a.collection].add(a),
  this._lla = e,
  a.altitudeMode == geofs.api.ALTITUDE_RELATIVE && (this._billboard.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND),
  a.altitudeMode == geofs.api.CLAMP_TO_GROUND && (this._billboard.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND),
  a.opacity && this.setOpacity(a.opacity),
  a.scale && this.setScale(a.scale),
  a.rotation && this.setRotation(a.rotation),
  a.geofsFixCameraRotation && this.fixCameraRotation(),
  this._options = a
}
,
geofs.api.billboard.prototype = {
  setUrl: function(e) {
      if (!this._billboard)
          return
  },
  setVisibility: function(e) {
      this._billboard && (this._billboard.show = e)
  },
  setColor: function(e) {
      if (this._billboard) {
          var t = this.opacity || 1;
          e.alpha = t,
          this._billboard.color = e
      }
  },
  setCssColor: function(e) {
      this._billboard && (this._billboard.color = Cesium.Color.fromCssColorString(e))
  },
  setOpacity: function(e) {
      if (this._billboard) {
          var t = this._billboard.color || new Cesium.Color(1,1,1,1);
          t.alpha = e,
          this._billboard.color = t,
          this.opacity = e
      }
  },
  setRotation: function(e) {
      this._billboard && (this._billboard.rotation = e)
  },
  setScale: function(e) {
      this._billboard && (this._billboard.scale = e)
  },
  setLocation: function(e) {
      if (this._billboard) {
          if (!V3.isValid(e)) {
              geofs.debug.debugger();
              return
          }
          this._lla = e,
          this._billboard.position = Cesium.Cartesian3.fromDegrees(e[1], e[0], e[2])
      }
  },
  getLla: function(e) {
      return this._lla
  },
  fixCameraRotation: function() {
      this.rotationFixCallback = geofs.api.addFrameCallback( () => {
          this._billboard.rotation = geofs.camera.radianRoll
      }
      , "billboardsRotationFix")
  },
  destroy: function() {
      this._billboard && (geofs.api.removeFrameCallback(this.rotationFixCallback, "billboardsRotationFix"),
      geofs.api.billboards[this._options.collection].remove(this._billboard),
      this._billboard = null)
  }
},
geofs.api.groundTexture = function(e, t, a) {
  a = Object.assign({
      width: .001
  }, a),
  e = e || [0, 0, 0],
  a.image = a.image || t,
  a.image += geofs.killCache,
  a.position = Cesium.Cartesian3.fromDegrees(e[1], e[0], e[2]),
  this._entity = geofs.api.viewer.entities.add({
      polygon: {
          hierarchy: {
              positions: [new Cesium.Cartesian3.fromDegrees(e[1] - a.width,e[0] - a.width,0), new Cesium.Cartesian3.fromDegrees(e[1] + a.width,e[0] - a.width,0), new Cesium.Cartesian3.fromDegrees(e[1] + a.width,e[0] + a.width,0), new Cesium.Cartesian3.fromDegrees(e[1] - a.width,e[0] + a.width,0)]
          },
          material: new Cesium.ImageMaterialProperty({
              image: a.image
          }),
          classificationType: Cesium.ClassificationType.TERRAIN,
          stRotation: 0,
          shadows: Cesium.ShadowMode.ENABLED
      },
      interleave: !1,
      allowPicking: !1
  }),
  this.lla = e,
  this._options = a,
  a.opacity && this.setOpacity(a.opacity),
  a.scale && this.setScale(a.scale),
  a.rotation && this.setRotation(a.rotation)
}
,
geofs.api.groundTexture.prototype = {
  setUrl: function(e) {
      this._entity && (this._entity.polygon.material.image = e)
  },
  setVisibility: function(e) {
      this._entity && (this._entity.show = e)
  },
  setColor: function(e) {
      if (this._entity) {
          var t = this.opacity || 1;
          e.alpha = t,
          this._entity.polygon.material.color = e
      }
  },
  setOpacity: function(e) {
      if (this._entity) {
          var t = this._entity.polygon.material.color || new Cesium.Color(1,1,1,1);
          t.alpha = e,
          this._entity.polygon.material.color = t,
          this.opacity = e
      }
  },
  setRotation: function(e) {
      this._entity && (this._entity.stRotation = e)
  },
  setScale: function(e) {
      this._entity && (this.scale = e,
      this.setLocation(this.lla))
  },
  setLocation: function(e) {
      if (!this._entity)
          return;
      if (!V3.isValid(e)) {
          geofs.debug.debugger();
          return
      }
      this.lla = e;
      let t = this._options.width * this.scale;
      this._entity.hierarchy = [new Cesium.Cartesian3.fromDegrees(e[1] - t,e[0] - t,0), new Cesium.Cartesian3.fromDegrees(e[1] + t,e[0] - t,0), new Cesium.Cartesian3.fromDegrees(e[1] + t,e[0] + t,0), new Cesium.Cartesian3.fromDegrees(e[1] - t,e[0] + t,0)]
  },
  getLla: function(e) {
      return this.lla
  },
  destroy: function() {
      this._entity && (geofs.api.viewer.entities.remove(this._entity),
      this._entity = null)
  }
},
geofs.api.notify = function(e, t, a) {
  $.haring.create(e, t || "OK", a)
}
,
geofs.api.analytics = {
  init: function() {},
  event: function(e, t, a, o) {
      window.gtag && window.gtag("event", t, {
          event_category: e,
          event_label: a,
          value: o
      })
  }
},
geofs.api.postMessage = function(e) {
  window.top.postMessage(e, "*")
}
,
geofs.api.Canvas = function(e) {
  this.canvas = document.createElement("canvas"),
  this.width = this.canvas.width = e.width,
  this.height = this.canvas.height = e.height;
  let t = {};
  e.willReadFrequently && (t.willReadFrequently = !0),
  this.context = this.canvas.getContext("2d", t),
  e.color = e.color || "#000000",
  this._options = e,
  this.patchSize = e.patchSize || e.width,
  this.context.fillStyle = e.color,
  this.context.fillRect(0, 0, this.canvas.width, this.canvas.height),
  this.images = {},
  this.imageIndex = 0
}
,
geofs.api.Canvas.prototype = {
  loadTiles: function(e) {
      return Array.isArray(e) || (e = [e]),
      this.patchSize = this.canvas.width / Math.sqrt(e.length),
      this.imagesToLoad = e.length,
      this.imagesLoaded = 0,
      this.context.fillStyle = this._options.color,
      this.context.fillRect(0, 0, this.canvas.width, this.canvas.height),
      this._options.blur && (this.context.filter = "blur(" + this._options.blur + "px)"),
      new Promise(t => {
          e.forEach( (e, a) => {
              let o = this.loadImage(e, a);
              o.onload = e => {
                  ++this.imagesLoaded == this.imagesToLoad && this.paintAndResolve(t)
              }
              ,
              o.onerror = e => {
                  ++this.imagesLoaded == this.imagesToLoad && this.paintAndResolve(t)
              }
          }
          )
      }
      )
  },
  paintAndResolve: function(e) {
      var t = this.canvas.width / this.patchSize;
      for (var a in this.images)
          try {
              this.context.drawImage(this.images[a], this.patchSize * (a % t), this.patchSize * Math.floor(a / t), this.patchSize, this.patchSize)
          } catch (o) {}
      e(this.canvas)
  },
  clear: function(e) {
      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height),
      e && (this.context.fillStyle = e,
      this.context.fillRect(0, 0, this.canvas.width, this.canvas.height))
  },
  loadImage: function(e, t) {
      return void 0 == t && (t = this.imageIndex++),
      this.images[t] = this.images[t] || new Image,
      this.images[t].crossOrigin = "anonymous",
      this.images[t].src = e,
      this.images[t]
  },
  drawRotatedSprite: function(e) {
      let t = e.image;
      if (!t.complete)
          return;
      let a = this.context;
      e.sprite = e.sprite || e.size,
      a.save(),
      a.translate(e.destination[0], e.destination[1]),
      a.rotate(e.rotation),
      e.translation = e.translation || [0, 0];
      let o = V2.parseInt(V2.add(e.center, e.translation));
      a.drawImage(t, e.origin[0], e.origin[1], e.sprite[0], e.sprite[1], -o[0], -o[1], e.size[0], e.size[1]),
      a.restore()
  },
  drawSprite: function(e) {
      let t = e.image;
      if (!t.complete)
          return;
      let a = this.context;
      e.sprite = e.sprite || e.size,
      e.center = e.center || [0, 0],
      e.translation = e.translation || [0, 0],
      e.destination = V2.add(V2.sub(e.destination, e.center), e.translation),
      a.drawImage(t, e.origin[0], e.origin[1], e.sprite[0], e.sprite[1], e.destination[0], e.destination[1], e.size[0], e.size[1])
  },
  getImageAsURLData: function() {
      if (!this.canvas.toBlob)
          return this.canvas.toDataURL();
      this.canvas.toBlob(e => URL.createObjectURL(e))
  },
  destroy: function() {
      for (var e in this.images)
          this.images[e] = null;
      this.images = null,
      $(this.canvas).remove()
  }
},
geofs.api.FlatRunwayTerrainProvider = function(e) {
  this.baseProvider = e.baseProvider,
  this.regions = {},
  this.tiles = {},
  this.defaultMinFlatteningLevel = 6,
  this.minFlatteningLevel = 6,
  this.maximumLevel = 12,
  this.maximumLevel = e.maximumLevel || this.maximumLevel,
  this.flatten = !e.bypass,
  this.setMaximumLevel(this.maximumLevel);
  var t = () => {
      for (var e in this.regions = {},
      geofs.runways.nearRunways)
          this.addRunway(geofs.runways.nearRunways[e])
  }
  ;
  $(document).on("runwayUpdate", t),
  t()
}
,
geofs.api.FlatRunwayTerrainProvider.prototype = {
  aName: "FlatRunwayTerrainProvider",
  get availability() {
      return this.baseProvider.availability
  },
  get credit() {
      return this.baseProvider.credit
  },
  get _tileCredits() {
      return this.baseProvider._tileCredits
  },
  get errorEvent() {
      return this.baseProvider.errorEvent
  },
  get hasMetadata() {
      return this.baseProvider.hasMetadata
  },
  get _layers() {
      return this.baseProvider._layers
  },
  get hasVertexNormals() {
      return this.baseProvider.hasVertexNormals
  },
  get requestMetadata() {
      return this.baseProvider.requestMetadata
  },
  get requestVertexNormals() {
      return this.baseProvider.requestVertexNormals
  },
  get hasWaterMask() {
      return this.baseProvider.hasWaterMask
  },
  get _ready() {
      return this.baseProvider._ready
  },
  get ready() {
      return this.baseProvider.ready
  },
  get readyPromise() {
      return this.baseProvider.readyPromise
  },
  get tilingScheme() {
      return this.baseProvider.tilingScheme
  },
  getLevelMaximumGeometricError: function(e) {
      return this.baseProvider.getLevelMaximumGeometricError(e)
  },
  getTileDataAvailable: function(e, t, a) {
      return !(a > this.maximumLevel) && this.baseProvider.getTileDataAvailable(e, t, a)
  },
  setMaximumLevel: function(e) {
      e < this.defaultMinFlatteningLevel ? this.minFlatteningLevel = e : this.minFlatteningLevel = this.defaultMinFlatteningLevel,
      this.maximumLevel = e
  },
  addRunway: function(e) {
      var t = xy2ll([e.padding, e.padding], e.threshold1);
      e.rec = Cesium.Rectangle.fromDegrees(Math.min(e.threshold1[1], e.threshold2[1]) - t[1], Math.min(e.threshold1[0], e.threshold2[0]) - t[0], Math.max(e.threshold1[1], e.threshold2[1]) + t[1], Math.max(e.threshold1[0], e.threshold2[0]) + t[0]),
      e.threshold1Cartesian = Cesium.Cartesian3.fromDegrees(e.threshold1[1], e.threshold1[0]),
      e.threshold2Cartesian = Cesium.Cartesian3.fromDegrees(e.threshold2[1], e.threshold2[0]),
      e.direction = Cesium.Cartesian3.subtract(e.threshold1Cartesian, e.threshold2Cartesian, new Cesium.Cartesian3);
      var a = {
          name: e.id,
          rec: e.rec,
          runways: [e],
          coord: geofs.mainAirportList[e.icao],
          vertices: {}
      };
      for (var o in this.regions) {
          var r = this.regions[o];
          void 0 !== Cesium.Rectangle.intersection(r.rec, a.rec) && (a.rec = Cesium.Rectangle.union(a.rec, r.rec),
          a.name += r.name,
          a.runways = a.runways.concat(r.runways),
          delete this.regions[o])
      }
      this.regions[a.name] = a
  },
  requestTileGeometry: function e(t, a, o, r) {
      if (o >= this.minFlatteningLevel && this.flatten) {
          var n = this.baseProvider.tilingScheme.tileXYToRectangle(t, a, o);
          for (var s in this.regions)
              if (void 0 !== Cesium.Rectangle.intersection(this.regions[s].rec, n)) {
                  var c = this.baseProvider.requestTileGeometry(t, a, o, r);
                  if (void 0 === c)
                      return;
                  return this.getPromise(c, n, this.regions[s])
              }
      }
      return this.baseProvider.requestTileGeometry(t, a, o, r)
  },
  getPromise: function e(t, a, o) {
      if (void 0 !== t) {
          var r;
          return Promise.all([new Promise( (e, t) => {
              o.referenceElevation ? e(o.referenceElevation) : (o.coord || (o.coord = [o.runways[0].threshold1[0], o.runways[0].threshold1[1]]),
              Cesium.sampleTerrain(this.baseProvider, this.maximumLevel, [Cesium.Cartographic.fromDegrees(o.coord[1], o.coord[0])]).then(a => {
                  a[0] && a[0].height ? (o.referenceElevation = a[0].height,
                  o.runways.forEach(e => {
                      e.setElevation(o.referenceElevation)
                  }
                  ),
                  e(o.referenceElevation)) : t("no value")
              }
              ))
          }
          ), t]).then(e => {
              try {
                  for (var t = e[0], r = e[1], n = 0; n < o.runways.length; n++) {
                      var s = o.runways[n]
                        , c = 32767
                        , d = !1;
                      r._oldMinimumHeight = r._minimumHeight,
                      r._oldMaximumHeight = r._maximumHeight;
                      var u = r._oldMaximumHeight - r._oldMinimumHeight
                        , p = c / u;
                      t > r._maximumHeight && (r._maximumHeight = t,
                      d = !0),
                      t < r._minimumHeight && (r._minimumHeight = t,
                      d = !0);
                      for (var h = r._oldMinimumHeight - r._minimumHeight, m = r._maximumHeight - r._minimumHeight, f = c / m, g = (t - r._minimumHeight) * f, y = 0; y < r._heightValues.length; y++) {
                          var v = a.south + a.height * (r._quantizedVertices[r._heightValues.length + y] / c)
                            , _ = a.west + a.width * (r._quantizedVertices[y] / c);
                          if (Cesium.Rectangle.contains(o.rec, new Cesium.Cartographic(_,v,0))) {
                              var b = Cesium.Cartesian3.fromRadians(_, v);
                              Cesium.Cartesian3.subtract(s.threshold1Cartesian, b, b);
                              var x = Cesium.Cartesian3.magnitude(b)
                                , S = Cesium.Cartesian3.multiplyByScalar(s.direction, Cesium.Cartesian3.dot(b, s.direction) / Cesium.Cartesian3.dot(s.direction, s.direction), new Cesium.Cartesian3)
                                , P = Cesium.Cartesian3.subtract(b, S, new Cesium.Cartesian3);
                              if (Math.sqrt(Cesium.Cartesian3.dot(P, P)) < s.padding && x < s.lengthMeters + s.padding) {
                                  r._heightValues[y] = g;
                                  continue
                              }
                          }
                          d && (r._heightValues[y] = (r._heightValues[y] / p + h) * f)
                      }
                  }
                  return r
              } catch (A) {
                  geofs.debug.log("FlatRunwayTerrainProvider promise: " + A)
              }
          }
          )
      }
  }
},
geofs.api.waterDetection = {
  initialized: !1,
  canvasAPI: null,
  blur: 0,
  backgroundColour: "#000000",
  depthSlope: .03,
  depthOffset: 1.5,
  tileSize: 256,
  zoomLevel: 11,
  lastTileURL: null,
  lastDepth: 0,
  create: function() {
      this.canvasAPI = new geofs.api.Canvas({
          width: this.tileSize,
          height: this.tileSize,
          color: this.backgroundColour,
          willReadFrequently: !0
      }),
      this.initialized = !0
  },
  reset: function() {
      this.lastDepth = 0
  },
  getWaterDepth: function(e, t) {
      if (!this.initialized)
          return null;
      let a = geofs.coord2tile(e, t, this.zoomLevel)
        , o = geofs.landuseServer + this.zoomLevel + "/" + a.x + "/" + a.y + ".png";
      if (this.lastTileURL != o) {
          this.canvasAPI.context.filter = "blur(" + this.blur + "px)",
          this.canvasAPI.loadTiles(o),
          this.lastTileURL = o,
          this.tileOrigin = geofs.tile2coord(a.x, a.y, this.zoomLevel);
          let r = geofs.tile2coord(a.x + 1, a.y + 1, this.zoomLevel);
          return this.pixelGeographicSize = {
              lat: (r.lat - this.tileOrigin.lat) / this.tileSize,
              lon: (r.lon - this.tileOrigin.lon) / this.tileSize
          },
          this.lastDepth
      }
      {
          let n, s;
          n = {
              x: Math.round((t - this.tileOrigin.lon) / this.pixelGeographicSize.lon),
              y: Math.round((e - this.tileOrigin.lat) / this.pixelGeographicSize.lat)
          };
          var c = this.canvasAPI.context.getImageData(n.x, n.y, 1, 1).data;
          return s = this.depthSlope * c[2] - this.depthOffset,
          geofs.cautiousWithTerrain && (s = 0),
          this.lastDepth = s,
          s
      }
  },
  destroy: function() {
      this.canvasAPI && (this.canvasAPI.destroy(),
      this.canvasAPI = null),
      this.initialized = !1
  }
},
geofs.api.tileLayerConstructor = L.tileLayer.fallback,
geofs.api.mapMaxZoom = 13,
geofs.api.mapOption = {
  minZoom: 3,
  maxZoom: geofs.api.mapMaxZoom,
  markerZoomAnimation: !1,
  worldCopyJump: !0,
  preferCanvas: !0,
  attributionControl: !1
},
geofs.api.mapTooltipOptions = {
  permanent: !1
},
geofs.api.toolTipPositioning = [{
  direction: "top",
  offset: L.point(0, -15)
}, {
  direction: "right",
  offset: L.point(15, 0)
}, {
  direction: "bottom",
  offset: L.point(0, 15)
}, {
  direction: "left",
  offset: L.point(-15, 0)
}],
geofs.api.map = {
  defaultMarker: {
      coords: [0, 0],
      radius: 5,
      color: "#ffffff",
      weight: 2,
      fillColor: "#000000",
      fillOpacity: 1,
      pane: "markerPane",
      popupMinWidth: 200,
      popupMaxWidth: 400
  },
  markerByMinZoom: [[], [], [], [], [], [], [], [], [], [], [], [], [], []],
  markerLayers: {
      navaid: {
          minZoom: 6,
          maxZoom: 15,
          tileSize: 5,
          tiles: {}
      },
      major: {
          minZoom: 6,
          maxZoom: 15,
          tileSize: 5,
          tiles: {}
      },
      minor: {
          minZoom: 8,
          maxZoom: 15,
          tileSize: 5,
          tiles: {}
      }
  },
  defaultLayer: {
      minZoom: 0,
      maxZoom: 15,
      tileSize: 10,
      tiles: {}
  },
  init: function(e, t, a) {
      e.zoom = e.zoom || 10,
      this._holder = e.holder || $(".geofs-map-viewport")[0],
      this._holder = e.holder || $(".geofs-map-viewport")[0],
      this._map = L.map(this._holder, geofs.api.mapOption),
      geofs.api.tileLayerConstructor(geofs.osmTileProvider, {
          attribution: "\xa9 OpenStreetMap contributors - Made with Natural Earth."
      }).addTo(this._map),
      this._map.zoomControl.setPosition("bottomleft"),
      this.icons = {},
      this._map.on("load resize moveend", () => {
          this.updateMarkerLayers()
      }
      ),
      this._map.on("zoomend", () => {
          for (var e in this._map.getZoom(),
          this.updateMarkerVisibility(),
          ui.playerMarkers) {
              var t = ui.playerMarkers[e]._marker;
              t._icon && (t._icon.style.transform += " rotate(" + t._geofsRotation + "deg)")
          }
          this.updateMarkerLayers()
      }
      ),
      this._map.getPane("tooltipPane").style.opacity = .9,
      this._map.getPane("overlayPane").style.opacity = .7,
      this._genericPopup = L.popup({
          closeButton: !1
      }),
      this._map.setView(L.latLng(t, a), e.zoom),
      this._map.on("mouseup", controls.mouseUpHandler),
      $(document).on("click ", ".geofs-createPath", () => {
          geofs.api.map.flightPathOn ? geofs.api.map.stopCreatePath(this) : geofs.api.map.createPath()
      }
      ).on("click", ".geofs-clearPath", () => {
          geofs.api.map.clearPath(this)
      }
      )
  },
  updateMap: function(e, t, a) {
      let o = L.latLng(e, t);
      if (a) {
          let r = this._map.project(o);
          r = new L.point(r.x + a[0],r.y + a[1]),
          o = this._map.unproject(r)
      }
      this._map.panTo(o)
  },
  getCenterLla: function(e, t) {
      var a = this._map.getCenter();
      return [a.lat, a.lng]
  },
  getPixelSize: function() {
      return this._map.getSize()
  },
  llaToPixel: function(e) {
      return this._map.latLngToContainerPoint(L.latLng(e[0], e[1]))
  },
  getIcon: function(e, t) {
      return this.icons[e] || (t.url ? this.icons[e] = L.icon({
          iconUrl: t.url,
          iconSize: t.size || [0, 0],
          iconAnchor: t.anchor || [0, 0],
          popupAnchor: [0, 0],
          opacity: t.opacity,
          className: t.className
      }) : this.icons[e] = L.divIcon({
          className: t.className
      })),
      this.icons[e]
  },
  addLayer: function(e) {
      return this._map.createPane(e)
  },
  addLayeredMarker: function(e, t) {
      var a = geofs.api.map.markerLayers[e]
        , o = geofs.getLatLonMatrixcoord(t.coords[0], t.coords[1], a.tileSize);
      geofs.api.map.markerLayers[e] || (geofs.api.map.markerLayers[e] = Object.assign({}, geofs.api.map.defaultLayer)),
      geofs.api.map.markerLayers[e].visibileTiles = {},
      geofs.api.map.markerLayers[e].tiles[o] || (geofs.api.map.markerLayers[e].tiles[o] = []),
      geofs.api.map.markerLayers[e].tiles[o].push(t)
  },
  getVisibleTiles: function(e, t) {
      for (var a = e.getNorthEast().wrap(), o = e.getSouthWest().wrap(), r = Math.floor(o.lng / t), n = Math.floor(o.lat / t), s = (parseInt((a.lng - o.lng) / t) || 1) + 2, c = (parseInt((a.lat - o.lat) / t) || 1) + 2, d = {}, u = r; u < r + s; u++)
          for (var p = n; p < n + c; p++)
              d[p + "/" + u] = !0;
      return d
  },
  showTile: function(e, t) {
      e.tiles[t] && (e.tiles[t].forEach(e => {
          e.marker || (e.marker = new geofs.api.map.marker(e)),
          e.marker.addToMap(),
          e.marker._marker.options.keepToFront && e.marker._marker.bringToFront()
      }
      ),
      e.visibileTiles[t] = e.tiles[t])
  },
  hideTile: function(e, t) {
      e.visibileTiles && e.visibileTiles[t] && e.tiles[t] && (e.tiles[t].forEach(e => {
          e.marker && (e.marker.destroy(),
          e.marker = null)
      }
      ),
      delete e.visibileTiles[t])
  },
  updateMarkerLayers: function() {
      var e = this._map.getZoom();
      for (var t in geofs.api.map.markerLayers) {
          var a = geofs.api.map.markerLayers[t];
          if (e > a.minZoom && e < a.maxZoom) {
              var o = this.getVisibleTiles(this._map.getBounds(), a.tileSize);
              for (var r in a.visibileTiles)
                  o[r] || this.hideTile(a, r);
              for (var r in o)
                  this.showTile(a, r)
          } else
              for (var r in a.visibileTiles)
                  this.hideTile(a, r)
      }
  },
  updateMarkerVisibility: function() {
      for (var e = this._map.getZoom(), t = 0; t < this.markerByMinZoom.length; t++)
          this.markerByMinZoom[t].hidden ? t <= e && (this.markerByMinZoom[t].forEach(e => {
              e.addToMap(),
              e._marker.options.keepToFront && e._marker.bringToFront()
          }
          ),
          this.markerByMinZoom[t].hidden = !1) : t > e && (this.markerByMinZoom[t].forEach(e => {
              e.removeFromMap()
          }
          ),
          this.markerByMinZoom[t].hidden = !0)
  },
  getCoordsFromMouseEvent: function(e) {
      return [e.latlng.lat, e.latlng.lng]
  },
  isGenericPopupOpen: function() {
      return !!this._genericPopup._map
  },
  closeGenericPopup: function() {
      this._genericPopup.closePopup()
  },
  openGenericPopup: function(e, t) {
      this._genericPopup.closePopup(),
      this._genericPopup.setContent(e).setLatLng(L.latLng(t[0], t[1])).openOn(this._map)
  },
  closeAllPopups: function() {
      this._map.closePopup()
  },
  setTooltipVisibility: function(e) {
      geofs.api.mapTooltipOptions.permanent = e
  },
  addImageLayer: function(e, t, a) {
      return L.imageOverlay(e, a || [[90, -180], [-90, 180]], {
          opacity: t
      }).addTo(this._map)
  },
  removeImageLayer: function(e) {
      e.remove()
  }
},
geofs.api.map.marker = function(e) {
  if ((e = Object.assign({}, geofs.api.map.defaultMarker, e)).zIndexOffset = e.zIndex,
  e.img ? (e.img.offset && (e.img.rotate && (e.img.offset = V3.rotate([e.img.offset[0], e.img.offset[1], 0], [0, 0, 1], e.img.rotate * DEGREES_TO_RAD)),
  e.img.offset = {
      x: e.img.offset[0],
      y: e.img.offset[1]
  }),
  this._marker = L.canvasMarker(e.coords, e)) : e.icon ? (e.opacity = e.opacity || e.icon.options.opacity,
  this._marker = L.marker(e.coords, e)) : this._marker = L.circleMarker(e.coords, e),
  e.popup && this._marker.bindPopup(e.popup, {
      minWidth: e.popupMinWidth,
      maxWidth: e.popupMaxWidth,
      closeButton: !1
  }),
  e.label) {
      this.label = e.label;
      var e = Object.assign({}, geofs.api.mapTooltipOptions, geofs.api.toolTipPositioning[Math.floor(4 * Math.random())]);
      this._marker.bindTooltip(this.label, e)
  }
  e.minZoom && e.minZoom <= geofs.api.mapMaxZoom && geofs.api.map.markerByMinZoom[e.minZoom].push(this)
}
,
geofs.api.map.marker.prototype = {
  addToMap: function(e, t) {
      this._marker.addTo(e || geofs.api.map._map)
  },
  removeFromMap: function() {
      this._marker.remove()
  },
  update: function(e, t, a, o) {
      e && t && this._marker.setLatLng(L.latLng(e, t)),
      o && (this.label = o,
      this._marker.setTooltipContent(o)),
      a && this._marker._icon && (this._marker._geofsRotation = a,
      this._marker._icon.style.transform += " rotate(" + this._marker._geofsRotation + "deg)")
  },
  destroy: function() {
      this._marker.unbindTooltip(),
      this._marker.unbindPopup(),
      this._marker.remove()
  },
  resetTooltip: function() {
      if (this._marker) {
          this._marker.unbindTooltip();
          var e = Object.assign({}, geofs.api.mapTooltipOptions, geofs.api.toolTipPositioning[Math.floor(4 * Math.random())]);
          this._marker.bindTooltip(this.label, e)
      }
  }
},
geofs.api.map.path = [],
geofs.api.map.createPath = function(e, t, a) {
  e = e || geofs.api.map.path;
  let o = L.polyline(t, a).addTo(geofs.api.map._map);
  return e.push(o),
  o
}
,
geofs.api.map.createGreatCirclePath = function(e, t, a, o) {
  e = e || geofs.api.map.path;
  let r = L.Polyline.Arc(t, a, o).addTo(geofs.api.map._map);
  return e.push(r),
  r
}
,
geofs.api.map.clearPath = function(e) {
  (e = e || geofs.api.map.path).forEach(e => {
      e.remove()
  }
  ),
  e = []
}
,
geofs.api.reverserGeocode = function(e, t) {
  var a = "/backend/geocode/geocode.php?query=" + e;
  jQuery.getJSON(a, e => {
      try {
          e.lat && e.lon && t(e.lat, e.lon)
      } catch (a) {}
  }
  )
}
,
geofs.api.pixelDensityMobileThreshold = 1.5,
geofs.api.testIfMobileDevice = function() {
  let e = geofs.api.hasTouch() && geofs.api.hasOrientation() && window.devicePixelRatio >= geofs.api.pixelDensityMobileThreshold;
  return !!geofs.isApp || !!geofs.forceMobileMode || !!e
}
,
geofs.api.hasTouch = function() {
  return !!navigator.maxTouchPoints
}
,
geofs.api.hasOrientation = function() {
  return !!window.DeviceOrientationEvent
}
,
geofs.api.getPlatform = function() {
  return geofs.platform ? geofs.platform : null
}
,
geofs.api.doRetro = function() {
  if (!geofs.retroOn) {
      var e;
      geofs.aircraftList[2e3] = {
          name: "Retro 172",
          dir: "|models|aircraft|retro|c172|",
          multiplayerFiles: "multiplayer.gltf,multiplayer-low.gltf",
          path: "/models/aircraft/retro/c172/"
      },
      geofs.retroOn = !0,
      clearInterval(weather.interval),
      weather.refresh = function() {}
      ,
      weather.update = function() {}
      ,
      geofs.aircraft.instance.change(2e3).then( () => {
          audio.impl.html5.playFile("/sounds/retro/chiptune.mp3", 1e3),
          geofs.useSimpleShadow(!0);
          var e = Cesium.Color.fromCssColorString("#2caecf")
            , t = Cesium.Color.fromCssColorString("#0b2740");
          geofs.fx.water.material = new Cesium.Material({
              fabric: {
                  type: "retrowire",
                  source: geofsShaders["wireFS.glsl"],
                  uniforms: {
                      windSpeed: 0,
                      geofsTime: 0,
                      wireframeColor: e,
                      backgroundColor: t
                  }
              }
          }),
          geofs.api.viewer.scene.globe.material = geofs.fx.water.material;
          var a = geofs.api.viewer.entities.add({
              position: Cesium.Cartesian3.fromDegrees(0, 0, 1e6),
              billboard: {
                  image: "images/retro/sun.png",
                  show: !0,
                  pixelOffset: new Cesium.Cartesian2(0,0),
                  eyeOffset: new Cesium.Cartesian3(0,0,0),
                  horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                  verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                  width: 256,
                  height: 256
              }
          });
          geofs.api.addFrameCallback(function() {
              a.position = new Cesium.Cartesian3.fromDegrees(geofs.aircraft.instance.llaLocation[1] - 10,geofs.aircraft.instance.llaLocation[0],1e4)
          }),
          geofs.fx.atmosphere.create(!1, 0, !1, !1, !0),
          geofs.api.viewer.scene.skyAtmosphere.hueShift = .3,
          geofs.api.viewer.scene.skyAtmosphere.brightnessShift = -.2,
          geofs.api.viewer.scene.skyAtmosphere.saturationShift = .2,
          geofs.api.viewer.scene.skyBox.show = !1,
          geofs.api.viewer.scene.sun.show = !1,
          geofs.api.viewer.scene.fog.density = 8e-5,
          geofs.runways.modelVisibility = !0,
          geofs.runways.redraw(),
          geofs.buildings.buildingsShader && (geofs.buildings.buildingsShader && geofs.buildings.buildingsShader.setUniform("u_retro", !0),
          geofs.buildings.buildingsShader.setUniform("u_buildingTexture", new Cesium.TextureUniform({
              url: "shaders/buildings/retro.jpg",
              minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR
          })),
          geofs.buildings.buildingsShader.setUniform("u_specularTexture", new Cesium.TextureUniform({
              url: "shaders/black.jpg"
          }))),
          geofs.trees.shader && geofs.trees.shader.setUniform("u_treeTexture", new Cesium.TextureUniform({
              url: "shaders/trees/retro.png",
              minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR
          }))
      }
      )
  }
}
,
geofs.api.color = {
  pixelToHex: function(e) {
      return Cesium.Color.fromBytes(e[0], e[1], e[2], e[3] || 255).toCssHexString()
  },
  bytesToHex: function(e, t, a, o) {
      return Cesium.Color.fromBytes(e, t, a, o || 255).toCssHexString()
  },
  compareRGBBytes: function(e, t) {
      return e.forEach( (e, a) => {
          if (e != t[a])
              return !1
      }
      ),
      !0
  },
  mix: function(e, t, a) {
      return Cesium.Color.lerp(e, t, a, new Cesium.Color)
  },
  mixArray: function(e, t) {
      let a = e.length - 1
        , o = t * a
        , r = parseInt(o)
        , n = clamp(parseInt(o + 1), 0, a)
        , s = e[r]
        , c = e[n]
        , d = o - Math.floor(o);
      return Cesium.Color.lerp(s, c, d, new Cesium.Color)
  }
},
geofs.runways = geofs.runways || {
  nearRunways: [],
  tempRunways: [],
  lastRunwayTestLocation: [0, 0],
  runwayNumberLimit: 6,
  refreshRate: 1e4,
  refreshDistanceThreshold: .1,
  modelVisibility: !1,
  defaultPadding: 1e3,
  defaultWidth: 200,
  defaultLength: 1e4,
  tileLength: 582,
  modelRunwayWidth: 60,
  thresholdToAimingPoint: 350,
  thresholdLength: 582,
  modelVerticalOffset: .1,
  imageryLayers: [],
  imageryOpacity: .6,
  init() {},
  redraw: function() {
      geofs.runways.modelVisibility && (geofs.runways.setRunwayModelVisibility(!1),
      geofs.runways.setRunwayModelVisibility(!0))
  },
  refresh: function() {
      var e = geofs.aircraft.instance.llaLocation;
      if (clearInterval(geofs.runwaysCheckTimeout),
      geofs.runwaysCheckTimeout = setInterval(geofs.runways.refresh, geofs.runways.refreshRate),
      !(V2.length(V2.sub(e, geofs.runways.lastRunwayTestLocation)) < geofs.runways.refreshDistanceThreshold)) {
          geofs.runways.lastRunwayTestLocation = e;
          for (var t = geofs.runways.getNearRunways(e, geofs.runways.runwayNumberLimit), a = {}, o = 0; o < t.length; o++) {
              var r = geofs.runways.generateRunwayId(t[o]);
              a[r] || (geofs.runways.nearRunways[r] ? a[r] = geofs.runways.nearRunways[r] : a[r] = geofs.runways.newRunwayFromGridRecord(t[o], r))
          }
          for (var o in geofs.runways.nearRunways)
              a[o] || geofs.runways.nearRunways[o].destroy();
          for (var o in geofs.runways.nearRunways = Object.assign({}, a),
          geofs.runways.nearRunways) {
              let n = geofs.runways.nearRunways[o];
              geofs.runways.modelVisibility && n.generateRunwayModel(),
              n.addPAPIs(),
              n.setElevation()
          }
          $("body").trigger("runwayUpdate")
      }
  },
  reset: function() {
      Object.keys(geofs.runways.nearRunways).forEach(e => geofs.runways.nearRunways[e].destroy()),
      geofs.runways.nearRunways = {},
      geofs.runways.refresh()
  },
  getNearestRunway: function(e) {
      var t, a = 1;
      do
          t = geofs.runways.getNearRunways(e, 1, a++);
      while (!t.length && a < 10);
      if (t[0]) {
          var o = t[0]
            , r = geofs.runways.generateRunwayId(o);
          return geofs.runways.nearRunways[r] || (geofs.runways.nearRunways[r] = geofs.runways.newRunwayFromGridRecord(o, r)),
          geofs.runways.nearRunways[r]
      }
      return null
  },
  getNearRunways: function(e, t, a) {
      a = a || 1,
      t = t || geofs.runways.runwayNumberLimit;
      for (var o, r = parseInt(e[0]), n = parseInt(e[1]), s = [], c = -a; c <= a; c++) {
          o = geofs.majorRunwayGrid[n + c] || {};
          for (var d = -a; d <= a; d++)
              o[r + d] && (s = s.concat(o[r + d]))
      }
      return geofs.runways.setRunwayDistance(e, s),
      s.sort( (e, t) => e.distance - t.distance),
      s.slice(0, t)
  },
  setRunwayDistance: function(e, t) {
      for (var a = 0, o = t.length; a < o; a++) {
          var r = t[a];
          r.distance = geofs.utils.llaDistanceInMeters(e, [r[4], r[5]])
      }
  },
  setRunwayModelVisibility: function(e) {
      Object.keys(geofs.runways.nearRunways).forEach(t => {
          geofs.runways.nearRunways[t].destroyRunwayModel(),
          e && geofs.runways.nearRunways[t].generateRunwayModel()
      }
      ),
      geofs.runways.modelVisibility = e
  },
  toggleRunwayCircuit: function(e) {
      this.tempRunways[e] = this.tempRunways[e] || geofs.runways.newRunwayFromNavaidId(e),
      this.tempRunways[e].circuitModelA ? (this.tempRunways[e].hideCircuit(),
      this.tempRunways[e].destroy()) : this.tempRunways[e].showCircuit()
  },
  setCircuitVisibility: function(e) {
      Object.keys(geofs.runways.nearRunways).forEach(t => {
          geofs.runways.nearRunways[t].hideCircuit(),
          e && geofs.runways.nearRunways[t].showCircuit()
      }
      ),
      geofs.preferences.circuits = e
  },
  env: {},
  getRotationCanvas: function(e) {
      return geofs.runways.env[e] || (geofs.runways.env[e] = {},
      geofs.runways.env[e].promise = new Promise(t => {
          let a = document.createElement("img");
          a.onload = a => {
              var o = a.currentTarget
                , r = document.createElement("canvas");
              r.width = o.width,
              r.height = o.width,
              geofs.runways.env[e].image = o,
              geofs.runways.env[e].canvas = r,
              geofs.runways.env[e].context = r.getContext("2d"),
              geofs.runways.env[e].context.translate(o.width / 2, o.width / 2),
              t(geofs.runways.env[e])
          }
          ,
          a.src = e
      }
      ),
      geofs.runways.env[e].promise.then(e => e)),
      geofs.runways.env[e].promise
  },
  setAsyncPrimitiveMaterial: async function(e, t, a) {
      let o = await geofs.runways.getRotationCanvas(e);
      o.context.clearRect(-o.image.width, -o.image.width, 2 * o.image.width, 2 * o.image.width),
      o.context.save(),
      o.context.rotate(t),
      o.context.globalAlpha = geofs.runways.imageryOpacity,
      o.context.drawImage(o.image, -o.image.width / 2, -(o.image.height / 2)),
      o.canvas.toBlob ? o.canvas.toBlob(e => {
          a.appearance = new Cesium.EllipsoidSurfaceAppearance({
              material: new Cesium.Material({
                  fabric: {
                      type: "Image",
                      uniforms: {
                          image: URL.createObjectURL(e)
                      }
                  }
              }),
              aboveGround: !0
          })
      }
      ) : a.appearance = new Cesium.EllipsoidSurfaceAppearance({
          material: new Cesium.Material({
              fabric: {
                  type: "Image",
                  uniforms: {
                      image: o.canvas.toDataURL()
                  }
              }
          }),
          aboveGround: !0
      }),
      o.context.restore()
  },
  asyncSetImageLayerRotationPosition: async function(e, t, a, o) {
      let r = await geofs.runways.getRotationCanvas(e);
      r.context.clearRect(-r.image.width, -r.image.width, 2 * r.image.width, 2 * r.image.width),
      r.context.save(),
      r.context.rotate(t),
      r.context.drawImage(r.image, -r.image.width / 2, -(r.image.height / 2));
      var n = {
          rectangle: a,
          alpha: geofs.runways.imageryOpacity,
          minimumTerrainLevel: 12
      };
      if (r.canvas.toBlob)
          r.canvas.toBlob(e => {
              var t = new Cesium.ImageryLayer(new Cesium.SingleTileImageryProvider({
                  url: URL.createObjectURL(e),
                  rectangle: a
              }),n);
              geofs.api.viewer.imageryLayers.add(t),
              o.imageryLayers.push(t)
          }
          );
      else {
          var s = new Cesium.ImageryLayer(new Cesium.SingleTileImageryProvider({
              url: r.canvas.toDataURL(),
              rectangle: a
          }),n);
          geofs.api.viewer.imageryLayers.add(s),
          o.imageryLayers.push(s)
      }
      r.context.restore()
  }
},
geofs.runways.generateRunwayId = function(e) {
  return e[0] + e[1] + e[2] + e[3]
}
,
geofs.runways.newRunwayFromNavaidId = function(e) {
  let t = geofs.nav.getNavaid(e);
  return geofs.runways.newRunwayFromNavaidObject(t, e)
}
,
geofs.runways.newRunwayFromNavaidObject = function(e, t) {
  let a = [e.icao, null, null, e.heading, e.lat, e.lon, null];
  return new geofs.runways.runway(a,t,!0)
}
,
geofs.runways.newRunwayFromGridRecord = function(e, t) {
  return new geofs.runways.runway(e,t)
}
,
geofs.runways.runway = function(e, t, a) {
  this.id = t || geofs.runways.generateRunwayId(e),
  this.icao = e[0],
  this.location = [e[4], e[5], 0],
  this.heading = fixAngle(e[3]),
  this.lengthFeet = e[1],
  this.widthFeet = e[2],
  this.padding = e[6] || geofs.runways.defaultPadding,
  this.headingRad = this.heading * DEGREES_TO_RAD,
  this.lengthMeters = (this.lengthFeet || geofs.runways.defaultLength) * FEET_TO_METERS,
  this.widthMeters = (this.widthFeet || geofs.runways.defaultWidth) * FEET_TO_METERS,
  this.threshold1 = this.location,
  this.meterLengthLocal = [Math.sin(this.headingRad), Math.cos(this.headingRad), 0],
  this.meterlla = xyz2lla(this.meterLengthLocal, this.threshold1),
  this.lengthInLla = V3.scale(this.meterlla, this.lengthMeters),
  this.meterWidthLocal = [-Math.cos(this.headingRad), Math.sin(this.headingRad), 0],
  this.meterWidthLla = xyz2lla(this.meterWidthLocal, this.threshold1),
  this.widthInLla = V3.scale(this.meterWidthLla, this.widthMeters),
  this.meterAcrossInLla = V3.scale(this.widthInLla, 1 / this.widthMeters),
  this.threshold2 = V3.add(this.threshold1, this.lengthInLla),
  this.aimingPointLla1 = V3.add(this.threshold1, V3.scale(this.meterlla, geofs.runways.thresholdToAimingPoint)),
  this.aimingPointLla2 = V3.add(this.threshold2, V3.scale(this.meterlla, -geofs.runways.thresholdToAimingPoint)),
  this.lightsOn = !1,
  this.lights = [],
  this.PAPIs = [],
  this.localStepXm = this.widthMeters / 33,
  this.localStepYm = 50,
  this.stepX = V3.scale(this.widthInLla, 1 / 33),
  this.stepY = V3.scale(this.meterlla, 50)
}
,
geofs.runways.runway.prototype = {
  setElevation: function(e) {
      if (!this.elevationSet) {
          if (void 0 == e) {
              let t = geofs.mainAirportList[this.icao] ? geofs.mainAirportList[this.icao] : this.threshold1;
              geofs.api.getGuarantiedGroundAltitude(t).then(e => {
                  this.setElevation(e[0].height || 0)
              }
              );
              return
          }
          this.location[2] = e,
          this.threshold1[2] = e,
          this.threshold2[2] = e,
          this.PAPIs.forEach(t => {
              t.location[2] = e
          }
          ),
          this.elevationSet = !0
      }
  },
  showCircuit: function() {
      if (this.circuitModelA || "FAKE" == this.icao)
          return;
      let e = {
          url: "/models/objects/misc/circuitA.glb",
          location: [this.threshold1[0], this.threshold1[1], 0],
          rotation: [this.heading, 0, 0],
          altitudeMode: geofs.api.ALTITUDE_RELATIVE,
          scale: 1
      };
      this.circuitModelA = new geofs.api.Model(null,e);
      let t = {
          url: "/models/objects/misc/circuitB.glb",
          location: [this.threshold2[0], this.threshold2[1], 0],
          rotation: [this.heading, 0, 0],
          altitudeMode: geofs.api.ALTITUDE_RELATIVE,
          scale: 1
      };
      this.circuitModelB = new geofs.api.Model(null,t)
  },
  destroyCircuit: function() {
      this.circuitModelA && (this.circuitModelA.destroy(),
      this.circuitModelA = null,
      this.circuitModelB.destroy(),
      this.circuitModelB = null)
  },
  hideCircuit: function() {
      this.destroyCircuit()
  },
  turnLightsOn: function() {
      if ("FAKE" != this.icao && !this.lightsOn) {
          for (var e = geofs.runwaysLights.templateCenter[1] - 1, t = geofs.runwaysLights.thresholdLightTemplate[e], a = t[1], o = 0, r = -a, n = e, s = geofs.runwaysLights.thresholdLightTemplate.length; n < s; n++)
              for (var c = geofs.runwaysLights.thresholdLightTemplate[n], d = c[0], u = r, p = r + c[1]; u < p; u++)
                  this.addLightRow(this.threshold1, d, -u),
                  r++;
          for (var h, m = V2.add(this.threshold1, V2.scale(this.stepY, a)), f = (this.lengthMeters - this.localStepYm * a) / this.localStepYm, d = geofs.runwaysLights.thresholdLightTemplate[0][0], r = 0; r < f; r++)
              this.addLightRow(m, d, r);
          for (var e = geofs.runwaysLights.templateCenter[1] - 1, t = geofs.runwaysLights.thresholdLightTemplate[e], a = t[1], o = 0, r = -a, n = e, s = geofs.runwaysLights.thresholdLightTemplate.length; n < s; n++)
              for (var c = geofs.runwaysLights.thresholdLightTemplate[n], d = c[0], u = r, p = r + c[1]; u < p; u++)
                  this.addLightRow(this.threshold2, d, u),
                  r++;
          this.lightsOn = !0
      }
  },
  addLightRow: function(e, t, a) {
      for (var o = V2.add(e, V2.scale(this.stepY, a)), r = 0, n = t.length; r < n; r++) {
          var s = t[r];
          if (s) {
              var c = V2.add(o, V3.scale(this.stepX, r - geofs.runwaysLights.templateCenter[0]));
              c[2] = geofs.runwaysLights.lightElevation,
              this.lights.push(new geofs.fx.light(c,s,geofs.runwaysLights.lightBillboardOptions))
          }
      }
  },
  turnLightsOff: function() {
      if (this.lightsOn) {
          for (var e = 0; e < this.lights.length; e++)
              this.lights[e].destroy(),
              this.lights[e] = null;
          this.lights = [],
          this.lightsOn = !1
      }
  },
  addPAPIs: function() {
      if (!this.PAPIs.length) {
          var e = xyz2lla(V3.scale(this.meterWidthLocal, 9), this.threshold1)
            , t = V3.add(this.aimingPointLla1, xyz2lla(V3.scale(this.meterWidthLocal, this.widthMeters / 2 + 15), this.aimingPointLla1));
          t = V3.add(t, V3.scale(this.stepY, 5)),
          this.PAPIs.push(new geofs.runwaysLights.PAPI(t,e)),
          e = xyz2lla(V3.scale(this.meterWidthLocal, -9), this.threshold2),
          t = V3.add(this.aimingPointLla2, xyz2lla(V3.scale(this.meterWidthLocal, -this.widthMeters / 2 - 15), this.aimingPointLla2)),
          t = V3.add(t, V3.scale(this.stepY, -5)),
          this.PAPIs.push(new geofs.runwaysLights.PAPI(t,e))
      }
  },
  generateRunwayModel: function() {
      if (this.modelExists || "FAKE" == this.icao)
          return;
      var e = new Cesium.Color(.5,.5,.5,geofs.runways.imageryOpacity);
      if (geofs.retroOn) {
          var t = new Cesium.GeometryInstance({
              geometry: new Cesium.GroundPolylineGeometry({
                  positions: Cesium.Cartesian3.fromDegreesArray([this.threshold1[1] - this.widthInLla[1], this.threshold1[0] - this.widthInLla[0], this.threshold1[1] + this.widthInLla[1], this.threshold1[0] + this.widthInLla[0], this.threshold2[1] + this.widthInLla[1], this.threshold2[0] + this.widthInLla[0], this.threshold2[1] - this.widthInLla[1], this.threshold2[0] - this.widthInLla[0]]),
                  width: 10,
                  loop: !0
              }),
              attributes: {
                  color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString("#2caecf"))
              }
          });
          geofs.api.viewer.scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({
              geometryInstances: t,
              appearance: new Cesium.PolylineColorAppearance
          }));
          return
      }
      if (Cesium.Entity.supportsMaterialsforEntitiesOnTerrain(geofs.api.viewer.scene) && !geofs.isApp) {
          this.entities = [];
          let a = V3.scale(this.widthInLla, .5);
          var o = geofs.api.viewer.entities.add({
              polygon: {
                  hierarchy: {
                      positions: [new Cesium.Cartesian3.fromDegrees(this.threshold1[1] - a[1],this.threshold1[0] - a[0],0), new Cesium.Cartesian3.fromDegrees(this.threshold1[1] + this.lengthInLla[1] - a[1],this.threshold1[0] + this.lengthInLla[0] - a[0],0), new Cesium.Cartesian3.fromDegrees(this.threshold1[1] + this.lengthInLla[1] + a[1],this.threshold1[0] + this.lengthInLla[0] + a[0],0), new Cesium.Cartesian3.fromDegrees(this.threshold1[1] + a[1],this.threshold1[0] + a[0],0)]
                  },
                  material: new Cesium.ImageMaterialProperty({
                      image: "models/objects/runway/full.jpg",
                      color: e
                  }),
                  classificationType: Cesium.ClassificationType.TERRAIN,
                  stRotation: this.headingRad - HALF_PI,
                  shadows: Cesium.ShadowMode.ENABLED
              },
              interleave: !1,
              allowPicking: !1
          });
          this.modelExists = !0,
          this.entities.push(o);
          return
      }
      let r = .5 * this.lengthMeters
        , n = V2.scale(this.meterlla, r)
        , s = xy2ll([r, r], this.threshold1)
        , c = [this.threshold1[0] + n[0], this.threshold1[1] + n[1]]
        , d = Cesium.Rectangle.fromDegrees(c[1] - s[1], c[0] - s[0], c[1] + s[1], c[0] + s[0]);
      geofs.runways.asyncSetImageLayerRotationPosition("models/objects/runway/full.jpg", this.headingRad - HALF_PI, d, this)
  },
  destroyRunwayModel: function() {
      this.entities && this.entities.forEach(e => {
          geofs.api.viewer.entities.remove(e)
      }
      ),
      this.primitives && this.primitives.forEach(e => {
          geofs.api.viewer.scene.groundPrimitives.remove(e)
      }
      ),
      this.entities = null,
      this.imageryLayers && (this.imageryLayers.forEach(e => {
          geofs.api.viewer.imageryLayers.remove(e, !0)
      }
      ),
      this.imageryLayers = []),
      this.creationTime = null,
      this.modelExists = !1
  },
  destroyLights: function() {
      if (this.lights) {
          for (var e = 0; e < this.lights.length; e++)
              this.lights[e].destroy();
          this.lights = []
      }
  },
  destroyPAPIs: function() {
      if (this.PAPIs) {
          for (var e = 0; e < this.PAPIs.length; e++)
              this.PAPIs[e].destroy();
          this.PAPIs = []
      }
  },
  destroy: function() {
      this.destroyRunwayModel(),
      this.destroyCircuit(),
      this.destroyLights(),
      this.destroyPAPIs()
  }
},
$("body").on("runwayUpdate", function() {
  geofs.runwaysLights.updateAll()
}),
$("body").on("nightChange", function() {
  geofs.runwaysLights.updateAll()
}),
geofs.runwaysLights = {
  lightBillboardOptions: {
      altitudeMode: geofs.api.ALTITUDE_RELATIVE,
      sizeInMeters: !1,
      scaleByDistance: new Cesium.NearFarScalar(1,1,4e3,.15)
  },
  papiBillboardOptions: {
      altitudeMode: geofs.api.ALTITUDE_RELATIVE,
      sizeInMeters: !1,
      scaleByDistance: new Cesium.NearFarScalar(1,.15,4e3,.05)
  },
  lightElevation: .5,
  thresholdLightTemplate: [[[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], "length"], [[1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1], 12], [[3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3], 1], [[0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], 5], [[0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], 1], [[0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], 5], [[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], 1], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 5]],
  templateCenter: [17, 2]
},
geofs.runwaysLights.turnAllOff = function() {
  for (var e in geofs.runways.nearRunways)
      geofs.runways.nearRunways[e].turnLightsOff()
}
,
geofs.runwaysLights.turnAllOn = function() {
  for (var e in geofs.runways.nearRunways)
      geofs.runways.nearRunways[e].turnLightsOn()
}
,
geofs.runwaysLights.updateAll = function() {
  geofs.isNight ? geofs.runwaysLights.turnAllOn() : geofs.runwaysLights.turnAllOff()
}
,
geofs.runwaysLights.PAPI = function(e, t) {
  this.lights = [],
  this.heightAboveGround = 1;
  let a = [e[0], e[1]];
  for (var o = 0; o < 4; o++)
      this.lights[o] = {
          white: new geofs.fx.light([a[0], a[1], this.heightAboveGround],"whitepapi",geofs.runwaysLights.papiBillboardOptions),
          red: new geofs.fx.light([a[0], a[1], this.heightAboveGround],"redpapi",geofs.runwaysLights.papiBillboardOptions)
      },
      a = V2.add(a, t);
  this.location = e,
  this.refresh()
}
,
geofs.runwaysLights.PAPI.prototype = {
  refresh: function() {
      clearInterval(this.papiInterval),
      this.papiInterval = setInterval( () => {
          var e = [geofs.aircraft.instance.llaLocation[0], geofs.aircraft.instance.llaLocation[1], this.location[2]]
            , t = geofs.utils.llaDistanceInMeters(e, this.location, this.location)
            , a = Math.atan2(geofs.aircraft.instance.llaLocation[2] - this.location[2], t) * RAD_TO_DEGREES
            , o = a < 2
            , r = a < 2.5
            , n = a < 3.5
            , s = a < 4;
          this.lights[3].white.setVisibility(!o),
          this.lights[3].red.setVisibility(o),
          this.lights[2].white.setVisibility(!r),
          this.lights[2].red.setVisibility(r),
          this.lights[1].white.setVisibility(!n),
          this.lights[1].red.setVisibility(n),
          this.lights[0].white.setVisibility(!s),
          this.lights[0].red.setVisibility(s)
      }
      , 1e3)
  },
  destroy: function() {
      clearInterval(this.papiInterval);
      for (var e = 0; e < 4; e++)
          this.lights[e].red.destroy(),
          this.lights[e].white.destroy();
      this.location = null,
      this.lights = null
  }
},
geofs.animation = {},
geofs.animation.init = function() {}
,
geofs.animation.getRampRatio = function(e, t) {
  if (t < 0 || t > 1)
      return 0;
  var a = e.length - 1
    , o = 1 / a
    , r = Math.ceil(t / o)
    , n = clamp(r - 1, 0, a - 1);
  r = clamp(r, 1, a);
  var s = e[n]
    , c = e[r];
  return c > s ? s + (c - s) * ((t - n * o) / o) : c + (s - c) * ((o - (t - n * o)) / o)
}
,
geofs.animation.getRampValue = function(e, t) {
  var a = 0;
  return t > e[0] && t < e[3] && (a = t < e[1] ? 1 / (e[1] - e[0]) * (t - e[0]) : t > e[2] ? 1 - 1 / (e[3] - e[2]) * (t - e[2]) : 1),
  a
}
,
geofs.animation.values = {},
geofs.animation.resetValues = function(e) {
  geofs.animation.values = Object.assign({}, geofs.animation.values, e)
}
,
geofs.animation.getValue = function(e) {
  return geofs.animation.values[e] || 0
}
,
geofs.animation.setValue = function(e, t) {
  return geofs.animation.values[e] = t
}
,
geofs.animation.filter = function(e, t) {
  if (e.minOf && e.minOf.forEach) {
      t = geofs.animation.filter(e.minOf[0]);
      for (let a = 1; a < e.minOf.length; a++)
          t = Math.min(t, geofs.animation.filter(e.minOf[a]))
  }
  if ("random" == e.value)
      t = Math.random();
  else if (e.function) {
      if (t = 0,
      !geofs.aircraft.instance.aircraftRecord.isCommunity)
          try {
              t = Function(e.function)()
          } catch (o) {
              t = 0
          }
  } else
      e.text ? t = e.text : e.value && e.value.forEach ? (t = 0,
      e.value.forEach(e => {
          t = Math.maxAbsValue(t, geofs.animation.values[e])
      }
      )) : e.maxValue && e.maxValue.forEach ? (t = 0,
      e.maxValue.forEach(e => {
          t = Math.max(t, geofs.animation.values[e])
      }
      )) : e.minValue && e.minValue.forEach ? (t = geofs.animation.values[e.minValue[0]],
      e.minValue.forEach(e => {
          t = Math.min(t, geofs.animation.values[e])
      }
      )) : t = t || geofs.animation.values[e.value] || ("text" == e.type ? "" : 0);
  if ("strobe" == e.value)
      t = 0,
      geofs.utils.fastNow() % 1500 > 1400 && (t = 1);
  else if ("strobe2" == e.value)
      t = 0,
      geofs.utils.fastNow() % 1800 > 1700 && (t = 1);
  else if ("strobe3" == e.value) {
      t = 0;
      var r = geofs.utils.fastNow() % 1800;
      (r > 100 && r < 200 || r > 1700) && (t = 1)
  }
  if (e.eq && (t = t == e.eq ? 1 : 0),
  e.notEq && (t = t != e.notEq ? 1 : 0),
  e.ramp)
      t = geofs.animation.getRampValue(e.ramp, t);
  else if (e.valueRamp)
      t = geofs.animation.getRampRatio(e.valueRamp, t);
  else if (e.ratioRamp) {
      var n = geofs.animation.getRampRatio(e.ratioRamp, t);
      t *= n
  }
  e.inverse && (t = 1 - t),
  e.floor && (t = Math.floor(t)),
  e.abs && (t = Math.abs(t)),
  e.between && (t = t > e.between[0] && t < e.between[1] ? 1 : 0),
  e.delay && (t -= e.delay,
  t = clamp(t, 0, 1),
  e.delay < 0 && (t += e.delay)),
  e.threshold && (t < e.threshold ? t = 0 : t -= e.threshold),
  e.negthreshold && (t > e.negthreshold ? t = 0 : t -= e.negthreshold),
  e.gt && (t = t > e.gt ? 1 : 0),
  e.lt && (t = t < e.lt ? 1 : 0),
  e.min && t < e.min && (t = e.min),
  e.max && t > e.max && (t = e.max);
  var s = !1;
  if (e.when) {
      for (var c = 0, d = e.when.length; c < d; c++)
          if (e.when[c] == t) {
              s = !0;
              break
          }
      t = s
  } else if (e.whenNot) {
      s = !0;
      for (var c = 0, d = e.whenNot.length; c < d; c++)
          if (e.whenNot[c] == t) {
              s = !1;
              break
          }
      t = s
  }
  return e.preoffset && (t += e.preoffset),
  e.log && (t = Math.log(t)),
  e.ratio && (t *= e.ratio),
  e.power && (t = Math.pow(t, e.power)),
  e.offset && (t += e.offset),
  e.set && (t = t ? e.set : e.unset || 0),
  e.fmin && t < e.fmin && (t = e.fmin),
  e.fmax && t > e.fmax && (t = e.fmax),
  e.concat && (Array.isArray(e.concat) || (e.concat = [e.concat]),
  e.concat.forEach(e => {
      t += void 0 !== geofs.animation.values[e] ? geofs.animation.values[e] : e
  }
  )),
  t
}
,
window.geofs = window.geofs || {},
geofs.utils = {
  timeProvider: window.performance || window.Date
},
geofs.utils.lastNow = geofs.utils.timeProvider.now(),
geofs.utils.fastNow = function() {
  return geofs.utils.lastNow
}
,
geofs.utils.now = function() {
  return geofs.utils.lastNow = geofs.utils.timeProvider.now(),
  geofs.utils.lastNow
}
,
geofs.utils.updateTime = function(e, t) {
  return geofs.utils.lastNow - (e.lastNow || 0) > t && (e.lastNow = geofs.utils.lastNow,
  !0)
}
,
geofs.utils.hourStamp = function() {
  return Math.round(Date.now() / 36e5)
}
,
geofs.utils.llaDistanceInMeters = function(e, t, a) {
  return V2.length(ll2xy(V3.sub(e, t), a || e))
}
,
geofs.utils.llaDistanceInMeters3D = function(e, t, a) {
  return V3.length(lla2xyz(V3.sub(e, t), a || e))
}
,
geofs.utils.functionsMap = {},
geofs.utils.executeOnceWithinTime = function(e, t) {
  let a = e.toString().substring(0, 50);
  clearTimeout(geofs.utils.functionsMap[a]),
  geofs.utils.functionsMap[a] = setTimeout( () => {
      delete geofs.utils.functionsMap[a],
      e()
  }
  , t)
}
,
geofs.utils.throttleWithDefault = function(e, t, a, o) {
  return geofs.utils.lastNow - (o.time || 0) > a ? (o.time = geofs.utils.lastNow,
  e()) : t
}
,
geofs.utils.pivotArray = function(e) {
  var t = {};
  try {
      for (i = 0,
      l = e.length; i < l; i++)
          t[e[i]] = 1
  } catch (a) {}
  return t
}
,
geofs.utils.htrFromHeadingNormal = function(e, t) {
  var a = e * DEGREES_TO_RAD
    , o = [Math.sin(a), Math.cos(a), 0]
    , r = V3.normalize(V3.cross(o, t))
    , n = V3.cross(t, r)
    , s = [r, n, t];
  return M33.getOrientation(s)
}
,
geofs.utils.hash = function(e) {
  for (var t = 0, a = 0; t < e.length; t++)
      a = Math.imul(31, a) + e.charCodeAt(t) | 0;
  return a
}
,
geofs.utils.hashCode = function(e) {
  return geofs.utils.hash(e) + ""
}
,
geofs.utils.displayAltitude = function(e) {
  return e > 18e3 ? e = "FL" + 5 * Math.round(e / 500) : e += "ft.",
  e
}
,
geofs.utils.parseAltitude = function(e) {
  if (void 0 != e)
      return ("FL" == (e += "").toUpperCase().substr(0, 2) && (e = parseInt(100 * e.substr(2))),
      e = parseInt(e),
      isNaN(e)) ? null : e
}
,
geofs.utils.stickyRounding = function(e, t) {
  let a = .5 / t
    , o = Math.trunc(e)
    , r = Math.abs(e - o)
    , n = 0;
  return r > 1 - 2 * t && (n = r - (1 - 2 * t)),
  r < 0 && (n = -(t - r)),
  o + n * a
}
,
geofs.utils.knotsToMach = function(e) {
  return geofs.utils.msToMach(e * KNOTS_TO_MS)
}
,
geofs.utils.machToKnots = function(e) {
  return geofs.utils.machToMs(e) * MS_TO_KNOTS
}
,
geofs.utils.msToMach = function(e) {
  return e / (331.3 + .606 * weather.atmosphere.airTempAtAltitude)
}
,
geofs.utils.machToMs = function(e) {
  return e * (331.3 + .606 * weather.atmosphere.airTempAtAltitude)
}
,
geofs.utils.sortLocationByDistance = function(e, t) {
  for (var a = 0, o = t.length; a < o; a++) {
      var r = t[a]
        , n = r.coords || [r.lat, r.lon];
      r.distance = geofs.utils.distanceBetweenLocations(e, n)
  }
  return t.sort( (e, t) => e.distance - t.distance),
  t
}
,
geofs.utils.distanceBetweenLocations = function(e, t) {
  let a = e[0] * DEGREES_TO_RAD
    , o = t[0] * DEGREES_TO_RAD
    , r = e[1] * DEGREES_TO_RAD
    , n = t[1] * DEGREES_TO_RAD
    , s = (n - r) * Math.cos((a + o) / 2)
    , c = o - a;
  return Math.sqrt(s * s + c * c) * MERIDIONAL_RADIUS
}
,
geofs.utils.bearingBetweenLocations = function(e, t) {
  let a = e[0] * DEGREES_TO_RAD
    , o = t[0] * DEGREES_TO_RAD
    , r = e[1] * DEGREES_TO_RAD
    , n = t[1] * DEGREES_TO_RAD
    , s = Math.sin(n - r) * Math.cos(o)
    , c = Math.cos(a) * Math.sin(o) - Math.sin(a) * Math.cos(o) * Math.cos(n - r)
    , d = Math.atan2(s, c);
  return (d * RAD_TO_DEGREES + 360) % 360
}
,
geofs.utils.lookAt = function(e, t, a) {
  var o = lla2xyz(V3.sub(e, t), t)
    , r = M33.makeOrthonormalFrame(o, a);
  return M33.getOrientation(r)
}
,
geofs.utils.limitRate = function(e, t, a, o) {
  var r = t - e;
  return Math.abs(r * o) > a ? e + r * a * o : t
}
,
geofs.utils.morseMap = {
  A: ".-",
  B: "-...",
  C: "-.-.",
  D: "-..",
  E: ".",
  F: "..-.",
  G: "--.",
  H: "....",
  I: "..",
  J: ".---",
  K: "-.-",
  L: ".-..",
  M: "--",
  N: "-.",
  O: "---",
  P: ".--.",
  Q: "--.-",
  R: ".-.",
  S: "...",
  T: "-",
  U: "..-",
  W: ".--",
  X: "-..-",
  Y: "-.--",
  Z: "--..",
  1: ".----",
  2: "..---",
  3: "...--",
  4: "....-",
  5: ".....",
  6: "-....",
  7: "--...",
  8: "---..",
  9: "----.",
  0: "-----"
},
geofs.utils.textToMorse = function(e) {
  return e.toUpperCase().split("").map(e => geofs.utils.morseMap[e]).join(" ")
}
,
geofs.utils.easingFunctions = {
  linear: function(e) {
      return e
  },
  easeInQuad: function(e) {
      return e * e
  },
  easeOutQuad: function(e) {
      return e * (2 - e)
  },
  easeInOutQuad: function(e) {
      return e < .5 ? 2 * e * e : -1 + (4 - 2 * e) * e
  },
  easeInCubic: function(e) {
      return e * e * e
  },
  easeOutCubic: function(e) {
      return --e * e * e + 1
  },
  easeInOutCubic: function(e) {
      return e < .5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1
  },
  easeInQuart: function(e) {
      return e * e * e * e
  },
  easeOutQuart: function(e) {
      return 1 - --e * e * e * e
  },
  easeInOutQuart: function(e) {
      return e < .5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e
  },
  easeInQuint: function(e) {
      return e * e * e * e * e
  },
  easeOutQuint: function(e) {
      return 1 + --e * e * e * e * e
  },
  easeInOutQuint: function(e) {
      return e < .5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e
  }
},
geofs.utils.isWebglSupported = function() {
  try {
      var e = document.createElement("canvas");
      return !!window.WebGLRenderingContext && e.getContext("webgl")
  } catch (t) {
      return !1
  }
}
,
geofs.utils.getFunctionFromString = function(e) {
  var t = window
    , a = e.split(".");
  for (i = 0; i < a.length - 1; i++)
      if (void 0 == (t = t[a[i]]))
          return;
  return t[a[a.length - 1]]
}
,
geofs.utils.booleanToBinary = function(e) {
  return e ? 1 : 0
}
,
geofs.utils.toFixedFloat = function(e, t) {
  return Number(e.toFixed(t))
}
,
geofs.utils.arrayToFixed = function(e, t) {
  for (let a = 0; a < e.length; a++)
      e[a] = Number(e[a].toFixed(t));
  return e
}
,
geofs.utils.wordToDigit = function(e) {
  switch (e) {
  case "zero":
      return 0;
  case "one":
      return 1;
  case "two":
      return 2;
  case "three":
      return 3;
  case "four":
      return 4;
  case "five":
      return 5;
  case "six":
      return 6;
  case "seven":
      return 7;
  case "height":
      return 8;
  case "nine":
      return 9
  }
  return e
}
,
geofs.ajax = {},
geofs.ajax.post = function(e, t, a, o) {
  var r = JSON.stringify(t);
  return $.ajax({
      type: "POST",
      url: e,
      crossDomain: !0,
      data: r,
      dataType: "json",
      success: a,
      error: function(e, t, a) {
          try {
              o(e, t, a)
          } catch (r) {}
          geofs.debug.error(a, "geofs.ajax.post. POST failed" + t + " - " + a)
      }
  })
}
,
geofs.selectDropdown = function(e, t) {
  for (var a = 0; a < e.options.length; a++)
      if (e.options[a].value == t) {
          e.selectedIndex = a;
          break
      }
}
,
geofs.getLink = function() {
  var e = geofs.aircraft.instance.llaLocation[2];
  geofs.aircraft.instance.groundContact && (e = 0),
  new URL(window.location.href);
  var t = geofs.url + "/fly?";
  t += "a=" + geofs.aircraft.instance.id,
  t += "&la=" + geofs.aircraft.instance.llaLocation[0].toFixed(5),
  t += "&lo=" + geofs.aircraft.instance.llaLocation[1].toFixed(5),
  t += "&al=" + e.toFixed();
  var a = "Use this link to start the simulator at the current location:<textarea>" + (t += "&h=" + geofs.aircraft.instance.htr[0].toFixed()) + "</textarea>";
  $(".geofs-linkOutput").html(a)
}
,
geofs.isArray = function(e) {
  return !!e && e.constructor === Array
}
,
geofs.loadModel = function(e, t) {
  return (t = t || {}).url = e + geofs.killCache,
  geofs.api.loadModel(t)
}
,
geofs.getGroundAltitude = function(e, t) {
  let a = geofs.objects.getAltitudeAtLocation(e);
  if (a)
      return a;
  var o = geofs.api.getGroundAltitude(e, t);
  return {
      location: [e[0], e[1], o]
  }
}
,
geofs.getCollisionResult = function(e, t, a, o) {
  var r;
  if (t && a && (geofs.isApp || geofs.api.renderingSettings.degradedCollisions || geofs.cautiousWithTerrain)) {
      let n;
      n = a.normal[2] < .45 ? a.location[2] : geofs.getAltitudeAtPointFromCollisionResult(a, [t[0], t[1], 0]),
      r = {
          location: [e[0], e[1], n],
          normal: V3.dup(a.normal),
          object: a.object
      }
  } else
      r = geofs.getGroundAltitude(e, o);
  return r
}
,
geofs.getAltitudeAtPointFromCollisionResult = function(e, t) {
  var a = -e.normal[0] / e.normal[2]
    , o = -e.normal[1] / e.normal[2];
  return e.location[2] + t[0] * a + t[1] * o
}
,
geofs.getNormalFromCollision = function(e, t) {
  var a;
  let o = 10;
  return geofs.api.renderingSettings.degradedCollisions && (o = 100),
  a = geofs.api.googleTileset ? [0, 0, 1] : e.normal ? e.normal : geofs.utils.throttleWithDefault( () => geofs.api.getGroundNormal(e.location, t), t.oldNormal || [0, 0, 1], o, t)
}
;
var PID = function(e, t, a) {
  this._kp = e,
  this._ki = t,
  this._kd = a,
  this.reset()
};
PID.prototype.reset = function() {
  this._previousInput = 0,
  this._previousError = 0,
  this._integral = 0,
  this._setPoint = 0,
  this._minOutput = 0,
  this._maxOutput = 0
}
,
PID.prototype.initialize = function(e, t) {
  this._integral = e || 0,
  this._previousInput = t || 0
}
,
PID.prototype.set = function(e, t, a) {
  this._minOutput = t,
  this._maxOutput = a,
  this._setPoint = e
}
,
PID.prototype.compute = function(e, t) {
  var a = this._setPoint - e;
  this._integral += a * t * this._ki,
  this._integral = clamp(this._integral, this._minOutput, this._maxOutput);
  var o = -(e - this._previousInput);
  return this._previousInput = e,
  clamp(this._kp * a + this._integral + this._kd * o, this._minOutput, this._maxOutput)
}
,
geofs.useSimpleShadow = function(e) {
  !1 == e && !1 !== geofs.simpleShadowOn ? (geofs.aircraft.instance && geofs.aircraft.instance.removeShadow && geofs.aircraft.instance.removeShadow(),
  geofs.api.useNativeShadows(!0),
  geofs.simpleShadowOn = !1) : !0 == e && !geofs.simpleShadowOn && geofs.aircraft.instance && geofs.aircraft.instance.addShadow() && (geofs.api.useNativeShadows(!1),
  geofs.simpleShadowOn = !0)
}
,
geofs.disableShadows = function() {
  geofs.shadowsDisabled || (geofs.useSimpleShadow(!0),
  geofs.shadowsDisabled = !0)
}
,
geofs.enableShadows = function() {
  !1 !== geofs.shadowsDisabled && (geofs.useSimpleShadow(geofs.preferences.graphics.forceSimpleShadow || geofs.preferences.graphics.simpleShadow),
  geofs.shadowsDisabled = !1)
}
,
geofs.shadow = function(e, t) {
  this.createShadow(e + geofs.killCache, t),
  this.context = {},
  this.shadowOffset = .1
}
,
geofs.shadow.prototype = {
  createShadow: function(e, t) {
      this.scale = V3.scale(t, 2),
      this.scale[2] = 1,
      this.shadow = new geofs.api.Model(e)
  },
  setLocationRotation: function(e, t) {
      var a = geofs.getCollisionResult(e, [0, 0, 0], geofs.aircraft.instance.collResult, this.context)
        , o = geofs.getNormalFromCollision(a, this)
        , r = geofs.aircraft.instance.object3d.getWorldFrame()[1]
        , n = V3.normalize(V3.cross(r, o))
        , s = V3.cross(o, n)
        , c = [n, s, o]
        , d = M33.getOrientation(c)
        , u = [e[0], e[1], a.location[2] + this.shadowOffset];
      this.shadow.setPositionOrientationAndScale(u, d, this.scale)
  },
  destroy: function() {
      this.shadow.destroy(),
      this.shadowBox = null,
      this.context = null
  }
},
geofs.WGS84TileSize = 256,
geofs.WGS84Coord2tile = function(e, t, a) {
  let o = Math.pow(2, a)
    , r = fixAngle360(t + 180) * o
    , n = (90 - e) * o;
  return {
      x: Math.floor(r / geofs.WGS84TileSize),
      y: Math.floor(n / geofs.WGS84TileSize)
  }
}
,
geofs.WGS84Coord2tileQuad = function(e, t, a) {
  let o = geofs.WGS84Coord2tile(e, t, a);
  return [{
      x: o.x - 1,
      y: o.y - 1
  }, {
      x: o.x,
      y: o.y - 1
  }, {
      x: o.x - 1,
      y: o.y
  }, {
      x: o.x,
      y: o.y
  }]
}
,
geofs.WGS84Tile2coord = function(e, t, a) {
  let o = Math.pow(2, a);
  return {
      lon: e * geofs.WGS84TileSize / o - 180,
      lat: 90 - t * geofs.WGS84TileSize / o
  }
}
,
geofs.coord2tile = function(e, t, a) {
  let o = Math.pow(2, a)
    , r = e * DEGREES_TO_RAD;
  return {
      x: Math.floor((t + 180) / 360 * o),
      y: Math.floor((1 - Math.log(Math.tan(r) + 1 / Math.cos(r)) / Math.PI) / 2 * o)
  }
}
,
geofs.coord2CenterTile = function(e, t, a) {
  let o = Math.pow(2, a)
    , r = e * DEGREES_TO_RAD;
  return {
      x: Math.round((t + 180) / 360 * o),
      y: Math.round((1 - Math.log(Math.tan(r) + 1 / Math.cos(r)) / Math.PI) / 2 * o)
  }
}
,
geofs.coord2tileQuad = function(e, t, a) {
  let o = geofs.coord2CenterTile(e, t, a);
  return [{
      x: o.x - 1,
      y: o.y - 1
  }, {
      x: o.x,
      y: o.y - 1
  }, {
      x: o.x - 1,
      y: o.y
  }, {
      x: o.x,
      y: o.y
  }]
}
,
geofs.coord2tileGrid = function(e, t, a, o, r) {
  r = r || geofs.coord2CenterTile(e, t, a);
  let n = Math.floor(o / 2)
    , s = [];
  for (var c = -n; c < n; c++) {
      let d = c < 0 ? Math.abs(c) : c + 1;
      for (var u = -n; u < n; u++) {
          let p = Math.max(u < 0 ? Math.abs(u) : u + 1, d);
          s.push({
              x: r.x + u,
              y: r.y + c,
              r: p
          })
      }
  }
  return s
}
,
geofs.tile2Grid = function(e, t) {
  let a = Math.floor(e / 2)
    , o = [];
  for (var r = -a; r <= a; r++) {
      let n = r < 0 ? Math.abs(r) : r + 1;
      for (var s = -a; s <= a; s++) {
          let c = Math.max(s < 0 ? Math.abs(s) : s + 1, n);
          o.push({
              x: t.x + s,
              y: t.y + r,
              r: c
          })
      }
  }
  return o
}
,
geofs.tile2coord = function(e, t, a) {
  let o = Math.pow(2, a);
  var r = e / o * 360 - 180
    , n = Math.PI - 2 * Math.PI * t / o;
  return {
      lat: RAD_TO_DEGREES * Math.atan(.5 * (Math.exp(n) - Math.exp(-n))),
      lon: r
  }
}
,
geofs.getLatLonMatrixcoord = function(e, t, a) {
  return parseInt(e / a) + "/" + parseInt(t / a)
}
,
geofs.perlin = {
  size: 100,
  gradient: [],
  normalizationRatio: 1 / Math.sqrt(.5),
  lerp: function(e, t, a) {
      return (1 - a) * e + a * t
  },
  dotGridGradient: function(e, t, a, o) {
      let r = o - t;
      return (a - e) * geofs.perlin.gradient[t][e][0] + r * geofs.perlin.gradient[t][e][1]
  },
  get: function(e, t, a) {
      e = Math.abs(e * a) % geofs.perlin.size,
      t = Math.abs(t * a) % geofs.perlin.size;
      let o = parseInt(e), r = o + 1, n = parseInt(t), s = n + 1, c = e - o, d = t - n, u, p, h, m, f;
      return u = geofs.perlin.dotGridGradient(o, n, e, t),
      p = geofs.perlin.dotGridGradient(r, n, e, t),
      h = geofs.perlin.lerp(u, p, c),
      u = geofs.perlin.dotGridGradient(o, s, e, t),
      p = geofs.perlin.dotGridGradient(r, s, e, t),
      m = geofs.perlin.lerp(u, p, c),
      f = geofs.perlin.lerp(h, m, d),
      geofs.perlin.normalizationRatio * f
  }
};
for (var w = 0; w <= geofs.perlin.size; w++) {
  geofs.perlin.gradient[w] = [];
  for (var h = 0; h <= geofs.perlin.size; h++) {
      var theta = Math.random() * TWO_PI;
      geofs.perlin.gradient[w][h] = [Math.cos(theta), Math.sin(theta)]
  }
}
geofs.tileManager = function(e) {
  this.sizeInPixels = e.sizeInPixels || 512,
  this.zoomLevel = e.zoomLevel || 12,
  this.server = e.server,
  this.tileSize = 256,
  this.maxZoomLevel = 20,
  this.minZoomLevel = 11,
  this.backgroundColor = "#000000",
  this.useDataView = e.useDataView,
  e.sizeInTiles ? (this.sizeInTiles = e.sizeInTiles,
  this.sizeInPixels = this.tileSize * this.sizeInTiles) : this.sizeInTiles = Math.round(this.sizeInPixels / this.tileSize),
  this.canvasAPI = new geofs.api.Canvas({
      width: this.sizeInPixels,
      height: this.sizeInPixels,
      color: this.backgroundColor
  }),
  this.tileSizeAtZoom = [],
  this.tileSizeAtZoom[this.zoomLevel] = this.tileSize;
  for (var t = this.zoomLevel + 1; t <= this.maxZoomLevel; t++) {
      let a = Math.pow(2, t - this.zoomLevel);
      this.tileSizeAtZoom[t] = Math.floor(this.tileSize / a)
  }
  this.initialized = !0
}
,
geofs.tileManager.prototype = {
  update: function(e, t) {
      if (!this.initialized)
          return;
      this.tileCoordinates = geofs.coord2tileGrid(e, t, this.zoomLevel, this.sizeInTiles),
      this.originAtZoom = [],
      this.originAtZoom[this.zoomLevel] = this.tileCoordinates[0];
      for (var a = this.zoomLevel + 1; a <= this.maxZoomLevel; a++) {
          let o = Math.pow(2, a - this.zoomLevel);
          this.originAtZoom[a] = {
              x: this.tileCoordinates[0].x * o,
              y: this.tileCoordinates[0].y * o
          }
      }
      let r = this.tileCoordinates[0].x + "-" + this.tileCoordinates[0].y;
      if (r == this.originTileId)
          return;
      this.ready = !1,
      this.dataView = null,
      this.originTileId = r;
      let n = [];
      this.tileCoordinates.forEach(e => {
          n.push(this.server + this.zoomLevel + "/" + e.x + "/" + e.y + ".png")
      }
      ),
      this.origin = geofs.tile2coord(this.tileCoordinates[0].x, this.tileCoordinates[0].y, this.zoomLevel),
      this.end = geofs.tile2coord(this.tileCoordinates[0].x + this.sizeInTiles, this.tileCoordinates[0].y + this.sizeInTiles, this.zoomLevel),
      this.pixelGeographicSize = {
          lat: (this.end.lat - this.origin.lat) / this.sizeInPixels,
          lon: (this.end.lon - this.origin.lon) / this.sizeInPixels
      },
      this.canvasAPI.loadTiles(n).then(e => {
          this.useDataView && this.prepareDataView(e),
          this.ready = !0
      }
      )
  },
  prepareDataView: function() {
      var e = this.canvasAPI.context.getImageData(0, 0, this.canvasAPI.canvas.width, this.canvasAPI.canvas.height);
      this.dataView = new DataView(e.data.buffer)
  },
  coordsToPixels: function(e, t) {
      if (!this.ready)
          return;
      let a = {
          x: (t - this.origin.lon) / this.pixelGeographicSize.lon,
          y: (e - this.origin.lat) / this.pixelGeographicSize.lat
      };
      return geofs.debugOn && $(".redpixel").css({
          top: a.y + "px",
          left: a.x + "px"
      }),
      a
  },
  getSubTilePixel: function(e, t, a, o, r) {
      if (!this.ready)
          return;
      let n = {
          x: e - this.originAtZoom[a].x,
          y: t - this.originAtZoom[a].y
      }
        , s = Math.round(n.x * this.tileSizeAtZoom[a] + o)
        , c = Math.round(n.y * this.tileSizeAtZoom[a] + r);
      if (!this.useDataView)
          return this.originAtZoom[a].x,
          this.originAtZoom[a].y,
          this.canvasAPI.context.getImageData(s, c, 1, 1).data;
      try {
          return this.dataView.getUint32(4 * (s + c * this.canvasAPI.canvas.width))
      } catch (d) {
          return null
      }
  },
  getTilePixel: function(e, t, a, o, r) {
      if (!this.ready)
          return;
      let n = {
          x: e - this.originAtZoom[a].x,
          y: t - this.originAtZoom[a].y
      };
      return this.canvasAPI.context.getImageData(n.x * this.tileSizeAtZoom[a] + o / this.tileSizeAtZoom[a], n.y * this.tileSizeAtZoom[a] + r / this.tileSizeAtZoom[a], 1, 1)
  },
  getTileImageData: function(e, t, a, o, r, n, s) {
      if (!this.ready)
          return;
      let c = {
          x: e - this.originAtZoom[a].x,
          y: t - this.originAtZoom[a].y
      };
      return this.canvasAPI.context.getImageData(c.x * this.tileSizeAtZoom[a] + o / this.tileSizeAtZoom[a], c.y * this.tileSizeAtZoom[a] + r / this.tileSizeAtZoom[a], sizePx.w / this.tileSizeAtZoom[a], sizePx.h / this.tileSizeAtZoom[a])
  },
  getImageDataFromCoords: function(e, t) {
      if (!this.ready)
          return;
      let a = this.coordsToPixels(e.lat, e.lon)
        , o = this.coordsToPixels(t.lat, t.lon)
        , r = {
          w: o.x - a.x,
          h: o.y - a.y
      };
      return this.canvasAPI.context.getImageData(a.x, a.y, r.w, r.h)
  },
  pixelsToCoords: function(e, t) {}
},
window.geofs = window.geofs || {};
var PAGE_PATH = document.location.href.replace(/\/[^\/]+$/, "/");
geofs.includes = {},
geofs.initialRunways = [[-22.81244, -43.26368, 0, 126], [43.674166, 10.3843691, 0, 36.54], [40.45589, -3.54654, 0, -39], [37.62616, -122.39275, 0, 118], [51.15143, -.16629, 0, -102], [48.99873, 2.60975, 0, -95], [33.93726741762918, -118.38364975124578, 0, -96.50347129433592], [42.36021520436057, -70.98767662157663, 0, -103.54], [25.800717256450998, -80.30116643603567, 0, 87.65], [43.66555302435758, 7.228367855065596, 0, -135.67487141768297]],
geofs.lastFlightDefault = {},
geofs.groundElevation = 0,
geofs.waveHeight = 0,
geofs.waveVerticalSpeed = 0,
geofs.groundIsWater = !1,
geofs.waterIsSea = !1,
geofs.frameNumber = 0,
geofs.init = function() {
  geofs.PRODUCTION = geofs.PRODUCTION || !1,
  geofs.PRODUCTION || (geofs.killCache = "?kc=" + Date.now(),
  geofs.debug.init()),
  geofs.api.analytics.init(),
  geofs.doPause(1),
  geofs.viewport = $(".geofs-ui-3dview")[0],
  geofs.canvas = $(".geofs-ui-3dview"),
  geofs.resizeHandlers = {},
  geofs.resizeHandlersIndex = 0,
  geofs.addResizeHandler(geofs.getViewportDimentions, geofs),
  $(window).resize(geofs.handleResize),
  geofs.getViewportDimentions(),
  geofs.lastTime = geofs.utils.now(),
  $(window).on("unload", geofs.unload),
  geofs.initPreferences(),
  geofs.mobile.init(),
  geofs.autoStart ? geofs.start() : window.localStorage.getItem("startModalDone") || geofs.isApp ? geofs.isApp ? (geofs.mobile.configure(),
  geofs.start()) : geofs.manualStart || geofs.start() : (geofs.preferencesDefault.mobile = !1,
  geofs.isMobileDevice ? ($(".geofs-startModalMobile").show(),
  $(".geofs-startModalMobile .geofs-fly-button-mobile").one("click ", () => {
      geofs.preferencesDefault.mobile = !0,
      geofs.mobile.configure(),
      $(".geofs-startModalMobile").hide(),
      geofs.start()
  }
  ),
  $(".geofs-startModalMobile .geofs-fly-button").one("click ", () => {
      $(".geofs-startModalMobile").hide(),
      geofs.start()
  }
  )) : ($(".geofs-startModal").show(),
  $(".geofs-startModal .geofs-fly-button").one("click ", () => {
      $(".geofs-startModal").hide(),
      geofs.start()
  }
  )))
}
,
geofs.start = function(e, t) {
  geofs.readPreferences( () => {
      ui.init(),
      flight.recorder.init(),
      controls.init(),
      geofs.nav.init(),
      geofs.radio.init(),
      window.localStorage.setItem("startModalDone", !0);
      try {
          geofs.world = geofs.api.initWorld("geofs-ui-3dview")
      } catch (a) {
          geofs.debug.error(a)
      }
      geofs.isMobileDevice && geofs.preferences.mobile || geofs.isApp || geofs.forceMobileMode ? geofs.mobile.turnOn() : (geofs.mobile.turnOff(),
      geofs.preferences.mobile = !1),
      window.fireBasicEvent("geofsStarted"),
      geofs.api.renderingQuality(geofs.preferences.graphics.quality),
      geofs.api.enhanceColors(geofs.preferences.graphics.enhanceColors),
      geofs.debug.afterWorldInit();
      var o = JSON.parse(geofs.localStorage.getItem("flight")) || {};
      geofs.lastFlight = $.extend(!0, {}, geofs.lastFlightDefault, o);
      var r = geofs.initialRunways[Math.floor(Math.random() * geofs.initialRunways.length)]
        , n = getURLParameters()
        , s = parseFloat(n.alt) || parseFloat(n.al) || void 0
        , c = parseFloat(n.heading) || parseFloat(n.h) || void 0
        , d = parseFloat(n.lat) || parseFloat(n.la) || void 0
        , u = parseFloat(n.lon) || parseFloat(n.lo) || void 0;
      ("0" == n.alt || "0" == n.al) && (s = 0);
      var p = [d, u, s, c, !0];
      geofs.initialCoordinates = $.extend({}, t, r, geofs.lastFlight.coordinates, p),
      geofs.initialCoordinates && (geofs.initialCoordinates[0] < -90 || geofs.initialCoordinates[0] > 90 || !geofs.initialCoordinates[0] || geofs.initialCoordinates[1] < -180 || geofs.initialCoordinates[1] > 180 || !geofs.initialCoordinates[1] || geofs.initialCoordinates[2] > 1e5) && (geofs.initialCoordinates = [0, 0, 0]),
      geofs.aircraft.instance = new geofs.aircraft.Aircraft(geofs.initialCoordinates);
      var h = e || n.aircraft || n.a || geofs.lastFlight.aircraftId || 1;
      geofs.doPause(1),
      geofs.probeTerrain(),
      (async () => {
          await geofs.aircraft.instance.loadWithLivery(h, geofs.initialCoordinates, geofs.lastFlight.liveryId),
          n && n.aps && (geofs.initialCoordinates[5] = n.aps,
          geofs.autopilot.turnOn(),
          geofs.autopilot.setSpeed(parseInt(n.aps)),
          geofs.autopilot.setVerticalSpeed(parseInt(n.apvs) || 0),
          geofs.autopilot.setAltitude(parseInt(n.apa || geofs.initialCoordinates[2] * METERS_TO_FEET)),
          geofs.autopilot.setCourse(parseInt(n.aph) || geofs.initialCoordinates[3] || 0))
      }
      )(),
      geofs.camera.init(geofs.initialCoordinates),
      weather.init(geofs.initialCoordinates),
      geofs.api.setWaterEffect(geofs.preferences.graphics.waterEffect),
      geofs.api.setVegetation(geofs.preferences.graphics.vegetation),
      geofs.api.setBuildings(geofs.preferences.graphics.buildings),
      geofs.objects.init(),
      multiplayer.init(),
      geofs.fx.init(),
      geofs.initLoggedInUser(),
      geofs.api.addFrameCallback(geofs.frameCallback),
      window.fireBasicEvent("geofsInitialized")
  }
  )
}
,
geofs.unload = function() {
  if (geofs.api.destroyWorld(),
  geofs.saveFlight(),
  geofs.PRODUCTION)
      try {
          if (multiplayer.avgPing) {
              var e = 50 * Math.ceil(multiplayer.avgPing / 50);
              geofs.api.analytics.event("system", "networkLatency", e + "", Math.floor(multiplayer.avgPing))
          }
          var t = 5 * Math.ceil(geofs.debug.fps / 5);
          geofs.api.analytics.event("system", "framerate", t + "", 1 * geofs.debug.fps)
      } catch (a) {
          geofs.debug.error(a, "geofs.unload")
      }
}
,
geofs.initLoggedInUser = function() {
  //!!! Legacy horror -> watch the case of muteList <> mutelist
  geofs.userRecord.muteListMap = {};
  var e = 0
    , t = () => {
      if (!geofs.pause) {
          var t = {
              action: "keeptime"
          };
          e == controls.rawPitch || geofs.autopilot.on || (t.activeFlying = !0),
          $(".geofs-apiResponse").htmlView("load", "/backend/accounts/api.php", t)
      }
      e = controls.rawPitch
  }
    , a = 6e4;
  clearInterval(geofs.keepAliveInterval),
  geofs.keepAliveInterval = setInterval(t, a)
}
,
geofs.terrainProbbingDone = function() {
  geofs.cautiousWithTerrain && (geofs.cautiousWithTerrain = !1,
  geofs.debug.log("terrainStable"),
  $(geofs.viewport).trigger("terrainStable"))
}
,
geofs.terrainProbingDuration = 1e4,
geofs.probeTerrain = function() {
  geofs.cautiousWithTerrain || $(geofs.viewport).trigger("terrainUnstable"),
  geofs.cautiousWithTerrain = !0,
  clearTimeout(geofs.probbingTimeout),
  geofs.probbingTimeout = setTimeout(geofs.terrainProbbingDone, geofs.terrainProbingDuration)
}
,
$(document).on("terrainProviderUpdate", function() {
  geofs.probeTerrain()
}),
geofs.togglePause = function() {
  geofs.pause ? geofs.undoPause(2) : geofs.doPause(2)
}
,
geofs.isPaused = function() {
  if (geofs.absolutePause || geofs.pause)
      return !0
}
,
geofs.doPause = function(e, t) {
  e = e || 0,
  geofs.pauses = geofs.pauses || {},
  2 == e && (geofs.userPause = !0),
  e < geofs.pauseLevel || (t || multiplayer.stopUpdates(),
  audio.stop(),
  ui.toggleButton(".geofs-button-pause", !0),
  geofs.pause = !0,
  geofs.pauseLevel = e)
}
,
geofs.undoPause = function(e) {
  if (2 == (e = e || 0) && (geofs.userPause = !1),
  !(e < geofs.pauseLevel)) {
      if (geofs.userPause) {
          geofs.pauseLevel = 2;
          return
      }
      geofs.lastTime = null,
      multiplayer.startUpdates(),
      geofs.pause = !1,
      ui.toggleButton(".geofs-button-pause", !1),
      geofs.pauseLevel = 0,
      geofs.api.triggerExplicitRendering()
  }
}
,
geofs.frameCallback = function(e) {
  geofs.frameNumber++;
  var t = e - geofs.lastTime;
  geofs.lastTime = e,
  t <= 0 && (t = 1),
  (t *= geofs.preferences.simulationSpeed) > 100 && (t = 100);
  var a = t / 1e3;
  geofs.pause || (flight.terrainElevationManagement(),
  controls.update(a),
  geofs.autopilot.UI.update(a),
  flight.tick(a, t, e),
  multiplayer.update(t),
  geofs.debug.update(t),
  geofs.nav.update(a),
  geofs.radio.update(a),
  geofs.flightPlan.update(a),
  instruments.update(),
  audio.update(),
  geofs.fx.update(t),
  geofs.map.updateMap(geofs.aircraft.instance.llaLocation),
  geofs.objects.update(geofs.camera.lla)),
  geofs.pauseLevel < 3 && (geofs.camera.update(a),
  weather.update(a),
  geofs.buildings.update(geofs.camera.lla),
  geofs.trees.update(geofs.camera.lla),
  geofs.fx.atmosphere.update(geofs.camera.lla),
  geofs.api.updateGoogleTiles(geofs.camera.lla),
  geofs.preferences.graphics.waterEffect && geofs.fx.water.update(geofs.camera.lla),
  geofs.api.triggerExplicitRendering()),
  geofs.api.renderingSettings.adaptativeRenderingQuality && geofs.api.adaptativeRenderingQuality()
}
,
geofs.flyTo = function(e, t) {
  if (e) {
      geofs.doPause(1);
      var a = geofs.aircraft.instance;
      e[0] = e[0] || geofs.initialRunways[0][0],
      e[1] = e[1] || geofs.initialRunways[0][1],
      e[2] = e[2] || 0,
      e[3] = e[3] || 0,
      e[4] ? a.absoluteStartAltitude = !0 : a.absoluteStartAltitude = !1,
      a.startAltitude = e[2],
      geofs.lastFlightCoordinates = e;
      var o = e[0]
        , r = e[1]
        , n = e[2]
        , s = [0, 0, 0];
      s[0] = e[3];
      var c = 0 == n;
      a.llaLocation = [o, r, n],
      t ? geofs.camera.update(1) : (geofs.probeTerrain(),
      "free" == geofs.camera.currentModeName || "chase" == geofs.camera.currentModeName ? geofs.camera.reset() : geofs.camera.set(geofs.camera.currentMode),
      controls.reset(),
      weather.reset()),
      geofs.api.waterDetection.reset(),
      a.reset(c),
      instruments.reset(),
      geofs.objects.update(a.llaLocation),
      geofs.runways.refresh(),
      geofs.runwaysLights.updateAll(),
      ui.hideCrashNotification(),
      geofs.api.getGuarantiedGroundAltitude([o, r, 0]).then(t => {
          var o = t[0].height || 0;
          if (geofs.groundElevation = o,
          flight.reset(geofs.groundElevation),
          a.absoluteStartAltitude ? a.startAltitude < geofs.groundElevation && (c = !0) : a.startAltitude += geofs.groundElevation,
          c && (a.startAltitude = geofs.groundElevation + a.definition.startAltitude,
          a.absoluteStartAltitude = !1),
          a.llaLocation[2] = a.startAltitude,
          flight.elevationAtPreviousLocation = o,
          c)
              s[1] = a.definition.startTilt || 0,
              a.startOnGround = !0,
              a.groundContact = !0,
              a.place(a.llaLocation, s),
              a.object3d.compute(a.llaLocation),
              a.render(),
              geofs.undoPause(1);
          else {
              a.startOnGround = !1,
              a.place(a.llaLocation, s),
              a.object3d.compute(a.llaLocation);
              var r = (e[5] || a.definition.minimumSpeed) / MS_TO_KNOTS * a.definition.mass;
              a.rigidBody.applyCentralImpulse(V3.scale(a.object3d.getWorldFrame()[1], r)),
              geofs.undoPause(1)
          }
          geofs.camera.update(2),
          flight.recorder.clear(),
          $(document).trigger("flyto")
      }
      ).catch(e => {
          a.startOnGround = !1,
          a.place(a.llaLocation, s),
          a.object3d.compute(a.llaLocation);
          var t = a.definition.minimumSpeed / 1.94 * a.definition.mass;
          a.rigidBody.applyCentralImpulse(V3.scale(a.object3d.getWorldFrame()[1], t)),
          geofs.undoPause(1)
      }
      )
  }
}
,
geofs.flyToCamera = function() {
  geofs.flyTo(geofs.camera.getFlytToCoordinates()),
  geofs.camera.setToNeutral()
}
,
geofs.resetFlight = function() {
  window.confirm("Are you sure you want to reset this flight?") && geofs.flyTo(geofs.lastFlightCoordinates || geofs.initialCoordinates, !0)
}
,
window.addEventListener("deferredload", function() {
  $(document).on("loginchange preferenceRead", function() {
      geofs.api.setDataProvider(geofs.preferences.graphics.dataProvider)
  }),
  $(document).on("subscriptionchange", function() {
      geofs.api.setDataProvider("hd")
  }),
  $(document).on("dataProviderChange", function() {
      geofs.preferences.graphics.dataProvider = geofsSetDataProvider,
      geofs.savePreferences(),
      $("#" + geofsSetDataProvider + "Imagery").click()
  }),
  geofs.init()
}),
geofs.preferences = {},
geofs.userRecord = geofs.userRecord || {},
geofs.preferencesDefault = {
  aircraft: "",
  coordinates: "",
  controlMode: "mouse",
  keyboard: {
      sensitivity: 1,
      exponential: 0,
      mixYawRoll: !0,
      steerWithRoll: !0,
      keys: {
          "Toggle Autopilot": {
              keycode: 65,
              label: "<A>"
          },
          "Bank left": {
              keycode: 37,
              label: "<Left Arrow>"
          },
          "Bank right": {
              keycode: 39,
              label: "<Right Arrow>"
          },
          "Pitch down": {
              keycode: 38,
              label: "<Up Arrow>"
          },
          "Pitch up": {
              keycode: 40,
              label: "<Down Arrow>"
          },
          "Steer left": {
              keycode: 188,
              label: "<"
          },
          "Steer right": {
              keycode: 190,
              label: ">"
          },
          Brakes: {
              keycode: 32,
              label: "<Space bar>"
          },
          "Parking brake": {
              keycode: 186,
              label: ";"
          },
          "Increase throttle": {
              keycode: 107,
              label: "+"
          },
          "Decrease throttle": {
              keycode: 109,
              label: "-"
          },
          "Increase throttle alt": {
              keycode: 33,
              label: "<Page up>"
          },
          "Decrease throttle alt": {
              keycode: 34,
              label: "<Page down>"
          },
          "Elevator trim up": {
              keycode: 36,
              label: "<Home>"
          },
          "Elevator trim down": {
              keycode: 35,
              label: "<End>"
          },
          "Elevator trim neutral": {
              keycode: 46,
              label: "<Delete>"
          },
          "Engine switch (on/off)": {
              keycode: 69,
              label: "E"
          },
          "Cycle flaps": {
              keycode: 70,
              label: "F"
          },
          "Gear toggle (up/down)": {
              keycode: 71,
              label: "G"
          },
          "Accessories (hook/floats/rudder) toggle": {
              keycode: 90,
              label: "Z"
          },
          "Lower flaps": {
              keycode: 219,
              label: "["
          },
          "Raise flaps": {
              keycode: 221,
              label: "]"
          },
          "Airbrake toggle (on/off)": {
              keycode: 66,
              label: "B"
          },
          "Optional Animated Part toggle (on/off)": {
              keycode: 88,
              label: "X"
          },
          "Push To Talk": {
              keycode: 84,
              label: "T"
          }
      }
  },
  mouse: {
      sensitivity: 1,
      exponential: 1,
      reverse: !1,
      mixYawRoll: !0,
      steerWithRoll: !0
  },
  joystick: {
      sensitivity: 1,
      exponential: 1,
      mixYawRoll: !1,
      steerWithRoll: !1,
      axis: {
          pitch: 1,
          roll: 0,
          yaw: 5,
          throttle: 6
      },
      multiplier: {
          pitch: !1,
          roll: !1,
          yaw: !1,
          throttle: !1
      },
      calibration: {},
      buttons: {
          0: "setBrakes",
          1: "setElevatorTrimDown",
          2: "setElevatorTrimUp",
          3: "setFlapsUp",
          4: "setFlapsDown",
          5: "setGear",
          6: "setAirbrakes",
          7: "setOptionalAnimatedPart"
      }
  },
  orientation: {
      sensitivity: 1,
      exponential: 1,
      mixYawRoll: !0,
      steerWithRoll: !0,
      axis: {
          pitch: 0,
          roll: 1,
          yaw: 2
      },
      multiplier: {
          pitch: !1,
          roll: !1,
          yaw: !1
      }
  },
  touch: {
      sensitivity: .2,
      exponential: 1.5,
      mixYawRoll: !0,
      steerWithRoll: !0,
      axis: {
          pitch: 0,
          roll: 1,
          yaw: 2
      },
      multiplier: {
          pitch: !1,
          roll: !1,
          yaw: !1
      }
  },
  camera: {
      headMotion: !1
  },
  weather: {
      sun: !1,
      localTime: 12,
      season: 1,
      manual: !0,
      quality: 0,
      advanced: {
          clouds: 0,
          fog: 0,
          windSpeed: 0,
          windDirection: 0,
          turbulences: 0
      }
  },
  graphics: {
      quality: 3,
      slaveQuality: 3,
      enhanceColors: 1,
      volumetricClouds: !1,
      advancedAtmosphere: !0,
      waterEffect: !1,
      vegetation: !1,
      buildings: !1,
      contrails: !1,
      dataProvider: "hd",
      advanced: {
          resolutionScale: 1,
          viewingDistance: 3,
          tileCacheSize: 250,
          fxaa: !0,
          msaaSamples: 1,
          globeLighting: !0,
          shadowQuality: 1,
          dropShadow: !0,
          softShadows: !1,
          cloudDensity: .6
      }
  },
  audio: {
      sound: !0,
      volume: 1
  },
  interface: {
      transparent: !0,
      showYokeCursor: !1,
      drawFlightPath: !1,
      recenterMap: !0
  },
  copilot: {
      enabled: !1,
      voice: null,
      volume: 1,
      readingFrequency: 0
  },
  simBriefUsername: "",
  crashDetection: !1,
  showPapi: !0,
  multiplayer: !0,
  showCommunityMultiplayer: !1,
  adsb: !1,
  chat: !1,
  sound: !0,
  volume: 1,
  recorderLength: 1e3,
  simulationSpeed: 1
},
geofs.preferencesKeycodeLookup = {
  8: "<Back space>",
  9: "<Tab>",
  13: "<Enter>",
  16: "<Shift>",
  17: "<Control>",
  18: "<Alt>",
  19: "<Break>",
  20: "<Caps Lock>",
  32: "<Space bar>",
  33: "<Page up>",
  34: "<Page down>",
  35: "<End>",
  36: "<Home>",
  37: "<Left Arrow>",
  38: "<Up Arrow>",
  39: "<Right Arrow>",
  40: "<Down Arrow>",
  44: "<Print scr>",
  45: "<Insert>",
  46: "<Delete>",
  110: "<Delete>",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "<Num lock>",
  145: "<Scroll Lock>"
},
geofs.localStorage = window.localStorage || {},
geofs.initPreferences = function() {
  geofs.$preferencePanel = $(".geofs-preferences");
  var e = function(e) {
      e.stopPropagation()
  };
  geofs.$preferencePanel.keydown(e),
  geofs.$preferencePanel.keyup(e),
  $(document).on("expanded", ".geofs-preference-controls", function() {
      geofs.preferencesStartFeedback()
  }).on("collapsed", ".geofs-preference-controls", function() {
      geofs.preferencesStopFeedback()
  })
}
,
geofs.isPreferencePanelOpen = function() {
  return geofs.$preferencePanel.is(":visible")
}
,
geofs.saveFlight = function(e) {
  if (geofs.aircraft.instance) {
      var t = geofs.aircraft.instance.getCurrentCoordinates();
      geofs.aircraft.instance.groundContact ? t[2] = 0 : t[4] = !0,
      e = {
          coordinates: t,
          aircraftId: geofs.aircraft.instance.aircraftRecord.id,
          liveryId: geofs.aircraft.instance.liveryId
      }
  }
  e && geofs.localStorage.setItem("flight", JSON.stringify(e))
}
,
geofs.savePreferences = function() {
  try {
      var e = JSON.stringify(geofs.preferences);
      geofs.localStorage.setItem("settings", e)
  } catch (t) {
      geofs.debug.error(t, "Could not save preferences")
  }
  $(document).trigger("preferenceSaved")
}
,
geofs.resetPreferences = function(e) {
  geofs.localStorage.clear(),
  geofs.flyTo(geofs.initialRunways[0]),
  geofs.preferences = clone(geofs.preferencesDefault),
  geofs.preferences.version = geofs.version,
  geofs.savePreferences(),
  geofs.preferenceInitialized = !1,
  e && (geofs.preferenceInitialized = !1,
  geofs.initializePreferencesPanel())
}
,
geofs.readPreferences = function(e) {
  var t = {};
  try {
      t = JSON.parse(geofs.localStorage.getItem("settings")),
      geofs.forcePreferenceResetOnVersionChange && t.version != geofs.version && (geofs.resetPreferences(),
      geofs.api.notify("Preferences are reset to default after version change.")),
      t && !t.version && (geofs.debug.error(null, "geofs.readPreferences - !savedPreferences.version"),
      geofs.api.notify("Unable to read saved preferences. Preferences are reset to default."),
      geofs.resetPreferences())
  } catch (a) {
      geofs.debug.error(a, "geofs.readPreferences - Unable to read saved preferences. Preferences are reset to default."),
      geofs.api.notify("Error while reading saved preferences. Preferences are reset to default."),
      geofs.resetPreferences()
  }
  if (geofs.preferences = $.extend(!0, {}, geofs.preferencesDefault, t),
  geofs.preferences.version = geofs.version,
  geofs.userRecord.id || (geofs.preferences.chat = !1),
  e)
      try {
          e()
      } catch (o) {
          geofs.debug.error(o, "geofs.readPreferences>callback"),
          geofs.api.notify("Error during GeoFS initialization. Try to reset preferences to default. Please contact support if this error keeps occurring.")
      }
  $(document).trigger("preferenceRead")
}
,
geofs.populateCopilotVoices = function() {
  var e = $(".geofs-copilot-voices-container", geofs.$preferencePanel);
  if (!e)
      return;
  let t = geofs.speech.getVoices();
  for (var a = '<select id="copilotvoice" data-gespref="geofs.preferences.copilot.voice" class="mdl-selectfield__select">', o = 0; o < t.length; o++)
      ("en-US" == t[o].lang || "en-GB" == t[o].lang) && (a += '<option value="' + o + '">' + t[o].name + "</option>");
  a += "</select>",
  e.html(a),
  componentHandler.upgradeDom(),
  geofs.setInputHandlers(e)
}
,
geofs.populateButtonAssignments = function() {
  var e = $(".geofs-joystick-button-container", geofs.$preferencePanel);
  if (e) {
      var t = "";
      for (i in controls.setters)
          t += '<option value="' + i + '">' + controls.setters[i].label + "</option>";
      t += "</select>";
      var a = "";
      for (var o in controls.joystick.buttons)
          a += '<div class="geofs-feedback-wrapper"><label>Button ' + controls.joystick.buttons[o].globalId + '</label><div class="geofs-feedback" button="' + o + '"></div>',
          a += '<select data-gespref="geofs.preferences.joystick.buttons.' + o + '" data-update="{controls.joystick.configure()}">' + t + "</div>";
      e.html(a),
      componentHandler.upgradeDom()
  }
}
,
geofs.populateAxesAssignments = function() {
  var e = $(".geofs-joystick-axes-container", geofs.$preferencePanel);
  if (e) {
      var t = "";
      for (i in controls.axisSetters)
          t += '<option value="' + i + '">' + controls.axisSetters[i].label + "</option>";
      t += "</select>";
      var a = "";
      for (var o in controls.joystick.axes)
          a += '<div class="geofs-feedback-wrapper"><label>Axis ' + controls.joystick.axes[o].globalId + "</label>",
          a += '<select data-gespref="geofs.preferences.joystick.axis.' + o + '">' + t,
          a += '<div class="progress" axis="' + o + '"><div class="bar"></div></div>',
          a += '<label class="mdl-switch mdl-js-switch mdl-js-ripple-effect" title="Inverse axis">',
          a += '<input type="checkbox" class="mdl-switch__input" data-gespref="geofs.preferences.joystick.multiplier.' + o + '" data-update="{controls.setMode()}">',
          a += '<span class="mdl-switch__label">Inverse</span>',
          a += "</label>";
      e.html(a),
      componentHandler.upgradeDom()
  }
}
,
geofs.populateKeyAssignments = function() {
  var e = $(".geofs-keyboard-keys-container", geofs.$preferencePanel)
    , t = "";
  for (var a in geofs.preferences.keyboard.keys) {
      var o = "keyInput" + geofs.preferences.keyboard.keys[a].keycode;
      t += '<div class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label"><input id="' + o + '" class="geofs-preferences-key-detect mdl-textfield__input" type="text" data-type="keydetect" data-gespref="geofs.preferences.keyboard.keys.' + a + '" keycode="' + geofs.preferences.keyboard.keys[a].keycode + '" value="' + geofs.preferences.keyboard.keys[a].label + '"/><label class="mdl-textfield__label" for="' + o + '">' + a + "</label></div>"
  }
  e.html(t),
  e.on("click focus", ".geofs-preferences-key-detect", t => {
      $(".geofs-preference-key-detecting", e).each( (e, t) => {
          t.value = t._originalValue,
          $(t).removeClass("geofs-preference-key-detecting")
      }
      ),
      t.currentTarget._originalValue = t.currentTarget.value,
      t.currentTarget.value = "",
      $(t.currentTarget).addClass("geofs-preference-key-detecting")
  }
  ).on("keyup", ".geofs-preferences-key-detect", e => {
      var t, a = e.currentTarget;
      $(a).hasClass("geofs-preference-key-detecting") && (27 != e.which ? (t = geofs.preferencesKeycodeLookup[e.which] ? geofs.preferencesKeycodeLookup[e.which] : a.value.toUpperCase(),
      a.value = t,
      a.setAttribute("keycode", e.which),
      geofs.setPreferenceFromInput(a)) : a.value = a._originalValue,
      $(a).removeClass("geofs-preference-key-detecting"),
      $(a).blur(),
      e.stopPropagation(),
      e.preventDefault())
  }
  ).on("keydown", ".geofs-preferences-key-detect", e => {
      $(e.currentTarget).hasClass("geofs-preference-key-detecting") && 9 == e.which && (e.stopPropagation(),
      e.preventDefault())
  }
  ).on("blur", ".geofs-preferences-key-detect", e => {
      $(e.currentTarget).hasClass("geofs-preference-key-detecting") && ("" == e.currentTarget.value && (e.currentTarget.value = e.currentTarget._originalValue),
      $(e.currentTarget).removeClass("geofs-preference-key-detecting"),
      e.stopPropagation(),
      e.preventDefault())
  }
  ),
  componentHandler.upgradeDom()
}
,
geofs.preferencesDebugInfo = function() {
  geofs.api.debug(!0);
  for (var e = "Network Latency (avg): " + multiplayer.avgPing + " ms<br/>Frame rate (avg): " + geofs.debug.fps + " fps<br/>--------------<br/><b>Last 10 log messages:</b><br/>", t = 0; t < geofs.debug.logStack.length; t++)
      e += geofs.debug.logStack[t] + "<br/>";
  try {
      var a = $(".geofs-ui-3dview canvas")[0].getContext("webgl") || $(".geofs-ui-3dview canvas")[0].getContext("webgl2");
      e += "--------------<br/><b>WebGL info:</b><br/>",
      e += "gl.VERSION: " + a.getParameter(a.VERSION) + "<br/>",
      e += "gl.SHADING_LANGUAGE_VERSION: " + a.getParameter(a.SHADING_LANGUAGE_VERSION) + "<br/>",
      e += "gl.VENDOR: " + a.getParameter(a.VENDOR) + "<br/>",
      e += "gl.RENDERER: " + a.getParameter(a.RENDERER) + "<br/>";
      var o = a.getExtension("WEBGL_debug_renderer_info");
      e += "UNMASKED_RENDERER_WEBGL: " + a.getParameter(o.UNMASKED_RENDERER_WEBGL) + "<br/>",
      e += "UNMASKED_VENDOR_WEBGL: " + a.getParameter(o.UNMASKED_VENDOR_WEBGL) + "<br/>"
  } catch (r) {}
  $(".geofs-debug-info", geofs.$preferencePanel).html(e)
}
,
geofs.preferencesTestJoystick = function() {
  var e = controls.joystick.poll();
  return e ? ($(".geofs-preferences-joystick-status .alert-success").show().html(controls.joystick.info),
  $(".geofs-preferences-joystick-status .alert-warning").hide(),
  $(".geofs-preferences-joystick-status .alert-error").hide()) : (controls.joystick.api ? ($(".geofs-preferences-joystick-status .alert-error").hide(),
  $(".geofs-preferences-joystick-status .alert-warning").show()) : $(".geofs-preferences-joystick-status .alert-error").show(),
  $(".geofs-preferences-joystick-status .alert-success").hide()),
  e
}
,
geofs.preferencesTestOrientation = function() {
  return controls.orientation.isAvailable() ? ($(".geofs-preferences-orientation").show(),
  !0) : ($(".geofs-preferences-orientation").hide(),
  !1)
}
,
geofs.preferencesStartFeedback = function() {
  geofs.preferencesFeedbackInterval || (geofs.preferencesFeedbackInterval = setInterval( () => {
      geofs.preferencesTestJoystick() && ($(".geofs-preferences-joystick .progress[axis]", geofs.$preferencePanel).each( (e, t) => {
          var a = controls.joystick.getAxisValue(t.getAttribute("axis"));
          a = (a + 1) * 50,
          $(t).find(".bar").css("width", a + "%")
      }
      ),
      $(".geofs-preferences-joystick .geofs-feedback[button]", geofs.$preferencePanel).each( (e, t) => {
          controls.joystick.checkButton(parseInt(t.getAttribute("button"))) ? $(t).addClass("on") : $(t).removeClass("on")
      }
      )),
      geofs.preferencesTestOrientation() && $(".geofs-preferences-orientation .progress[axis]", geofs.$preferencePanel).each( (e, t) => {
          var a = controls.orientation.getNormalizedAxis(geofs.preferences.orientation.axis[t.getAttribute("axis")]);
          a *= 100,
          t.getAttribute("centered") && (a = (a + 100) / 2),
          $(t).find(".bar").css("width", a + "%")
      }
      )
  }
  , 100))
}
,
geofs.preferencesStopFeedback = function() {
  clearInterval(geofs.preferencesFeedbackInterval),
  geofs.preferencesFeedbackInterval = null
}
,
geofs.initializePreferencesPanel = function() {
  try {
      if (geofs.preferencesDebugInfo(),
      geofs.preferenceInitialized)
          return;
      controls.joystick.ready && (geofs.populateButtonAssignments(),
      geofs.populateAxesAssignments()),
      $(controls.joystick).on("joystickReady", function() {
          geofs.populateButtonAssignments(),
          geofs.populateAxesAssignments(),
          geofs.setPreferenceValues(geofs.$preferencePanel.find(".geofs-preferences-joystick")),
          geofs.setInputHandlers(geofs.$preferencePanel.find(".geofs-preferences-joystick"))
      }),
      geofs.populateCopilotVoices(),
      geofs.setPreferenceValues(geofs.$preferencePanel),
      geofs.setInputHandlers(geofs.$preferencePanel),
      geofs.populateKeyAssignments(),
      geofs.preferencesTestJoystick(),
      geofs.preferencesTestOrientation(),
      geofs.preferenceInitialized = !0
  } catch (e) {
      geofs.debug.error(e, "geofs.initializePreferencesPanel")
  }
}
,
geofs.setPreferenceValues = function(e, t) {
  $(e || geofs.$preferencePanel).find("[data-gespref]").each( (e, a) => {
      var o = $(a)
        , r = a.getAttribute("data-type") || a.getAttribute("type");
      "SELECT" == a.nodeName && (r = "select"),
      r = r.toLowerCase();
      for (var n = a.getAttribute("data-gespref").split("."), s = window, e = 0; e < n.length - 1; e++)
          s = s[n[e]];
      var c = s[n[e]];
      switch (r) {
      case "slider":
          o.slider("value", c, t ? "none" : null);
          break;
      case "select":
          geofs.selectDropdown(a, c);
          break;
      case "radio-button":
          var d, u = a.getAttribute("data-matchvalue");
          u && u == c && o.addClass("is-checked");
          break;
      case "checkbox":
      case "radio":
          var d, u = a.getAttribute("data-matchvalue");
          d = u ? u == c : !0 == c,
          o.prop("checked", d),
          d ? o.parent(".mdl-radio, .mdl-switch").addClass("is-checked") : o.parent(".mdl-radio, .mdl-switch").removeClass("is-checked");
          break;
      case "keydetect":
          break;
      default:
          a.value = c
      }
  }
  )
}
,
geofs.setInputHandlers = function(e) {
  $(e).find("[data-gespref]").each( (e, t) => {
      var a = $(t)
        , o = t.getAttribute("data-type") || t.getAttribute("type");
      switch ("SELECT" == t.nodeName && (o = "select"),
      o = o.toLowerCase()) {
      case "slider":
          a.handlerSet || (a.on("change", (e, t) => {
              geofs.setPreferenceFromInput(e.currentTarget)
          }
          ),
          a.handlerSet = !0);
          break;
      case "select":
          t.onchange = () => {
              geofs.setPreferenceFromInput(event.currentTarget)
          }
          ;
          break;
      case "radio-button":
          t.onclick = e => {
              geofs.setPreferenceFromInput(e.currentTarget)
          }
          ;
          break;
      case "checkbox":
      case "radio":
          t.onchange = e => {
              geofs.setPreferenceFromInput(e.currentTarget)
          }
          ;
          break;
      case "keydetect":
          break;
      default:
          t.onchange = e => {
              geofs.setPreferenceFromInput(e.currentTarget)
          }
      }
  }
  )
}
,
geofs.destroyPreferencePanel = function() {
  geofs.api.debug(!1),
  geofs.preferencesStopFeedback()
}
,
geofs.cancelPreferencesPanel = function() {
  geofs.destroyPreferencePanel(),
  ui.closePreferencePanel()
}
,
geofs.setPreferenceFromInput = function(e) {
  try {
      var t, a, o = e.getAttribute("data-gespref");
      if (!o)
          return;
      var r = e.getAttribute("data-type") || e.getAttribute("type");
      "SELECT" == e.nodeName && (r = "select"),
      r = r.toLowerCase();
      for (var n = o.split("."), s = window, c = 0; c < n.length - 1; c++)
          s = s[n[c]];
      switch (r) {
      case "radio-button":
          $(e).is(".is-checked") && (s[n[c]] = e.getAttribute("data-matchvalue"));
          break;
      case "checkbox":
          var d = e.getAttribute("data-matchvalue");
          a = e.checked,
          d ? a && (s[n[c]] = d) : s[n[c]] = a;
          break;
      case "radio":
          var d = e.getAttribute("data-matchvalue");
          a = e.checked,
          d ? a && (s[n[c]] = d,
          a = d) : s[n[c]] = a;
          break;
      case "slider":
          a = parseFloat($(e).slider("value")),
          s[n[c]] = a;
          break;
      case "keydetect":
          a = e.value,
          s[n[c]].keycode = parseInt(e.getAttribute("keycode")),
          s[n[c]].label = a;
          break;
      default:
          a = e.value,
          s[n[c]] = a
      }
      var u = e.getAttribute("data-update");
      if (u) {
          var p = Function("value", u);
          try {
              p.call(e, a)
          } catch (h) {
              geofs.debug.error(h, "setPreferenceFromInput updateFunction.call")
          }
      }
      e = null,
      o = null,
      r = null,
      n = null,
      s = null,
      t = null,
      a = null
  } catch (m) {
      geofs.debug.error(m, "geofs.setPreferenceFromInput")
  }
}
,
geofs.savePreferencesPanel = function() {
  geofs.destroyPreferencePanel(),
  geofs.savePreferences()
}
;
var ui = ui || {};
function Overlay(e, t, a) {
  if (this.definition = {
      url: "",
      anchor: {
          x: 0,
          y: 0
      },
      position: {
          x: 0,
          y: 0
      },
      rotation: 0,
      size: {
          x: 0,
          y: 0
      },
      offset: {
          x: 0,
          y: 0
      },
      visibility: !0,
      opacity: 1,
      scale: {
          x: 1,
          y: 1
      },
      rescale: !!t && t.definition.rescale,
      rescalePosition: !1,
      inline: !1,
      alignment: {
          x: "left",
          y: "bottom"
      },
      overlays: []
  },
  this.parent = t,
  this.children = [],
  this.definition = $.extend(!0, {}, this.definition, e),
  this.position = this.definition.position,
  this.size = this.definition.size,
  this.iconFrame = this.definition.iconFrame,
  this.scale = this.definition.scale,
  this.positionOffset = this.definition.offset,
  this._offset = {
      x: 0,
      y: 0
  },
  this._sizeScale = 1,
  this.rotation = this.definition.rotation,
  this.opacity = this.definition.opacity,
  this.anchor = this.definition.anchor,
  this.visibility = this.definition.visibility,
  t)
      this.compositor = this.parent.compositor;
  else {
      this.isRootLayer = !0;
      let o = "css";
      (e.compositors || "").indexOf(geofs.api.preferredCompositor) > -1 && (o = geofs.api.preferredCompositor),
      this.compositor = new geofs.api.compositors[o](a,this)
  }
  if ("canvas" == this.compositor.name && (this.opacity = geofs.overlayClassToOpacityMap[this.definition.class] || this.opacity),
  this.compositorLayer = this.compositor.createLayer(a, this.definition.inline),
  this.compositorLayer.setUrl(this.definition.url),
  this.compositorLayer.setMask(this.definition.maskUrl, this.definition.clip),
  this.compositorLayer.setText(this.definition.text),
  this.compositorLayer.setClass(this.definition.class),
  this.compositorLayer.setStyle(this.definition.style),
  this.compositorLayer.setSize(this.definition.size),
  this.compositorLayer.setAnchor(this.definition.anchor),
  this.compositorLayer.setPosition(this.definition.position),
  this.compositorLayer.setDrawOrder(this.definition.drawOrder || 0),
  $(this.compositorLayer).one("load", e => {
      var t = this.definition.size.x / e.currentTarget.naturalSize.x
        , a = 1;
      this.definition.size.y && (a = this.definition.size.y / e.currentTarget.naturalSize.y),
      this.definition.size = e.currentTarget.naturalSize;
      var o = t;
      this._sizeScale = o,
      this.scaleAndPlace()
  }
  ),
  this.compositorLayer.setVisibility(this.definition.visibility),
  this.definition.animations)
      for (var r = 0, n = this.definition.animations.length; r < n; r++) {
          var s = this.definition.animations[r];
          "rotate" == s.type && (this.definition.animateRotation = !0),
          "show" == s.type && (this.animateVisibility = !0,
          this.animationVisibility = this.definition.visibility)
      }
  this.definition.manipulator && $(this.compositorLayer._$element).on("mousedown touchstart", e => {
      e.which = 4,
      controls.manipulator = this.definition.manipulator,
      controls.wheelManipulator = null,
      controls.mouseDownHandler(e),
      e.preventDefault()
  }
  ).on("mouseup touchend", e => {
      controls.manipulator = null,
      controls.wheelManipulator = null
  }
  ).on("mouseenter", e => {
      controls.wheelManipulator = this.definition.manipulator
  }
  ).on("mouseleave", e => {
      controls.wheelManipulator = null
  }
  ).addClass("geofs-manipulator");
  for (var r = 0; r < this.definition.overlays.length; r++) {
      let c = this.definition.overlays[r];
      c.compositor = this.definition.compositors;
      var d = new Overlay(c,this,this.definition.inline || c.inline ? this.compositorLayer.getElement() : c.container || a);
      this.children[r] = d
  }
}
ui.playerMarkers = {},
ui.playerSymbols = {},
ui.mouseUpHandlers = [],
ui.svgPlanePath = "M250.2,59.002c11.001,0,20.176,9.165,20.176,20.777v122.24l171.12,95.954v42.779l-171.12-49.501v89.227l40.337,29.946v35.446l-60.52-20.18-60.502,20.166v-35.45l40.341-29.946v-89.227l-171.14,49.51v-42.779l171.14-95.954v-122.24c0-11.612,9.15-20.777,20.16-20.777z",
ui.svgPlaneStyles = {
  traffic: {
      path: ui.svgPlanePath,
      fillColor: "#9abcc8",
      fillOpacity: 1,
      scale: .05,
      strokeColor: "#4a68b8",
      strokeWeight: 1,
      anchor: [250, 250]
  },
  blue: {
      path: ui.svgPlanePath,
      fillColor: "#19abff",
      fillOpacity: 1,
      scale: .06,
      strokeColor: "#162b63",
      strokeWeight: 1,
      anchor: [250, 250]
  },
  yellow: {
      path: ui.svgPlanePath,
      fillColor: "#dbb33c",
      fillOpacity: 1,
      scale: .07,
      strokeColor: "#5d4c1a",
      strokeWeight: 1,
      anchor: [250, 250]
  }
},
ui.init = function() {
  ui.mouseUpHandler = function(e) {
      ui.dragging && ((ui.resizeV || ui.resizeH) && (ui.dragging.resize && ui.dragging.resize(),
      ui.resizeV = null,
      ui.resizeH = null,
      ui.dragging.style.cursor = "default"),
      ui.dragging = null),
      ui.runMouseUpHandlers(e)
  }
  ,
  ui.$viewport = $(".geofs-ui-3dview"),
  $(document).mouseup(ui.mouseUpHandler),
  $(".geofs-ui-3dview, .geofs-canvas-mouse-overlay").on("click", e => {
      window.focus(),
      document.activeElement && document.activeElement.blur()
  }
  ),
  $(document).on("contextmenu", ".geofs-canvas-mouse-overlay", e => {
      e.preventDefault()
  }
  ),
  geofs.map.init(),
  ui.panel.init(),
  ui.userDialog.init(),
  ui.chat.init(),
  ui.vr.init(),
  $(document).on("keydown", ".geofs-stopKeyboardPropagation", e => {
      e.stopImmediatePropagation()
  }
  ),
  $(document).on("keyup", ".geofs-stopKeyupPropagation", e => {
      e.stopImmediatePropagation()
  }
  ),
  $(document).on("click mousedown", ".geofs-stopMousePropagation", e => {
      e.stopImmediatePropagation()
  }
  ),
  $(document).on("click", "[data-aircraft]", e => {
      (!multiplayer.flightSharing.status || multiplayer.flightSharing.host) && (geofs.aircraft.instance.change(e.currentTarget.getAttribute("data-aircraft"), e.currentTarget.getAttribute("data-livery")),
      ui.panel.hide(null, !0),
      e.stopPropagation())
  }
  ),
  $(document).on("click", "[data-camera]", e => {
      var t = e.currentTarget.getAttribute("data-camera");
      Number.isInteger(parseInt(t)) ? geofs.camera.set(parseInt(t)) : geofs.camera.set(null, t)
  }
  ),
  $(document).on("click", ".geofs-crashed", () => {
      geofs.resetFlight()
  }
  ),
  $(document).on("click", "[data-location]", e => {
      Function("{" + e.currentTarget.getAttribute("data-location") + "}")(),
      ui.panel.hide(null, !0),
      e.stopPropagation()
  }
  ),
  $(document).on("keydown", ".address-input", e => {
      e.stopImmediatePropagation()
  }
  ),
  $(document).on("submit", ".geofs-locationForm", e => {
      geoDecodeLocation($(".address-input").val(), (e, t) => {
          null != geofs && null != geofs.aircraft.instance && geofs.flyTo([e, t, 1e3, 0])
      }
      ),
      $(".address-input").val(""),
      ui.collapseLeft(),
      e.preventDefault()
  }
  ),
  ui.applyPreferences()
}
,
ui.showManipulatorCursor = function() {
  ui.$viewport.addClass("geofs-manipulator")
}
,
ui.hideManipulatorCursor = function() {
  ui.$viewport.removeClass("geofs-manipulator")
}
,
ui.showCrashNotification = function() {
  $(".geofs-crashOverlay").addClass("geofs-crashed"),
  geofs.camera.animations.orbitHorizontal.active = !0
}
,
ui.hideCrashNotification = function() {
  $(".geofs-crashOverlay").removeClass("geofs-crashed"),
  geofs.camera.animations.orbitHorizontal.active = !1
}
,
ui.toggleFullscreen = function() {
  ui.isFullscreen ? (document.exitFullscreen(),
  ui.isFullscreen = !1,
  $("body").removeClass("fullscreen")) : (document.body.requestFullscreen(),
  ui.isFullscreen = !0,
  $("body").addClass("fullscreen"))
}
,
ui.applyPreferences = function() {
  geofs.preferences.interface.transparent ? $("body").addClass("geofs-transparentUI") : $("body").removeClass("geofs-transparentUI"),
  geofs.preferences.interface.showYokeCursor ? $("body").addClass("geofs-showYokeCursor") : $("body").removeClass("geofs-showYokeCursor"),
  geofs.handleResize()
}
,
ui.toggleButton = function(e, t) {
  (t = void 0 == t ? !$(e).hasClass("mdl-button--colored") : t) ? $(e).addClass("mdl-button--colored") : $(e).removeClass("mdl-button--colored")
}
,
ui.expandLeft = function() {
  $("body").addClass("geofs-expand-left"),
  geofs.handleResize()
}
,
ui.collapseLeft = function(e) {
  $("body").removeClass("geofs-expand-left"),
  geofs.handleResize()
}
,
ui.addMouseUpHandler = function(e) {
  ui.mouseUpHandlers.push(e)
}
,
ui.runMouseUpHandlers = function(e) {
  for (var t = 0; t < ui.mouseUpHandlers.length; t++)
      try {
          ui.mouseUpHandlers[t](e)
      } catch (a) {
          geofs.debug.error(a, "ui.runMouseUpHandlers")
      }
}
,
ui.panel = {
  init: function() {
      $(document).on("click", "[data-toggle-panel]", e => {
          ui.panel.toggle($(e.currentTarget).attr("data-toggle-panel")),
          e.stopImmediatePropagation()
      }
      ),
      $(document).on("click", () => {
          ui.panel.hide($(".geofs-toggle-panel.geofs-visible").not("[data-noblur]"), !0)
      }
      ),
      $(document).on("click", ".geofs-list-collapsible-item", e => {
          ui.panel.toggleItem(e.currentTarget, e),
          e.preventDefault(),
          e.stopImmediatePropagation()
      }
      ),
      $(document).on("click", ".geofs-collapsible", e => {
          e.stopImmediatePropagation()
      }
      ),
      $(document).on("click", ".geofs-advanced", e => {
          $(e.currentTarget).toggleClass("geofs-expanded")
      }
      )
  },
  toggleItem: function(e, t) {
      var a = $(e)
        , o = a.parents(".geofs-list").first();
      o.find(".geofs-list-item-expanded").not(t.target).removeClass("geofs-list-item-expanded"),
      a.toggleClass("geofs-list-item-expanded"),
      a.hasClass("geofs-list-item-expanded") ? a.trigger("expanded") : a.trigger("collapsed"),
      a.attr("data-noscroll") || o.scrollTop(e.offsetTop)
  },
  expendItem: function(e, t) {
      var a = $(e)
        , o = a.parents(".geofs-list").first();
      o.find(".geofs-list-item-expanded").not(t.target).removeClass("geofs-list-item-expanded"),
      a.addClass("geofs-list-item-expanded"),
      a.trigger("expanded"),
      o.scrollTop(e.offsetTop)
  },
  toggle: function(e, t) {
      var a = $(e);
      a.attr("data-parentZIndex") ? a.parent().css("z-index", a.attr("data-parentZIndex")) : a.parent().css("z-index", ""),
      a.attr("data-parentWidth") ? a.parent().css("width", a.attr("data-parentWidth")) : a.parent().css("width", ""),
      a.hasClass("geofs-visible") ? ui.panel.hide(e, !0) : ui.panel.show(e)
  },
  show: function(e) {
      var t = $(e);
      if (ui.panel.hide()) {
          ui.expandLeft("panel"),
          t.addClass("geofs-visible");
          try {
              Function(t.attr("data-onshow"))()
          } catch (a) {
              geofs.debug.throw(a)
          }
          t.find(".geofs-list-item-expanded").trigger("expanded")
      }
  },
  hide: function(e, t) {
      var a = !0
        , o = $(e || ".geofs-toggle-panel.geofs-visible");
      return $(o).each( (t, o) => {
          var r = $(o);
          if (!e && r.attr("data-modal"))
              return a = !1,
              !1;
          r.removeClass("geofs-visible");
          try {
              Function(r.attr("data-onhide"))()
          } catch (n) {
              geofs.debug.throw(n)
          }
      }
      ),
      o.length && t && ui.collapseLeft(e),
      o.find(".geofs-list-collapsible-item").trigger("collapsed"),
      a
  }
},
ui.closePreferencePanel = function() {
  ui.panel.hide(".geofs-preference-list", !0)
}
,
ui.openMap = function(e) {
  let t = (e = e || {}).lat || geofs.aircraft.instance.llaLocation[0] || 0
    , a = e.lon || geofs.aircraft.instance.llaLocation[1] || 0;
  geofs.map.startMap(),
  geofs.map.updateMap([t, a], !0)
}
,
ui.closeMap = function() {
  geofs.map.stopMap()
}
,
ui.Text = function(e, t) {
  (t = Object.assign({}, this.defaultOptions, t)).text = e + "",
  this._overlay = new geofs.api.cssCompositor(t)
}
,
ui.Text.prototype = {
  defaultOptions: {
      rescale: !1,
      anchor: {
          x: 0,
          y: 0
      }
  },
  show: function() {
      this._overlay.setVisibility(!0)
  },
  hide: function() {
      this._overlay.setVisibility(!1)
  },
  setText: function(e) {
      this._overlay.setText(e)
  },
  destroy: function() {
      this._overlay.destroy()
  }
},
ui.clearPlayerList = function() {
  $(".geofs-player-list").html("")
}
,
ui.initPlayerList = function() {}
,
ui.userDialog = {
  init() {
      $(document).on("click", "[data-player]", e => {
          var t = e.currentTarget.getAttribute("data-player");
          t != geofs.userRecord.id && ui.userDialog.open(t)
      }
      );
      var e = $(".geofs-user-dialog");
      e.on("click", ".geofs-join-user", t => {
          var a = e.data("user")
            , o = multiplayer.users[a.uid]
            , r = o.getCoordinates();
          r[0] -= .003 * Math.cos(r[3] * DEGREES_TO_RAD),
          r[1] -= .003 * Math.sin(r[3] * DEGREES_TO_RAD),
          o.isOnGround() && (r[2] = 0),
          r && (r[4] = !0,
          geofs.flyTo(r)),
          ui.userDialog.close()
      }
      ).on("click", ".geofs-ignore-user", () => {
          var t = e.data("user");
          multiplayer.blockUser(t.acid),
          ui.userDialog.close()
      }
      ).on("click", ".geofs-share-user", () => {
          var t = e.data("user");
          multiplayer.flightSharing.request(multiplayer.getUser(t.uid)),
          ui.userDialog.close()
      }
      ).on("click", ".geofs-ban-user", () => {
          var t = e.data("user");
          multiplayer.banUser(t.acid),
          ui.userDialog.close()
      }
      ).on("click", ".geofs-cancel", () => {
          ui.userDialog.close()
      }
      )
  },
  open(e) {
      var t = multiplayer.getUser(e);
      t && $(".geofs-user-dialog").data("user", {
          callsign: t.callsign,
          uid: e,
          acid: t.acid
      }).css("display", "flex").find(".geofs-user-callsign").html(t.callsign)
  },
  close() {
      $(".geofs-user-dialog").data("user", null).css("display", "none")
  }
},
ui.chat = {},
ui.chat.maxNumberMessages = 30,
ui.chat.init = function() {
  $(".geofs-chat-input").keydown(e => {
      27 == e.which && ui.chat.hideInput(!0)
  }
  ).mousedown(e => {
      e.preventDefault()
  }
  ),
  $(".geofs-chat-form").submit(e => {
      multiplayer.setChatMessage($(".geofs-chat-input").val()),
      ui.chat.hideInput(!0),
      e.preventDefault()
  }
  ),
  $(".geofs-chat-button").mouseup(e => {
      ui.chat.showInput(),
      e.stopPropagation()
  }
  ),
  $(".geofs-chat-send-button").mouseup(e => {
      e.stopPropagation()
  }
  ),
  ui.addMouseUpHandler(ui.chat.hideInput),
  ui.chat.visibility()
}
,
ui.chat.showInput = function() {
  !1 == geofs.preferences.chat ? ui.notification.show("Chat is disabled. You can enable it in the option panel.") : ($(".geofs-chat-input-section").addClass("geofs-visible"),
  $(".geofs-chat-input").focus())
}
,
ui.chat.hideInput = function(e) {
  $(".geofs-chat-input-section").removeClass("geofs-visible"),
  $(".geofs-chat-input").val(""),
  !0 === e && $(".geofs-chat-input").blur()
}
,
ui.chat.publish = function(e) {
  if (geofs.preferences.chat) {
      var t = decodeURIComponent(e.msg);
      ui.chat.$container = ui.chat.$container || $(".geofs-chat-messages");
      var a = "";
      e.acid == geofs.userRecord.id && (a = "myself"),
      ui.chat.$container.prepend('<div class="geofs-chat-message ' + e.rs + '"><b class="label ' + a + '" data-player="' + e.uid + '" acid="' + e.acid + '" callsign="' + e.cs + '">' + e.cs + ":</b> " + t + "</div>"),
      ui.chat.$container.find(".geofs-chat-message").each( (e, t) => {
          $(t).css("opacity", (ui.chat.maxNumberMessages - e) / ui.chat.maxNumberMessages)
      }
      ).eq(ui.chat.maxNumberMessages).remove()
  }
}
,
ui.chat.removeUserMessages = function(e) {
  ui.chat.$container && ui.chat.$container.find("[acid=" + e + "]").remove()
}
,
ui.chat.visibility = function() {
  geofs.preferences.chat ? $("body").addClass("geofs-chatOn") : $("body").removeClass("geofs-chatOn")
}
,
ui.vr = {},
ui.vr.init = function() {
  geofs.api.isWebXRAvailable() && $(".geofs-button-vr").css("display", "inline-block")
}
,
ui.vr.toggle = function() {
  geofs.api.toggleVr(),
  ui.toggleButton(".geofs-button-vr", geofs.vrOn)
}
,
ui.notification = {},
ui.notification.show = function(e) {
  geofs.api.notify(e)
}
,
ui.notification.showOnce = function(e, t) {
  geofs.preferences.key || (geofs.api.notify(e),
  geofs.preferences.key = "notified",
  geofs.savePreferences())
}
,
geofs.handleResize = function() {
  clearTimeout(geofs.resizingTimeout),
  geofs.resizingTimeout = setTimeout( () => {
      for (var e in geofs.resizeHandlers)
          try {
              geofs.resizeHandlers[e](geofs.viewport.offsetWidth, geofs.viewport.offsetHeight)
          } catch (t) {
              geofs.debug.error(t, "geofs.handleResize")
          }
  }
  , 300)
}
,
geofs.addResizeHandler = function(e, t) {
  if (!t || !t.resizeHandlerId) {
      geofs.resizeHandlers[geofs.resizeHandlersIndex] = e;
      var a = geofs.resizeHandlersIndex++;
      return t && (t.resizeHandlerId = a),
      a
  }
}
,
geofs.removeResizeHandler = function(e) {
  delete geofs.resizeHandlers[e]
}
,
geofs.getViewportDimentions = function() {
  geofs.viewportWidth = geofs.viewport.offsetWidth,
  geofs.viewportHeight = geofs.viewport.offsetHeight,
  geofs.viewportDimensions = {
      x: geofs.viewportWidth,
      y: geofs.viewportHeight
  },
  geofs.camera.cam && (geofs.fovScale = Math.pow(geofs.viewportWidth / VIEWPORT_REFERENCE_WIDTH, .5),
  geofs.fovScale = geofs.fovScale / Math.pow(geofs.api.getFOV(geofs.camera.cam), 1))
}
,
geofs.currentVisibility = 0,
geofs.visibilityCycle = function() {
  geofs.currentVisibility++,
  4 == geofs.currentVisibility && (geofs.currentVisibility = 0),
  0 == geofs.currentVisibility && (instruments.show(),
  $("body").removeClass("geofs-uiMinimalistic"),
  $("body").removeClass("geofs-uiNone")),
  1 == geofs.currentVisibility && (instruments.show(),
  $("body").addClass("geofs-uiMinimalistic"),
  $("body").removeClass("geofs-uiNone")),
  2 == geofs.currentVisibility && (instruments.hide(),
  instruments.show("controls"),
  $("body").addClass("geofs-uiMinimalistic"),
  $("body").removeClass("geofs-uiNone")),
  3 == geofs.currentVisibility && (instruments.hide(),
  $("body").removeClass("geofs-uiMinimalistic"),
  $("body").addClass("geofs-uiNone")),
  instruments.update()
}
,
geofs.overlayClassToOpacityMap = {
  "geofs-instrument-background": .4,
  "geofs-overlay-moreTransparence": .6
},
Overlay.prototype.makeDirty = function() {
  this.dirty = !0
}
,
Overlay.prototype.setVisibility = function(e) {
  (!this.animateVisibility || this.animationVisibility) && this.compositorLayer.setVisibility(e),
  this.visibility = e;
  for (var t = 0; t < this.children.length; t++)
      this.children[t].setVisibility(e)
}
,
Overlay.prototype.setOpacity = function(e) {
  this.compositorLayer.setOpacity(e),
  this.opacity = e;
  for (var t = 0; t < this.children.length; t++)
      this.children[t].setOpacity(e)
}
,
Overlay.prototype.scaleAllProperties = function(e) {
  e = e || this.scale;
  var t = {
      x: 1,
      y: 1
  }
    , a = {
      x: 1 * this._sizeScale,
      y: 1 * this._sizeScale
  };
  this.definition.rescalePosition && (t = {
      x: e.x,
      y: e.y
  }),
  this.definition.rescale && (a = {
      x: a.x * e.x,
      y: a.y * e.y
  }),
  this.position = {
      x: this.definition.position.x * t.x,
      y: this.definition.position.y * t.y
  },
  this.size = {
      x: this.definition.size.x * a.x,
      y: this.definition.size.y * a.y
  },
  this.compositorLayer.setSize(this.size),
  this.positionOffset = {
      x: this.definition.offset.x * a.x,
      y: this.definition.offset.y * a.y
  },
  this.compositorLayer.setOffset(this.positionOffset),
  this.compositorLayer.setTranslation({
      x: 0,
      y: 0
  }),
  this.definition.iconFrame ? (this.iconFrame = {
      x: this.definition.iconFrame.x * a.x,
      y: this.definition.iconFrame.y * a.y
  },
  this.compositorLayer.setFrameSize(this.iconFrame)) : (this.iconFrame = this.size,
  this.compositorLayer.setFrameSize(this.size)),
  this.anchor = {
      x: this.definition.anchor.x * a.x,
      y: this.definition.anchor.y * a.y
  },
  this.compositorLayer.setAnchor(this.anchor),
  this.rotationCenter = {
      x: this.anchor.x,
      y: this.iconFrame.y - this.anchor.y
  },
  this.compositorLayer.setRotationCenter(this.rotationCenter)
}
,
Overlay.prototype.scaleAndPlace = function(e, t, a, o) {
  if ("canvas" == this.compositor.name && (o = !0),
  this.scale = this.scaleFromParent(e),
  (this.definition.rescale && !this.parent || this.definition.rescalePosition) && !o) {
      var r = clamp((a = a || geofs.viewportDimensions).x / VIEWPORT_REFERENCE_WIDTH, .3, 1)
        , n = clamp(a.y / VIEWPORT_REFERENCE_HEIGHT, .3, 1)
        , s = Math.min(r, n);
      this.scale = S2.scale(this.scale, s)
  }
  this.offset = {
      x: 0,
      y: 0
  },
  this.scaleAllProperties(),
  this.place(t, a);
  for (var c = 0; c < this.children.length; c++)
      this.children[c].scaleAndPlace(null, null, a)
}
,
Overlay.prototype.place = function(e, t) {
  !this.parent || this.parent.definition.inline || this.definition.container ? (e = e || this.definition.position,
  "cockpit" == geofs.camera.currentModeName && this.definition.cockpit ? this.position = e : this.definition.alignment && "css" == this.compositor.name && (t = t || geofs.viewportDimensions,
  "right" == this.definition.alignment.x && (this.position.x = t.x - e.x * this.scale.x),
  "center" == this.definition.alignment.x && (this.position.x = t.x / 2 - e.x * this.scale.x),
  "top" == this.definition.alignment.y && (this.position.y = t.y - e.y * this.scale.y),
  "center" == this.definition.alignment.y && (this.position.y = t.y / 2 - e.y * this.scale.y))) : (this.definition.animateRotation || (this.rotation = this.definition.rotation + this.parent.rotation),
  "canvas" == this.compositor.name ? this.position = {
      x: this.parent.position.x + this.definition.position.x * this.scale.x,
      y: this.parent.position.y - this.definition.position.y * this.scale.y
  } : this.position = {
      x: this.parent.position.x + this.definition.position.x * this.scale.x,
      y: this.parent.position.y + this.definition.position.y * this.scale.y
  }),
  this.compositorLayer.setPosition(this.position),
  this.compositorLayer.setOpacity(this.opacity),
  this.compositorLayer.setRotation(this.rotation)
}
,
Overlay.prototype.scaleFromParent = function(e) {
  e = e || {
      x: 1,
      y: 1
  };
  var t = this.parent ? this.parent.scale : {
      x: 1,
      y: 1
  };
  return {
      x: this.definition.scale.x * t.x * e.x,
      y: this.definition.scale.y * t.y * e.y
  }
}
,
Overlay.prototype.positionFromParentRotation = function() {
  var e = [this.position.x, this.position.y, 0]
    , t = M33.identity();
  return t = M33.rotationZ(t, -this.parent.rotation * DEGREES_TO_RAD),
  {
      x: (e = M33.transform(t, e))[0],
      y: e[1]
  }
}
,
Overlay.prototype.animate = function(e) {
  if (this.definition.animations)
      for (var t = 0; t < this.definition.animations.length; t++) {
          var a = this.definition.animations[t]
            , o = geofs.animation.filter(a);
          if (a.lastValue == o && !(e || a.forceRefresh || this.parent && this.parent.dirty)) {
              this.dirty = !1;
              continue
          }
          switch (this.dirty = !0,
          a.lastValue = o,
          a.type) {
          case "moveY":
              !isNaN(o) && this.visibility && this.compositorLayer.setPositionY(this.position.y + o * this.scale.y);
              break;
          case "translateY":
              !isNaN(o) && this.visibility && this.translateIcon(o, "Y");
              break;
          case "translateX":
              !isNaN(o) && this.visibility && this.translateIcon(o, "X");
              break;
          case "scaleX":
              !isNaN(o) && this.visibility && (this.size.x = o * this.scale.x,
              this.compositorLayer.setSize(this.size));
              break;
          case "scaleFrameX":
              !isNaN(o) && this.visibility && (this.iconFrame.x = o,
              this.compositorLayer.setFrameSize(this.iconFrame));
              break;
          case "scaleFrameY":
              !isNaN(o) && this.visibility && (this.iconFrame.y = o,
              this.compositorLayer.setFrameSize(this.iconFrame));
              break;
          case "text":
              this.compositorLayer.setText(o);
              break;
          case "title":
              this.compositorLayer.setTitle(o);
              break;
          case "opacity":
              this.setOpacity(o);
              break;
          case "show":
              this.visibility && this.compositorLayer.setVisibility(o),
              this.animationVisibility = o;
              break;
          default:
              o && this.visibility && this.rotate(o)
          }
      }
  for (var r = 0; r < this.children.length; r++)
      this.children[r].animate(e);
  this.isRootLayer && this.compositor.render()
}
,
Overlay.prototype.translateIcon = function(e, t) {
  "Y" == t ? this._offset.y = e * this.scale.y * this._sizeScale - this.size.y + this.iconFrame.y : this._offset.x = e * this.scale.x * this._sizeScale,
  this.compositorLayer.setTranslation(this._offset)
}
,
Overlay.prototype.rotate = function(e) {
  this.rotation = e,
  this.parent && (this.rotation += this.parent.rotation),
  this.compositorLayer.setRotation(this.rotation)
}
,
Overlay.prototype.setText = function(e) {
  this.compositorLayer.setText(e)
}
,
Overlay.prototype.setTitle = function(e) {
  this.compositorLayer.setTitle(e)
}
,
Overlay.prototype.destroy = function() {
  this.compositor && this.compositor.destroy(),
  this.compositorLayer && this.compositorLayer.destroy();
  for (var e = 0; e < this.children.length; e++)
      this.children[e].destroy()
}
,
geofs.fx = geofs.fx || {
  globeLoaded: !1
},
geofs.fx.texture2url = {
  smoke: "images/particles/smoke-light.png",
  whitesmoke: "images/particles/smoke-white.png",
  darkSmoke: "images/particles/smoke-dark.png",
  contrails: "images/particles/contrails.png",
  1: "images/lights/yellowflare.png",
  2: "images/lights/redflare.png",
  3: "images/lights/greenflare.png",
  white: "images/lights/whitelight.png",
  red: "images/lights/redlight.png",
  green: "images/lights/greenlight.png",
  orange: "images/lights/orangelight.png",
  yellow: "images/lights/yellowlight.png",
  whitepapi: "images/lights/whitepapi.png",
  redpapi: "images/lights/redpapi.png"
},
geofs.fx.particles = {},
geofs.fx.particleEmitters = {},
geofs.fx.init = function() {
  $(document).on("globeLoaded", () => {
      geofs.fx.globeLoaded = !0
  }
  )
}
,
geofs.fx.precisionTime = 0,
geofs.fx.update = function(e) {
  for (var t in geofs.fx.particleEmitters)
      geofs.fx.particleEmitters[t].update(e);
  for (var t in geofs.fx.particles)
      geofs.fx.particles[t].update(e);
  geofs.preferences.graphics.waterEffect && geofs.fx.wake.update(),
  geofs.pause || (geofs.fx.precisionTime = geofs.api.precisionTime)
}
,
geofs.fx.setParticlesColor = function(e) {
  for (var t in geofs.fx.particles)
      geofs.fx.particles[t].setColor(e)
}
,
geofs.fx.maxTimeSinceLastParticleEmission = 1e3,
geofs.fx.maxParticlePerFrame = 2,
geofs.fx.ParticleEmitter = function(e) {
  this._birth = geofs.utils.fastNow(),
  this._id = this._birth + Math.random(),
  this._lastEmission = this._birth,
  this._on = !e.off,
  this._options = e,
  this._options.location = this._options.location || [0, 0, 0],
  geofs.fx.particleEmitters[this._id] = this,
  this._options.anchor && geofs.aircraft.instance && (this._options.location = V3.dup(Object3D.utilities.getPointLla(this._options.anchor, geofs.aircraft.instance.llaLocation)))
}
,
geofs.fx.ParticleEmitter.prototype = {
  update: function() {
      if (this._on) {
          var e, t = geofs.utils.fastNow();
          if (t - this._birth > this._options.duration) {
              this.destroy();
              return
          }
          var a = t - this._lastEmission
            , o = a * this._options.rate;
          a > geofs.fx.maxTimeSinceLastParticleEmission && (o = geofs.fx.maxParticlePerFrame),
          o > geofs.fx.maxParticlePerFrame && (o = geofs.fx.maxParticlePerFrame);
          var r = null;
          if (this._options.anchor && (r = V3.dup(Object3D.utilities.getPointLla(this._options.anchor, geofs.aircraft.instance.llaLocation))),
          this._options.followPath) {
              if (this._lastEmissionLocation) {
                  var n = V3.sub(r, this._lastEmissionLocation)
                    , s = V2.length(lla2xyz(n, this._lastEmissionLocation));
                  s > this._options.pathStep && (this._options.location = r,
                  this._options.startRotation = geofs.utils.lookAt(r, this._lastEmissionLocation, [0, 0, 1]),
                  this._options.startScale = s,
                  new geofs.fx.Particle(this._options,this),
                  this._lastEmissionLocation = V3.dup(r),
                  this._lastEmission = t)
              } else
                  this._lastEmissionLocation = V3.dup(r)
          } else {
              var c = null;
              if (r) {
                  var n = V3.sub(r, this._options.location);
                  c = V3.scale(n, 1 / o)
              }
              for (var d = 0; d < o - 1; d++)
                  c && (this._options.location = V3.add(this._options.location, c)),
                  new geofs.fx.Particle(this._options,this),
                  this._lastEmission = t
          }
          r && (this._options.location = r)
      }
  },
  isOn: function() {
      return this._on
  },
  turnOn: function() {
      this._on = !0
  },
  turnOff: function() {
      this._on = !1
  },
  destroy: function() {
      delete geofs.fx.particleEmitters[this._id]
  }
},
geofs.fx.ParticuleEmitter = geofs.fx.ParticleEmitter,
geofs.fx.particleBillboardOptions = {
  sizeInMeters: !0
},
geofs.fx.Particle = function(e, t) {
  var a = Object.assign({}, e);
  this._birth = geofs.utils.fastNow(),
  this._id = this._birth + Math.random(),
  this._emitter = t,
  geofs.fx.particles[this._id] = this,
  a.url = a.url || geofs.fx.texture2url[a.texture],
  a.startOpacity = a.startOpacity || 1,
  a.endOpacity = a.endOpacity || a.startOpacity,
  a.startScale = a.startScale || 1,
  a.endScale = a.endScale || a.startScale,
  a.easing = a.easing || "linear",
  a.randomizeStartScale && (a.startScale += Math.random() * a.randomizeStartScale),
  a.randomizeEndScale && (a.endScale += Math.random() * a.randomizeEndScale),
  "random" == a.startRotation && (a.startRotation = Math.random() * TWO_PI),
  "random" == a.endRotation && (a.endRotation = Math.random() * TWO_PI),
  a.startRotation = a.startRotation || 0,
  a.endRotation = a.endRotation || a.startRotation,
  this.currentLocation = V3.dup(a.location),
  a.dtOpacity = a.endOpacity - a.startOpacity,
  a.dtScale = a.endScale - a.startScale,
  a.dtRotation = a.endRotation - a.startRotation,
  this._options = a,
  this.create()
}
,
geofs.fx.Particle.prototype = {
  create: function() {
      this._currentScale = this._options.startScale,
      this._currentOpacity = this._options.startOpacity,
      this._currentRotation = this._options.startRotation;
      var e = {
          opacity: this._currentOpacity,
          scale: this._currentScale,
          rotation: this._currentRotation,
          color: geofs.fx.cloudManager.cloudColor
      };
      this._options = Object.assign(this._options, e, geofs.fx.particleBillboardOptions),
      this._options.model ? (this._options.rotation = [this._currentRotation, 0, 0],
      this._APIElement = new geofs.api.Model(this._options.model,this._options)) : this._options.groundTexture ? this._APIElement = new geofs.api.groundTexture(this.currentLocation,this._options.groundTexture,this._options) : (this._options.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(this._options.near || 50,this._options.far || 1e6),
      this._APIElement = new geofs.api.billboard(this.currentLocation,this._options.url,this._options))
  },
  setColor: function(e) {
      this._APIElement && this._APIElement.setColor(e)
  },
  setLocation: function(e) {
      this._APIElement && (this.currentLocation = e,
      this._APIElement.setLocation(this.currentLocation))
  },
  setRotation: function(e, t) {
      this._APIElement && (this._currentRotation = e,
      this._APIElement.setRotation(this._currentRotation, t))
  },
  setScale: function(e) {
      this._APIElement && this._APIElement.setScale(e)
  },
  setPositionOrientationAndScale: function(e, t, a) {
      this._APIElement && this._APIElement.setPositionOrientationAndScale(e, t, a)
  },
  update: function(e) {
      var t = (geofs.utils.fastNow() - this._birth) / this._options.life;
      if (t > 1) {
          this.destroy();
          return
      }
      if (this._APIElement) {
          var a = geofs.utils.easingFunctions[this._options.easing](t);
          this._options.dtOpacity && (this._currentOpacity = clamp(this._options.startOpacity + this._options.dtOpacity * a, 0, 1),
          this._APIElement.setOpacity(this._currentOpacity)),
          this._options.dtScale && (this._currentScale = this._options.startScale + this._options.dtScale * a,
          this._APIElement.setScale(this._currentScale)),
          this._options.dtRotation && (this._currentRotation = this._options.startRotation + this._options.dtRotation * a,
          this._APIElement.setRotation(this._currentRotation)),
          this._options.velocity && this._options.direction && (this._options.velocityDamper && (this._options.velocity *= this._options.velocityDamper * e),
          this.currentLocation = V3.add(this.currentLocation, V3.scale(this._options.direction, this._options.velocity)),
          this._APIElement.setLocation(this.currentLocation)),
          this._options.floatsOnWaves && (this.currentLocation[2] = geofs.fx.water.getWaveHeight(this.currentLocation[0], this.currentLocation[1]),
          this._APIElement.setLocation(this.currentLocation))
      }
  },
  destroy: function() {
      this._APIElement && (this._APIElement.destroy(),
      this._APIElement = null),
      this._emitter = null,
      geofs.fx.particles[this._id] = null,
      delete geofs.fx.particles[this._id]
  }
},
geofs.fx.light = function(e, t, a) {
  e = e || [0, 0, 0];
  var o = geofs.fx.texture2url[t];
  this._billboard = new geofs.api.billboard(e,o,a)
}
,
geofs.fx.light.prototype = {
  setVisibility: function(e) {
      return this._billboard.setVisibility(e),
      !0
  },
  setLocation: function(e) {
      this._billboard.setLocation(e)
  },
  destroy: function() {
      this._billboard.destroy(),
      this._billboard = null
  }
},
geofs.light = geofs.fx.light,
geofs.fx.dayNightManager = {
  nightSunColors: [Cesium.Color.fromCssColorString("#ff8c4e30"), Cesium.Color.fromCssColorString("#2e150d25"), Cesium.Color.fromCssColorString("#20202020"), Cesium.Color.fromCssColorString("#20202020"), Cesium.Color.fromCssColorString("#20202020"), Cesium.Color.fromCssColorString("#20202020"), Cesium.Color.fromCssColorString("#20202020"), Cesium.Color.fromCssColorString("#20202020")],
  daySunColors: [Cesium.Color.fromCssColorString("#ff8c4e30"), Cesium.Color.fromCssColorString("#ffbe97ff"), Cesium.Color.fromCssColorString("#ffffffff"), Cesium.Color.fromCssColorString("#ffffffff"), Cesium.Color.fromCssColorString("#ffffffff"), Cesium.Color.fromCssColorString("#ffffffff"), Cesium.Color.fromCssColorString("#ffffffff"), Cesium.Color.fromCssColorString("#ffffffff")],
  brightness: {
      valueRamp: [100, 1, 1, 1, 1, 1, 1, 1]
  },
  saturation: {
      valueRamp: [.01, .01, 1, 1, 1, 1, 1, 1]
  },
  gamma: {
      valueRamp: [.1, .1, 1, 1, 1, 1, 1, 1]
  },
  hue: {
      valueRamp: [0, 0, 0, 0, 0, 0, 0, 0]
  },
  brightnessShift: {
      valueRamp: [-.6, -.6, -.2, 0, 0]
  },
  groundBrightnessShift: {
      valueRamp: [-1.5, -1.3, -.4, 0, 0]
  },
  groundAtmoSaturationShift: {
      valueRamp: [-.6, -.6, 0, 0, 0]
  },
  groundHueShift: {
      valueRamp: [0, 0, 0, 0, 0]
  },
  cloudsBrightness: {
      valueRamp: [0, 0, 0, .5, 1, 1]
  },
  fogBrightness: {
      valueRamp: [.1, .1, .2, .5, 1, 1]
  },
  blackMarbleVisibility: {
      valueRamp: [1, 1, 1, 0, 0]
  },
  blackMarbleAlpha: {
      valueRamp: [.1, .1, .1, 0, 0]
  },
  init: function() {
      weather.timeRatio > .55 ? geofs.api.viewer.scene.moon.show = !0 : geofs.api.viewer.scene.moon.show = !1,
      geofs.fx.dayNightManager.sunColor = geofs.fx.dayNightManager.daySunColor,
      setTimeout( () => {
          this.update()
      }
      , 0)
  },
  update: function() {
      let e = Cesium.Cartesian3.normalize(geofs.api.viewer.scene.sun._boundingVolume.center, new Cesium.Cartesian3)
        , t = Cesium.Cartesian3.normalize(geofs.camera.cam.position, new Cesium.Cartesian3)
        , a = parseFloat(Cesium.Cartesian3.dot(t, e).toPrecision(2));
      if (!a || a == geofs.fx.sunDotNormal)
          return;
      geofs.fx.sunDotNormal = a;
      let o, r;
      a > 0 ? (geofs.fx.dayNightManager.sunColor = geofs.api.color.mixArray(geofs.fx.dayNightManager.daySunColors, clamp(a, 0, 1)),
      o = geofs.api.color.mixArray(geofs.fx.water.dayHorizonColors, clamp(a, 0, 1)),
      r = geofs.api.color.mixArray(geofs.fx.water.dayAzimutColors, clamp(a, 0, 1))) : (geofs.fx.dayNightManager.sunColor = geofs.api.color.mixArray(geofs.fx.dayNightManager.nightSunColors, clamp(-a, 0, 1)),
      o = geofs.api.color.mixArray(geofs.fx.water.nightHorizonColors, clamp(-a, 0, 1)),
      r = geofs.api.color.mixArray(geofs.fx.water.nightAzimutColors, clamp(-a, 0, 1))),
      geofs.fx.dayNightManager.sunColor.blue < .35 ? geofs.isNight = !0 : geofs.isNight = !1,
      geofs.fx.water.setColours(o, r),
      geofs.animation.values.night != geofs.isNight && $("body").trigger("nightChange"),
      geofs.animation.values.night = geofs.isNight,
      a < 0 ? geofs.api.viewer.scene.skyBox.show = !0 : geofs.api.viewer.scene.skyBox.show = !1,
      geofs.fx.dayNightManager.sunIntensity = geofs.fx.dayNightManager.sunColor.alpha,
      geofs.api.setSceneLight(geofs.fx.dayNightManager.sunColor, geofs.fx.dayNightManager.sunIntensity * weather.belowCloudsBrightness),
      geofs.fx.cloudManager.setCloudColors(null, null, null, 1, geofs.fx.dayNightManager.sunColor);
      var n = a
        , s = clamp(1 - weather.timeRatio + n, 0, 1);
      this.illumination != s && (geofs.api.setImageryColorModifier("time", {
          brightness: geofs.animation.filter(this.brightness, s),
          saturation: geofs.animation.filter(this.saturation, s),
          gamma: geofs.animation.filter(this.gamma, s),
          hue: geofs.animation.filter(this.hue, s)
      }),
      this.illumination = s)
  }
},
geofs.fx.atmosphere = {
  color: Cesium.Color.fromCssColorString("#b6d3f5ff"),
  dayColor: Cesium.Color.fromCssColorString("#b6d3f5ff"),
  nightColor: Cesium.Color.fromCssColorString("#e0773dff"),
  brightness: 1,
  postProcessingStageSet: !1,
  updatePeriod: 1e3,
  cloudsUpdatePeriod: 6e5,
  cloudLayerPosition: .2,
  planetRadiusOffset: 1e4,
  planetRadius: 6361e3,
  realPlanetRadius: 6371e3,
  atmosphereThickness: 111e3,
  create: function(e, t, a, o, r) {
      if (this.advancedAtmosphere != e && this.destroy(),
      this.volumetricClouds != a && this.destroy(),
      this.quality != t && this.destroy(),
      this.realTimeClouds != o && this.destroy(),
      this.retro != r && this.destroy(),
      geofs.fx.atmosphere.postProcessingStages)
          return;
      this.reset();
      var n = e ? "#define ADVANCED_ATMOSPHERE\n" : ""
        , s = "#define QUALITY_" + t + "\n"
        , c = a ? "#define VOLUMETRIC_CLOUDS\n" : ""
        , d = o ? "#define REALTIME_CLOUDS\n" : ""
        , u = r ? "#define RETRO\n" : ""
        , p = .01 * weather.definition.cloudCover;
      this.quality = t,
      this.advancedAtmosphere = e,
      this.volumetricClouds = a && e,
      this.realTimeClouds = o,
      this.retro = r,
      geofs.api.useNativeAtmosphere(!this.advancedAtmosphere);
      let h = geofs.fx.atmosphere.planetRadius + geofs.fx.atmosphere.atmosphereThickness;
      geofs.fx.atmosphere.realPlanetRadius = geofs.fx.atmosphere.planetRadius + geofs.fx.atmosphere.planetRadiusOffset;
      let m = h * h;
      if (geofs.fx.atmosphere.atmospherePostProcessStage = new Cesium.PostProcessStage({
          fragmentShader: n + u + d + c + s + geofsShaders["atmosphereCommon.glsl"] + geofsShaders["atmosphereOnlyFS.glsl"],
          uniforms: {
              planetRadius: geofs.fx.atmosphere.planetRadius,
              realPlanetRadius: geofs.fx.atmosphere.realPlanetRadius,
              atmoRadiusSquared: m,
              backgroundFogDensity: 0,
              backgroundFogColor: geofs.fx.atmosphere.color,
              volumetricFogDensity: 0,
              volumetricFogBottom: 0,
              volumetricFogTop: 0
          }
      }),
      a) {
          geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.volumetricCloudsTexture = "volumetricClouds",
          geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.windVector = weather.currentWindVectorWC,
          geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudCover = p;
          let f = weather.definition.cloudTop - weather.definition.cloudBase
            , g = f * geofs.fx.atmosphere.cloudLayerPosition
            , y = weather.definition.cloudBase + g
            , v = geofs.fx.atmosphere.realPlanetRadius + weather.definition.cloudBase
            , _ = v + f;
          geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudBase = weather.definition.cloudBase,
          geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudTop = weather.definition.cloudTop,
          geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.layerPosition = geofs.fx.atmosphere.cloudLayerPosition,
          geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudThickness = f,
          geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.baseThickness = g,
          geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.layer = y,
          geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudBaseRadius = v,
          geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudTopRadius = _;
          let b = clamp(.12 * t, .25, 1);
          geofs.fx.atmosphere.cloudsPostProcessStage = new Cesium.PostProcessStage({
              textureScale: b,
              fragmentShader: n + u + d + c + s + geofsShaders["atmosphereCommon.glsl"] + geofsShaders["volumetricCloudsFS.glsl"],
              uniforms: {
                  planetRadius: geofs.fx.atmosphere.planetRadius,
                  realPlanetRadius: geofs.fx.atmosphere.realPlanetRadius,
                  atmoRadiusSquared: m,
                  windVector: weather.currentWindVectorWC,
                  cloudCover: p,
                  cloudBase: weather.definition.cloudBase,
                  cloudTop: weather.definition.cloudTop,
                  layerPosition: geofs.fx.atmosphere.cloudLayerPosition,
                  cloudThickness: f,
                  baseThickness: g,
                  layer: y,
                  cloudBaseRadius: v,
                  cloudTopRadius: _,
                  noiseTexture: "/shaders/noise/bluenoise.png"
              }
          }),
          o && (p = 1,
          geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.coverageTexture = weather.realTimeCloudTexture + "?t=" + geofs.utils.hourStamp(),
          geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudCover = p,
          geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.coverageTexture = weather.realTimeCloudTexture + "?t=" + geofs.utils.hourStamp(),
          geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.cloudCover = p),
          geofs.fx.atmosphere.blurStage = Cesium.PostProcessStageLibrary.createBlurStage(),
          geofs.fx.atmosphere.blurStage.uniforms.delta = 1,
          geofs.fx.atmosphere.blurStage.uniforms.sigma = 2,
          geofs.fx.atmosphere.blurStage.uniforms.stepSize = clamp(6 - t, 1, 4),
          geofs.fx.atmosphere.postProcessingStages = new Cesium.PostProcessStageComposite({
              inputPreviousStageTexture: !1,
              stages: [new Cesium.PostProcessStageComposite({
                  inputPreviousStageTexture: !0,
                  stages: [geofs.fx.atmosphere.cloudsPostProcessStage, geofs.fx.atmosphere.blurStage],
                  name: "volumetricClouds"
              }), geofs.fx.atmosphere.atmospherePostProcessStage]
          })
      } else
          geofs.fx.atmosphere.postProcessingStages = geofs.fx.atmosphere.atmospherePostProcessStage;
      $(document).on("terrainProviderWillUpdate", () => {
          geofs.fx.globeLoaded = !1,
          this.destroy()
      }
      ),
      $(document).on("globeLoaded", () => {
          geofs.fx.atmosphere.addPostProcessingStage(),
          geofs.fx.atmosphere.tileLoadProgressListener()
      }
      ),
      geofs.fx.atmosphere.tileLoadProgressListener = geofs.api.viewer.scene.globe.tileLoadProgressEvent.addEventListener(e => {
          e > 2 && (geofs.fx.globeLoaded = !0,
          $("body").trigger("globeLoaded"))
      }
      ),
      geofs.fx.atmosphere.addPostProcessingStage()
  },
  addPostProcessingStage: function() {
      geofs.fx.globeLoaded && !geofs.fx.atmosphere.postProcessingStageSet && (geofs.api.viewer.scene.postProcessStages.add(geofs.fx.atmosphere.postProcessingStages),
      geofs.fx.atmosphere.postProcessingStageSet = !0)
  },
  reset: function() {},
  update: function(e, t) {
      if (!geofs.fx.atmosphere.postProcessingStages || !geofs.utils.updateTime(this, this.updatePeriod) && !t)
          return;
      let a = geofs.api.viewer.scene.globe.ellipsoid.cartographicToCartesian(new Cesium.Cartographic(e[1] * DEGREES_TO_RAD,e[0] * DEGREES_TO_RAD,0))
        , o = Cesium.Cartesian3.magnitude(a)
        , r = o - geofs.fx.atmosphere.planetRadiusOffset
        , n = r + geofs.fx.atmosphere.atmosphereThickness;
      geofs.fx.atmosphere.realPlanetRadius = o;
      let s = n * n
        , c = weather.definition.cloudTop - weather.definition.cloudBase
        , d = c * geofs.fx.atmosphere.cloudLayerPosition
        , u = weather.definition.cloudBase + d
        , p = geofs.fx.atmosphere.realPlanetRadius + weather.definition.cloudBase
        , h = p + c;
      geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.planetRadius = r,
      geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.realPlanetRadius = geofs.fx.atmosphere.realPlanetRadius,
      geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.atmoRadiusSquared = s,
      geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudBase = weather.definition.cloudBase,
      geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudTop = weather.definition.cloudTop,
      geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.layerPosition = geofs.fx.atmosphere.cloudLayerPosition,
      geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudThickness = c,
      geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.baseThickness = d,
      geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.layer = u,
      geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudBaseRadius = p,
      geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudTopRadius = h,
      geofs.fx.atmosphere.cloudsPostProcessStage && (geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.planetRadius = r,
      geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.realPlanetRadius = geofs.fx.atmosphere.realPlanetRadius,
      geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.cloudBase = weather.definition.cloudBase,
      geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.cloudTop = weather.definition.cloudTop,
      geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.layerPosition = geofs.fx.atmosphere.cloudLayerPosition,
      geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.cloudThickness = c,
      geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.baseThickness = d,
      geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.layer = u,
      geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.cloudBaseRadius = p,
      geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.cloudTopRadius = h),
      this.realTimeClouds && geofs.utils.updateTime(this, this.cloudsUpdatePeriod) && (geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.coverageTexture = weather.realTimeCloudTexture + "?t=" + geofs.utils.hourStamp(),
      geofs.fx.atmosphere.cloudsPostProcessStage && (geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.coverageTexture = weather.realTimeCloudTexture + "?t=" + geofs.utils.hourStamp()))
  },
  setConditions: function(e, t) {
      geofs.fx.atmosphere.postProcessingStages && this.volumetricClouds && (this.realTimeClouds && (t = 1),
      geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.windVector = e,
      geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudCover = t,
      geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.windVector = e,
      geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.cloudCover = t,
      geofs.fx.atmosphere.update(geofs.camera.lla, !0))
  },
  setVolumetricFog: function(e, t, a) {
      geofs.fx.atmosphere.postProcessingStages && (geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.volumetricFogBottom = e,
      geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.volumetricFogTop = t,
      geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.volumetricFogDensity = a)
  },
  setFogColor: function(e, t) {
      if (!geofs.fx.atmosphere.postProcessingStages)
          return;
      t = t || this.brightness,
      e = e || weather.timeRatio,
      t *= weather.belowCloudsBrightness;
      let a = Cesium.Color.lerp(geofs.fx.atmosphere.dayColor, geofs.fx.atmosphere.nightColor, e, new Cesium.Color);
      a = new Cesium.Color(a.red * t,a.green * t,a.blue * t,1),
      geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.backgroundFogColor = a
  },
  setFogDensity: function(e) {
      geofs.fx.atmosphere.postProcessingStages && (geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.backgroundFogDensity = e)
  },
  destroy: function() {
      geofs.fx.atmosphere.postProcessingStages && (geofs.api.viewer.scene.postProcessStages.remove(geofs.fx.atmosphere.postProcessingStages),
      geofs.fx.atmosphere.postProcessingStages.isDestroyed() || geofs.fx.atmosphere.postProcessingStages.destroy(),
      geofs.fx.atmosphere.postProcessingStageSet = !1,
      geofs.fx.atmosphere.postProcessingStages = null,
      geofs.fx.atmosphere.atmospherePostProcessStage = null,
      geofs.fx.atmosphere.cloudsPostProcessStage = null,
      geofs.fx.atmosphere.tileLoadProgressListener && geofs.fx.atmosphere.tileLoadProgressListener())
  }
},
geofs.fx.cloudManager = {
  cloudCoverToCloudNumber: 15,
  clouds: {},
  numberOfClouds: 0,
  currentID: 0,
  maxNumberOfClouds: 0,
  refreshDistance: 1e3,
  currentCenter: [0, 0, 0],
  redAnimation: {
      valueRamp: [255, 255, 250, 100, 100]
  },
  greenAnimation: {
      valueRamp: [255, 255, 230, 100, 100]
  },
  blueAnimation: {
      valueRamp: [255, 255, 200, 100, 100]
  },
  fogBrightnessRamp: [0, 0, 0, 1],
  groundBrightnessRamp: [-.4, -.4, -.4, 0],
  setCloudCoverToCloudNumber: function(e) {
      this.cloudCoverToCloudNumber = e || this.cloudCoverToCloudNumber,
      geofs.fx.cloudManager.instance && this.setCloudCover(geofs.fx.cloudManager.instance.percentCoverage)
  },
  init: function(e) {
      this.cloudSituation = null;
      var t = lla2xyz(V3.sub(this.currentCenter, e), geofs.aircraft.instance.llaLocation);
      V3.length(t) > this.refreshDistance && this.destroyAllClouds(),
      this.currentCenter = e,
      this.numberOfClouds = 0,
      geofs.fx.cloudManager.instance = this
  },
  spawnClouds: function() {
      var e = this.maxNumberOfClouds - this.numberOfClouds;
      if (e > 0)
          for (var t = 0; t < e; t++)
              new geofs.fx.Cloud;
      else if (e < 0)
          for (; e < 0; )
              this.destroyLastCloud(),
              e++
  },
  triggerUpdate: function() {
      this.cloudSituation = null
  },
  update: function(e, t) {
      if (geofs.fx.cloudManager.instance) {
          geofs.fx.cloudManager.instance.currentCenter = e;
          var a, o = clamp((e[2] - (weather.definition.cloudBase - weather.definition.coverHalfThickness)) / weather.definition.cloudCoverThickness, weather.belowCloudsBrightness, 1);
          if (a = e[2] < weather.definition.cloudBase ? 2 : e[2] < weather.definition.cloudBase + weather.definition.coverHalfThickness ? 6 : e[2] < weather.definition.cloudBase + weather.definition.cloudCoverThickness ? 12 : 8,
          e[2] < weather.definition.fogCeiling && (a += 1),
          this.cloudSituation != a && (geofs.fx.atmosphere.setVolumetricFog(weather.definition.fogBottom, weather.definition.fogCeiling, weather.definition.fog),
          a <= 7 ? (geofs.fx.atmosphere.setFogDensity(weather.definition.backgroundFogDensity),
          this.fullCover ? (geofs.fx.precipitation.show(),
          this.fullCover.entity.show(),
          geofs.disableShadows(),
          geofs.api.hideSun(),
          geofs.api.setImageryColorModifier("cloudcover", {
              saturation: clamp(o, .2, 1),
              brightness: clamp(o, .2, 1)
          }),
          geofs.api.setAtmosphereColorModifier("cloudcover", {
              saturationShift: -2,
              brightnessShift: o - .9,
              groundBrightnessShift: o - 1.2,
              groundSaturationShift: o - 1
          })) : (geofs.enableShadows(),
          geofs.api.showSun(),
          geofs.api.removeImageryColorModifier("cloudcover"),
          geofs.api.removeAtmosphereColorModifier("cloudcover"))) : 8 & a && (geofs.fx.atmosphere.setFogDensity(0),
          this.fullCover && (this.fullCover.entity.show(),
          geofs.fx.atmosphere.setVolumetricFog(weather.definition.cloudBase, weather.definition.cloudBase + weather.definition.coverHalfThickness, 1)),
          geofs.fx.precipitation.hide(),
          geofs.enableShadows(),
          geofs.api.showSun(),
          geofs.api.removeImageryColorModifier("cloudcover"),
          geofs.api.removeAtmosphereColorModifier("cloudcover"))),
          4 & a && this.fullCover) {
              var r = 0;
              a < 8 && (r = weather.definition.backgroundFogDensity);
              var n = clamp((weather.definition.coverHalfThickness - Math.abs(weather.definition.cloudBase - e[2])) * .1, r, 1);
              geofs.fx.atmosphere.setFogDensity(n),
              n > .5 ? this.fullCover.entity.hide() : this.fullCover.entity.show()
          }
          o != this.lastBrightness && (geofs.api.setAtmosphereColorModifier("clouds", {
              cloudsBrightness: o,
              groundBrightnessShift: geofs.animation.getRampRatio(this.groundBrightnessRamp, o),
              fogBrightness: geofs.animation.getRampRatio(this.fogBrightnessRamp, o)
          }),
          this.lastBrightness = o),
          this.cloudSituation = a
      }
  },
  setCloudsBrightness: function(e) {
      geofs.fx.cloudManager.instance && this.setCloudColors(null, null, null, e)
  },
  setCloudColors: function(e, t, a, o, r) {
      if (geofs.fx.cloudManager.instance) {
          e && t && a ? this.cloudColor = Cesium.Color.fromBytes(e, t, a) : r ? this.cloudColor = r : this.cloudColor || (this.cloudColor = Cesium.Color.fromBytes(255, 255, 255)),
          this.brightness = o || this.brightness || 1;
          var n, r = this.cloudColor.darken(1 - this.brightness, new Cesium.Color);
          for (var s in geofs.fx.cloudManager.instance.clouds)
              geofs.fx.cloudManager.instance.clouds[s].setColor(r);
          this.fullCover && this.fullCover.setColor(r),
          geofs.fx.atmosphere.setFogColor(),
          geofs.fx.setParticlesColor(r)
      }
  },
  setCloudCover: function(e) {
      if (geofs.fx.cloudManager.instance) {
          this.percentCoverage = e || 0;
          var t = .01 * e;
          this.percentCoverage >= 100 ? this.fullCover || (this.fullCover = new geofs.fx.CloudCover([geofs.camera.lla[0], geofs.camera.lla[1], weather.definition.cloudBase])) : this.fullCover && (this.fullCover.destroy(),
          this.fullCover = null),
          geofs.api.setAtmosphereColorModifier("weatherHaze", {
              groundBrightnessShift: clamp(.5 * t, 0, .1),
              fogBrightness: clamp(1 + t, 1, 1.2),
              brightnessShift: clamp(.5 * t, 0, .1)
          }),
          this.setNumberOfClouds(this.percentCoverage * this.cloudCoverToCloudNumber),
          this.cloudSituation = null
      }
  },
  setNumberOfClouds: function(e) {
      geofs.fx.cloudManager.instance && (this.maxNumberOfClouds = e,
      this.spawnClouds())
  },
  setCeiling: function(e) {
      for (var t in this.fullCover && this.fullCover.update(),
      this.clouds)
          this.clouds[t].setCeiling(e)
  },
  destroyLastCloud: function() {
      geofs.fx.cloudManager.instance.currentID--,
      this.clouds[geofs.fx.cloudManager.instance.currentID].destroy()
  },
  destroyAllClouds: function() {
      if (geofs.fx.cloudManager.instance) {
          for (var e in this.clouds)
              this.clouds[e].destroy();
          this.fullCover && (this.fullCover.destroy(),
          this.fullCover = null),
          geofs.fx.cloudManager.instance.currentID = 0
      }
  },
  destroy: function() {
      geofs.fx.cloudManager.instance && (this.destroyAllClouds(),
      geofs.fx.cloudManager.instance = null)
  }
},
geofs.fx.Cloud = function(e, t) {
  this._id = geofs.fx.cloudManager.instance.currentID++,
  this._type = Object.assign({}, this.defaultType, this.types[Math.floor(Math.random() * this.types.length)]),
  geofs.fx.cloudManager.instance.numberOfClouds++,
  geofs.fx.cloudManager.instance.clouds[this._id] = this,
  this.create(e)
}
,
geofs.fx.Cloud.prototype = {
  shadowSize: .002,
  shadowTexture: "images/weather/clouds/shadow1.png",
  defaultType: {
      belowCeiling: 0,
      aboveCeiling: 1e3,
      opacity: .8,
      minRadius: 1,
      maxRadius: 1e5,
      rotationMultiplier: 0,
      brightnessDelta: 0
  },
  types: [{
      billboard: "images/weather/clouds/1.png",
      belowCeiling: 500,
      aboveCeiling: 1e3,
      minScale: 6,
      maxScale: 10,
      maxRadius: 5e4,
      opacity: .9,
      shadow: !0
  }, {
      billboard: "images/weather/clouds/6.png",
      belowCeiling: 500,
      aboveCeiling: 1e3,
      minScale: 10,
      maxScale: 15,
      maxRadius: 5e4,
      opacity: .9,
      shadow: !0
  }, {
      billboard: "images/weather/clouds/1.png",
      belowCeiling: 500,
      aboveCeiling: 1500,
      maxRadius: 1e5,
      minScale: 10,
      maxScale: 15,
      opacity: .9,
      shadow: !0
  }, {
      billboard: "images/weather/clouds/5.png",
      belowCeiling: 500,
      aboveCeiling: 1e3,
      maxRadius: 1e5,
      minScale: 6,
      maxScale: 10,
      opacity: .9,
      shadow: !0
  }, {
      billboard: "images/weather/clouds/cumuloniumbus.png",
      belowCeiling: 500,
      aboveCeiling: 100,
      maxRadius: 1e5,
      minScale: 6,
      maxScale: 10,
      opacity: .9,
      shadow: !0
  }, {
      model: "models/clouds/flat1.gltf",
      belowCeiling: 2e3,
      aboveCeiling: 9e3,
      minScale: 4e4,
      maxScale: 45e3,
      maxRadius: 3e5,
      rotationMultiplier: 360,
      opacity: 1
  }, {
      model: "models/clouds/flat2.gltf",
      belowCeiling: 2e3,
      aboveCeiling: 9e3,
      minScale: 4e4,
      maxScale: 45e3,
      maxRadius: 3e5,
      rotationMultiplier: 360,
      opacity: 1
  }],
  billboardOptions: {
      sizeInMeters: !0,
      collection: "default",
      geofsFixCameraRotation: !0
  },
  modelOptions: {},
  create: function(e) {
      if (!e) {
          var t = Math.random() * TWO_PI
            , a = Math.sqrt(Math.random()) * (this._type.maxRadius - this._type.minRadius) + this._type.minRadius
            , o = [Math.cos(t) * a, Math.sin(t) * a];
          (e = V3.add(geofs.aircraft.instance.llaLocation, xy2ll(o, geofs.aircraft.instance.llaLocation)))[2] = Math.random() * (this._type.aboveCeiling - this._type.belowCeiling) + (weather.definition.cloudBase + this._type.belowCeiling)
      }
      if (this._location = e,
      this._type.billboard) {
          var r = Object.assign({}, this.billboardOptions);
          r.scale = clamp(Math.random() * (this._type.maxScale - this._type.minScale) + this._type.minScale, this._type.minScale, this._type.maxScale),
          r.translucencyByDistance = new Cesium.NearFarScalar(this._type.maxRadius / 2,this._type.opacity,this._type.maxRadius,.3),
          r.opacity = this._type.billboardOpacity,
          this._entity = new geofs.api.billboard(e,this._type.billboard,r)
      } else if (this._type.model) {
          var r = Object.assign({}, this.modelOptions);
          r.scale = clamp(Math.random() * (this._type.maxScale - this._type.minScale) + this._type.minScale, this._type.minScale, this._type.maxScale),
          r.rotation = [Math.random() * this._type.rotationMultiplier, 0, 0],
          r.location = e,
          this._entity = new geofs.api.Model(this._type.model,r)
      }
      this.update()
  },
  setCeiling: function(e) {
      e = e || weather.definition.cloudBase;
      var t = Math.random() * (this._type.aboveCeiling - this._type.belowCeiling) + (e + this._type.belowCeiling);
      this._entity.setLocation([this._entity._lla[0], this._entity._lla[1], t])
  },
  setColor: function(e) {
      this._entity.setColor(e)
  },
  move: function(e) {
      this._location = V3.add(this._location, e),
      this._entity.setLocation(this._location)
  },
  setLocation: function(e) {
      this._location = e,
      this._entity.setLocation(e)
  },
  update: function() {
      var e = ll2xy(V3.sub(this._location, geofs.aircraft.instance.llaLocation), geofs.aircraft.instance.llaLocation);
      if (e[2] = 0,
      V2.length(e) > this._type.maxRadius) {
          if (geofs.fx.cloudManager.instance.numberOfClouds <= geofs.fx.cloudManager.instance.maxNumberOfClouds) {
              e = V3.scale(V3.normalize(e), .9 * this._type.maxRadius);
              var t = V3.add(geofs.aircraft.instance.llaLocation, xyz2lla([-e[0], -e[1], e[2]], geofs.aircraft.instance.llaLocation));
              t[2] = this._location[2],
              this.setLocation(t)
          } else {
              this.destroy();
              return
          }
      }
      clearTimeout(this._updateTimeout),
      this._updateTimeout = setTimeout( () => {
          this.update()
      }
      , 2e4 + 2e4 * Math.random())
  },
  destroy: function() {
      clearTimeout(this._updateTimeout),
      delete geofs.fx.cloudManager.instance.clouds[this._id],
      geofs.fx.cloudManager.instance.numberOfClouds--,
      this._entity && this._entity.destroy(),
      this._shadowPrimitive && (geofs.api.viewer.scene.groundPrimitives.remove(this._shadowPrimitive),
      this._shadowPrimitive.destroy()),
      this._shadowEntity && geofs.api.viewer.entities.remove(this._shadowEntity)
  }
},
geofs.fx.CloudCover = function(e) {
  this.create(e)
}
,
geofs.fx.CloudCover.prototype = {
  texture: "models/clouds/cover.jpg",
  size: 1,
  options: {
      url: "models/clouds/cover.gltf",
      scale: 4e5
  },
  create: function(e) {
      if (!this.entity) {
          var t = Object.assign({}, this.options);
          t.location = e,
          this.entity = new geofs.api.Model(null,t),
          this.update()
      }
  },
  setColor: function(e) {
      this.entity.setColor(e)
  },
  setLocation: function(e) {
      this.entity.setLocation(e)
  },
  update: function() {
      this.setLocation([geofs.camera.lla[0], geofs.camera.lla[1], weather.definition.cloudBase]),
      clearTimeout(this._updateTimeout),
      this._updateTimeout = setTimeout( () => {
          this.update()
      }
      , 2e4)
  },
  destroy: function() {
      clearTimeout(this._updateTimeout),
      this.entity && this.entity.destroy(),
      this.entity = null
  }
},
geofs.fx.precipitation = {
  types: {
      snow: {
          speed: .001,
          model: "models/precipitations/snow.gltf?k=1"
      },
      rain: {
          speed: .1,
          model: "models/precipitations/rain.gltf?k=1"
      }
  },
  visible: !0,
  init: function() {},
  create: function(e, t) {
      e != geofs.fx.precipitation.type && (geofs.fx.precipitation.apiModel && geofs.fx.precipitation.destroy(),
      geofs.fx.precipitation.type = e,
      geofs.fx.precipitation.amount = t,
      geofs.fx.precipitation.apiModel = new geofs.api.Model(geofs.fx.precipitation.types[e].model),
      geofs.fx.precipitation.motionOffset = 0)
  },
  update: function(e, t) {
      if (geofs.fx.precipitation.apiModel && (e[2] < weather.definition.cloudBase + weather.definition.coverHalfThickness ? this.show() : this.hide(),
      this.visible)) {
          !geofs.fx.precipitation._material && geofs.fx.precipitation.apiModel._model && geofs.fx.precipitation.apiModel._model.ready && (geofs.fx.precipitation._material = geofs.fx.precipitation.apiModel._model.getMaterial("rainMaterial"));
          var a, o, r, n, s = 0;
          "chase" == geofs.camera.currentModeName || "free" == geofs.camera.currentModeName ? (r = weather.currentWindSpeedMs,
          n = weather.currentWindDirection + 180,
          s = 90) : (r = geofs.aircraft.instance.trueAirSpeed,
          n = Math.atan2(geofs.aircraft.instance.airVelocityDirection[0], geofs.aircraft.instance.airVelocityDirection[1]) * RAD_TO_DEGREES,
          s = Math.acos(geofs.aircraft.instance.airVelocityDirection[2]) * RAD_TO_DEGREES),
          r < 2 && (n = 0),
          (a = [n, 2 * r, 0])[1] = clamp(a[1], 0, s),
          o = [2, 2, clamp(2 + .5 * r, 2, 50)],
          geofs.fx.precipitation.apiModel.setPositionOrientationAndScale(geofs.camera.lla, a, o),
          geofs.fx.precipitation._material && !geofs.pause && (geofs.fx.precipitation.motionOffset -= Math.min(.9, .01 + t * geofs.aircraft.instance.trueAirSpeed * geofs.fx.precipitation.types[geofs.fx.precipitation.type].speed),
          geofs.fx.precipitation.motionOffset < 0 && (geofs.fx.precipitation.motionOffset += 1),
          geofs.fx.precipitation._material.setValue("motion", geofs.fx.precipitation.motionOffset))
      }
  },
  show: function() {
      !this.visible && geofs.fx.precipitation.apiModel && (geofs.fx.precipitation.apiModel.show(),
      this.visible = !0)
  },
  hide: function() {
      this.visible && geofs.fx.precipitation.apiModel && (geofs.fx.precipitation.apiModel.hide(),
      this.visible = !1)
  },
  destroy: function() {
      geofs.fx.precipitation.apiModel && (geofs.fx.precipitation.type = "none",
      geofs.fx.precipitation._material = null,
      geofs.fx.precipitation.apiModel.destroy(),
      geofs.fx.precipitation.apiModel = null)
  }
},
geofs.fx.water = {
  dayHorizonColors: [Cesium.Color.fromCssColorString("#c8976b"), Cesium.Color.fromCssColorString("#d0eef1"), Cesium.Color.fromCssColorString("#d0eef1"), Cesium.Color.fromCssColorString("#d0eef1"), Cesium.Color.fromCssColorString("#d0eef1"), Cesium.Color.fromCssColorString("#d0eef1"), Cesium.Color.fromCssColorString("#d0eef1")],
  nightHorizonColors: [Cesium.Color.fromCssColorString("#c8976b"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606")],
  dayAzimutColors: [Cesium.Color.fromCssColorString("#001528"), Cesium.Color.fromCssColorString("#28537b"), Cesium.Color.fromCssColorString("#28537b"), Cesium.Color.fromCssColorString("#28537b"), Cesium.Color.fromCssColorString("#28537b"), Cesium.Color.fromCssColorString("#28537b"), Cesium.Color.fromCssColorString("#28537b")],
  nightAzimutColors: [Cesium.Color.fromCssColorString("#001528"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606")],
  create: function() {
      geofs.api.googleTileset ? geofs.fx.water.postProcessingStage || (geofs.fx.water.postProcessingStage = new Cesium.PostProcessStage({
          fragmentShader: geofsShaders["postprocessedwater.glsl"],
          uniforms: {
              windSpeed: weather.currentWindSpeedMs || 0,
              geofsTime: 0,
              camTilt: 0,
              horizonColor: Cesium.Color.fromCssColorString("#f1f9fbff"),
              azimutColor: Cesium.Color.fromCssColorString("#38618aff"),
              normalMap: "/shaders/oceannormal2.jpg",
              foamTexture: "/shaders/seafoam.jpg"
          }
      }),
      geofs.fx.globeLoaded ? geofs.api.viewer.scene.postProcessStages.add(geofs.fx.water.postProcessingStage) : $(document).on("globeLoaded", () => {
          geofs.api.viewer.scene.postProcessStages.add(geofs.fx.water.postProcessingStage)
      }
      )) : (geofs.api.waterMask = geofs.api.viewer.imageryLayers.addImageryProvider(new Cesium.UrlTemplateImageryProvider({
          url: geofs.landuseServer + "{z}/{x}/{y}.png",
          hasAlphaChannel: !1,
          enablePickFeatures: !1,
          maximumAnisotropy: 0,
          maximumLevel: 12
      })),
      geofs.api.waterMask.alpha = .01,
      geofs.api.waterMask.show = !0,
      geofs.fx.water.material = new Cesium.Material({
          fabric: {
              type: "MyWater",
              source: geofsShaders["oceanFS.glsl"],
              uniforms: {
                  windSpeed: weather.currentWindSpeedMs || 0,
                  geofsTime: 0,
                  horizonColor: Cesium.Color.fromCssColorString("#f1f9fbff"),
                  azimutColor: Cesium.Color.fromCssColorString("#38618aff"),
                  normalMap: "/shaders/oceannormal2.jpg",
                  foamTexture: "/shaders/seafoam.jpg",
                  lightsTexture: "/shaders/noise/citylights.png"
              }
          }
      }),
      geofs.api.viewer.scene.globe.material = geofs.fx.water.material)
  },
  setConditions: function(e) {
      geofs.fx.water.material && (geofs.fx.water.material.uniforms.windSpeed = e,
      geofs.api.googleTileset && geofs.api.googleTileset.customShader.setUniform("u_windSpeed", e))
  },
  setColours: function(e, t) {
      geofs.fx.water.material && (geofs.fx.water.material.uniforms.horizonColor = e,
      geofs.fx.water.material.uniforms.azimutColor = t,
      geofs.api.googleTileset && (geofs.api.googleTileset.customShader.setUniform("u_horizonColor", e),
      geofs.api.googleTileset.customShader.setUniform("u_azimutColor", t)))
  },
  update: function(e) {
      geofs.fx.water.postProcessingStage && (geofs.fx.water.postProcessingStage.uniforms.camTilt = Math.sin(geofs.camera.htr[1] * DEGREES_TO_RAD)),
      geofs.fx.water.material && (geofs.fx.water.timeRatio != weather.timeRatio && (geofs.fx.water.timeRatio = weather.timeRatio),
      geofs.fx.water.material.uniforms.geofsTime = geofs.fx.precisionTime,
      geofs.api.googleTileset && geofs.api.googleTileset.customShader.setUniform("u_geofsTime", geofs.fx.precisionTime))
  },
  getWaveHeight: function(e, t, a) {
      a = a || 0;
      let o = (geofs.fx.precisionTime + a) * .001
        , r = .35 * weather.definition.windSpeedMS
        , n = Cesium.Cartesian3.fromDegrees(t, e)
        , s = {
          x: (n = Cesium.Cartesian3.normalize(n, n)).y / n.x,
          y: n.z
      };
      var c = V2.scale([(Math.sin((2e4 * s.x + o) % TWO_PI) + 1) * .5, (Math.sin((1e5 * s.y + o) % TWO_PI) + 1) * .5], r);
      return c[0] * c[1]
  },
  destroy: function() {
      geofs.fx.water.postProcessingStage && (geofs.api.viewer.scene.postProcessStages.remove(geofs.fx.water.postProcessingStage),
      geofs.fx.water.postProcessingStage.isDestroyed() || geofs.fx.water.postProcessingStage.destroy(),
      geofs.fx.water.postProcessingStage = null),
      geofs.api.viewer.imageryLayers.remove(geofs.api.waterMask, !0),
      geofs.api.waterMask = null,
      geofs.fx.water.material = new Cesium.Material({
          fabric: {
              type: "Null",
              source: "czm_material czm_getMaterial(czm_materialInput materialInput) {czm_material material; return material;}",
              uniforms: {
                  windSpeed: 0,
                  geofsTime: 0
              }
          }
      }),
      geofs.api.viewer.scene.globe.material = geofs.fx.water.material
  }
},
geofs.fx.wake = {
  anchor: [0, 0, 0],
  altitude: .2,
  create: function() {
      geofs.fx.wake.emitter || (geofs.fx.wake.emitter = new geofs.fx.ParticleEmitter({
          off: !0,
          anchor: geofs.fx.wake.anchor,
          location: geofs.fx.wake.anchor,
          duration: 1e10,
          rate: .001,
          life: 1e4,
          easing: "easeOutQuart",
          startOpacity: 1,
          endOpacity: .001,
          startScale: 1,
          endScale: 50,
          model: "models/wake/wake.gltf",
          rotationAxis: 0,
          maximumScale: 2e4
      }))
  },
  update: function() {
      geofs.aircraft.instance.waterContact && geofs.preferences.graphics.waterEffect ? (geofs.waterIsSea ? geofs.fx.wake.emitter._options.floatsOnWaves = !0 : geofs.fx.wake.emitter._options.floatsOnWaves = !1,
      geofs.fx.wake.anchor[0] = geofs.aircraft.instance.llaLocation[0],
      geofs.fx.wake.anchor[1] = geofs.aircraft.instance.llaLocation[1],
      geofs.fx.wake.anchor[2] = geofs.groundElevation + geofs.waveHeight + geofs.fx.wake.altitude,
      geofs.fx.wake.emitter._options.startRotation = geofs.fx.wake.emitter._options.endRotation = geofs.aircraft.instance.htr[0],
      geofs.fx.wake.emitter._options.rate = clamp(2e-4 * geofs.aircraft.instance.velocityScalar, .001, .01),
      geofs.fx.wake.emitter._options.startScale = clamp(.1 * geofs.aircraft.instance.velocityScalar, 1, 5),
      geofs.fx.wake.emitter._options.endScale = clamp(1e-4 * geofs.aircraft.instance.definition.mass, 50, 150),
      geofs.fx.wake.emitter.turnOn()) : geofs.fx.wake.emitter && geofs.fx.wake.emitter.turnOff()
  },
  destroy: function() {
      geofs.fx.wake.emitter && geofs.fx.wake.emitter.turnOff()
  }
},
window.flight = window.flight || {},
flight.minPenetrationThreshold = .001,
flight.arrestingHookDiscardVelocity = .1,
flight.arrestingHookDiscardLength = 100,
flight.currentAltitudeTestContext = {},
flight.pastAltitudeTestContext = {},
flight.tick = function(e, t, a) {
  var o, r = clamp(Math.floor(t / geofs.api.renderingSettings.physicsDeltaMs), 1, 10), n = e / r, s = 1 / e, c = geofs.aircraft.instance, d = geofs.animation.values;
  c.totalThrust = 0;
  var u = 1
    , p = 1
    , h = c.definition.zeroThrustAltitude
    , m = c.definition.zeroRPMAltitude;
  h ? u = clamp(h - d.altitude, 0, h) / h : m && (p = clamp(m - d.altitude, 0, m) / m);
  for (var f = geofs.aircraft.instance.engines, g = f.length, y = 0; y < g; y++) {
      var v = f[y]
        , _ = controls.throttle
        , b = 1
        , x = v.animations;
      if (x)
          for (var S = 0; S < x.length; S++) {
              var P = x[S];
              switch (P.type) {
              case "throttle":
                  _ = geofs.animation.filter(P);
                  break;
              case "pitch":
                  b = geofs.animation.filter(P)
              }
          }
      if (c.engine.on) {
          var A = (c.definition.maxRPM - c.definition.minRPM) * _ + c.definition.minRPM
            , k = (A *= p) - v.rpm;
          v.rpm += k * c.definition.engineInertia * e,
          geofs.aircraft.instance.definition.reverse && (v.rpm < c.definition.minRPM && v.rpm > 0 && !c.engine.startup && (v.rpm = -c.definition.minRPM),
          v.rpm > -c.definition.minRPM && v.rpm < 0 && !c.engine.startup && (v.rpm = c.definition.minRPM)),
          v.contrailEmitter && (geofs.preferences.graphics.contrails && c.llaLocation[2] > weather.contrailAltitude ? v.contrailEmitter.turnOn() : v.contrailEmitter.turnOff())
      } else
          v.rpm < 1e-5 ? v.rpm = 0 : v.rpm -= v.rpm * c.definition.engineInertia * e;
      var T = Math.abs(v.rpm)
        , C = v.thrust;
      v.afterBurnerThrust && _ > .9 && (C = v.afterBurnerThrust),
      v.rpm < 0 && (C = v.reverseThrust ? -v.reverseThrust : 0);
      var R = C * clamp(T - c.definition.minRPM, 0, c.definition.maxRPM) * c.engine.invRPMRange;
      R *= u,
      R *= b,
      v.currentThrust = R,
      c.totalThrust += R
  }
  g > 0 && (c.engine.rpm = parseInt(T));
  for (var V = 0, y = 0, M = geofs.aircraft.instance.balloons.length; y < M; y++) {
      var D = geofs.aircraft.instance.balloons[y]
        , O = clamp(controls[D.controller.name] * D.controller.ratio || 0, 0, 1);
      V = D.temperature;
      var E = (V += O * D.heatingSpeed * e) - weather.atmosphere.airTempAtAltitude;
      V -= D.coolingSpeed * E * e,
      V = clamp(V, 0, 300),
      D.temperature = V;
      var I = V + KELVIN_OFFSET
        , N = weather.atmosphere.airPressureAtAltitude / (GAS_CONSTANT * I)
        , F = (weather.atmosphere.airDensityAtAltitude - N) * D.volume;
      D.liftingForce = F * GRAVITY,
      c.envelopeTemp = V
  }
  if (geofs.waterDepth = geofs.api.waterDetection.getWaterDepth(c.llaLocation[0], c.llaLocation[1]),
  geofs.waterDepth > 0) {
      if (geofs.groundIsWater = !0,
      geofs.groundElevation < .1) {
          geofs.waterIsSea = !0;
          let z = geofs.fx.water.getWaveHeight(c.llaLocation[0], c.llaLocation[1], -1)
            , B = geofs.fx.water.getWaveHeight(c.llaLocation[0], c.llaLocation[1], 0);
          geofs.waveVerticalSpeed = (z - B) / e,
          geofs.waveHeight = B,
          geofs.debug.watch("waterDepth", geofs.waterDepth),
          geofs.debug.watch("waveHeight", geofs.waveHeight)
      } else
          geofs.waterIsSea = !1,
          geofs.waveHeight = 0
  } else
      geofs.groundIsWater = !1,
      geofs.waterIsSea = !1,
      geofs.waveHeight = 0;
  weather.atmosphere.update(c.llaLocation[2]),
  c.stalling = !1;
  for (var j = 0; j < r; j++) {
      c.velocity = c.rigidBody.v_linearVelocity,
      c.velocityDirection = V3.normalize(c.velocity),
      c.velocityScalar = V3.length(c.velocity),
      c.groundSpeed = V2.length([c.velocity[0], c.velocity[1]]),
      c.velocityScalar,
      c.airVelocity = V3.sub(c.velocity, weather.currentWindVector),
      c.airVelocityDirection = V3.normalize(c.airVelocity),
      c.trueAirSpeed = V3.length(c.airVelocity),
      geofs.aircraft.instance.object3d.getWorldFrame()[2];
      for (var y = 0, M = c.balloons.length; y < M; y++) {
          var D = c.balloons[y];
          c.rigidBody.applyForce([0, 0, D.liftingForce], D.points.forceSourcePoint.worldPosition)
      }
      for (var y = 0; y < c.engines.length; y++) {
          var v = c.engines[y]
            , U = v.object3d.getWorldFrame()[v.forceDirection];
          c.rigidBody.applyForce(V3.scale(U, v.currentThrust), v.points.forceSourcePoint.worldPosition)
      }
      if (c.trueAirSpeed > .01) {
          var G = c.trueAirSpeed * c.trueAirSpeed;
          W = c.definition.dragCoefficient ? .5 * c.definition.dragCoefficient * weather.atmosphere.airDensityAtAltitude * G : c.definition.dragFactor * G * weather.atmosphere.airDensityAtAltitude;
          var H = V3.scale(c.airVelocityDirection, -W);
          c.rigidBody.applyCentralForce(H);
          for (var y = 0, M = c.airfoils.length; y < M; y++) {
              var W, q, H, Y = c.airfoils[y];
              if (!Y.disabled) {
                  var X = Y.points.forceSourcePoint
                    , Z = Y.object3d.getWorldFrame()
                    , Q = c.rigidBody.getVelocityInLocalPoint(X.worldPosition);
                  if (Y.propwash) {
                      var K = c.engine.rpm * Y.propwash
                        , J = V3.dot(Q, c.object3d.worldRotation[1]);
                      Q = V3.add(Q, V3.scale(c.object3d.worldRotation[1], clamp(K - J, 0, K)))
                  }
                  Q = V3.sub(Q, weather.currentWindVector),
                  Q = V3.sub(Q, weather.thermals.currentVector);
                  var ee = Object3D.utilities.getPointLla(X, c.llaLocation);
                  Q = V3.add(Q, weather.getLocalTurbulence(ee)),
                  Y.velocity = V3.length(Q);
                  var et = V3.normalize(Q)
                    , ei = Y.velocity * Y.velocity
                    , ea = Z[Y.forceDirection]
                    , eo = -V3.dot(ea, et)
                    , er = V3.cross(ea, et)
                    , en = V3.rotate(ea, er, eo);
                  if (Y.span) {
                      var es, el = Y.aspectRatio || Y.span / Y.chord, ec = Y.area || Y.span * Y.chord, ed = eo * TWO_PI * (el / (el + 2)), eu = ed * ed / (PI * el * (Y.efficiencyFactor || PLANFORM_EFFICIENCY_FACTOR)) + 0;
                      if (!0 == Y.stalls) {
                          c.angleOfAttackDeg = eo * RAD_TO_DEGREES;
                          var ep = Math.abs(c.angleOfAttackDeg);
                          ep > Y.stallIncidence && (c.stalling = !0,
                          ed *= 1 - clamp(ep - Y.stallIncidence, 0, .9 * Y.zeroLiftIncidence) / Y.zeroLiftIncidence)
                      }
                      var eh = .5 * weather.atmosphere.airDensityAtAltitude * ei * ec;
                      H = eu * eh,
                      q = ed * eh
                  } else if (Y.area) {
                      var em = eo * TWO_PI;
                      if (!0 == Y.stalls) {
                          c.angleOfAttackDeg = eo * RAD_TO_DEGREES;
                          var ep = Math.abs(c.angleOfAttackDeg);
                          ep > Y.stallIncidence && (c.stalling = !0,
                          em *= 1 - clamp(ep - Y.stallIncidence, 0, .9 * Y.zeroLiftIncidence) / Y.zeroLiftIncidence)
                      }
                      H = .5 * ei * (MIN_DRAG_COEF + DRAG_CONSTANT * em * em) * weather.atmosphere.airDensityAtAltitude,
                      q = weather.atmosphere.airDensityAtAltitude * ei * .5 * Y.area * em
                  } else {
                      var ef = Y.liftFactor
                        , eg = Y.dragFactor;
                      if (!0 == Y.stalls) {
                          c.angleOfAttackDeg = eo * RAD_TO_DEGREES;
                          var ep = Math.abs(c.angleOfAttackDeg);
                          ep > Y.stallIncidence && (c.stalling = !0,
                          ef *= .9 - clamp(ep - Y.stallIncidence, 0, Y.zeroLiftIncidence) / Y.zeroLiftIncidence)
                      }
                      var e$ = eo * ei;
                      q = ef * e$ * weather.atmosphere.airDensityAtAltitude,
                      H = eg * Math.abs(e$) * weather.atmosphere.airDensityAtAltitude
                  }
                  Y.lift = q,
                  d[Y.name + "Lift"] = q,
                  q && c.rigidBody.applyForce(V3.scale(en, q), X.worldPosition),
                  H && c.rigidBody.applyForce(V3.scale(et, -H), X.worldPosition)
              }
          }
      }
      var ey = 0;
      if (c.groundContact = !1,
      c.waterContact = !1,
      c.rigidBody.applyForce(c.rigidBody.gravityForce, c.parts.root.points.centerOfMass.worldPosition),
      geofs.withinCollisionRange) {
          for (var ev = geofs.aircraft.instance.collisionPoints, e_ = [], ew = 0, y = 0, M = ev.length; y < M; y++) {
              var eb, ex = ev[y];
              ex.id = y;
              var eS = ex.part;
              ex.groundContact = c.groundContact,
              eS.contact = null;
              var eP = V3.add(c.llaLocation, xyz2lla(ex.worldPosition, c.llaLocation));
              c.rigidBody.getVelocityInLocalPoint(ex.worldPosition);
              var eA = geofs.getCollisionResult(eP, ex.worldPosition, c.collResult, ex)
                , ek = eA.location[2]
                , eT = eS.object3d.getWorldFrame()
                , e0 = c.collResult.normal;
              if (geofs.waterDepth > 0 && eS.buoyancy && !eA.object) {
                  var eC = Math.min(ek + geofs.waveHeight - eP[2], 10);
                  if (eC > 0 && !ex.wrongAltitude) {
                      let e8 = Math.min(eC, 1);
                      eb = {
                          collisionPoint: ex,
                          normal: [0, 0, 1],
                          depth: eC,
                          submersionRatio: e8,
                          force: e8 * eS.buoyancy,
                          type: "buoyancy"
                      },
                      eS.contact = eb,
                      e_.push(eb)
                  }
                  ek -= geofs.waterDepth
              } else if (eS.suspension) {
                  var eR = eS.points.suspensionOrigin
                    , eV = eR.worldPosition[2] + c.llaLocation[2] - ek
                    , eM = eS.suspension.restLength - eV
                    , eL = clamp(eM / eS.suspension.restLength, 0, 1)
                    , e1 = eL * eS.suspension.restLength;
                  if (eL > 0 && eR.worldPosition[2] >= ex.worldPosition[2] && !ex.wrongAltitude) {
                      var eD = V3.dot(e0, eT[2]);
                      eb = {
                          collisionPoint: ex,
                          normal: e0,
                          force: eS.suspension.stiffness * e1,
                          type: "raycast",
                          contactFwdDir: V3.cross(e0, V3.normalize(eT[0])),
                          contactSideDir: V3.cross(e0, V3.normalize(eT[1]))
                      },
                      (eL >= eS.suspension.hardPoint || eD < .4) && (eb.type = "hardpoint",
                      eb.penetration = ek - (ex.worldPosition[2] + c.llaLocation[2]),
                      ew = Math.max(ew, eb.penetration)),
                      eS.contact = eb,
                      e_.push(eb),
                      eR[2] = -eM;
                      var eO = eS.name + "Suspension";
                      d[eO] = eM,
                      eS.suspension.rest = !1
                  } else if (!eS.suspension.rest) {
                      var eO = eS.name + "Suspension";
                      d[eO] = 0,
                      eS.points.suspensionOrigin[2] = 0,
                      eS.suspension.rest = !0
                  }
                  var eE = {};
                  eE[eS.name] = eS,
                  c.placeParts(eE)
              } else if (eS.hook) {
                  if (eA.object && eA.object.arrestingCable && !c.arrestingCableContact) {
                      var eI = ek - eP[2];
                      eI >= -eA.object.arrestingCableHeight && (c.arrestingCableContact = {
                          collisionPoint: ex,
                          normal: e0,
                          type: "arrestingCable",
                          object: eA.object,
                          contactFwdDir: V3.cross(e0, V3.normalize(eT[0])),
                          contactSideDir: V3.cross(e0, V3.normalize(eT[1]))
                      })
                  }
                  if (c.arrestingCableContact) {
                      var eN = geofs.utils.llaDistanceInMeters(eP, c.arrestingCableContact.object.location);
                      c.velocityScalar < flight.arrestingHookDiscardVelocity || eN > flight.arrestingHookDiscardLength ? (c.arrestingCableContact.object.model.setPositionOrientationAndScale(c.arrestingCableContact.object.location, null, 1),
                      c.arrestingCableContact = null) : (eS.contact = c.arrestingCableContact,
                      e_.push(c.arrestingCableContact),
                      c.arrestingCableContact.object.model.setPositionOrientationAndScale(eP, null, [1.6 * eN, 1, 1]))
                  }
              } else if (eS.catapult) {
                  if (c.launchBarContact = null,
                  c.onCatapult = !1,
                  eA.object && eA.object.catapult) {
                      var eI = ek - eP[2];
                      eI > -.1 && (c.onCatapult = !0,
                      controls.throttle > .5 && (c.launchBarContact = {
                          collisionPoint: ex,
                          normal: e0,
                          type: "launchBar",
                          object: eA.object,
                          contactFwdDir: V3.normalize(eT[1]),
                          contactSideDir: null
                      },
                      e_.push(c.launchBarContact)))
                  }
              } else {
                  var eI = ek - eP[2];
                  if (eI >= 0 && !ex.wrongAltitude) {
                      ew = Math.max(ew, eI);
                      var eb = {
                          collisionPoint: ex,
                          normal: e0,
                          penetration: eI,
                          type: "standard",
                          contactFwdDir: V3.cross(e0, V3.normalize(eT[0])),
                          contactSideDir: V3.cross(e0, V3.normalize(eT[1]))
                      };
                      eS.contact = eb,
                      e_.push(eb)
                  }
              }
          }
          if (e_.length && (c.groundContact = !0,
          !flight.skipCollisionResponse)) {
              ew > flight.minPenetrationThreshold && !geofs.cautiousWithTerrain && (c.llaLocation[2] = c.llaLocation[2] + ew,
              ew = 0);
              for (var eF = 0, M = e_.length; eF < M; eF++) {
                  var eb = e_[eF]
                    , ex = eb.collisionPoint
                    , eS = ex.part
                    , e3 = ex.contactProperties
                    , ez = c.rigidBody.getVelocityInLocalPoint(ex.worldPosition);
                  ez = V3.add(ez, [0, 0, geofs.waveVerticalSpeed]);
                  var e2 = V3.dot(eb.normal, ez);
                  ey = Math.max(ey, Math.abs(e2));
                  var eB = 0;
                  if ("buoyancy" == eb.type) {
                      let e4 = clamp(.1 * eb.force * e2, 0, eb.force);
                      var ej = eb.force - e4;
                      c.rigidBody.applyForce(V3.scale(eb.normal, ej), ex.worldPosition);
                      let eU = V3.normalize(ez)
                        , eG = V3.length(ez)
                        , eH = eG * eG * .5;
                      if ("float" == eS.type) {
                          let eW = eS.object3d.getWorldFrame()[eS.forceDirection]
                            , e6 = -V3.dot(eW, eU) * TWO_PI
                            , e5 = .01
                            , eq = WATER_DENSITY * eH * eS.area * e6 * e5;
                          c.rigidBody.applyForce(V3.scale(eW, eq), ex.worldPosition)
                      }
                      let eY = eH * WATER_DENSITY * eb.submersionRatio;
                      geofs.aircraft.instance.object3d.setVectorWorldPosition(eS.dragVector);
                      let e7 = V3.mult(eU, V3.abs(eS.dragVector.worldPosition))
                        , eX = V3.scale(e7, -eY);
                      c.rigidBody.applyForce(eX, ex.worldPosition),
                      c.waterContact = !0
                  }
                  if (("raycast" == eb.type || "hardpoint" == eb.type) && (eB = (eb.force - eS.suspension.damping * e2) * c.rigidBody.mass * n) > 0 && c.rigidBody.applyImpulse(V3.scale(eb.normal, eB), ex.worldPosition),
                  "arrestingCable" == eb.type && (c.arrestingCableContact.force = V3.scale(ez, -eS.hook.strength),
                  c.rigidBody.applyForce(c.arrestingCableContact.force, ex.worldPosition)),
                  "launchBar" == eb.type && (c.launchBarContact.force = V3.scale(geofs.aircraft.instance.object3d.getWorldFrame()[1], eS.catapult.strength),
                  c.launchBarContact.force[2] = 0,
                  controls.steering = 0,
                  controls.yaw = 0,
                  c.rigidBody.applyForce(c.launchBarContact.force, [0, 0, 0]),
                  geofs.debug.watch("catapult", c.launchBarContact.force)),
                  ("standard" == eb.type || "hardpoint" == eb.type) && e2 < 0) {
                      var eZ = c.rigidBody.computeJacobian(0, e2, ex.worldPosition, eb.normal)
                        , e9 = V3.scale(eb.normal, eZ);
                      c.rigidBody.applyImpulse(e9, ex.worldPosition),
                      eB = eZ
                  }
                  var eQ = eB * e3.frictionCoef;
                  if (eQ = clamp(eQ, eQ, 2 * c.rigidBody.mass * n * e3.frictionCoef),
                  "buoyancy" == eb.type)
                      ;
                  else if ("wheel" == eS.type) {
                      var eK = eb.contactFwdDir
                        , eJ = eb.contactSideDir
                        , te = V3.dot(eJ, ez)
                        , tt = V3.dot(eK, ez);
                      eb.forwardProjVel = tt,
                      eb.sideProjVel = te;
                      var ti = c.rigidBody.computeJacobian(0, te, ex.worldPosition, eJ)
                        , ta = c.rigidBody.computeJacobian(0, tt, ex.worldPosition, eK)
                        , to = Math.abs(ti)
                        , tr = Math.abs(ta)
                        , tn = 1
                        , ts = 1;
                      Math.abs(tt) > e3.lockSpeed ? ts = e3.rollingFriction : (eb.forwardProjVel = 0,
                      eb.sideProjVel = 0);
                      var tl = eS.brakesController;
                      if (tl && tr > 0) {
                          var tc = clamp(d[tl] * eS.brakesControllerRatio, 0, 1);
                          ts = clamp(eQ / (tr * e3.frictionCoef), 0, 1) * tc
                      }
                      var td = c.definition.brakeDamping || 3;
                      controls.brakes > .05 && (ts = clamp(eQ / (tr * e3.frictionCoef * td) * controls.brakes, 0, 1)),
                      to > eQ && (tn = clamp(eQ / (to * to), e3.dynamicFriction, 1)),
                      c.rigidBody.applyImpulse(V3.scale(eJ, ti * tn), ex.worldPosition),
                      c.rigidBody.applyImpulse(V3.scale(eK, ta * ts), ex.worldPosition)
                  } else {
                      var tu = V3.sub(ez, V3.scale(eb.normal, e2))
                        , tp = V3.normalize(tu)
                        , th = V3.length(tu);
                      if (th) {
                          var tm = c.rigidBody.computeJacobian(0, th, ex.worldPosition, tp)
                            , tf = Math.abs(tm)
                            , tg = 1;
                          tf > eQ && (tg = clamp(eQ / (tf * tf), e3.dynamicFriction, 1)),
                          c.rigidBody.applyImpulse(V3.scale(tp, tg * tm), ex.worldPosition)
                      }
                  }
              }
          }
      } else
          for (var y = 0, M = geofs.aircraft.instance.suspensions.length; y < M; y++) {
              var eS = geofs.aircraft.instance.suspensions[y];
              if (eS.suspension && !eS.suspension.rest) {
                  var eO = eS.name + "Suspension";
                  d[eO] = 0,
                  eS.points.suspensionOrigin[2] = 0,
                  eS.suspension.rest = !0
              }
          }
      flight.recorder.playing || flight.sharing.on || (c.rigidBody.integrateVelocities(n),
      c.rigidBody.integrateTransform(n),
      geofs.aircraft.instance.object3d.compute(c.llaLocation),
      geofs.aircraft.instance.htr = geofs.aircraft.instance.object3d.htr,
      flight.setAnimationValues(n, a),
      geofs.autopilot.update(n),
      flight.recorder.record())
  }
  !0 == flight.recorder.playing ? (flight.recorder.play(t),
  flight.setAnimationValues(e, a)) : flight.sharing.on ? (flight.sharing.update(t),
  flight.setAnimationValues(e, a)) : (c.rigidBody.setCurrentAcceleration(s, e),
  c.placeParts()),
  c.render(),
  geofs.preferences.crashDetection && ey > 10 && !c.crashed && (c.crashNotified = !0,
  ui.showCrashNotification(),
  c.crash()),
  c.htrAngularSpeed = V3.sub(c.object3d.htr, c.htr),
  c.htrAngularSpeed = fixAngles(c.htrAngularSpeed),
  c.htrAngularSpeed = V3.scale(c.htrAngularSpeed, 1 / t),
  c.htr = c.object3d.htr,
  c.maxAngularVRatio = 0;
  for (var y = 0, M = c.wheels.length; y < M; y++) {
      var t$ = c.wheels[y];
      if (t$.oldAngularVelocity = t$.angularVelocity,
      t$.contact) {
          t$.angularVelocity = t$.contact.forwardProjVel * e / t$.arcDegree;
          var ty = t$.angularVelocity / t$.oldAngularVelocity;
          t$.contact.forwardProjVel > 30 && ty > 40 && new geofs.fx.ParticleEmitter({
              anchor: t$.contact.collisionPoint,
              duration: 200,
              rate: .05,
              life: 2e3,
              startScale: .001,
              endScale: .05,
              startOpacity: .3,
              endOpacity: .001,
              startRotation: "random",
              endRotation: "random",
              texture: "smoke"
          }),
          c.maxAngularVRatio = Math.max(c.maxAngularVRatio, ty)
      } else
          t$.angularVelocity > .01 && (t$.angularVelocity *= .9);
      var tv = t$.name + "Rotation"
        , t_ = d[tv] || 0;
      d[tv] = fixAngle360(t_ + t$.angularVelocity),
      d[tv + "Ratio"] = d[tv] / 360
  }
}
,
flight.setAnimationValues = function(e, t) {
  var a = geofs.aircraft.instance
    , o = geofs.animation.values
    , r = a.llaLocation[2] * METERS_TO_FEET
    , n = (r - a.oldAltitude * METERS_TO_FEET) * 60 / e || 0;
  a.oldAltitude = a.llaLocation[2];
  var s = fixAngle(weather.currentWindDirection - a.htr[0])
    , c = a.engine.rpm * a.definition.RPM2PropAS * e;
  o.acceleration = M33.transform(M33.transpose(a.object3d._rotation), a.rigidBody.v_acceleration),
  o.accX = o.acceleration[0],
  o.accY = o.acceleration[1],
  o.accZ = o.acceleration[2],
  o.angularAcceleration = M33.transform(M33.transpose(a.object3d._rotation), a.rigidBody.v_angularAcceleration),
  o.aAccX = o.angularAcceleration[0],
  o.aAccY = o.angularAcceleration[1],
  o.aAccZ = o.angularAcceleration[2],
  o.loadFactor = o.acceleration[2] / GRAVITY,
  o.slipball = exponentialSmoothing("slipball", o.acceleration[0], .02),
  o.airspeedms = a.trueAirSpeed,
  o.ktas = a.trueAirSpeed * MS_TO_KNOTS,
  o.kiasChangeRate = (o.kias - o.ktas) * e,
  o.kias = o.ktas,
  o.kiasUnits = o.ktas % 10,
  o.kiasTens = o.ktas % 100,
  o.kiasHundreds = o.ktas % 1e3,
  o.kiasThousands = o.ktas % 1e4,
  o.groundSpeed = a.groundSpeed,
  o.groundSpeedKnt = a.groundSpeed * MS_TO_KNOTS;
  let d = clamp(a.trueAirSpeed / 50, 0, 1);
  o.airVibration = Math.random() * d,
  o.airVibration2 = Math.random() * d,
  o.altitudeMeters = a.llaLocation[2],
  o.altitude = r,
  o.haglMeters = geofs.relativeAltitude,
  o.haglFeet = geofs.relativeAltitude * METERS_TO_FEET,
  o.groundElevationFeet = geofs.groundElevation * METERS_TO_FEET,
  o.verticalSpeed = n,
  o.climbrate = n,
  o.aoa = a.angleOfAttackDeg,
  o.turnrate = 60 * fixAngle(a.htr[0] - o.heading) / e,
  o.heading = a.htr[0],
  o.heading360 = fixAngle360(a.htr[0]),
  o.atilt = a.htr[1],
  o.aroll = a.htr[2],
  o.enginesOn = a.engine.on,
  o.engineVibration = a.engine.rpm > 100 ? Math.random() * clamp(1e3 / a.engine.rpm, 0, 1) : 0,
  o.prop = fixAngle360(o.prop + c),
  o.thrust = a.totalThrust,
  o.rpm = a.engine.rpm,
  o.throttle = controls.throttle,
  o.mixture = controls.mixture,
  o.carbHeat = controls.carbHeat,
  o.smoothThrottle = exponentialSmoothing("throttle", o.throttle, .02),
  o.pitch = controls.pitch,
  o.rawPitch = controls.rawPitch,
  o.roll = controls.roll,
  o.invRoll = -controls.roll,
  o.yaw = controls.yaw,
  o.rawYaw = controls.rawYaw,
  o.steering = controls.steering,
  o.trim = controls.elevatorTrim,
  o.brakes = controls.brakes,
  o.gearPosition = controls.gear.position,
  o.invGearPosition = 1 - controls.gear.position,
  o.gearTarget = controls.gear.target,
  o.flapsValue = controls.flaps.position / controls.flaps.maxPosition,
  o.accessoriesPosition = controls.accessories.position,
  o.accessoriesTarget = controls.accessories.target,
  o.flapsPosition = controls.flaps.position,
  o.flapsTarget = controls.flaps.target,
  o.flapsPositionRatio = controls.flaps.positionRatio,
  o.flapsPositionTarget = controls.flaps.positionTarget,
  o.flapsSteps = geofs.aircraft.instance.definition.flapsSteps,
  o.airbrakesPosition = controls.airbrakes.position,
  o.optionalAnimatedPartPosition = controls.optionalAnimatedPart.position,
  o.optionalAnimatedPartTarget = controls.optionalAnimatedPart.target,
  o.airbrakesTarget = controls.airbrakes.target,
  o.parkingBrake = a.brakesOn,
  o.groundContact = a.groundContact ? 1 : 0,
  o.arrestingHookTension = a.arrestingCableContact ? V3.length(a.arrestingCableContact.force) : 0,
  o.onCatapult = a.onCatapult,
  o.catapult = !!a.launchBarContact,
  o.stalling = !geofs.aircraft.instance.groundContact && a.stalling,
  o.airTemp = weather.atmosphere.airTempAtAltitude;
  let u = new Date;
  if (o.compHours = u.getHours(),
  o.compMinutes = u.getMinutes(),
  o.compSeconds = u.getSeconds(),
  o.mach = geofs.utils.msToMach(a.trueAirSpeed),
  o.machUnits = Math.floor(o.mach),
  o.machTenth = Math.floor(10 * (o.mach % 1).toPrecision(2)),
  o.machHundredth = Math.floor(100 * (o.mach % .1).toPrecision(2)),
  o.altTenThousands = r % 1e5,
  o.altThousands = r % 1e4,
  o.altHundreds = r % 1e3,
  o.altTens = r % 100,
  o.altTensShift = Math.floor(r % 1e5 / 1e4),
  o.altUnits = r % 10,
  o.relativeWind = s,
  o.windSpeed = weather.currentWindSpeed,
  o.windSpeedLabel = parseInt(weather.currentWindSpeed) + " kts",
  o.view = geofs.camera.currentView,
  o.insideView = geofs.camera.currentDefinition.insideView,
  o.cameraDotAircraftForward = geofs.camera.dotAircraftForward,
  o.envelopeTemp = a.envelopeTemp,
  o.maxAngularVRatio = a.maxAngularVRatio,
  a.groundContact ? o.rollingSpeed = a.velocityScalar : o.rollingSpeed = 0,
  "free" == geofs.camera.currentModeName || "chase" == geofs.camera.currentModeName) {
      var p = geofs.utils.llaDistanceInMeters3D(geofs.camera.lla, a.llaLocation);
      o.cameraAircraftSpeed = (o.cameraAircraftDistance - p) / e,
      o.cameraAircraftDistance = p
  } else
      o.cameraAircraftSpeed = 0,
      o.cameraAircraftDistance = 0;
  o.geofsTime = t
}
,
$(".geofs-recordPlayer-slider").on("userchange", (e, t) => {
  flight.recorder.setStep(parseInt(t), "slide")
}
).on("dragstart", () => {
  geofs.api.nativeMouseHandling = !0
}
).on("dragend", () => {
  geofs.api.nativeMouseHandling = !1
}
),
flight.recorder = {
  tape: [],
  rate: 4,
  maxLength: 1e3,
  playing: !1,
  currentStep: 0,
  lastRecordTime: 0,
  pathDrawDistanceThreshold: 500,
  mapPath: [],
  pathColors: [Cesium.Color.fromCssColorString("#e6e435ff"), Cesium.Color.fromCssColorString("#74e635ff"), Cesium.Color.fromCssColorString("#29d1d3ff"), Cesium.Color.fromCssColorString("#d32929ff"), Cesium.Color.fromCssColorString("#ae35e6ff")],
  init: function() {
      this.period = 1e3 / this.rate,
      this.setRecorderDuration()
  },
  record: function() {
      var e = geofs.utils.now();
      if (e - flight.recorder.lastRecordTime < flight.recorder.period)
          return;
      flight.recorder.lastRecordTime = e;
      var t = geofs.aircraft.instance.llaLocation
        , a = geofs.aircraft.instance.htr;
      let o = 0;
      this.lastDrawnLla ? o = geofs.utils.distanceBetweenLocations(this.lastDrawnLla, t) : this.lastDrawnLla = t,
      o > this.pathDrawDistanceThreshold && (this.drawPath(this.lastDrawnLla, t),
      this.lastDrawnLla = t);
      var r = flight.recorder.makeRecord(e, t, a);
      flight.recorder.tape.push(r),
      flight.recorder.tape.length > flight.recorder.maxLength && flight.recorder.tape.shift()
  },
  makeRecord: function(e, t, a) {
      return t = t || geofs.aircraft.instance.llaLocation,
      a = a || geofs.aircraft.instance.htr,
      {
          ti: e || geofs.utils.now(),
          co: [Number(t[0].toFixed(8)), Number(t[1].toFixed(8)), Number(t[2].toFixed(3)), Number(a[0].toFixed(2)), Number(a[1].toFixed(2)), Number(a[2].toFixed(2))],
          ct: [Number(controls.rawPitch.toFixed(2)), Number(controls.roll.toFixed(2)), Number(controls.yaw.toFixed(2)), Number(controls.throttle.toFixed(2)), controls.gear.position, controls.flaps.position, controls.airbrakes.position, controls.brakes, controls.elevatorTrim],
          st: [geofs.utils.booleanToBinary(geofs.aircraft.instance.groundContact), geofs.utils.booleanToBinary(geofs.aircraft.instance.engine.on), controls.flaps.target, geofs.aircraft.instance.engine.rpm],
          ve: geofs.utils.arrayToFixed(geofs.aircraft.instance.rigidBody.getLinearVelocity().concat(geofs.aircraft.instance.rigidBody.getAngularVelocity()), 8),
          acc: geofs.utils.arrayToFixed(geofs.aircraft.instance.rigidBody.getLinearAcceleration().concat(geofs.aircraft.instance.rigidBody.getAngularAcceleration()), 8)
      }
  },
  setRecorderDuration: function() {
      flight.recorder.maxLength = parseInt(60 * geofs.preferences.recorderLength * this.rate) || this.defaultMaxLength,
      this.setTapeLength(flight.recorder.maxLength)
  },
  setTapeLength: function(e) {
      flight.recorder.maxLength = e || flight.recorder.maxLength,
      flight.recorder.tape.length > flight.recorder.maxLength && (flight.recorder.tape = flight.recorder.tape.splice(-flight.recorder.maxLength)),
      flight.recorder.playing && (flight.recorder.setStep(flight.recorder.currentStep, "set"),
      $(".geofs-recordPlayer-slider").attr("data-max", flight.recorder.tape.length - 2))
  },
  clear: function() {
      this.lastDrawnLla = null,
      this.clearPath(),
      flight.recorder.tape = []
  },
  clearPath: function() {
      geofs.api.map.clearPath(flight.recorder.mapPath)
  },
  setPathDrawState: function() {
      geofs.savePreferences(),
      this.clearPath()
  },
  enterPlayback: function() {
      $(".geofs-recordPlayer-slider").attr("data-max", flight.recorder.tape.length - 2),
      $("body").addClass("geofs-record-playing"),
      flight.recorder.currentStep = 0,
      flight.recorder.startPlayback()
  },
  exitPlayback: function() {
      geofs.doPause(),
      flight.recorder.playing = !1,
      geofs.aircraft.instance.rigidBody.clearForces(),
      flight.recorder.setStep(flight.recorder.currentStep, "set"),
      flight.recorder.tape.splice(flight.recorder.currentStep),
      geofs.aircraft.instance.object3d.resetRotationMatrix(),
      $("body").removeClass("geofs-record-playing")
  },
  pausePlayback: function() {
      flight.recorder.paused = !0
  },
  unpausePlayback: function() {
      flight.recorder.startPlayback()
  },
  startPlayback: function() {
      flight.recorder.playing = !0,
      flight.recorder.paused = !1,
      flight.recorder.setStep(flight.recorder.currentStep, "set"),
      geofs.undoPause(2)
  },
  setStep: function(e, t) {
      if (e > flight.recorder.tape.length - 2 && (e = flight.recorder.tape.length - 2,
      flight.recorder.pausePlayback(),
      geofs.doPause()),
      e < 0 && (e = 0),
      !flight.recorder.tape[e])
          return geofs.doPause(),
          !1;
      flight.recorder.currentStep = e,
      "slide" == t || "set" == t ? (flight.recorder.liveRecord = Object.assign({}, flight.recorder.tape[e]),
      flight.interpolator.setAircraft(flight.recorder.liveRecord),
      geofs.map.updatePlaneMarker(geofs.aircraft.instance.llaLocation[0], geofs.aircraft.instance.llaLocation[1], geofs.aircraft.instance.htr[0]),
      geofs.aircraft.instance.render()) : flight.recorder.liveRecord.st = flight.recorder.tape[e - 1].st,
      t && "set" != t || $(".geofs-recordPlayer-slider").slider("value", e);
      var a = clamp(flight.recorder.tape[e + 1].ti - flight.recorder.liveRecord.ti, 1, 1e3);
      return flight.recorder.deltaRecord = flight.interpolator.computeDeltaRecord(flight.recorder.liveRecord, flight.recorder.tape[e + 1], a),
      !0
  },
  play: function(e) {
      if (!flight.recorder.paused) {
          flight.interpolator.increment(flight.recorder.liveRecord, flight.recorder.deltaRecord, e);
          for (var t = flight.recorder.currentStep; flight.recorder.tape[t + 1] && flight.recorder.tape[t + 1].ti - flight.recorder.liveRecord.ti < flight.recorder.period; )
              t++;
          t > flight.recorder.currentStep ? flight.recorder.setStep(t) : flight.recorder.tape[t + 1].ti - flight.recorder.liveRecord.ti > 1e3 && flight.recorder.setStep(t + 1, "set")
      }
  },
  drawPath: function(e, t) {
      if (!geofs.preferences.interface.drawFlightPath)
          return;
      let a = {
          weight: 4,
          color: geofs.api.color.mixArray(flight.recorder.pathColors, clamp(t[2] / 15e3, 0, 1)).toCssHexString()
      };
      geofs.api.map.createPath(flight.recorder.mapPath, [e, t], a)
  },
  import: async function(e) {
      this.clear();
      let t = JSON.parse(e);
      if (t && t.tape) {
          if (await geofs.aircraft.instance.loadWithLivery(t.aircraft, null, t.aircraft.livery),
          flight.recorder.tape = t.tape,
          flight.recorder.tape.length > 1) {
              let a, o;
              flight.recorder.tape.forEach(e => {
                  let t = [e.co[0], e.co[1], e.co[2]];
                  a ? o = geofs.utils.distanceBetweenLocations(a, t) : a = t,
                  o > this.pathDrawDistanceThreshold && (this.drawPath(a, t),
                  a = t)
              }
              )
          }
          t.tape.length > flight.recorder.maxLength && this.setTapeLength(t.tape.length),
          $(".geofs-recordPlayer-slider").attr("data-max", flight.recorder.tape.length - 2),
          this.startPlayback()
      }
  },
  export: function() {
      return JSON.stringify({
          aircraft: geofs.aircraft.instance.aircraftRecord.id,
          livery: geofs.aircraft.instance.liveryId,
          tape: flight.recorder.tape
      })
  },
  upload: function(e) {
      let t = e.files[0]
        , a = new FileReader;
      a.onload = e => {
          let t = e.target.result;
          flight.recorder.import(t)
      }
      ,
      a.onerror = e => {
          geofs.debug.log(e)
      }
      ,
      a.readAsText(t),
      $(e).val("")
  },
  download: function(e) {
      if (flight.recorder.tape.length < 1)
          return;
      let t = "GeoFS-flight.json"
        , a = new Blob([flight.recorder.export()],{
          type: "text/plain"
      });
      window.URL.createObjectURL(a),
      e.download = t,
      e.href = window.URL.createObjectURL(a)
  }
},
flight.sharing = {
  targetDT: geofs.MPSMinUpdateDelay || 500,
  start: function(e) {
      flight.sharing.reset(e),
      flight.sharing.on = !0
  },
  stop: function() {
      flight.sharing.reset(),
      flight.sharing.on = !1
  },
  reset: function(e) {
      flight.sharing.lastRecord = e,
      flight.sharing.liveRecord = null,
      flight.sharing.deltaRecord = null,
      geofs.aircraft.instance.rigidBody.clearForces()
  },
  peerUpdate: function(e, t) {
      if (!flight.sharing.lastRecord) {
          flight.sharing.lastRecord = Object.assign({}, e);
          return
      }
      if (!flight.sharing.liveRecord) {
          flight.sharing.liveRecord = Object.assign({}, e),
          exponentialSmoothing("sharingAveragedDT", flight.sharing.targetDT, 0, 1);
          return
      }
      let a = Date.now();
      flight.sharing.now = flight.sharing.now || a,
      flight.sharing.now = a;
      let o = e.ti - flight.sharing.liveRecord.ti
        , r = exponentialSmoothing("sharingAveragedDT", e.ti - flight.sharing.lastRecord.ti, null, .01)
        , n = (o - r) * .5;
      if (0 == (o = Math.max(r, o))) {
          geofs.debug.log("liveToUpdateDT == 0");
          return
      }
      flight.sharing.lastRecord = Object.assign({}, e),
      flight.sharing.deltaRecord = flight.interpolator.computeDeltaRecord(flight.sharing.liveRecord, flight.sharing.lastRecord, Math.abs(o), n),
      flight.sharing.liveRecord.st = flight.sharing.lastRecord.st
  },
  update: function(e) {
      flight.sharing.liveRecord && flight.sharing.deltaRecord && flight.interpolator.increment(flight.sharing.liveRecord, flight.sharing.deltaRecord, e)
  }
},
flight.interpolator = {
  computeDeltaRecord: function(e, t, a, o) {
      o = o || 0;
      var r = 1 / a
        , n = M3.sub(t.co, e.co);
      n[3] = fixAngle(n[3]),
      n[4] = fixAngle(n[4]),
      n[5] = fixAngle(n[5]);
      var s = M3.sub(t.ct, e.ct)
        , c = M3.sub(t.ve, e.ve)
        , d = M3.sub(t.acc, e.acc);
      return n = M3.scale(n, r),
      s = M3.scale(s, r),
      c = M3.scale(c, r),
      d = M3.scale(d, r),
      {
          co: n,
          ct: s,
          ve: c,
          acc: d,
          timeError: o * r
      }
  },
  increment: function(e, t, a) {
      e.ti += a + t.timeError * a,
      e.co = M3.add(e.co, M3.scale(t.co, a)),
      e.co[3] = fixAngle(e.co[3]),
      e.co[4] = fixAngle(e.co[4]),
      e.co[5] = fixAngle(e.co[5]),
      e.ct = M3.add(e.ct, M3.scale(t.ct, a)),
      e.ve = M3.add(e.ve, M3.scale(t.ve, a)),
      e.acc = M3.add(e.acc, M3.scale(t.acc, a)),
      flight.interpolator.setAircraft(e)
  },
  setAircraft: function(e) {
      var t = e.co
        , a = [t[0], t[1], t[2]]
        , o = [t[3], t[4], t[5]]
        , r = e.ct;
      controls.rawPitch = r[0],
      controls.pitch = r[0] + r[8],
      controls.roll = r[1],
      controls.yaw = r[2],
      controls.throttle = r[3],
      controls.elevatorTrim = r[8],
      controls.gear.position = snapToUnit(r[4]),
      controls.flaps.position = r[5],
      controls.airbrakes.position = snapToUnit(r[6]),
      controls.brakes = snapToUnit(r[7]);
      let n = e.st;
      geofs.aircraft.instance.groundContact = n[0],
      geofs.aircraft.instance.engine.on = n[1],
      controls.flaps.target = n[2],
      controls.setPartAnimationDelta(controls.flaps);
      var s = [e.ve[0], e.ve[1], e.ve[2]]
        , c = [e.ve[3], e.ve[4], e.ve[5]];
      geofs.aircraft.instance.rigidBody.setLinearVelocity(s),
      geofs.aircraft.instance.rigidBody.setAngularVelocity(c);
      var d = [e.acc[0], e.acc[1], e.acc[2]]
        , u = [e.acc[3], e.acc[4], e.acc[5]];
      geofs.aircraft.instance.rigidBody.setLinearAcceleration(d),
      geofs.aircraft.instance.rigidBody.setAngularAcceleration(u),
      geofs.aircraft.instance.object3d.compute(a),
      geofs.aircraft.instance.place(a, o)
  }
},
flight.terrainElevationManagement = () => {
  var e = geofs.aircraft.instance
    , t = [e.llaLocation[0], e.llaLocation[1], e.llaLocation[2]];
  flight.currentAltitudeTestContext.groundContact = e.groundContact,
  e.collResult = geofs.getCollisionResult(t, null, null, flight.currentAltitudeTestContext);
  var a = e.collResult.location[2];
  if (geofs.groundElevation = a,
  geofs.relativeAltitude = e.llaLocation[2] - geofs.groundElevation,
  geofs.withinCollisionRange = !1,
  geofs.relativeAltitude < geofs.aircraft.instance.boundingSphereRadius + geofs.aircraft.instance.velocityScalar ? (geofs.withinCollisionRange = !0,
  e.collResult.normal = geofs.getNormalFromCollision(e.collResult, flight.currentAltitudeTestContext)) : e.collResult.normal = [0, 0, 1],
  !flight.recorder.playing) {
      if (geofs.cautiousWithTerrain) {
          var o, r = geofs.getGroundAltitude(e.lastLlaLocation, flight.pastAltitudeTestContext).location[2], n = r - flight.elevationAtPreviousLocation, s = .2;
          flight.skipCollisionResponse = !1,
          Math.abs(n) > s && (e.absoluteStartAltitude || (geofs.cautiousWithTerrain || r > e.llaLocation[2]) && (e.llaLocation[2] = e.llaLocation[2] + n),
          e.groundContact && (e.llaLocation[2] = a + e.definition.startAltitude,
          flight.skipCollisionResponse = !0),
          geofs.probeTerrain())
      }
      flight.elevationAtPreviousLocation = a,
      e.lastLlaLocation = e.llaLocation
  }
}
,
flight.reset = function(e) {
  flight.currentAltitudeTestContext = {
      lastGroundAltitude: e
  },
  flight.pastAltitudeTestContext = {
      lastGroundAltitude: e
  },
  flight.recorder.clear()
}
;
var physics = window.physics || {};
function rigidBody() {
  this.mass = 0,
  this.s_inverseMass = 0,
  this.reset(),
  this.minLinearVelocity = .1,
  this.minAngularVelocity = .01,
  this.impulseQueue = []
}
rigidBody.prototype.reset = function() {
  this.v_linearVelocity = [0, 0, EPSILON],
  this.v_angularVelocity = [0, 0, EPSILON],
  this.v_totalForce = [0, 0, EPSILON],
  this.v_totalTorque = [0, 0, EPSILON],
  this.v_prevLinearVelocity = [0, 0, EPSILON],
  this.v_prevAngularVelocity = [0, 0, EPSILON],
  this.v_acceleration = [0, 0, EPSILON],
  this.v_angularAcceleration = [0, 0, EPSILON]
}
,
rigidBody.prototype.setMassProps = function(e, t) {
  t = t || .1,
  $.isArray(t) || (t = [t, t, t]),
  this.mass = e,
  this.s_inverseMass = 1 / e,
  this.v_localInvInertia = [t[0] / e, t[1] / e, t[2] / e],
  this.m_localInvInertiaTensor = [[this.v_localInvInertia[0], 0, 0], [0, this.v_localInvInertia[1], 0], [0, 0, this.v_localInvInertia[2]]],
  this.m_worldInvInertiaTensor = M33.dup(this.m_localInvInertiaTensor),
  this.gravityForce = [0, 0, -GRAVITY * e]
}
,
rigidBody.prototype.getLinearVelocity = function() {
  return this.v_linearVelocity
}
,
rigidBody.prototype.getAngularVelocity = function() {
  return this.v_angularVelocity
}
,
rigidBody.prototype.getLinearAcceleration = function() {
  return this.v_acceleration
}
,
rigidBody.prototype.getAngularAcceleration = function() {
  return this.v_angularAcceleration
}
,
rigidBody.prototype.setLinearVelocity = function(e) {
  this.v_linearVelocity = e
}
,
rigidBody.prototype.setAngularVelocity = function(e) {
  this.v_angularVelocity = e
}
,
rigidBody.prototype.setLinearAcceleration = function(e) {
  this.v_acceleration = e
}
,
rigidBody.prototype.setAngularAcceleration = function(e) {
  this.v_angularAcceleration = e
}
,
rigidBody.prototype.getVelocityInLocalPoint = function(e) {
  return V3.add(this.v_linearVelocity, V3.cross(e, this.v_angularVelocity))
}
,
rigidBody.prototype.getForceInLocalPoint = function(e) {
  var t = V3.add(this.v_totalForce, V3.cross(e, this.v_totalTorque));
  return V3.add(t, V3.scale(this.getVelocityInLocalPoint(e), this.mass))
}
,
rigidBody.prototype.applyCentralForce = function(e) {
  this.v_totalForce = V3.add(this.v_totalForce, e)
}
,
rigidBody.prototype.applyTorque = function(e) {
  this.v_totalTorque = V3.add(this.v_totalTorque, e)
}
,
rigidBody.prototype.applyForce = function(e, t) {
  this.applyCentralForce(e),
  this.applyTorque(V3.cross(e, t))
}
,
rigidBody.prototype.applyCentralImpulse = function(e) {
  this.v_linearVelocity = V3.add(this.v_linearVelocity, V3.scale(e, this.s_inverseMass))
}
,
rigidBody.prototype.applyTorqueImpulse = function(e) {
  this.v_angularVelocity = V3.add(this.v_angularVelocity, M33.multiplyV(this.m_worldInvInertiaTensor, e))
}
,
rigidBody.prototype.applyImpulse = function(e, t) {
  this.applyCentralImpulse(e),
  this.applyTorqueImpulse(V3.cross(e, t))
}
,
rigidBody.prototype.queueImpulse = function(e, t) {
  this.impulseQueue.push([e, t])
}
,
rigidBody.prototype.clearImpulseQueue = function() {
  this.impulseQueue = []
}
,
rigidBody.prototype.applyImpulseQueue = function() {
  this.impulseQueue.forEach(e => {
      this.applyImpulse(e[0], e[1])
  }
  ),
  this.clearImpulseQueue()
}
,
rigidBody.prototype.computeJacobian = function(e, t, a, o) {
  var r, n = -(1 + e) * t;
  return n / (this.s_inverseMass + V3.dot(o, V3.cross(a, M33.multiplyV(this.m_worldInvInertiaTensor, V3.cross(o, a)))))
}
,
rigidBody.prototype.computeImpulse = function(e, t, a, o) {
  var r = this.computeJacobian(e, t, a, o);
  return V3.scale(o, r)
}
,
rigidBody.prototype.integrateVelocities = function(e) {
  this.v_linearVelocity = V3.add(this.v_linearVelocity, V3.scale(this.v_totalForce, this.s_inverseMass * e)),
  this.v_angularVelocity = V3.add(this.v_angularVelocity, M33.multiplyV(this.m_worldInvInertiaTensor, V3.scale(this.v_totalTorque, e)))
}
,
rigidBody.prototype.integrateTransform = function(e) {
  var t = V3.length(this.v_linearVelocity)
    , a = V3.length(this.v_angularVelocity);
  if (t > this.minLinearVelocity || a > this.minAngularVelocity) {
      var o = geofs.aircraft.instance
        , r = xyz2lla(V3.scale(this.v_linearVelocity, e), o.llaLocation);
      o.llaLocation = V3.add(o.llaLocation, r);
      var n = V3.scale(this.v_angularVelocity, e);
      n = M33.transformByTranspose(o.object3d._initialRotation, n),
      o.object3d.rotateInitialRotation(n)
  }
  this.clearForces()
}
,
rigidBody.prototype.setCurrentAcceleration = function(e, t) {
  this.v_acceleration = V3.scale(V3.sub(this.v_linearVelocity, this.v_prevLinearVelocity), e),
  this.v_acceleration = V3.add([0, 0, GRAVITY], this.v_acceleration),
  this.v_angularAcceleration = V3.scale(V3.sub(this.v_angularVelocity, this.v_prevAngularVelocity), e),
  this.v_prevLinearVelocity = V3.dup(this.v_linearVelocity),
  this.v_prevAngularVelocity = V3.dup(this.v_angularVelocity)
}
,
setInterval( () => {
  if (geofs.aircraft.instance && geofs.aircraft.instance.object3d)
      try {
          geofs.aircraft.instance.object3d.resetRotationMatrix()
      } catch (e) {
          geofs.debug.error(e, "resetRotationMatrix interval")
      }
}
, 1e4),
rigidBody.prototype.clearForces = function() {
  this.v_totalForce = [0, 0, 0],
  this.v_totalTorque = [0, 0, 0]
}
,
rigidBody.prototype.saveState = function() {
  this.savedLinearVelocity = V3.dup(this.v_linearVelocity),
  this.savedAngularVelocity = V3.dup(this.v_angularVelocity)
}
,
rigidBody.prototype.restoreState = function() {
  this.clearForces(),
  this.v_linearVelocity = V3.dup(this.savedLinearVelocity),
  this.v_angularVelocity = V3.dup(this.savedAngularVelocity)
}
,
geofs.aircraft = {
  default: 1
},
geofs.aircraft.defaultDefinition = {
  Vspeeds: {
      VS0: -1,
      VS: 0,
      VFE: -1,
      VNO: 0,
      VNE: 0
  }
},
geofs.aircraft.Aircraft = function(e) {
  geofs.aircraft.instance = this,
  this.engine = {},
  this.engine.rpm = 0,
  this.engine.on = !0,
  this.brakesOn = !1,
  this.groundContact = !0,
  this.llaLocation = [e[0], e[1], e[2]],
  this.lastLlaLocation = this.llaLocation,
  this.collResult = {
      location: [0, 0, 0],
      normal: [0, 0, 1]
  },
  this.relativeAltitude = 0,
  this.htr = [0, 0, 0],
  this.htrAngularSpeed = [0, 0, 0],
  this.airVelocityDirection = [0, 0, 0],
  this.trueAirSpeed = 0,
  this.reset()
}
,
geofs.aircraft.Aircraft.prototype.getCurrentCoordinates = function() {
  var e = [];
  return e[0] = this.llaLocation[0],
  e[1] = this.llaLocation[1],
  e[2] = this.llaLocation[2],
  e[2] < .5 || this.groundContact ? (this.groundContact = !0,
  e[2] = 0) : e[4] = !0,
  e[3] = geofs.aircraft.instance.htr[0],
  e
}
,
geofs.aircraft.Aircraft.prototype.addShadow = function() {
  if (this.removeShadow(),
  !this.aircraftRecord)
      return !1;
  var e = this.aircraftRecord.fullPath + (this.definition.shadowFile || "shadow.glb")
    , t = V3.scale(this.definition.shadowBox, this.definition.scale);
  return t[2] = 0,
  this.shadow = new geofs.shadow(e,t),
  !0
}
,
geofs.aircraft.Aircraft.prototype.removeShadow = function() {
  try {
      this.shadow.destroy()
  } catch (e) {}
  this.shadow = null
}
,
geofs.aircraft.Aircraft.prototype.loadDefault = function(e) {
  e && ui.notification.show(e),
  geofs.aircraft.instance.change(geofs.aircraft.default, null, !0)
}
,
geofs.aircraft.Aircraft.prototype.parseRecord = function(e) {
  var t;
  try {
      var a = JSON.parse(e);
      if (this.aircraftRecord = a,
      a.definition) {
          var o = atob(a.definition);
          t = JSON.parse(o)[0]
      }
      if (a.error) {
          this.loadDefault(a.error);
          return
      }
  } catch (r) {
      return
  }
  return t
}
,
geofs.aircraft.Aircraft.prototype.change = function(e, t, a, o) {
  e = e || this.aircraftRecord.id;
  let r = this.load(e, this.getCurrentCoordinates(), a, o);
  return r.then( () => {
      this.loadLivery(t)
  }
  ),
  geofs.api.analytics.event("aircraft", geofs.aircraftList[e].name),
  r
}
,
geofs.aircraft.Aircraft.prototype.loadLivery = function(e) {
  if (!e) {
      this.liveryId = null;
      return
  }
  this.liveryId = e;
  var t = "cockpit" == geofs.camera.currentModeName ? "cockpit" : "root"
    , a = this.parts[t]["3dmodel"];
  if (!a)
      return;
  let o = () => {
      this.parts[t].textures && this.parts[t].textures.forEach && this.parts[t].textures.forEach(t => {
          a.changeTexture(this.aircraftRecord.fullPath + t.filename + e + ".jpg", t)
      }
      )
  }
  ;
  a.getReadyPromise().then( () => {
      o()
  }
  )
}
,
geofs.aircraft.Aircraft.prototype.loadWithLivery = async function(e, t, a) {
  await this.load(e, t),
  a && this.loadLivery(a)
}
,
geofs.aircraft.Aircraft.prototype.load = function(e, t, a, o) {
  if (geofs.aircraftList[e] && geofs.aircraftList[e].local)
      var r = geofs.aircraftList[e].path + "aircraft.json";
  else
      var r = "/models/aircraft/load.php";
  return new Promise( (n, s) => {
      if (this.id == e && !a) {
          n();
          return
      }
      geofs.doPause(1),
      this.unloadAircraft(),
      $.ajax(r, {
          data: {
              id: e,
              kc: geofs.killCache
          },
          dataType: "text",
          success: (r, s, c) => {
              var d;
              "error" != s && (geofs.aircraftList[e] && geofs.aircraftList[e].local && (r = JSON.stringify({
                  id: e,
                  name: geofs.aircraftList[e].name,
                  fullPath: geofs.aircraftList[e].path,
                  isPremium: !1,
                  isCommunity: !1,
                  definition: btoa(r)
              })),
              d = this.parseRecord(r)),
              d ? (geofs.aircraftList[e] && !geofs.aircraftList[e].local && (this.fullPath = this.aircraftRecord.fullPath),
              this.id = e,
              this.init(d, t, a, o)) : this.loadDefault("Could not load aircraft file"),
              n()
          }
          ,
          error: (t, a, o) => {
              e != geofs.aircraft.default && this.loadDefault("Could not load aircraft file" + o),
              s()
          }
      })
  }
  )
}
,
geofs.aircraft.Aircraft.prototype.init = function(e, t, a, o) {
  for (var r in this.definition = Object.assign({}, geofs.aircraft.defaultDefinition, e),
  this.setup = e,
  this.controllers = {
      pitch: {
          recenter: !1,
          sensitivity: 1,
          ratio: 1
      },
      roll: {
          recenter: !0,
          sensitivity: 1,
          ratio: 1
      },
      yaw: {
          recenter: !0,
          sensitivity: 1,
          ratio: 1
      }
  },
  this.parts = {},
  this.models = [],
  this.airfoils = [],
  this.engines = [],
  this.balloons = [],
  this.wheels = [],
  this.collisionPoints = [],
  this.lights = [],
  this.suspensions = [],
  this.manipulators = {},
  this.definition.orientation = this.definition.orientation || "Zup",
  this.definition.scale = this.definition.scale || 1,
  this.definition.startupTime = this.definition.startupTime || 1,
  this.definition.startAltitude = this.definition.startAltitude * this.definition.scale,
  this.definition.cockpitScaleFix = this.definition.cockpitScaleFix || 1,
  this.definition.motionSensitivity = this.definition.motionSensitivity || 1,
  geofs.animation.setValue("VS0", this.definition.Vspeeds.VS0),
  geofs.animation.setValue("VS", this.definition.Vspeeds.VS),
  geofs.animation.setValue("VFE", this.definition.Vspeeds.VFE),
  geofs.animation.setValue("VNO", this.definition.Vspeeds.VNO),
  geofs.animation.setValue("VNE", this.definition.Vspeeds.VNE),
  this.definition.cameras) {
      var n = this.definition.cameras[r];
      n.distance = n.distance * this.definition.scale,
      n.position && (n.position = V3.scale(n.position, this.definition.scale))
  }
  for (var r = 0; r < this.definition.parts.length; r++) {
      let s = this.definition.parts[r];
      s.disabled && (this.definition.parts.splice(r, 1),
      s = this.definition.parts[r]);
      var c = s.name;
      this.parts[c] = s
  }
  if (!this.parts.root) {
      var d = {
          name: "root",
          position: [0, 0, 0]
      };
      this.definition.parts.push(d),
      this.parts.root = d
  }
  this.parts.root.position = this.parts.root.position || [0, 0, 0],
  this.parts.root.points = this.parts.root.points || {},
  this.parts.root.points.centerOfMass = this.parts.root.points.centerOfMass || V3.scale(this.parts.root.position, -1),
  geofs.isApp && (this.parts.camera = {
      name: "camera",
      position: [.25, 0, 0]
  },
  this.parts.camera.object3d = new Object3D(this.parts.camera)),
  instruments.init(this.definition.instruments),
  this.addParts(this.definition.parts, this.aircraftRecord.fullPath, this.definition.scale, this.definition.orientation),
  this.object3d = this.parts.root.object3d,
  this.boundingSphereRadius = 0;
  for (var r = 0, u = this.collisionPoints.length; r < u; r++)
      this.boundingSphereRadius = Math.max(this.boundingSphereRadius, V3.length(this.collisionPoints[r]));
  for (var r in this.boundingSphereRadius *= 1.5,
  this.definition.contactProperties) {
      var p = this.definition.contactProperties[r];
      p.lockSpeed = p.lockSpeed || .01
  }
  this.object3d.compute(this.llaLocation),
  this.object3d.render(this.llaLocation),
  this.rigidBody || (this.rigidBody = new rigidBody),
  this.rigidBody.setMassProps(this.definition.mass, this.definition.tensorFactor),
  this.definition.RPM2PropAS = this.definition.driveRatio / 60 * 360,
  this.engine.invRPMRange = 1 / (this.definition.maxRPM - this.definition.minRPM),
  geofs.simpleShadowOn = !1,
  geofs.useSimpleShadow(!geofs.api.renderingSettings.dropShadow),
  this._cockpitLoaded = !1,
  audio.init(this.definition.sounds),
  (!a || o) && (controls.reset(),
  geofs.camera.reset()),
  instruments.reset(),
  this.reset(),
  this.definition.autopilot ? geofs.autopilot.init && geofs.autopilot.init() : geofs.autopilot.turnOff(),
  geofs.camera.set(geofs.camera.currentMode),
  t && geofs.flyTo(t, !0)
}
,
geofs.aircraft.Aircraft.prototype.loadCockpit = function() {
  var e = geofs.aircraft.instance.aircraftRecord.id;
  if (geofs.aircraftList[e] && geofs.aircraftList[e].local)
      var t = geofs.aircraftList[e].path + "cockpit/cockpit.json";
  else
      var t = "/models/aircraft/load.php";
  var a = new Promise( (a, o) => {
      if (this._cockpitLoaded) {
          a();
          return
      }
      if (!geofs.aircraft.instance.definition.cockpitModel) {
          geofs.aircraft.instance._cockpitLoaded = !0,
          o();
          return
      }
      $.ajax(t, {
          data: {
              id: e,
              kc: geofs.killCache,
              cockpit: !0
          },
          dataType: "text",
          success: (t, o) => {
              geofs.aircraftList[e] && geofs.aircraftList[e].local && (t = JSON.stringify({
                  id: e,
                  name: geofs.aircraftList[e].name,
                  fullPath: geofs.aircraftList[e].path,
                  isPremium: !1,
                  isCommunity: !1,
                  definition: btoa(t)
              }));
              var r = this.parseRecord(t);
              r && (this.cockpitSetup = r,
              this._cockpitLoaded = !0,
              geofs.aircraftList[e].local || (this.aircraftRecord.fullPath = this.aircraftRecord.fullPath),
              this.addParts(r.parts, this.aircraftRecord.fullPath + "cockpit/", this.cockpitSetup.scale, geofs.aircraft.instance.definition.orientation),
              instruments.rescale(),
              this.definition.cockpitScaleFix && this.fixCockpitScale(this.definition.cockpitScaleFix),
              this.object3d.compute(this.llaLocation),
              this.placeParts(),
              this.render()),
              a()
          }
          ,
          error: function(e, t) {
              o()
          }
      })
  }
  );
  return a.then( () => {
      this.loadLivery(this.liveryId)
  }
  ),
  a
}
,
geofs.aircraft.Aircraft.prototype.addParts = function(e, t, a, o) {
  a = a || 1;
  for (var r = 0; r < e.length; r++) {
      var n = e[r];
      if (n.include) {
          var s = geofs.includes[n.include];
          $.extend(!0, n, s[0]);
          for (var c = 1; c < s.length; c++) {
              var d = Object.assign({}, s[c], {
                  parent: n.name
              });
              d.name = n.name + d.name,
              e.push(d)
          }
      }
      if (n.indices && n.indices > 0) {
          for (var c = 2; c <= n.indices; c++) {
              var d = Object.assign({}, n, {
                  indices: null
              });
              d.name = n.name + c,
              d.node = d.node + c,
              e.push(d)
          }
          n.name += "1",
          n.node += "1"
      }
  }
  for (var r = 0; r < e.length; r++) {
      var n = e[r];
      n.points = n.points || {},
      n.type = n.type || !1,
      n.brakesController = n.brakesController || !1,
      n.animations = n.animations || [],
      geofs.aircraft.instance.parts[n.name] = n,
      geofs.aircraft.instance.addOffsets(n, a),
      n.forceDirection && (n.forceDirection = AXIS_TO_INDEX[n.forceDirection]),
      n.rotation && (n.rotation = V3.toRadians(n.rotation)),
      n.modelOnlyRotation && (n.modelOnlyRotation = V3.toRadians(n.modelOnlyRotation)),
      n.scale = n.scale || [1, 1, 1],
      n.scale = V3.scale(n.scale, a),
      n.originalScale = n.scale,
      geofs.version < 4 && (n.gltf2model = null);
      let u = n.gltf2model || n.model;
      if (u) {
          var p = u.url || u;
          t && "/" != p[0] && !n.include && (p = t + p);
          let h = {
              shadows: n.shadows ? window[n.shadows] : SHADOWS_ALL,
              incrementallyLoadTextures: !1,
              forceZup: n.gltf2model || n.forceZup
          };
          u.shader && (h.customShader = geofs.api.generateShader(u.shader, t)),
          n["3dmodel"] = new geofs.api.Model(p,h),
          this.models.push(n["3dmodel"]._model),
          n.renderer && (n.rendererInstance = new instruments.Renderer(n.renderer))
      }
      if (n.light) {
          var m = {
              scale: .2
          };
          n.lightBillboard = new geofs.fx.light(null,n.light,m),
          geofs.aircraft.instance.lights.push(n)
      }
      if (n.object3d = new Object3D(n),
      n.suspension) {
          if (n.suspension.length ? (n.suspension.origin = [n.collisionPoints[0][0], n.collisionPoints[0][1], n.collisionPoints[0][2] + n.suspension.length],
          f = n.suspension.length) : (n.suspension.origin = [n.collisionPoints[0][0], n.collisionPoints[0][1], 0],
          f = -n.collisionPoints[0][2]),
          n.suspension.restLength = f,
          "rotation" == n.suspension.motion) {
              var f, g, y, v = V3.length(n.collisionPoints[0]), _ = Math.atan2(n.collisionPoints[0][0] / v, n.collisionPoints[0][2] / v);
              y = _ < 0 ? _ + HALF_PI : _ - HALF_PI,
              g = {
                  type: "rotate",
                  axis: n.suspension.axis || "Y",
                  value: n.name + "Suspension",
                  ratio: y * RAD_TO_DEGREES * (n.suspension.ratio || 1)
              }
          } else
              g = {
                  type: "translate",
                  axis: n.suspension.axis || "Z",
                  value: n.name + "Suspension",
                  ratio: n.suspension.ratio || 1
              };
          n.animations.push(g),
          n.suspension.hardPoint = n.suspension.hardPoint || .5,
          n.points.suspensionOrigin = V3.dup(n.suspension.origin),
          geofs.aircraft.instance.suspensions.push(n)
      }
      for (var b = 0; b < n.animations.length; b++) {
          var g = n.animations[b];
          if (g.ratio = g.ratio || 1,
          g.offset = g.offset || 0,
          g.currentValue = null,
          g.delay && (g.ratio = g.ratio / (1 - Math.abs(g.delay))),
          "rotate" == g.type) {
              var x = g.method || "rotate";
              "parent" == g.frame && (x = "rotateParentFrame"),
              g.rotationMethod = n.object3d[x + g.axis]
          }
          "translate" != g.type || geofs.isArray(g.axis) || (g.axis = AXIS_TO_VECTOR[g.axis])
      }
      if ("wheel" == n.type && (n.radius = n.radius || 1,
      n.arcDegree = n.radius * TWO_PI / 360,
      n.angularVelocity = 0,
      geofs.aircraft.instance.wheels.push(n)),
      "airfoil" == n.type && (n.lift = 0,
      geofs.aircraft.instance.airfoils.push(n),
      n.stalls = n.stalls || !1,
      n.stallIncidence = n.stallIncidence || 12,
      n.zeroLiftIncidence = n.zeroLiftIncidence || 16,
      n.aspectRatio = n.aspectRatio || DEFAULT_AIRFOIL_ASPECT_RATIO,
      n.aspectRatioCoefficient = n.aspectRatio / n.aspectRatio + 2),
      "engine" == n.type && (n.rpm = 0,
      geofs.aircraft.instance.definition.originalInertia = geofs.aircraft.instance.definition.engineInertia,
      geofs.aircraft.instance.engines.push(n),
      n.contrail && (n.contrailEmitter = new geofs.fx.ParticleEmitter({
          off: !0,
          anchor: n.points.contrailAnchor,
          duration: 1e10,
          rate: .05,
          life: 4e4,
          easing: "easeOutQuart",
          startScale: .01,
          endScale: .01,
          randomizeStartScale: .02,
          randomizeEndScale: .15,
          startOpacity: .1,
          endOpacity: 1e-5,
          startRotation: "random",
          texture: "whitesmoke"
      }))),
      "balloon" == n.type && (n.temperature = n.initialTemperature || 0,
      n.coolingSpeed = n.coolingSpeed || 0,
      geofs.aircraft.instance.balloons.push(n)),
      n.collisionPoints) {
          for (var S = n.collisionPoints, P = geofs.aircraft.instance.definition.contactProperties[n.contactType || n.type], A = 0; A < S.length; A++)
              S[A].part = n,
              S[A].contactProperties = P,
              geofs.aircraft.instance.collisionPoints.push(S[A]);
          n.volume || n.buoyancy || ("airfoil" == n.type ? n.volume = this.definition.mass / (400 * S.length) : n.volume = .1,
          n.area = n.area || 0),
          n.dragVector = n.dragVector || [1, 1, 1],
          n.dragVector = V3.scale(n.dragVector, 1 / S.length)
      }
      n.volume && (n.buoyancy = WATER_DENSITY * GRAVITY * n.volume),
      n.controller && (geofs.aircraft.instance.controllers[n.controller.name] = n.controller)
  }
  for (var r = 0; r < e.length; r++) {
      var n = e[r];
      if ("root" != n.name && (n.parent || (n.parent = "root"),
      geofs.aircraft.instance.parts[n.parent].object3d.addChild(n.object3d)),
      n.node && (n.object3d.setModel(n.object3d.findModelInAncestry()),
      n.manipulator)) {
          let k = n.manipulator;
          "string" == typeof k && (k = geofs.aircraft.instance.aircraftRecord.isCommunity ? null : geofs.utils.getFunctionFromString(k)),
          k && (geofs.aircraft.instance.manipulators[n.node] = k,
          controls.addNodeClickHandler(n.node, function(e) {
              controls.manipulator = geofs.aircraft.instance.manipulators[e],
              controls.mouse.down = 4
          }))
      }
  }
}
,
geofs.aircraft.Aircraft.prototype.setVisibility = function(e) {
  this.object3d && this.object3d.setVisibility(e)
}
,
geofs.aircraft.Aircraft.prototype.unloadAircraft = function() {
  for (var e in geofs.aircraft.instance.parts) {
      var t = geofs.aircraft.instance.parts[e];
      t.object3d && (t.object3d.destroy(),
      delete geofs.aircraft.instance.parts[e].object3d,
      t.rendererInstance && t.rendererInstance.destroy(),
      t.particleEmitterInstance && t.particleEmitterInstance.destroy()),
      this.models = [],
      t.contrailEmitter && t.contrailEmitter.destroy()
  }
  if (geofs.aircraft.instance.parts = null,
  this.removeShadow(),
  geofs.aircraft.instance.lights)
      for (var e = 0, a = geofs.aircraft.instance.lights.length; e < a; e++)
          geofs.aircraft.instance.lights[e].lightBillboard.destroy();
  controls.clearNodeClickHandlers()
}
,
geofs.aircraft.Aircraft.prototype.reset = function(e) {
  for (var t in this.crashed = !1,
  this.crashNotified = !1,
  this.groundContact = e,
  this.arrestingCableContact = null,
  this.collisionPoints)
      this.collisionPoints[t].lastGroundAltitude = null,
      this.collisionPoints[t].part.contact = null;
  for (var t in e && !this.definition.gearInitiallyUp ? (geofs.animation.values.gearPosition = 0,
  controls.gear.position = 0,
  controls.gear.target = 0) : (geofs.animation.values.gearPosition = 1,
  controls.gear.position = 1,
  controls.gear.target = 1),
  this.rigidBody && this.rigidBody.reset(),
  this.parts) {
      var a = this.parts[t];
      if (a.object3d && a.object3d.reset(),
      a.animations)
          for (var o = 0; o < a.animations.length; o++)
              a.animations[o].currentValue = null;
      "wheel" == a.type && (a.angularVelocity = .01,
      a.oldAngularVelocity = .01)
  }
  if (this.engine.on = !0,
  this.engines)
      for (var t = 0; t < this.engines.length; t++)
          this.engines[t].rpm = this.definition.minRPM;
  this.engine.rpm = 0,
  geofs.animation.resetValues({
      altitude: 0,
      altitudeMeters: 0,
      prop: 0,
      throttle: 0,
      yaw: 0,
      pitch: 0,
      roll: 0,
      atilt: 0,
      aroll: 0,
      cameraAircraftDistance: 0,
      kias: 0,
      mach: 0,
      heading: 0,
      verticalSpeed: 0,
      optionalAnimatedPartPosition: 0,
      turnrate: 0,
      accX: 0,
      accY: 0,
      accZ: 0
  }),
  this.animationValue = geofs.animation.values,
  geofs.autopilot.resetPIDs && geofs.autopilot.resetPIDs()
}
,
geofs.aircraft.Aircraft.prototype.place = function(e, t) {
  this.llaLocation = e,
  this.lastLlaLocation = e,
  t && (this.htr = V3.dup(t),
  t = V3.toRadians(t),
  this.object3d.setInitialRotation([t[1], t[2], t[0]])),
  this.placeParts()
}
,
geofs.aircraft.Aircraft.prototype.placeParts = function(e) {
  var e = e || geofs.aircraft.instance.parts;
  for (var t in e)
      this.placePart(e[t])
}
,
geofs.aircraft.Aircraft.prototype.placePart = function(e) {
  if (e.animations) {
      e.object3d.resetAnimatedTransform();
      for (var t = 0, a = e.animations.length; t < a; t++) {
          var o = e.animations[t]
            , r = geofs.animation.filter(o);
          if (!isNaN(r)) {
              switch (o.type) {
              case "rotate":
                  var n = r * DEGREES_TO_RAD;
                  o.rotationMethod.call(e.object3d, n),
                  r = null;
                  break;
              case "scale":
                  var s = V3.add(e.originalScale, V3.scale(o.axis, r));
                  e.object3d.setScale(s);
                  break;
              case "translate":
                  var n = r;
                  e.object3d.translate(V3.scale(o.axis, n)),
                  r = null;
                  break;
              case "opacity":
                  e.object3d.setOpacity(r);
                  break;
              case "show":
                  r <= 0 && e.object3d.visible && e.object3d.setVisibility(!1);
              case "justshow":
                  r > 0 && !e.object3d.visible && e.object3d.setVisibility(!0);
                  break;
              case "hide":
                  r <= 0 && !e.object3d.visible && e.object3d.setVisibility(!0);
              case "justhide":
                  r > 0 && e.object3d.visible && e.object3d.setVisibility(!1);
                  break;
              case "render":
                  e.rendererInstance && e.object3d.visible && e.rendererInstance.update(e, r);
                  break;
              case "sound":
                  if (r > 0) {
                      if (!o.playing) {
                          o.playing = !0;
                          var c = function() {
                              audio.playSoundLoop(o.name, o.loop)
                          };
                          o.retard ? (clearTimeout(o.timeOut),
                          o.timeOut = setTimeout(c, o.retard)) : c()
                      }
                  } else
                      o.playing && (clearTimeout(o.timeOut),
                      audio.stopSoundLoop(o.name),
                      o.playing = !1);
                  break;
              case "property":
                  e[o.name] = r;
                  break;
              case "propertyRatio":
                  e[o.name] *= r
              }
              o.currentValue = r
          }
      }
  }
}
,
geofs.aircraft.Aircraft.prototype.render = function() {
  this.object3d.render(this.llaLocation),
  this.shadow && this.shadow.setLocationRotation(this.llaLocation, this.htr)
}
,
geofs.aircraft.Aircraft.prototype.startEngine = function() {
  this.engine.on || !0 === geofs.aircraft.instance.crashed || (this.engine.on = !0,
  this.engine.startup = !0,
  geofs.aircraft.instance.definition.engineInertia = 2 / this.definition.startupTime,
  setTimeout( () => {
      geofs.aircraft.instance.engine.startup = !1,
      geofs.aircraft.instance.definition.engineInertia = geofs.aircraft.instance.definition.originalInertia
  }
  , 1e3 * this.definition.startupTime),
  audio.playStartup())
}
,
geofs.aircraft.Aircraft.prototype.stopEngine = function() {
  this.engine.on && (geofs.aircraft.instance.definition.engineInertia = 2 / (this.definition.shutdownTime || 1),
  controls.throttle = 0,
  this.engine.on = !1,
  audio.playShutdown())
}
,
geofs.aircraft.Aircraft.prototype.addOffsets = function(e, t) {
  if (e.position && !e.doNotScalePosition && (e.position = V3.scale(e.position, t)),
  e.points.forceSourcePoint && (e.points.forceSourcePoint = V3.scale(e.points.forceSourcePoint, t)),
  e.collisionPoints)
      for (var a = 0; a < e.collisionPoints.length; a++)
          e.collisionPoints[a] = V3.scale(e.collisionPoints[a], t);
  if (e.animations)
      for (var a = 0; a < e.animations.length; a++)
          "translate" == e.animations[a].type && (e.animations[a].ratio = e.animations[a].ratio * t)
}
,
geofs.aircraft.Aircraft.prototype.fixCockpitScale = function(e) {
  if (e)
      for (var t in this.parts) {
          var a = this.parts[t];
          a.model && (a.object3d.setScale(V3.scale(a.originalScale, e)),
          1 == e ? a.object3d.setScaleOffset(null) : a.object3d.setScaleOffset(e))
      }
}
,
geofs.aircraft.Aircraft.prototype.crash = function() {
  this.engine.on = !1,
  this.crashed = !0,
  new geofs.fx.ParticleEmitter({
      anchor: {
          worldPosition: [0, 0, 0]
      },
      duration: 1e3,
      rate: .01,
      life: 1e4,
      near: 10,
      startScale: .05,
      endScale: 1,
      startOpacity: .5,
      endOpacity: 1e-4,
      texture: "darkSmoke"
  })
}
,
window.geofs = window.geofs || {},
geofs.objects = {
  on: !0,
  currentTileCoords: {},
  zoomLevel: 9,
  objectList: [],
  collidableObjectList: [],
  collidableObject: !1
},
geofs.objects.init = function() {
  geofs.objects.collidableInterval = setInterval(geofs.objects.updateCollidables, 2e3),
  $("body").on("nightChange", () => {
      geofs.objects.updateDayNightTextures(geofs.isNight)
  }
  ),
  geofs.objects.on = !0
}
,
geofs.objects.update = function(e) {
  if (geofs.objects.on) {
      var t = geofs.coord2tile(e[0], e[1], geofs.objects.zoomLevel);
      if (t.x != geofs.objects.currentTileCoords.x || t.y != geofs.objects.currentTileCoords.y) {
          let a = geofs.objectServer + (geofs.objects.zoomLevel + "/") + t.x + "/" + t.y + ".json" + geofs.killCache;
          $.getJSON(a, e => {
              geofs.objects.unloadModels(),
              geofs.objects.objectList = e || [],
              geofs.objects.preProcessObjects(),
              geofs.objects.updateCollidables(),
              geofs.objects.loadModels()
          }
          ),
          geofs.objects.currentTileCoords = t
      }
  }
}
,
geofs.objects.destroy = function() {
  clearInterval(geofs.objects.collidableInterval),
  geofs.objects.on = !1,
  geofs.objects.unloadModels(),
  geofs.objects.currentTileCoords = {}
}
,
geofs.objects.preProcessObjects = function() {
  geofs.objects.objectList.forEach(e => {
      if (e.collisionTriangles = e.collisionTriangles || [],
      e.options = e.options || {},
      e.htr = e.htr || [0, 0, 0],
      e.collisionTriangles) {
          var t = [0, 0, 0];
          t = e.rotateModelOnly ? M33.setFromEuler(V3.toRadians([0, 0, 0])) : M33.setFromEuler(V3.toRadians([e.htr[1], e.htr[2], e.htr[0]]));
          for (var a = 0, o = e.collisionTriangles.length; a < o; a++) {
              for (var r = e.collisionTriangles[a], n = 0; n < 3; n++)
                  r[n] = M33.transform(t, r[n]);
              r.u = V3.sub(r[1], r[0]),
              r.v = V3.sub(r[2], r[0]),
              r.n = V3.cross(r.u, r.v)
          }
      }
  }
  )
}
,
geofs.objects.unloadModels = function() {
  geofs.objects.objectList.forEach(e => {
      e.model && (e.model.destroy(),
      e.model = null)
  }
  )
}
,
geofs.objects.loadModels = function(e) {
  geofs.objects.objectList.forEach(e => {
      e.url && (e.options.url = e.url,
      e.options.location = e.location,
      e.options.rotation = e.htr,
      e.options.scale = e.scale,
      e.model = new geofs.api.Model(null,e.options),
      e.nightTexture && geofs.isNight && e.model.getReadyPromise().then( () => {
          e.model.changeTexture(e.nightTexture, e)
      }
      ))
  }
  )
}
,
geofs.objects.updateDayNightTextures = function(e) {
  geofs.objects.objectList.forEach(t => {
      t.nightTexture && t.model.getReadyPromise().then( () => {
          t.model.changeTexture(e ? t.nightTexture : t.dayTexture, t)
      }
      )
  }
  )
}
,
geofs.objects.updateCollidables = function() {
  geofs.objects.collidableObjectList = [],
  geofs.objects.collidableObject = !1,
  geofs.objects.objectList.forEach(e => {
      var t = lla2xyz(V3.sub(geofs.aircraft.instance.llaLocation, e.location), geofs.aircraft.instance.llaLocation);
      V3.length(t) < e.collisionRadius && (e.metricOffset = t,
      geofs.objects.collidableObject = !0,
      geofs.objects.collidableObjectList.push(e))
  }
  )
}
,
geofs.objects.areCollidableObjectAtLocation = function(e, t) {
  return !!geofs.objects.collidableObject
}
,
geofs.objects.getAltitudeAtLocation = function(lla, ignoreThickness) {
  if (geofs.objects.collidableObject)
      for (var origin = [lla[0], lla[1], 1e5], c = 0, lc = geofs.objects.collidableObjectList.length; c < lc; c++)
          for (var object = geofs.objects.collidableObjectList[c], rayOrigin = lla2xyz(V3.sub(origin, object.location), object.location), rayEnd = [rayOrigin[0], rayOrigin[1], 0], t = 0, lt = object.collisionTriangles.length; t < lt; t++) {
              var triangle = object.collisionTriangles[t]
                , result = intersect_RayTriangle([rayOrigin, rayEnd], triangle);
              if (result) {
                  let elevation = result.point[2] + object.location[2];
                  if (object.thickness && lla[2] < elevation - object.thickness && !ignoreThickness)
                      return null;
                  if (object.collisionCallback)
                      try {
                          eval(object.collisionCallback)
                      } catch (e) {
                          geofs.debug.error(e, "objects.getAltitudeAtLocation")
                      }
                  return {
                      location: [lla[0], lla[1], elevation],
                      normal: V3.normalize(triangle.n),
                      object: object
                  }
              }
          }
}
,
geofs.objects.move = function(e, t, a, o) {
  t = t || 0,
  a = a || 0,
  o = o || 0,
  geofs.objects.objectList[e].model.translate([1e-5 * t, 1e-5 * a, .1 * o])
}
,
geofs.objects.rotate = function(e, t) {
  let a = .1;
  t = t || 0,
  geofs.objects.objectList[e].model.rotate([t * a, 0, 0])
}
,
geofs.objects.scale = function(e, t) {
  let a = .01;
  t = t || 1,
  geofs.objects.objectList[e].model.scale(t * a)
}
,
geofs.objects.getLla = function(e) {
  return geofs.objects.objectList[e].model._model._apiLla
}
,
geofs.objects.getHtr = function(e) {
  return geofs.objects.objectList[e].model._model._apiHtr
}
,
geofs.objects.getScale = function(e) {
  return geofs.objects.objectList[e].model._model._apiScale
}
;
var controls = window.controls || {};
(controls = {}).states = {},
controls.mouse = {},
controls.mouse.down = !1,
controls.mouse.orbit = {},
controls.mouse.offset = {
  ratioX: .01,
  ratioY: .01
},
controls.keyboard = {},
controls.keyboard.rollIncrement = .5,
controls.keyboard.pitchIncrement = .5,
controls.keyboard.yawIncrement = .5,
controls.keyboard.throttleIncrement = .8,
controls.keyboard.recenterRatio = .05,
controls.keyboard.override = !1,
controls.keyboard.overrideRudder = !1,
controls.keyboard.exponential = 0,
controls.throttleIncrement = .1,
controls.touch = {
  pitch: 0,
  roll: 0,
  yaw: 0,
  throttle: 0
},
controls.orientation = {
  values: [0, 0, 0],
  generalMultiplier: 1
},
controls.mixYawRoll = !1,
controls.exponential = 1,
controls.steerWithRoll = !0,
controls.mode = "mouse",
controls.init = function() {
  controls.reset(),
  geofs.addResizeHandler(controls.initViewportDimensions, controls),
  $(document).on("keydown", controls.keyDown).on("keyup", controls.keyUp),
  window.onfocus = function() {
      controls.controlKeyPressed = !1
  }
  ,
  controls.mouseHandler = function(e) {
      let t = e;
      if (!e.pageX && e.changedTouches && (t = e.changedTouches[e.changedTouches.length - 1]),
      "touchmove" != e.type || "geofs-control-cursor" != t.target.className) {
          if (geofs.debugOn && geofs.debug.placingObjectId) {
              var a = controls.mouse.originalX - t.pageX
                , o = controls.mouse.originalY - t.pageY
                , r = controls.mouse.lastX - t.pageX
                , n = controls.mouse.lastY - t.pageY;
              controls.shiftKeyPressed ? controls.controlKeyPressed ? geofs.objects.scale(geofs.debug.placingObjectId, n) : geofs.objects.rotate(geofs.debug.placingObjectId, n) : controls.controlKeyPressed ? geofs.objects.move(geofs.debug.placingObjectId, r, n, 0) : controls.altKeyPressed && geofs.objects.move(geofs.debug.placingObjectId, 0, 0, n),
              controls.mouse.lastX = t.pageX,
              controls.mouse.lastY = t.pageY;
              return
          }
          if (!1 !== controls.mouse.down) {
              var a = controls.mouse.originalX - t.pageX
                , o = controls.mouse.originalY - t.pageY
                , r = controls.mouse.lastX - t.pageX
                , n = controls.mouse.lastY - t.pageY;
              4 == controls.mouse.down && controls.manipulator && controls.updateManipulator(controls.manipulator, {
                  ix: r,
                  iy: n,
                  ixr: r * controls.pageRatioX,
                  iyr: n * controls.pageRatioY,
                  dx: a * controls.pageRatioX,
                  dy: o * controls.pageRatioY
              }),
              1 == controls.mouse.down && !geofs.api.nativeMouseHandling && !("touchmove" == e.type && "geofs-view-pad" != t.target.className) && (controls.controlKeyPressed ? geofs.camera.translate(r * controls.mouse.offset.ratioX, 0, -n * controls.mouse.offset.ratioY) && (e.preventDefault(),
              e.stopPropagation && e.stopPropagation(),
              e.stopImmediatePropagation && e.stopImmediatePropagation()) : geofs.camera.rotate(r * controls.mouse.orbit.ratioX, n * controls.mouse.orbit.ratioY) && (e.preventDefault(),
              e.stopPropagation && e.stopPropagation(),
              e.stopImmediatePropagation && e.stopImmediatePropagation())),
              3 == controls.mouse.down && !geofs.api.nativeMouseHandling && geofs.camera.translate(0, -n * controls.mouse.orbit.ratioZ, 0) && (e.preventDefault(),
              e.stopImmediatePropagation && e.stopImmediatePropagation()),
              controls.mouse.lastX = t.pageX,
              controls.mouse.lastY = t.pageY
          } else
              "mouse" != controls.mode || controls.mouseOnHold || (controls.mouse.xValue = clamp((e.pageX - controls.mouse.oX - controls.mouse.cX) * controls.mouse.rX, -1, 1),
              controls.mouse.yValue = clamp((e.pageY - controls.mouse.tY - controls.mouse.cY) * controls.mouse.rY, -1, 1),
              controls.keyboard.override = !1)
      }
  }
  ,
  $(document).on("wheel", function(e) {
      if (controls.wheelManipulator) {
          let t = e.originalEvent.deltaY > 0 ? -1 : 1;
          controls.updateManipulator(controls.wheelManipulator, {
              ix: 0,
              iy: t,
              ixr: 0,
              iyr: 0,
              dx: 0,
              dy: t
          })
      }
  }),
  $(document).on("click", ".geofs-orientationReset, .geofs-orientationCalibrate", function() {
      controls.orientation.recenter()
  }),
  $(document).on("mousemove touchmove", function(e) {
      controls.mouseHandler(e)
  }),
  controls.mouseDownHandler = function(e) {
      let t = e;
      controls.mouse.down = e.which,
      0 === controls.mouse.down && (controls.mouse.down = 1),
      geofs.camera.isHandlingMouseRotation() && !("touchmove" == e.type && "geofs-view-pad" != e.target.className) && (e.preventDefault(),
      e.stopImmediatePropagation && e.stopImmediatePropagation(),
      !e.pageX && e.changedTouches && (t = e.changedTouches[e.changedTouches.length - 1]),
      controls.mouse.originalX = t.pageX,
      controls.mouse.originalY = t.pageY,
      controls.mouse.lastX = controls.mouse.originalX,
      controls.mouse.lastY = controls.mouse.originalY,
      geofs.camera.saveRotation(),
      geofs.camera.saveOffset()),
      controls.mouse.clickedElement = e.currentTarget,
      controls.mouse.clickedNode = geofs.api.getNodeNameFromScreenCoords(t.pageX - controls.mouse.oX, t.pageY - controls.mouse.oY),
      controls.mouse.clickedNode && (geofs.debug.log(controls.mouse.clickedNode),
      controls.runNodeClickHandlers(controls.mouse.clickedNode)),
      4 == controls.mouse.down && controls.manipulator && controls.applyManipulator(controls.manipulator)
  }
  ,
  controls.mouseUpHandler = function(e) {
      geofs.camera.isHandlingMouseRotation() && geofs.camera.saveRotation(),
      controls.mouse.down = !1,
      controls.mouse.clickedNode = null,
      controls.mouse.clickedElement = null,
      controls.manipulator && (controls.releaseManipulator(controls.manipulator),
      controls.manipulator = null),
      e && e.preventDefault && e.preventDefault()
  }
  ,
  $(document).on("mousedown touchstart", ".geofs-canvas-mouse-overlay", controls.mouseDownHandler),
  $(document).on("mouseup", controls.mouseUpHandler),
  $(document).on("touchend", ".geofs-canvas-mouse-overlay", controls.mouseUpHandler),
  $("body, .geofs-canvas-mouse-overlay").on("click touchend", () => {
      "orientation" != controls.mode || controls.orientation.iOSpermissionRequested || controls.orientation.requestIOSPermission()
  }
  ),
  $(".geofs-canvas-mousewheel-overlay").on("wheel", function(e) {
      e.originalEvent.deltaY / 120 < 0 ? geofs.camera.decreaseFOV() : geofs.camera.increaseFOV(),
      e.preventDefault(),
      e.stopPropagation()
  }),
  controls.joystick.init(),
  controls.orientation.init(),
  geofs.autopilot.UI.init(),
  controls.copilot.init(),
  controls.setMode(geofs.preferences.controlMode)
}
,
controls.nodeClickHandlers = {},
controls.addNodeClickHandler = function(e, t) {
  controls.nodeClickHandlers[e] = t
}
,
controls.runNodeClickHandlers = function(e) {
  for (var t in controls.nodeClickHandlers)
      t == e && controls.nodeClickHandlers[t](e)
}
,
controls.removeNodeClickHandler = function(e) {
  delete controls.nodeClickhandlerHandlers[e]
}
,
controls.clearNodeClickHandlers = function() {
  controls.nodeClickHandlers = {}
}
,
controls.addHammerHandlers = function() {
  if (!controls.addHammerHandlersAreSet) {
      var e, t;
      controls.addHammerHandlersAreSet = !0,
      e = $(".geofs-view-pad")[0],
      (t = new Hammer(e)).get("pinch").set({
          enable: !0
      }),
      t.on("pinchstart", e => {
          t.geoFSFOV = geofs.api.getFOV(geofs.camera.cam),
          e.preventDefault()
      }
      ),
      t.on("doubletap", e => {
          geofs.camera.setToNeutral(),
          e.preventDefault()
      }
      ),
      t.on("pinchmove", e => {
          geofs.camera.setFOV(1 / e.scale * t.geoFSFOV),
          controls.mouse.down = !1,
          e.preventDefault()
      }
      ),
      function() {
          var e = $(".geofs-control-cursor")
            , t = $(".geofs-control-pad")
            , a = new Hammer(t[0]);
          function o() {
              e.css("left", "0px"),
              e.css("top", 15 * controls.elevatorTrim + "px")
          }
          a.get("pinch").set({
              enable: !0
          }),
          a.get("pan").set({
              threshold: 0
          }),
          a.on("panstart", e => {
              var t = $(e.target);
              clearTimeout(controls.trimInterval),
              t.hasClass("geofs-control-trimup") ? controls.trimInterval = setInterval( () => {
                  a.trim(t, "Up")
              }
              , 500) : t.hasClass("geofs-control-trimdown") && (controls.trimInterval = setInterval( () => {
                  a.trim(t, "Down")
              }
              , 500)),
              e.preventDefault()
          }
          ),
          a.trim = function(e, t) {
              e.addClass("geofs-control-flash"),
              clearTimeout(e.flashtimeout),
              e.flashtimeout = setTimeout( () => {
                  e.removeClass("geofs-control-flash")
              }
              , 100),
              controls["trim" + t](),
              o()
          }
          ,
          a.on("press", e => {
              var t = $(e.target);
              clearTimeout(controls.trimInterval),
              t.hasClass("geofs-control-trimup") ? controls.trimInterval = setInterval( () => {
                  a.trim(t, "Up")
              }
              , 200) : t.hasClass("geofs-control-trimdown") && (controls.trimInterval = setInterval( () => {
                  a.trim(t, "Down")
              }
              , 200)),
              e.preventDefault()
          }
          ),
          a.on("panend pressup", e => {
              clearTimeout(controls.trimInterval),
              e.preventDefault()
          }
          ),
          a.on("panmove", t => {
              var a = $(t.target);
              if (!(a.hasClass("geofs-control-trimup") || a.hasClass("geofs-control-trimdown"))) {
                  var o = clamp(t.deltaX, -controls.controlPad.eX, controls.controlPad.eX)
                    , r = clamp(t.deltaY, -controls.controlPad.hY, controls.controlPad.hY);
                  controls.touch.roll = o * controls.controlPad.rX,
                  controls.touch.pitch = r * controls.controlPad.rY,
                  e.css("left", o + "px"),
                  e.css("top", r + "px"),
                  t.preventDefault()
              }
          }
          ),
          a.on("panend pancancel", e => {
              clearTimeout(controls.trimInterval);
              var t = $(e.target);
              t.hasClass("geofs-control-trimup") && a.trim(t, "Up"),
              t.hasClass("geofs-control-trimdown") && a.trim(t, "Down"),
              controls.touch.roll = 0,
              controls.touch.pitch = 0,
              o(),
              e.preventDefault()
          }
          ),
          a.on("tap", e => {
              var t = $(e.target);
              t.hasClass("geofs-control-trimup") && controls.trimUp(),
              t.hasClass("geofs-control-trimdown") && controls.trimDown(),
              clearTimeout(controls.trimInterval),
              t.hasClass("geofs-control-option-x") && controls.setters.setOptionalAnimatedPart.set(),
              t.hasClass("geofs-control-option-z") && controls.setters.setAccessories.set(),
              t.addClass("geofs-control-flash"),
              clearTimeout(t.flashtimeout),
              t.flashtimeout = setTimeout( () => {
                  t.removeClass("geofs-control-flash")
              }
              , 100),
              o(),
              e.preventDefault()
          }
          )
      }(),
      function() {
          var e = $(".geofs-throttle-cursor");
          $(".geofs-throttle-pad");
          var t = new Hammer(e[0]);
          controls.hammerThrottle = t,
          t.get("pinch").set({
              enable: !0
          }),
          t.get("pan").set({
              threshold: 0
          });
          var a = $(".geofs-rudder-cursor")
            , o = $(".geofs-rudder-pad");
          function r() {
              a.css("left", "0px")
          }
          $(document).on("preferenceRead preferenceSaved", () => {
              ("touch" != geofs.preferences.controlMode || geofs.preferences.touch.mixYawRoll) && ("orientation" != geofs.preferences.controlMode || geofs.preferences.orientation.mixYawRoll) ? ($(".geofs-throttle-pad").removeClass("geofs-rudder-on"),
              o.hide()) : ($(".geofs-throttle-pad").addClass("geofs-rudder-on"),
              o.show())
          }
          ),
          $(document).on("flyto", () => {
              e.css("bottom", "0%"),
              t.lastY = 0
          }
          ),
          geofs.api.addFrameCallback( () => {
              if (geofs.autopilot.on) {
                  var a = clamp(100 * controls.throttle, 5, 90);
                  e.css("bottom", a + "%"),
                  t.lastY = controls.throttle * controls.throttlePad.hY
              }
          }
          ),
          t.on("panstart", e => {
              t.startY = t.lastY || 0,
              e.preventDefault()
          }
          ),
          t.on("pan", o => {
              var r = t.startY - o.deltaY;
              r = clamp(r, 0, controls.throttlePad.hY),
              t.lastY = r,
              r = clamp(r * controls.throttlePad.rY, 0, 1),
              controls.throttle = r,
              e.css("bottom", clamp(100 * r, 5, 90) + "%");
              var n = clamp(o.deltaX, -controls.rudderPad.eX, controls.rudderPad.eX);
              controls.touch.yaw = n * controls.rudderPad.rX,
              controls.orientation.yaw = controls.touch.yaw,
              a.css("left", n + "px"),
              o.preventDefault()
          }
          ),
          t.on("panmove", e => {
              e.preventDefault()
          }
          ),
          t.on("panend pancancel", e => {
              controls.touch.yaw = 0,
              controls.orientation.yaw = 0,
              r(),
              e.preventDefault()
          }
          )
      }()
  }
}
,
controls.initViewportDimensions = function() {
  var e = $(".geofs-canvas-mouse-overlay")
    , t = e[0];
  controls.mouse.oX = e.offset().left,
  controls.mouse.oY = e.offset().top,
  controls.mouse.cX = t.offsetWidth / 2,
  controls.mouse.rX = 1 / controls.mouse.cX,
  controls.mouse.tY = e.offset().top,
  controls.mouse.cY = t.offsetHeight / 2,
  controls.mouse.rY = 1 / controls.mouse.cY,
  controls.throttlePad = $(".geofs-throttle-pad")[0],
  controls.throttlePad && (controls.throttlePad.tY = controls.throttlePad.offsetTop,
  controls.throttlePad.hY = controls.throttlePad.offsetHeight,
  controls.throttlePad.rY = 1 / controls.throttlePad.hY),
  controls.controlPad = $(".geofs-control-pad")[0],
  controls.controlPad && (controls.controlPad.tY = controls.controlPad.offsetTop,
  controls.controlPad.hY = 75,
  controls.controlPad.rY = 1 / controls.controlPad.hY,
  controls.controlPad.oX = controls.controlPad.offsetLeft,
  controls.controlPad.eX = 75,
  controls.controlPad.rX = 1 / controls.controlPad.eX),
  controls.rudderPad = $(".geofs-rudder-pad")[0],
  controls.rudderPad && (controls.rudderPad.oX = controls.rudderPad.offsetLeft,
  controls.rudderPad.eX = 50,
  controls.rudderPad.rX = 1 / controls.rudderPad.eX),
  controls.viewportWidth = t.offsetWidth,
  controls.viewportHeight = t.offsetHeight,
  controls.mouse.orbit.ratioX = 360 / controls.viewportWidth,
  controls.mouse.orbit.ratioY = 360 / controls.viewportHeight,
  controls.pageRatioX = 1 / controls.viewportWidth,
  controls.pageRatioY = 1 / controls.viewportHeight,
  controls.mouse.orbit.ratioZ = .1,
  geofs.isMobileDevice && controls.addHammerHandlers()
}
,
controls.resetWithAircraftDefinition = function() {
  controls.flaps.maxPosition = geofs.aircraft.instance.definition.flapsPositions ? geofs.aircraft.instance.definition.flapsPositions[geofs.aircraft.instance.definition.flapsPositions.length - 1] : geofs.aircraft.instance.definition.flapsSteps
}
,
controls.reset = function() {
  controls.roll = 0,
  controls.rawPitch = 0,
  controls.pitch = 0,
  controls.yaw = 0,
  controls.throttle = 0,
  controls.mixture = 1,
  controls.carbHeat = 1,
  controls.reverse = 0,
  controls.brakes = 0,
  controls.engine = {},
  controls.engine.on = !1,
  controls.elevatorTrim = 0,
  controls.elevatorTrimMin = -.5,
  controls.elevatorTrimMax = .5,
  controls.elevatorTrimStep = .01,
  controls.gear = {},
  controls.gear.position = 0,
  controls.gear.target = 0,
  controls.flaps = {},
  controls.flaps.position = 0,
  controls.flaps.target = 0,
  controls.flaps.maxPosition = 1,
  controls.flaps.positionRatio = 0,
  controls.airbrakes = {},
  controls.airbrakes.position = 0,
  controls.airbrakes.target = 0,
  controls.optionalAnimatedPart = {},
  controls.optionalAnimatedPart.position = 0,
  controls.optionalAnimatedPart.target = 0,
  controls.accessories = {},
  controls.accessories.position = 0,
  controls.accessories.target = 0,
  controls.states.left = !1,
  controls.states.right = !1,
  controls.states.up = !1,
  controls.states.down = !1,
  controls.states.rudderLeft = !1,
  controls.states.rudderRight = !1,
  controls.states.increaseThrottle = !1,
  controls.states.decreaseThrottle = !1,
  controls.mouse.xValue = 0,
  controls.mouse.yValue = 0,
  controls.initViewportDimensions(),
  geofs.aircraft.instance && geofs.aircraft.instance.definition && controls.resetWithAircraftDefinition()
}
,
controls.setMode = function(e) {
  e = e || geofs.preferences.controlMode || "mouse",
  controls.mode = e,
  "orientation" == controls.mode ? (controls.orientation.init(),
  controls.orientation.available ? $("body").addClass("geofs-orientation") : (controls.setMode("touch"),
  $("body").removeClass("geofs-orientation")),
  controls.exponential = 1,
  controls.mixYawRoll = geofs.preferences.orientation.mixYawRoll,
  controls.steerWithRoll = geofs.preferences.orientation.steerWithRoll,
  controls.sensitivity = geofs.preferences.orientation.sensitivity,
  controls.multiplier = {
      pitch: geofs.preferences.orientation.multiplier.pitch ? -1 : 1,
      roll: geofs.preferences.orientation.multiplier.roll ? -1 : 1,
      yaw: 1
  }) : $("body").removeClass("geofs-orientation"),
  "touch" == controls.mode ? (controls.exponential = 1,
  controls.mixYawRoll = geofs.preferences.touch.mixYawRoll,
  controls.steerWithRoll = geofs.preferences.touch.steerWithRoll,
  controls.sensitivity = geofs.preferences.touch.sensitivity,
  controls.multiplier = {
      pitch: 1,
      roll: 1,
      yaw: 1
  },
  $("body").addClass("geofs-touch")) : $("body").removeClass("geofs-touch"),
  "joystick" == controls.mode && (controls.exponential = 1,
  controls.mixYawRoll = geofs.preferences.joystick.mixYawRoll,
  controls.steerWithRoll = geofs.preferences.joystick.steerWithRoll,
  controls.sensitivity = geofs.preferences.joystick.sensitivity,
  controls.multiplier = {
      pitch: 1,
      roll: 1,
      yaw: 1,
      throttle: geofs.preferences.joystick.multiplier.throttle ? -1 : 1
  }),
  "mouse" == controls.mode && (controls.exponential = 1,
  controls.mixYawRoll = geofs.preferences.mouse.mixYawRoll,
  controls.steerWithRoll = geofs.preferences.mouse.steerWithRoll,
  controls.sensitivity = geofs.preferences.mouse.sensitivity,
  controls.multiplier = {
      pitch: geofs.preferences.mouse.reverse ? -1 : 1,
      roll: 1,
      yaw: 1
  }),
  "keyboard" == controls.mode && (controls.exponential = 0,
  controls.mixYawRoll = geofs.preferences.keyboard.mixYawRoll,
  controls.steerWithRoll = geofs.preferences.keyboard.steerWithRoll,
  controls.sensitivity = geofs.preferences.keyboard.sensitivity,
  controls.multiplier = {
      pitch: 1,
      roll: 1,
      yaw: 1
  }),
  geofs.preferences.controlMode = e,
  geofs.setPreferenceValues()
}
,
controls.axisSetters = {
  none: {
      label: "none",
      value: null
  },
  pitch: {
      label: "Pitch",
      overridesPeer: !0,
      process: e => controls.rawPitch = e * geofs.preferences.joystick.sensitivity
  },
  roll: {
      label: "Roll",
      overridesPeer: !0,
      process: e => controls.roll = e * geofs.preferences.joystick.sensitivity
  },
  yaw: {
      label: "Yaw",
      overridesPeer: !0,
      process: e => controls.yaw = e * geofs.preferences.joystick.sensitivity
  },
  throttle: {
      label: "Throttle",
      overridesPeer: !0,
      process: e => controls.throttle = (e + 1) / 2
  },
  reverse: {
      label: "Reverse",
      process: e => controls.reverse = (e + 1) / 2
  },
  throttlereverse: {
      label: "Throttle & Reverse",
      process: e => geofs.aircraft.instance.definition.reverse ? controls.throttle = e : controls.throttle = (e + 1) / 2
  },
  increaseThrottle: {
      label: "Increase/Decrease Throttle",
      process: (e, t) => controls.throttle += e * t
  },
  brakes: {
      label: "Brakes",
      overridesAutopilot: !0,
      overridesPeer: !0,
      process: e => controls.brakes = e
  },
  airbrakesPosition: {
      label: "Air Brakes",
      overridesAutopilot: !0,
      overridesPeer: !0,
      process(e) {
          controls.airbrakes.target = (e + 1) / 2,
          controls.setPartAnimationDelta(controls.airbrakes)
      }
  },
  flapsPosition: {
      label: "Flaps",
      overridesAutopilot: !0,
      process(e) {
          controls.flaps.positionTarget = (e + 1) / 2 * controls.flaps.maxPosition,
          controls.setPartAnimationDelta(controls.flaps)
      }
  },
  hatView: {
      label: "Hat Button View",
      overridesAutopilot: !0,
      max: 3,
      process(e, t) {
          var a = 40
            , o = 0
            , r = 0;
          e > -1 && e < 0 && (o = -a),
          e > -.4 && e < .7 && (r = -a),
          e > .4 && e < 1.1 && (o = a),
          (1 == e || e < -.7 && e > -1.1) && (r = a),
          (o || r) && (geofs.camera.rotate(o * t, r * t),
          geofs.camera.saveRotation())
      }
  },
  lookAround: {
      label: "Look left/right",
      overridesAutopilot: !0,
      process(e) {
          e != geofs.lookAroundValue && (geofs.camera.lookAround(90 * e),
          geofs.lookAroundValue = e)
      }
  },
  lookUpDown: {
      label: "Look up/down",
      overridesAutopilot: !0,
      process(e) {
          e != geofs.lookUpDownValue && (geofs.camera.lookAround(null, -90 * e),
          geofs.lookUpDownValue = e)
      }
  }
},
controls.setters = {
  none: {
      label: "none",
      set: function() {},
      unset: function() {}
  },
  toggleEngines: {
      label: "Turn Engines ON/OFF ",
      set: function() {
          geofs.aircraft.instance.engine.on ? geofs.aircraft.instance.stopEngine() : geofs.aircraft.instance.startEngine()
      }
  },
  setBrakes: {
      label: "Brakes",
      set: function() {
          geofs.aircraft.instance.brakesOn = !0,
          controls.brakes = 1
      },
      unset: function() {
          geofs.aircraft.instance.brakesOn = !1,
          controls.brakes = 0
      }
  },
  toggleAutoPilot: {
      label: "Autopilot",
      set: function() {
          geofs.autopilot.toggle()
      }
  },
  toggleParkingBrake: {
      label: "Parking brake",
      set: function() {
          geofs.aircraft.instance.brakesOn ? (geofs.aircraft.instance.brakesOn = !1,
          controls.brakes = 0) : (geofs.aircraft.instance.brakesOn = !0,
          controls.brakes = 1)
      }
  },
  setAirbrakes: {
      label: "Air Brakes",
      set: function() {
          0 == controls.airbrakes.target ? (controls.airbrakes.target = 1,
          controls.setPartAnimationDelta(controls.airbrakes)) : (controls.airbrakes.target = 0,
          controls.setPartAnimationDelta(controls.airbrakes))
      }
  },
  setAirbrakesUp: {
      label: "Airbrakes Full",
      set: function() {
          controls.airbrakes.target = 1,
          controls.setPartAnimationDelta(controls.airbrakes)
      }
  },
  setAirbrakesDown: {
      label: "Airbrakes Retract",
      set: function() {
          controls.airbrakes.target = 0,
          controls.setPartAnimationDelta(controls.airbrakes)
      }
  },
  setOptionalAnimatedPart: {
      label: "Optional Animated Parts",
      set: function() {
          0 == controls.optionalAnimatedPart.target ? (controls.optionalAnimatedPart.target = 1,
          controls.setPartAnimationDelta(controls.optionalAnimatedPart)) : (controls.optionalAnimatedPart.target = 0,
          controls.setPartAnimationDelta(controls.optionalAnimatedPart))
      }
  },
  setAccessories: {
      label: "Accessories (hook/floats/rudder)",
      set: function() {
          0 == controls.accessories.target ? (controls.accessories.target = 1,
          controls.setPartAnimationDelta(controls.accessories)) : (controls.accessories.target = 0,
          controls.setPartAnimationDelta(controls.accessories))
      }
  },
  setFlaps: {
      label: "Set Flaps",
      set: function() {
          controls.flaps.target >= 0 && controls.flaps.target <= geofs.aircraft.instance.definition.flapsSteps && (geofs.aircraft.instance.definition.flapsPositions && (controls.flaps.positionTarget = geofs.aircraft.instance.definition.flapsPositions[controls.flaps.target]),
          controls.setPartAnimationDelta(controls.flaps))
      }
  },
  setFlapsUp: {
      label: "Flaps Up",
      set: function() {
          controls.flaps.target > 0 && (controls.flaps.target--,
          geofs.aircraft.instance.definition.flapsPositions && (controls.flaps.positionTarget = geofs.aircraft.instance.definition.flapsPositions[controls.flaps.target]),
          controls.setPartAnimationDelta(controls.flaps))
      }
  },
  setFlapsDown: {
      label: "Flaps down",
      set: function() {
          controls.flaps.target < geofs.aircraft.instance.definition.flapsSteps && (controls.flaps.target++,
          geofs.aircraft.instance.definition.flapsPositions && (controls.flaps.positionTarget = geofs.aircraft.instance.definition.flapsPositions[controls.flaps.target]),
          controls.setPartAnimationDelta(controls.flaps))
      }
  },
  cycleFlaps: {
      label: "Cycle Flaps",
      set: function() {
          controls.flaps.target < geofs.aircraft.instance.definition.flapsSteps ? controls.flaps.target++ : controls.flaps.target = 0,
          geofs.aircraft.instance.definition.flapsPositions && (controls.flaps.positionTarget = geofs.aircraft.instance.definition.flapsPositions[controls.flaps.target]),
          controls.setPartAnimationDelta(controls.flaps)
      }
  },
  setGear: {
      label: "Toggle Gear (up/down)",
      set: function() {
          (geofs.aircraft.instance.definition.gearOperationAllowedOnGround || !geofs.aircraft.instance.groundContact || geofs.debugOn) && (0 == controls.gear.target ? (controls.gear.target = 1,
          controls.setPartAnimationDelta(controls.gear)) : (controls.gear.target = 0,
          controls.setPartAnimationDelta(controls.gear)))
      }
  },
  setGearDown: {
      label: "Gear Down",
      set: function() {
          (geofs.aircraft.instance.definition.gearOperationAllowedOnGround || !geofs.aircraft.instance.groundContact || geofs.debugOn) && 1 == controls.gear.target && (controls.gear.target = 0,
          controls.setPartAnimationDelta(controls.gear))
      }
  },
  setGearUp: {
      label: "Gear Up",
      set: function() {
          (geofs.aircraft.instance.definition.gearOperationAllowedOnGround || !geofs.aircraft.instance.groundContact || geofs.debugOn) && 0 == controls.gear.target && (controls.gear.target = 1,
          controls.setPartAnimationDelta(controls.gear))
      }
  },
  increaseThrottle: {
      label: "Increase Throttle",
      set: function(e) {
          controls.throttle += controls.throttleIncrement
      }
  },
  decreaseThrottle: {
      label: "Decrease Throttle",
      set: function(e) {
          controls.throttle -= controls.throttleIncrement
      }
  },
  setReverseNone: {
      label: "Set reverse to none",
      set: function() {
          controls.reverse = 0
      }
  },
  setReverseFull: {
      label: "Set reverse to full",
      set: function() {
          controls.reverse = 1
      }
  },
  fullReverse: {
      label: "Full reverse while pressed",
      set: function() {
          controls.reverse = 1
      },
      unset: function() {
          controls.reverse = 0
      }
  },
  toggleReverse: {
      label: "Toggle Reverse (full/none)",
      set: function() {
          controls.reverse > 0 ? controls.reverse = 0 : controls.reverse = 1
      }
  },
  setReverseOnThrottleAxis: {
      label: "Set reverse on throttle axis",
      set: function() {
          controls.throttleAsReverse = 1
      },
      unset: function() {
          controls.throttleAsReverse = 0
      }
  },
  setElevatorTrimUp: {
      label: "Elevator Trim Up",
      set: function() {
          controls.states.elevatorTrimUp = !0
      },
      unset: function() {
          controls.states.elevatorTrimUp = !1
      }
  },
  setElevatorTrimDown: {
      label: "Elevator Trim Down",
      set: function() {
          controls.states.elevatorTrimDown = !0
      },
      unset: function() {
          controls.states.elevatorTrimDown = !1
      }
  },
  setElevatorTrimNeutral: {
      label: "Elevator Trim Neutral",
      set: function() {
          controls.elevatorTrim = 0
      }
  },
  lookLeft: {
      label: "Look Left",
      overridesAutopilot: !0,
      set: function() {
          geofs.camera.lookAround(-90)
      },
      unset: function() {
          geofs.camera.lookAround(0)
      }
  },
  lookRight: {
      label: "Look Right",
      overridesAutopilot: !0,
      set: function() {
          geofs.camera.lookAround(90)
      },
      unset: function() {
          geofs.camera.lookAround(0)
      }
  },
  cameraRight: {
      label: "Rotate View Right",
      overridesAutopilot: !0,
      set: function() {
          geofs.camera.animations.orbitHorizontal.active = !0,
          geofs.camera.animations.orbitHorizontal.rate = 1
      },
      unset: function() {
          geofs.camera.animations.orbitHorizontal.active = !1
      }
  },
  cameraLeft: {
      label: "Rotate View Left",
      overridesAutopilot: !0,
      set: function() {
          geofs.camera.animations.orbitHorizontal.active = !0,
          geofs.camera.animations.orbitHorizontal.rate = -1
      },
      unset: function() {
          geofs.camera.animations.orbitHorizontal.active = !1
      }
  },
  cameraUp: {
      label: "Rotate View Up",
      overridesAutopilot: !0,
      set: function() {
          geofs.camera.animations.orbitVertical.active = !0,
          geofs.camera.animations.orbitVertical.rate = 1
      },
      unset: function() {
          geofs.camera.animations.orbitVertical.active = !1
      }
  },
  cameraDown: {
      label: "Rotate View Down",
      overridesAutopilot: !0,
      set: function() {
          geofs.camera.animations.orbitVertical.active = !0,
          geofs.camera.animations.orbitVertical.rate = -1
      },
      unset: function() {
          geofs.camera.animations.orbitVertical.active = !1
      }
  },
  reset: {
      label: "Reset Flight",
      overridesAutopilot: !0,
      set: function() {
          geofs.resetFlight()
      }
  },
  pushToTalk: {
      label: "Push to Talk",
      set: function() {
          geofs.radio.pushToTalk = !0,
          $(document).trigger("pushtotalk")
      },
      unset: function() {
          geofs.radio.pushToTalk = !1,
          $(document).trigger("pushedtotalk")
      }
  }
},
controls.trimUp = function(e) {
  controls.elevatorTrim < controls.elevatorTrimMax && (controls.elevatorTrim += controls.elevatorTrimStep)
}
,
controls.trimDown = function(e) {
  controls.elevatorTrim > controls.elevatorTrimMin && (controls.elevatorTrim -= controls.elevatorTrimStep)
}
,
controls.update = function(e) {
  try {
      controls.updateKeyboard(e)
  } catch (t) {
      geofs.debug.error(t, "controls.updateTouch")
  }
  if (controls.copilot.update(e),
  "joystick" == controls.mode)
      try {
          controls.updateJoystick(e)
      } catch (a) {
          geofs.debug.error(a, "controls.updateJoystick")
      }
  if (!geofs.autopilot.on) {
      if (controls.states.elevatorTrimUp ? (controls.trimUp(),
      controls.setters.setElevatorTrimUp.unset()) : controls.states.elevatorTrimDown && (controls.trimDown(),
      controls.setters.setElevatorTrimDown.unset()),
      ("mouse" == controls.mode || "touch" == controls.mode) && !controls.keyboard.override)
          try {
              controls.updateMouse(e)
          } catch (o) {
              geofs.debug.error(o, "controls.updateMouse")
          }
      if ("orientation" == controls.mode)
          try {
              controls.updateOrientation(e)
          } catch (r) {
              geofs.debug.error(r, "controls.updateOrientation")
          }
      if ("touch" == controls.mode)
          try {
              controls.updateTouch(e)
          } catch (n) {
              geofs.debug.error(n, "controls.updateTouch")
          }
      var s = controls.exponential;
      controls.keyboard.override && (s = controls.keyboard.exponential),
      controls.roll = controls.roll * controls.multiplier.roll,
      controls.rawPitch = controls.rawPitch * controls.multiplier.pitch,
      controls.yaw = controls.yaw * controls.multiplier.yaw,
      controls.roll = controls.roll * Math.pow(Math.abs(controls.roll), s),
      controls.rawPitch = controls.rawPitch * Math.pow(Math.abs(controls.rawPitch), s),
      controls.rawYaw = controls.yaw,
      controls.mixYawRoll && (controls.yaw = controls.roll),
      controls.steerWithRoll ? controls.steering = Math.abs(controls.yaw) > Math.abs(controls.roll) ? controls.yaw : controls.roll : controls.steering = controls.yaw,
      controls.keyboard.overrideRudder && (s = geofs.preferences.keyboard.exponential),
      controls.yaw = controls.yaw * Math.pow(Math.abs(controls.yaw), s),
      controls.rawYaw = controls.yaw
  }
  controls.roll = clamp(controls.roll, -1, 1),
  controls.rawPitch = clamp(controls.rawPitch, -1, 1),
  controls.yaw = clamp(controls.yaw, -1, 1),
  controls.pitch = controls.rawPitch + controls.elevatorTrim;
  var c = 0;
  geofs.aircraft.instance.definition.reverse && (c = -1,
  controls.throttle > 0 && (controls.reverse = 0)),
  controls.throttleAsReverse ? controls.throttle = clamp(-controls.throttle, c, 0) : controls.throttle = clamp(controls.throttle - controls.reverse, c, 1),
  controls.animatePart("gear", e),
  controls.animatePart("flaps", e),
  controls.animatePart("airbrakes", e),
  controls.animatePart("optionalAnimatedPart", e),
  controls.animatePart("accessories", e)
}
,
controls.setPartAnimationDelta = function(e) {
  e.positionTarget ? e.delta = e.positionTarget - e.position : e.delta = e.target - e.position
}
,
controls.animatePart = function(e, t) {
  var a, o = controls[e];
  if (a = o.positionTarget ? o.positionTarget : o.target,
  o.position != a && geofs.aircraft.instance.definition[e + "TravelTime"]) {
      var r = o.delta / (geofs.aircraft.instance.definition[e + "TravelTime"] / t);
      o.position += r,
      o.delta < 0 && o.position <= a && (o.position = a,
      o.delta = null),
      o.delta > 0 && o.position >= a && (o.position = a,
      o.delta = null),
      o.positionRatio = o.maxPosition ? o.position / o.maxPosition : o.position
  }
}
,
controls.updateMouse = function(e) {
  controls.roll = controls.mouse.xValue * geofs.preferences.mouse.sensitivity,
  controls.rawPitch = controls.mouse.yValue * geofs.preferences.mouse.sensitivity
}
,
controls.updateKeyboard = function(e) {
  var t = controls.keyboard.rollIncrement * e * geofs.preferences.keyboard.sensitivity;
  controls.states.left ? controls.roll -= t : controls.states.right ? controls.roll += t : geofs.aircraft.instance.controllers.roll.recenter && (controls.roll -= [controls.roll - 0] * controls.keyboard.recenterRatio * geofs.preferences.keyboard.sensitivity);
  var a = controls.keyboard.pitchIncrement * e * geofs.preferences.keyboard.sensitivity * geofs.aircraft.instance.controllers.pitch.sensitivity;
  controls.states.up ? controls.rawPitch -= a * geofs.aircraft.instance.controllers.pitch.ratio : controls.states.down ? controls.rawPitch += a * geofs.aircraft.instance.controllers.pitch.ratio : geofs.aircraft.instance.controllers.pitch.recenter && (controls.rawPitch -= [controls.rawPitch - 0] * a);
  var o = controls.keyboard.yawIncrement * e * geofs.preferences.keyboard.sensitivity;
  controls.states.rudderLeft ? controls.yaw -= o : controls.states.rudderRight ? controls.yaw += o : geofs.aircraft.instance.controllers.yaw.recenter && (controls.yaw -= [controls.yaw - 0] * controls.keyboard.recenterRatio * geofs.preferences.keyboard.sensitivity);
  var r = controls.keyboard.throttleIncrement * e;
  controls.states.increaseThrottle ? controls.throttle += r : controls.states.decreaseThrottle && (controls.throttle -= r)
}
,
controls.recenter = function() {
  controls.mouse.xValue = 0,
  controls.mouse.yValue = 0,
  controls.yaw = 0,
  controls.roll = 0,
  controls.rawPitch = 0
}
,
controls.keyDown = function(e) {
  switch (e.which) {
  case geofs.preferences.keyboard.keys["Toggle Autopilot"].keycode:
      controls.setters.toggleAutoPilot.set();
      break;
  case geofs.preferences.keyboard.keys["Bank left"].keycode:
      controls.states.left = !0,
      e.returnValue = !1,
      controls.keyboard.override = !0;
      break;
  case geofs.preferences.keyboard.keys["Bank right"].keycode:
      controls.states.right = !0,
      e.returnValue = !1,
      controls.keyboard.override = !0;
      break;
  case geofs.preferences.keyboard.keys["Pitch down"].keycode:
      controls.states.up = !0,
      e.returnValue = !1,
      controls.keyboard.override = !0;
      break;
  case geofs.preferences.keyboard.keys["Pitch up"].keycode:
      controls.states.down = !0,
      e.returnValue = !1,
      controls.keyboard.override = !0;
      break;
  case geofs.preferences.keyboard.keys["Steer left"].keycode:
      controls.states.rudderLeft = !0,
      e.returnValue = !1,
      controls.keyboard.overrideRudder = !0;
      break;
  case geofs.preferences.keyboard.keys["Steer right"].keycode:
      controls.states.rudderRight = !0,
      e.returnValue = !1,
      controls.keyboard.overrideRudder = !0;
      break;
  case geofs.preferences.keyboard.keys["Increase throttle"].keycode:
  case geofs.preferences.keyboard.keys["Increase throttle alt"].keycode:
      controls.states.increaseThrottle = !0,
      e.returnValue = !1;
      break;
  case geofs.preferences.keyboard.keys["Decrease throttle"].keycode:
  case geofs.preferences.keyboard.keys["Decrease throttle alt"].keycode:
      controls.states.decreaseThrottle = !0,
      e.returnValue = !1;
      break;
  case geofs.preferences.keyboard.keys.Brakes.keycode:
      controls.setters.setBrakes.set();
      break;
  case geofs.preferences.keyboard.keys["Parking brake"].keycode:
      controls.setters.toggleParkingBrake.set();
      break;
  case geofs.preferences.keyboard.keys["Engine switch (on/off)"].keycode:
      controls.setters.toggleEngines.set();
      break;
  case geofs.preferences.keyboard.keys["Gear toggle (up/down)"].keycode:
      controls.setters.setGear.set();
      break;
  case geofs.preferences.keyboard.keys["Lower flaps"].keycode:
      controls.setters.setFlapsDown.set();
      break;
  case geofs.preferences.keyboard.keys["Raise flaps"].keycode:
      controls.setters.setFlapsUp.set();
      break;
  case geofs.preferences.keyboard.keys["Cycle flaps"].keycode:
      controls.setters.cycleFlaps.set();
      break;
  case geofs.preferences.keyboard.keys["Airbrake toggle (on/off)"].keycode:
      controls.setters.setAirbrakes.set();
      break;
  case geofs.preferences.keyboard.keys["Accessories (hook/floats/rudder) toggle"].keycode:
      controls.setters.setAccessories.set();
      break;
  case geofs.preferences.keyboard.keys["Optional Animated Part toggle (on/off)"].keycode:
      controls.setters.setOptionalAnimatedPart.set();
      break;
  case geofs.preferences.keyboard.keys["Elevator trim up"].keycode:
      controls.setters.setElevatorTrimUp.set();
      break;
  case geofs.preferences.keyboard.keys["Elevator trim down"].keycode:
      controls.setters.setElevatorTrimDown.set();
      break;
  case geofs.preferences.keyboard.keys["Elevator trim neutral"].keycode:
      controls.setters.setElevatorTrimNeutral.set();
      break;
  case geofs.preferences.keyboard.keys["Push To Talk"].keycode:
      controls.setters.pushToTalk.set();
      break;
  case 13:
      controls.recenter();
      break;
  case 16:
      controls.shiftKeyPressed = !0;
      break;
  case 17:
      controls.controlKeyPressed = !0;
      break;
  case 18:
      controls.altKeyPressed = !0;
      break;
  case 27:
      flight.recorder.playing && (flight.recorder.exitPlayback(),
      e.preventDefault());
      break;
  case 86:
      flight.recorder.enterPlayback();
      break;
  case 83:
      audio.toggleMute();
      break;
  case 80:
      geofs.togglePause();
      break;
  case 67:
      geofs.camera.cycle();
      break;
  case 78:
      ui.panel.toggle(".geofs-map-list");
      break;
  case 79:
      ui.panel.toggle(".geofs-preference-list");
      break;
  case 9:
      geofs.flyToCamera();
      break;
  case 72:
      geofs.visibilityCycle();
      break;
  case 77:
      "mouse" == controls.mode ? controls.mouseOnHold = !controls.mouseOnHold : (controls.mouseOnHold = !1,
      controls.setMode("mouse")),
      controls.mouseOnHold ? $("body").addClass("geofs-mouseHold") : $("body").removeClass("geofs-mouseHold");
      break;
  case 75:
      controls.setMode("keyboard");
      break;
  case 74:
      controls.setMode("joystick");
      break;
  case 81:
      controls.controlKeyPressed && (geofs.camera.animations.orbitHorizontal.active = !geofs.camera.animations.orbitHorizontal.active);
      break;
  case 65:
      controls.controlKeyPressed && (geofs.camera.animations.orbitVertical.active = !geofs.camera.animations.orbitVertical.active);
      break;
  case 82:
      geofs.resetFlight();
      break;
  case 85:
      break;
  case 89:
      controls.controlKeyPressed && (weather.animate = !weather.animate);
      break;
  case 97:
      geofs.camera.setRotation(45);
      break;
  case 98:
      geofs.camera.setRotation(0);
      break;
  case 99:
      geofs.camera.setRotation(-45);
      break;
  case 100:
      geofs.camera.setRotation(90);
      break;
  case 101:
      geofs.camera.setToNeutral();
      break;
  case 102:
      geofs.camera.setRotation(-90);
      break;
  case 103:
      geofs.camera.setRotation(135);
      break;
  case 104:
      geofs.camera.setRotation(180);
      break;
  case 105:
      geofs.camera.setRotation(-135)
  }
  if (e.keyCode >= 48 && e.keyCode <= 57) {
      var t = e.keyCode - 48;
      controls.throttle = t / 9
  }
}
,
controls.keyUp = function(e) {
  switch (e.which) {
  case geofs.preferences.keyboard.keys["Bank left"].keycode:
      controls.states.left = !1,
      e.returnValue = !1;
      break;
  case geofs.preferences.keyboard.keys["Bank right"].keycode:
      controls.states.right = !1,
      e.returnValue = !1;
      break;
  case geofs.preferences.keyboard.keys["Pitch down"].keycode:
      controls.states.up = !1,
      e.returnValue = !1;
      break;
  case geofs.preferences.keyboard.keys["Pitch up"].keycode:
      controls.states.down = !1,
      e.returnValue = !1;
      break;
  case geofs.preferences.keyboard.keys["Steer left"].keycode:
      controls.states.rudderLeft = !1,
      e.returnValue = !1;
      break;
  case geofs.preferences.keyboard.keys["Steer right"].keycode:
      controls.states.rudderRight = !1,
      e.returnValue = !1;
      break;
  case geofs.preferences.keyboard.keys["Increase throttle"].keycode:
  case geofs.preferences.keyboard.keys["Increase throttle alt"].keycode:
      controls.states.increaseThrottle = !1,
      e.returnValue = !1;
      break;
  case geofs.preferences.keyboard.keys["Decrease throttle"].keycode:
  case geofs.preferences.keyboard.keys["Decrease throttle alt"].keycode:
      controls.states.decreaseThrottle = !1,
      e.returnValue = !1;
      break;
  case geofs.preferences.keyboard.keys["Elevator trim up"].keycode:
      controls.setters.setElevatorTrimUp.unset();
      break;
  case geofs.preferences.keyboard.keys["Elevator trim down"].keycode:
      controls.setters.setElevatorTrimDown.unset();
      break;
  case geofs.preferences.keyboard.keys.Brakes.keycode:
      controls.setters.setBrakes.unset();
      break;
  case 16:
      controls.shiftKeyPressed = !1;
      break;
  case 17:
      controls.controlKeyPressed = !1;
      break;
  case 18:
      controls.altKeyPressed = !1;
      break;
  case geofs.preferences.keyboard.keys["Push To Talk"].keycode:
      controls.setters.pushToTalk.unset()
  }
}
,
controls.joystick = {},
controls.joystick.deadZoneUp = .1,
controls.joystick.deadZoneDown = -.1,
controls.joystick.ready = !1,
controls.joystick.sticksNumber = 0,
controls.joystick.calibrationDurationSeconds = 15,
controls.joystick.poll = function() {
  if (controls.joystick.sticks = [],
  !controls.joystick.api)
      return !1;
  var e = controls.joystick.api.call(navigator);
  if (!(e.length > 0))
      return controls.joystick.ready = !1,
      !1;
  for (let t = 0; t < 5; t++)
      e[t] && controls.joystick.sticks.push(e[t]);
  return (controls.joystick.sticksNumber != controls.joystick.sticks.length && (controls.joystick.info = "",
  controls.joystick.sticks.forEach(e => {
      controls.joystick.info += e.id + "<br/>"
  }
  ),
  controls.joystick.configure(),
  $(controls.joystick).trigger("joystickReady"),
  controls.joystick.sticksNumber = controls.joystick.sticks.length),
  controls.joystick.sticks.length) ? (controls.joystick.ready = !0,
  !0) : (controls.joystick.ready = !1,
  !1)
}
,
controls.joystick.init = function() {
  controls.joystick.api = ("function" == typeof navigator.getGamepads ? navigator.getGamepads : null) || ("function" == typeof navigator.webkitGetGamepads ? navigator.webkitGetGamepads : null) || null,
  controls.joystick.poll()
}
,
controls.joystick.configure = function() {
  controls.joystick.oldButtonsValue = 0,
  controls.joystick.buttons = {},
  controls.joystick.axes = {},
  controls.joystick.buttonHandlers = [];
  var e = 0
    , t = 0;
  controls.joystick.sticks.forEach( (a, o) => {
      for (var r in a.hash = geofs.utils.hashCode(a.id),
      a.buttons) {
          var n = a.hash + r;
          if (geofs.preferences.joystick.buttons[n] && controls.setters[geofs.preferences.joystick.buttons[n]]) {
              var s = controls.setters[geofs.preferences.joystick.buttons[n]].set
                , c = controls.setters[geofs.preferences.joystick.buttons[n]].unset;
              s && controls.joystick.addButtonListener(n, "buttondown", s),
              c && controls.joystick.addButtonListener(n, "buttonup", c)
          }
          controls.joystick.buttons[n] = {
              stick: o,
              globalId: e,
              id: r
          },
          e++
      }
      for (var d in a.axes) {
          var n = a.hash + d;
          controls.joystick.axes[n] = {
              stick: o,
              globalId: t,
              id: d,
              enabled: 0 != a.axes[d]
          },
          t++
      }
  }
  )
}
,
controls.joystick.startCalibration = function() {
  for (var e in controls.joystick.axes)
      controls.joystick.axes[e].range = {
          min: 0,
          max: 0
      };
  controls.joystick.calibrating = !0,
  controls.joystick.calibratingTime = controls.joystick.calibrationDurationSeconds,
  controls.joystick.calibrationInterval = setInterval(controls.joystick.calibrationStatus, 250),
  $(".geofs-joystick-calibration .geofs-calibrating").show(),
  $(".geofs-joystick-calibration .geofs-calibrated").hide(),
  $(".geofs-joystick-calibration .geofs-joystick-startCalibration").hide()
}
,
controls.joystick.calibrationStatus = function() {
  controls.joystick.calibratingTime -= .25,
  $(".geofs-joystick-calibration .geofs-joystick-calibrationProgress").text(parseInt(controls.joystick.calibratingTime)),
  controls.joystick.calibratingTime <= 0 && controls.joystick.stopCalibration()
}
,
controls.joystick.stopCalibration = function() {
  clearInterval(controls.joystick.calibrationInterval),
  controls.joystick.calibrating = !1,
  $(".geofs-joystick-calibration .geofs-calibrating").hide(),
  $(".geofs-joystick-calibration .geofs-calibrated").show(),
  $(".geofs-joystick-calibration .geofs-joystick-startCalibration").show()
}
,
controls.joystick.resetCalibration = function() {
  for (var e in controls.joystick.axes)
      geofs.preferences.joystick.calibration[e] = {
          center: 0,
          multiplier: 1
      }
}
,
controls.joystick.checkButton = function(e) {
  var t = controls.joystick.buttons[e];
  if (t)
      return controls.joystick.sticks[t.stick].buttons[t.id].pressed
}
,
controls.joystick.getAxisValue = function(e, t, a) {
  if (controls.joystick.axes) {
      var o = controls.joystick.axes[e];
      if (o)
          return clamp(controls.joystick.sticks[o.stick].axes[o.id], t || -1, a || 1)
  }
}
,
controls.updateJoystick = function(e) {
  if (controls.joystick.poll()) {
      for (var t in controls.joystick.axes) {
          let a = controls.joystick.axes[t]
            , o = geofs.preferences.joystick.axis[t]
            , r = geofs.preferences.joystick.calibration[t] || {
              center: 0,
              multiplier: 1
          };
          if ("none" != o) {
              var n = controls.axisSetters[o];
              if (n && (!geofs.autopilot.on || n.overridesAutopilot) && (!flight.sharing.on || multiplayer.flightSharing.control || !n.overridesPeer) && !flight.recorder.playing) {
                  var s = controls.joystick.getAxisValue(t, n.min, n.max);
                  if (controls.joystick.calibrating) {
                      a.range.max = Math.max(a.range.max, s),
                      a.range.min = Math.min(a.range.min, s);
                      let c = a.range.max - a.range.min, d;
                      r = {
                          center: a.range.min + c / 2,
                          multiplier: 2 / c
                      },
                      geofs.preferences.joystick.calibration[t] = r
                  }
                  s = (s - r.center) * r.multiplier,
                  geofs.preferences.joystick.multiplier[t] && (s *= -1),
                  n.process && n.process(s, e)
              }
          }
      }
      if (controls.joystick.buttons)
          for (var t in controls.joystick.buttons) {
              var u, p = controls.joystick.buttons[t];
              if (p && "none" != geofs.preferences.joystick.buttons[t]) {
                  var h = p.oldValue
                    , m = controls.joystick.checkButton(t);
                  if (m != h) {
                      try {
                          if (m)
                              var u = controls.joystick.buttonHandlers.buttondown[t];
                          else
                              var u = controls.joystick.buttonHandlers.buttonup[t]
                      } catch (f) {}
                      if (u)
                          for (var g = 0; g < u.length; g++)
                              u[g](e);
                      p.oldValue = m
                  }
              }
          }
  }
}
,
controls.joystick.addButtonListener = function(e, t, a) {
  controls.joystick.buttonHandlers[t] = controls.joystick.buttonHandlers[t] || [],
  controls.joystick.buttonHandlers[t][e] = controls.joystick.buttonHandlers[e] || [],
  controls.joystick.buttonHandlers[t][e].push(a)
}
,
controls.applyManipulator = function(e) {
  e.setter && controls.setters[e.setter].set && controls.setters[e.setter].set()
}
,
controls.updateManipulator = function(e, t) {
  if ("function" == typeof e)
      try {
          e(t.ix, t.iy, t.dx, t.dy)
      } catch (a) {
          geofs.debug.error(a)
      }
  else {
      if (void 0 === controls[e.control] || void 0 === t[e.input])
          return;
      let o = controls[e.control] + t[e.input] * (e.ratio || 1);
      e.min && o < e.min && (o = e.min),
      e.max && o > e.max && (o = e.max),
      controls[e.control] = o
  }
}
,
controls.releaseManipulator = function(e) {
  e.setter && controls.setters[e.setter].unset && controls.setters[e.setter].unset()
}
,
controls.manipulators = {
  setThrottle(e, t, a, o) {
      controls.throttle = o
  }
},
controls.orientation.init = function() {
  controls.orientation.eventListenerSet || (controls.orientation.centers = null,
  $(".geofs-orientationCalibrate").show(),
  geofs.api.hasOrientation() ? (controls.orientation.available = !0,
  window.addEventListener("deviceorientation", function(e) {
      controls.orientation.available = !0,
      controls.orientation.values = [e.gamma, e.beta, e.alpha],
      controls.orientation.centers || (controls.orientation.centers = V3.dup(controls.orientation.values),
      controls.orientation.fixPitch(controls.orientation.centers))
  }),
  window.addEventListener("orientationchange", e => {
      controls.orientation.setScreenOrientation()
  }
  ),
  controls.orientation.setScreenOrientation(),
  controls.orientation.eventListenerSet = !0) : controls.orientation.available = !1)
}
,
controls.orientation.setScreenOrientation = function() {
  controls.orientation.generalMultiplier = 1,
  window.orientation < 0 && (controls.orientation.generalMultiplier = -1)
}
,
controls.orientation.requestIOSPermission = function() {
  "function" == typeof DeviceMotionEvent.requestPermission && DeviceMotionEvent.requestPermission().then(e => {
      controls.orientation.setScreenOrientation()
  }
  ).catch(console.error),
  controls.orientation.iOSpermissionRequested = !0
}
,
controls.orientation.fixPitch = function(e) {
  e && Math.abs(e[1]) > 90 && (e[0] < 0 && (e[0] = e[0] + 180),
  e[0] > 0 && (e[0] = e[0] - 180))
}
,
controls.orientation.recenter = function() {
  controls.orientation.centers = null,
  $(".geofs-orientationCalibrate").hide()
}
,
controls.orientation.isAvailable = function() {
  return controls.orientation.available
}
,
controls.orientation.getNormalizedAxis = function(e) {
  if (controls.orientation.values) {
      if (0 == e) {
          controls.orientation.fixPitch(controls.orientation.values);
          var t = controls.orientation.values[0] - controls.orientation.centers[0];
          return geofs.debug.watch("beta", controls.orientation.values[0]),
          geofs.debug.watch("centeredPitch", t),
          -(t / 30)
      }
      if (1 == e) {
          var a = controls.orientation.values[1];
          return a > 90 && (a = 180 - a),
          a < -90 && (a = -180 - a),
          geofs.debug.watch("gamma", controls.orientation.values[1]),
          a / 30
      }
  }
}
,
controls.orientation.getHtr = function() {
  return [controls.orientation.values[2], controls.orientation.values[1] + 270, controls.orientation.values[0]]
}
,
controls.updateOrientation = function(e) {
  if (controls.orientation.centers) {
      var t = controls.orientation.getNormalizedAxis(geofs.preferences.orientation.axis.pitch)
        , a = controls.orientation.getNormalizedAxis(geofs.preferences.orientation.axis.roll);
      controls.rawPitch = t * controls.orientation.generalMultiplier,
      controls.roll = a * controls.orientation.generalMultiplier,
      controls.yaw = controls.orientation.yaw,
      controls.keyboard.overrideRudder = !1
  }
}
,
controls.updateTouch = function(e) {
  controls.rawPitch = controls.touch.pitch,
  controls.roll = controls.touch.roll,
  controls.yaw = controls.touch.yaw
}
,
controls.copilot = {
  init() {
      if (!geofs.preferences.copilot.enabled) {
          controls.copilot.destroy();
          return
      }
      controls.copilot.initialized || (controls.copilot.initialized = !0,
      $(document).on("textSpoken", controls.copilot.speechCallback),
      geofs.speech.init(),
      geofs.populateCopilotVoices(),
      controls.copilot.lastReading = geofs.utils.now())
  },
  update(e) {
      if (geofs.preferences.copilot.readingFrequency > 0) {
          let t = geofs.utils.now();
          if (t - controls.copilot.lastReading > 6e4 / geofs.preferences.copilot.readingFrequency) {
              let a = ""
                , o = Math.round(geofs.animation.values.heading360 / 10);
              if (o != controls.copilot.spokenHeading && (controls.copilot.spokenHeading = o,
              a += "heading " + 10 * controls.copilot.spokenHeading + ", "),
              geofs.animation.values.haglFeet >= 110) {
                  let r = 100 * Math.round(geofs.animation.values.altitude / 100);
                  r != controls.copilot.spokenAltitude && (controls.copilot.spokenAltitude = r,
                  a += controls.copilot.spokenAltitude + " feet, ")
              }
              if (geofs.animation.values.haglFeet < 100 && geofs.animation.values.verticalSpeed < 0) {
                  let n = 10 * Math.round(geofs.animation.values.haglFeet / 10);
                  n != controls.copilot.spokenAltitude && (controls.copilot.spokenAltitude = n,
                  a += "ground " + controls.copilot.spokenAltitude + ", ")
              }
              let s = 20 * Math.round(geofs.animation.values.kias / 20);
              s > 0 && s != controls.copilot.spokenIAS && (controls.copilot.spokenIAS = s,
              a += controls.copilot.spokenIAS + " knots"),
              controls.copilot.speak(a),
              controls.copilot.lastReading = t
          }
      }
  },
  speechCallback() {
      geofs.speech.wordsSpoken.length > 0 && controls.copilot.command()
  },
  speak(e) {
      let t = {
          voice: geofs.preferences.copilot.voice,
          volume: geofs.preferences.copilot.volume
      };
      geofs.speech.speak(e, t)
  },
  command() {
      if (!geofs.preferences.copilot.enabled)
          return;
      let e = geofs.speech.commandSpoken
        , t = geofs.speech.valueSpoken;
      if (geofs.preferences.copilot.voice,
      geofs.preferences.copilot.volume,
      "autopilot" == e || "pilot" == e || "ap" == e) {
          "on" == t && (geofs.autopilot.turnOn(),
          controls.copilot.speak("autopilot on")),
          "off" == t && (geofs.autopilot.turnOff(),
          controls.copilot.speak("autopilot off"));
          return
      }
      if ("flaps" == e) {
          "down" == t && (controls.setters.setFlapsDown.set(),
          controls.copilot.speak("flaps " + (controls.flaps.positionTarget || controls.flaps.target || 0))),
          "up" == t && (controls.setters.setFlapsUp.set(),
          controls.copilot.speak("flaps " + (controls.flaps.positionTarget || controls.flaps.target || 0)));
          let a = parseInt(geofs.utils.wordToDigit(t));
          isNaN(a) || (controls.flaps.target = a,
          controls.setters.setFlaps.set(),
          controls.copilot.speak("flaps " + a));
          return
      }
      if ("gear" == e) {
          "down" == t && (controls.setters.setGearDown.set(),
          controls.copilot.speak("gear down")),
          "up" == t && (controls.setters.setGearUp.set(),
          controls.copilot.speak("gear up"));
          return
      }
      if ("spoilers" == e || "airbrakes" == e) {
          ("retract" == t || "down" == t) && (controls.setters.setAirbrakesDown.set(),
          controls.copilot.speak(e + " retracted")),
          ("full" == t || "extend" == t) && (controls.setters.setAirbrakesUp.set(),
          controls.copilot.speak(e + " full"));
          return
      }
      if ("thanks" == e || "thank" == e && "you" == t) {
          controls.copilot.speak("you're welcome");
          return
      }
      if (geofs.autopilot.on) {
          let o = parseInt((t + "").replace(/,/g, ""));
          if ("speed" == e) {
              if (isNaN(o)) {
                  controls.copilot.noComprendo();
                  return
              }
              geofs.autopilot.setSpeed(o),
              controls.copilot.speak(e + " " + t)
          }
          if ("heading" == e) {
              if (isNaN(o)) {
                  controls.copilot.noComprendo();
                  return
              }
              geofs.autopilot.setCourse(o),
              controls.copilot.speak(e + " " + t)
          }
          if ("flight" == e && "level" == geofs.speech.wordsSpoken[1] && (e = "altitude",
          t = "fl"),
          "altitude" == e) {
              let r = e + " " + t;
              if ("fl" == t && (o = 100 * parseInt(geofs.speech.wordsSpoken[2]),
              r = "flight level  " + geofs.speech.wordsSpoken[2]),
              isNaN(o)) {
                  controls.copilot.noComprendo();
                  return
              }
              geofs.autopilot.setAltitude(o),
              controls.copilot.speak(r)
          }
      }
  },
  noComprendo() {
      controls.copilot.speak(["say again", "come again", "repeat please", "I did not get that"][Math.floor(4 * Math.random())])
  },
  destroy() {
      controls.copilot.initialized && ($(document).off("textSpoken", controls.copilot.speechCallback),
      controls.copilot.initialized = !1,
      geofs.speech.destroy())
  }
},
geofs.autopilot = {
  on: !1,
  mode: "HDG",
  speedMode: "knots",
  PIDs: {},
  values: {
      course: 0,
      altitude: 0,
      speed: 0,
      verticalSpeed: 0
  },
  defaults: {
      maxBankAngle: 30,
      maxPitchAngle: 20,
      minPitchAngle: -20,
      baseClimbrate: 700,
      baseDescentrate: -1e3,
      maxClimbrate: 6e3,
      maxDescentrate: -6e3,
      ILSDescentrate: -2e3,
      ILSClimbrate: 0,
      verticalSpeedHoldMargin: 1e3,
      targetBankAngleRatio: 2,
      yawBankAngleRatio: .005,
      pitchAnglePID: [.01, .002, .01],
      elevatorPitchPID: [.01, .001, 1e-7],
      bankAnglePID: [.15, .001, .01],
      aileronsRollPID: [.1, .001, 1e-7],
      throttlePID: [.1, .001, .1],
      effectivenessRatioMaximum: 1.5
  },
  init: function() {
      var e = Object.assign({}, geofs.autopilot.defaults, geofs.aircraft.instance.definition.autopilot);
      geofs.autopilot.PIDs.pitchAngle = new PID(e.pitchAnglePID[0],e.pitchAnglePID[1],e.pitchAnglePID[2]),
      geofs.autopilot.PIDs.elevatorPitch = new PID(e.elevatorPitchPID[0],e.elevatorPitchPID[1],e.elevatorPitchPID[2]),
      geofs.autopilot.PIDs.bankAngle = new PID(e.bankAnglePID[0],e.bankAnglePID[1],e.bankAnglePID[2]),
      geofs.autopilot.PIDs.aileronsRoll = new PID(e.aileronsRollPID[0],e.aileronsRollPID[1],e.aileronsRollPID[2]),
      geofs.autopilot.PIDs.throttle = new PID(e.throttlePID[0],e.throttlePID[1],e.throttlePID[2]),
      geofs.autopilot.definition = e,
      $("#Qantas94Heavy-ap-nav").length > 0 && (geofs.autopilot = controls.autopilot,
      geofs.autopilot.UI = {
          update() {}
      },
      geofs.autopilot.values = {
          course: 0,
          altitude: 0,
          speed: 0,
          verticalSpeed: 0
      })
  },
  setMode: function(e) {
      if (geofs.autopilot.on) {
          if (e = e || geofs.autopilot.mode,
          geofs.autopilot.VNAV = !1,
          geofs.autopilot.currentNAVUnit && (geofs.autopilot.currentNAVUnit = null),
          "HDG" != e) {
              if (!geofs.nav.currentNAVUnit) {
                  this.setMode("HDG");
                  return
              }
              geofs.autopilot.currentNAVUnit = geofs.nav.currentNAVUnit,
              geofs.autopilot.VNAV = geofs.autopilot.currentNAVUnit.VNAV
          }
          geofs.autopilot.mode = e
      }
  },
  setCourse: function(e, t) {
      var a = geofs.autopilot.values.course;
      try {
          geofs.autopilot.values.course = fixAngle360(e),
          geofs.nav.setHDG(geofs.autopilot.values.course),
          "NAV" != geofs.autopilot.mode || t || geofs.autopilot.setMode("NOR")
      } catch (o) {
          geofs.autopilot.values.course = a
      }
  },
  setAltitude: function(e, t) {
      var a = geofs.autopilot.values.altitude;
      try {
          geofs.autopilot.values.altitude = e
      } catch (o) {
          geofs.autopilot.values.altitude = a
      }
  },
  setSpeed: function(e, t) {
      var a = geofs.autopilot.values.speed;
      try {
          geofs.autopilot.values.speed = e
      } catch (o) {
          geofs.autopilot.values.speed = a
      }
  },
  setSpeedMode: function(e) {
      e != geofs.autopilot.speedMode && ("mach" == e ? (geofs.autopilot.values.speed = Number(geofs.utils.knotsToMach(geofs.autopilot.values.speed).toFixed(2)),
      $(".geofs-autopilot-mach").addClass("numberValue").val(geofs.autopilot.values.speed),
      $(".geofs-autopilot-knots").removeClass("numberValue"),
      $(".geofs-speed-mode .switchLeft").removeClass("green-pad"),
      $(".geofs-speed-mode .switchRight").addClass("green-pad")) : (geofs.autopilot.values.speed = parseInt(geofs.utils.machToKnots(geofs.autopilot.values.speed)),
      $(".geofs-autopilot-mach").removeClass("numberValue"),
      $(".geofs-autopilot-knots").addClass("numberValue").val(geofs.autopilot.values.speed),
      $(".geofs-speed-mode .switchLeft").addClass("green-pad"),
      $(".geofs-speed-mode .switchRight").removeClass("green-pad")),
      geofs.autopilot.speedMode = e)
  },
  setVerticalSpeed: function(e) {
      var t = geofs.autopilot.values.verticalSpeed;
      if (!e) {
          geofs.autopilot.values.verticalSpeed = null;
          return
      }
      geofs.autopilot.values.verticalSpeed || (e = geofs.autopilot.targetVerticalSpeed || 0);
      try {
          geofs.autopilot.values.verticalSpeed = parseInt(clamp(e, geofs.autopilot.definition.maxDescentrate, geofs.autopilot.definition.maxClimbrate))
      } catch (a) {
          geofs.autopilot.values.verticalSpeed = t
      }
  },
  update: function(e) {
      if (!geofs.autopilot.on)
          return;
      var t = geofs.animation.values
        , a = geofs.autopilot
        , o = a.definition
        , r = clamp(t.kias / 150, 1, 5)
        , n = clamp(t.kias / 100, 1, o.effectivenessRatioMaximum);
      let s = geofs.autopilot.currentNAVUnit;
      if (s && s.inRange && s.LNAV) {
          if ("NAV" == a.mode) {
              let c = clamp(10 * s.courseDeviation, -45, 45)
                , d = fixAngle360(s.course + c);
              a.setCourse(d, !0)
          } else
              "NOR" == a.mode && 4.5 > Math.abs(s.courseDeviation) && (a.setMode("NAV"),
              a.setCourse(s.course, !0));
          if (geofs.autopilot.VNAV) {
              let u = "to" == s.direction ? -1 : 1
                , p = s.distance / geofs.aircraft.instance.groundSpeed / 60
                , h = s.height / p * METERS_TO_FEET * u;
              h += s.glideAngleDeviation * geofs.aircraft.instance.groundSpeed * 10,
              a.setVerticalSpeed(h)
          }
      }
      let m = fixAngle(fixAngle360(t.heading) - a.values.course);
      var f = clamp(m * o.targetBankAngleRatio, -o.maxBankAngle, o.maxBankAngle);
      a.PIDs.bankAngle.set(f, -o.maxBankAngle, o.maxBankAngle);
      var g = a.PIDs.bankAngle.compute(t.aroll, e);
      if (a.PIDs.aileronsRoll.set(g, -1, 1),
      controls.roll = -a.PIDs.aileronsRoll.compute(controls.roll, e) / n,
      controls.yaw = -f * o.yawBankAngleRatio,
      !geofs.autopilot.VNAV) {
          var y = a.values.altitude - t.altitude
            , v = clamp(r * o.baseClimbrate, 0, o.maxClimbrate)
            , _ = clamp(r * o.baseDescentrate, o.maxDescentrate, 0);
          a.targetVerticalSpeed = clamp(2 * y * r, _, v)
      }
      a.values.verticalSpeed && (!geofs.autopilot.VNAV && Math.abs(y) < o.verticalSpeedHoldMargin && Math.abs(a.targetVerticalSpeed) < Math.abs(a.values.verticalSpeed) ? a.setVerticalSpeed(null) : a.targetVerticalSpeed = a.values.verticalSpeed),
      a.PIDs.pitchAngle.set(a.targetVerticalSpeed, o.minPitchAngle, o.maxPitchAngle);
      var b = a.PIDs.pitchAngle.compute(t.verticalSpeed, e);
      a.PIDs.elevatorPitch.set(b, -1, 1),
      controls.rawPitch = a.PIDs.elevatorPitch.compute(-t.atilt, e) / n;
      let x = a.values.speed
        , S = t.kias;
      "mach" == geofs.autopilot.speedMode && (x = geofs.utils.machToKnots(a.values.speed),
      S = geofs.utils.machToKnots(t.mach)),
      a.PIDs.throttle.set(x, 0, 1),
      controls.throttle = a.PIDs.throttle.compute(S, e),
      controls.throttle = clamp(controls.throttle, 0, 1)
  },
  toggle: function() {
      geofs.autopilot.on ? geofs.autopilot.turnOff() : geofs.autopilot.turnOn()
  },
  resetPIDs: function() {
      for (var e in geofs.autopilot.PIDs)
          geofs.autopilot.PIDs[e].reset()
  },
  turnOn: function() {
      if (geofs.aircraft.instance.definition.autopilot) {
          var e = geofs.animation.values;
          geofs.autopilot.resetPIDs(),
          geofs.autopilot.setAltitude(e.altitude),
          geofs.autopilot.setCourse(e.heading),
          geofs.autopilot.setSpeed(e.kias),
          geofs.autopilot.setVerticalSpeed(e.verticalSpeed);
          var t = clamp(e.kias / 100, 1, geofs.autopilot.definition.effectivenessRatioMaximum);
          geofs.autopilot.PIDs.pitchAngle.initialize(-e.atilt, e.verticalSpeed),
          geofs.autopilot.PIDs.elevatorPitch.initialize(controls.rawPitch * t, -e.atilt),
          geofs.autopilot.PIDs.throttle.initialize(controls.throttle, e.kias),
          geofs.autopilot.on = !0,
          $(document).trigger("autopilotOn")
      }
  },
  turnOff: function() {
      geofs.autopilot.on = !1,
      $(document).trigger("autopilotOff")
  }
},
geofs.autopilot.UI = {
  values: {
      course: 0,
      altitude: 0,
      speed: 0,
      verticalSpeed: 0
  },
  init: function() {
      this.$autopilotPad = $(".geofs-autopilot-pad"),
      this.$autopilotHDGButton = $(".geofs-autopilot-HDG"),
      this.$autopilotNavButton = $(".geofs-autopilot-NAV"),
      this.$displays = {},
      this.$displays.course = $(".geofs-autopilot-course"),
      this.$displays.altitude = $(".geofs-autopilot-altitude"),
      this.$displays.speed = $(".geofs-autopilot-speed"),
      this.$displays.verticalSpeed = $(".geofs-autopilot-verticalSpeed"),
      $(document).on("autopilotOn", () => {
          clearTimeout(geofs.autopilot.autopilotPadTimeout),
          this.$autopilotPad.removeClass("red-pad").addClass("green-pad"),
          this.update(),
          this.$displays.course.trigger("change"),
          this.$displays.altitude.trigger("change"),
          this.$displays.speed.trigger("change"),
          this.$displays.verticalSpeed.trigger("change"),
          $(".geofs-autopilot-controls").show(),
          $(".geofs-autopilot-toggle").html("Engaged").addClass("mdl-button--colored")
      }
      ),
      $(document).on("autopilotOff", () => {
          this.$autopilotPad.removeClass("green-pad").addClass("red-pad"),
          $(".geofs-autopilot-controls").hide(),
          $(".geofs-autopilot-toggle").html("Disengaged").removeClass("mdl-button--colored"),
          clearTimeout(geofs.autopilot.autopilotPadTimeout),
          geofs.autopilot.autopilotPadTimeout = setTimeout( () => {
              this.$autopilotPad.removeClass("red-pad").removeClass("green-pad")
          }
          , 3e3)
      }
      ),
      $(document).on("pointerdown keydown change update wheel", ".numberUp, .numberDown, .numberValue", e => {
          var t = $(e.currentTarget)
            , a = $(e.currentTarget).parent().find(".numberValue")
            , o = Number(a.attr("smallstep"))
            , r = Number(a.attr("stepthreshold"))
            , n = Number(a.attr("step"))
            , s = Number(a.attr("min"))
            , c = Number(a.attr("max"))
            , d = Number(a.attr("decimals")) || 0
            , u = Math.pow(10, d)
            , p = 0
            , h = 0;
          (t.hasClass("numberUp") || 38 == e.which) && (p = 1),
          (t.hasClass("numberDown") || 40 == e.which) && (p = -1),
          "wheel" == e.type && (p = e.originalEvent.deltaY > 0 ? -1 : 1);
          var m = a.val();
          o && (p > 0 && m < r && (n = o),
          p < 0 && m <= r && (n = o)),
          h = n * p,
          h *= u;
          var f = a.attr("data-loop")
            , g = a.attr("data-method")
            , y = () => {
              var t = a.val();
              if (t *= u,
              t = parseInt(Math.round(t)) || 0,
              h) {
                  var o = t % h;
                  o > 0 ? h > 0 ? t += h - o : t -= o : t += h
              }
              t = Number((t / u).toFixed(d)),
              t = f && t > c ? s : f && t < s ? c : clamp(t, s, c),
              a.val(t),
              "update" != e.type && (geofs.autopilot[g](t),
              clearTimeout(window.spinnerRepeat))
          }
            , v = () => {
              y(),
              clearTimeout(window.spinnerRepeat),
              window.spinnerRepeat = setTimeout(v, 50)
          }
          ;
          h && (y(),
          "wheel" != e.type && (window.spinnerRepeat = setTimeout(v, 500))),
          ("change" == e.type || "update" == e.type) && y(),
          e.stopImmediatePropagation()
      }
      ).on("pointerup pointercancel mouseleave touchend", ".numberUp, .numberDown", () => {
          clearTimeout(window.spinnerRepeat)
      }
      ).on("pointerup", ".switchLeft, .switchMiddle, .switchRight", e => {
          let t = $(e.currentTarget)
            , a = t.attr("value")
            , o = t.attr("data-method");
          geofs.autopilot[o](a)
      }
      ).on("click", ".geofs-autopilot-pad", e => {
          geofs.autopilot.toggle()
      }
      ).on("keyup", ".numberValue", e => {
          clearTimeout(window.spinnerRepeat),
          e.stopImmediatePropagation()
      }
      )
  },
  update: function() {
      var e = geofs.autopilot;
      for (var t in this.values) {
          let a;
          a = null == e.values[t] ? "-----" : Number(e.values[t]),
          this.values[t] != a && (this.$displays[t].val(a).trigger("update"),
          this.values[t] = a)
      }
      let o = geofs.autopilot.currentNAVUnit;
      if (o && (o.inRange != this.inRange || o != this.navUnit) || e.mode != this.mode) {
          if ("HDG" == e.mode && (this.$autopilotHDGButton.addClass("green-pad"),
          this.$autopilotNavButton.removeClass("orange-pad").removeClass("green-pad")),
          "NOR" == e.mode && this.$autopilotHDGButton.addClass("green-pad"),
          "NAV" == e.mode && this.$autopilotHDGButton.removeClass("green-pad"),
          "NAV" == e.mode || "NOR" == e.mode) {
              if (!o.LNAVCapable) {
                  e.setMode("HDG");
                  return
              }
              o.inRange ? this.$autopilotNavButton.removeClass("orange-pad").addClass("green-pad") : this.$autopilotNavButton.removeClass("green-pad").addClass("orange-pad")
          }
          o ? (this.inRange = o.inRange,
          this.navUnit = o) : (this.inRange = !1,
          this.navUnit = null),
          this.mode = e.mode
      }
  }
},
(ui = ui || {}).hud = {},
ui.hud.autopilotIndicator = function() {}
,
geofs.map = {
  dontMoveTimeoutValue: 1e4,
  mapUpdateInterval: 10,
  minimumPanRatio: .4,
  cloudLayerUpdatePeriod: 18e5,
  init: function(e, t, a) {
      t = t || 0,
      a = a || 0,
      e = e || {},
      this._options = e,
      geofs.api.map.init(e, t, a),
      this.navaidsLayer = geofs.api.map.addLayer("navaids"),
      e.standalone || (this.planeMarker = new geofs.api.map.marker({
          zIndex: 1e3,
          icon: geofs.api.map.getIcon("yellow", geofs.map.icons.yellow)
      }),
      this.planeMarker.addToMap(),
      geofs.setInputHandlers(".geofs-map-list"),
      geofs.setPreferenceValues(".geofs-map-list")),
      this.setMouseClickBehavior(),
      e.standalone && (this.mapActive = !0),
      geofs.api.map.updateMarkerLayers(),
      this.ATCMode = !1,
      $(document).on("click", ".geofs-map-atc-button", e => {
          this.toggleATCMode(),
          e.preventDefault(),
          e.stopPropagation()
      }
      )
  },
  runwayMarkerRadius: 7,
  runwayMarkerPopup: function(e) {
      let t = e.options.runway
        , a = t.lat + "," + t.lon
        , o = t.name.split("|");
      var r = t;
      if ("ILS" == t.type)
          var n = geofs.nav.isNavaidInRange(r)
            , s = r.freq / 1e3 + "MHz";
      return '<div class="geofs-map-popup"><header><span class="mdl-chip"><span class="geofs-map-runway-chipIcon mdl-chip__contact mdl-color-text--white">' + o[0] + '</span><span class="mdl-chip__text">' + o[1] + " (" + o[2] + ')</span></span></header><button class="mdl-button mdl-js-button mdl-button--fab mdl-button--colored mdl-button--mini-fab" href="http://flyto://' + a + ",0," + t.heading + '" title="Take-off from"><i class="material-icons">flight_takeoff</i></button><button class="mdl-button mdl-js-button mdl-button--fab mdl-button--colored mdl-button--mini-fab" href="http://flyto://' + a + ",1000," + t.heading + '" title="Fly by"><i class="material-icons">flight</i></button><button class="mdl-button mdl-js-button mdl-button--fab mdl-button--colored mdl-button--mini-fab" href="http://flyto://' + a + ",0," + t.heading + ',approach,4800,450" title="Approach"><i class="material-icons">flight_land</i></button><button class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab geofs-addToFlightPlan" title="Set Flight Plan Departure" onclick="geofs.flightPlan.setDeparture(' + r.id + ');geofs.api.map.closeAllPopups();"><i class="material-icons">flight_takeoff</i></button><button class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab geofs-addToFlightPlan" title="Set Flight Plan Arrival" onclick="geofs.flightPlan.setDestination(' + r.id + ');geofs.api.map.closeAllPopups();"><i class="material-icons">flight_land</i></button>' + ("ILS" == t.type ? '<span class="mdl-chip" title="Tune in ILS" onclick="geofs.nav.selectNavaid(' + r.id + '); geofs.api.map.closeAllPopups();" style="cursor: pointer;" ><span class="geofs-map-radio-chipIcon mdl-chip__contact mdl-color-text--white"><i class="material-icons">sensors</i></span><span class="mdl-chip__text">' + s + (n ? "" : " (Out of range)") + "</span></span>" : "") + "</div>"
  },
  navaidMarkerPopup: function(e) {
      let t = e.options.navaid, a = t.lat + "," + t.lon, o = geofs.nav.isNavaidInRange(t), r;
      return t.freq >= 1e3 && (r = t.freq / 1e3 + "MHz"),
      t.freq < 1e3 && (r = t.freq + "KHz"),
      "GPS" == t.freq && (r = "GPS"),
      '<div class="geofs-map-popup"><header><span class="mdl-chip"><span class="mdl-chip__text"><b>' + t.type + '</b> <span class="geofs-navaidName">' + t.name + " (" + t.icao + ")</span> " + (t.ident ? '<code class="geofs-morse"><span>' + t.ident + "</span>" + geofs.utils.textToMorse(t.ident) + "</code>" : "") + ("FIX" == t.type ? '<i class="material-icons" title="Remove FIX" onclick="geofs.nav.removeNavaid(' + t.id + '); geofs.api.map.closeAllPopups();">delete</i>' : "") + '</span></span></header><button class="mdl-button mdl-js-button mdl-button--fab mdl-button--colored mdl-button--mini-fab" href="http://flyto://' + a + ',1000,0" title="Fly by"><i class="material-icons">flight</i></button><button class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab geofs-addToFlightPlan" title="Add to Flight Plan" onclick="geofs.flightPlan.addNavaidAsWaypoint(' + t.id + ');geofs.api.map.closeAllPopups();"><i class="material-symbols-outlined"">list_alt_add</i></button><span type="button" class="mdl-chip" title="Tune in NAV" onclick="geofs.nav.selectNavaid(' + t.id + ');geofs.api.map.closeAllPopups();" style="cursor: pointer;" ><span class="geofs-map-radio-chipIcon mdl-chip__contact mdl-color-text--white"><i class="material-icons">sensors</i></span><span class="mdl-chip__text">' + r + "</span></span>" + (o ? "" : '<span class="mdl-chip geofs-outofrange"><span class="mdl-chip__text">Out of range</span></span>') + "</div>"
  },
  icons: {
      ILS: {
          url: "images/map/icons/ils.png?v=1",
          size: [30, 30],
          anchor: [0, 0],
          offset: [0, 15],
          minZoom: 8
      },
      DME: {
          url: "images/map/icons/dme.png",
          size: [20, 20],
          anchor: [10, 10],
          minZoom: 5
      },
      NDB: {
          url: "images/map/icons/ndb.png",
          size: [40, 40],
          anchor: [20, 20],
          minZoom: 7
      },
      "NDB-DME": {
          url: "images/map/icons/ndb-dme.png",
          size: [40, 40],
          anchor: [20, 20],
          minZoom: 7
      },
      TACAN: {
          url: "images/map/icons/tacan.png",
          size: [20, 20],
          anchor: [10, 10],
          minZoom: 6
      },
      VOR: {
          url: "images/map/icons/vor.png",
          size: [20, 20],
          anchor: [10, 10],
          minZoom: 6
      },
      "VOR-DME": {
          url: "images/map/icons/vor-dme.png",
          size: [20, 20],
          anchor: [10, 10],
          minZoom: 6
      },
      VORTAC: {
          url: "images/map/icons/vortac.png",
          size: [20, 20],
          anchor: [10, 10],
          minZoom: 6
      },
      FIX: {
          url: "images/map/icons/fixflyby.png",
          size: [30, 30],
          anchor: [15, 15],
          minZoom: 1
      },
      WPT: {
          url: "images/map/icons/wptflyby.png",
          size: [40, 40],
          anchor: [20, 20],
          minZoom: 1
      },
      yellow: {
          url: geofs.localUrl + "images/map/icons/yellow.png",
          size: [40, 40],
          anchor: [20, 20],
          className: "geofs-myself-icon"
      },
      blue: {
          url: geofs.localUrl + "images/map/icons/blue.png",
          size: [30, 30],
          anchor: [15, 15],
          className: "geofs-map-icon"
      },
      traffic: {
          url: geofs.localUrl + "images/map/icons/blue.png",
          size: [20, 20],
          anchor: [10, 10],
          className: "geofs-traffic-icon"
      }
  },
  resize: function() {
      geofs.api.map._map.invalidateSize()
  },
  addRunwayMarker: function(e) {
      var t = {
          coords: [e.lat, e.lon],
          radius: geofs.map.runwayMarkerRadius,
          color: "#ffffff",
          zIndex: 1e3,
          fillColor: e.major ? "#184888" : "#ffd200",
          popup: geofs.map.runwayMarkerPopup,
          pane: "overlayPane",
          popupMinWidth: 200,
          closeButton: !1,
          keepToFront: !0,
          runway: e
      };
      geofs.api.map.addLayeredMarker(e.major ? "major" : "minor", t)
  },
  addNavaidMarker: function(e) {
      let t = this.icons[e.type];
      if (!t)
          return;
      let a = {
          url: t.url,
          size: t.size,
          rotate: e.heading || 0
      };
      t.offset && (a.offset = t.offset);
      var o = {
          coords: [e.lat, e.lon],
          opacity: t.opacity,
          radius: t.size[0] / 2,
          zIndex: 1,
          img: a,
          popupMinWidth: 200,
          closeButton: !1,
          pane: "overlayPane",
          navaid: e,
          minZoom: t.minZoom
      };
      "ILS" != e.type && (o.popup = geofs.map.navaidMarkerPopup);
      let r = new geofs.api.map.marker(o);
      return r.addToMap(),
      r
  },
  getLocationPopupContent: function(e) {
      let t = e[0] + "," + e[1];
      return '<div class="geofs-map-popup" style="width: 150px;"><button class="mdl-button mdl-js-button" href="http://flyto://' + t + ', 0, 0, true">Ground</button><button class="mdl-button mdl-js-button" href="http://flyto://' + t + ', 457, 0, true">1,000 feet</button><button class="mdl-button mdl-js-button" href="http://flyto://' + t + ', 1524, 0, true">5,000 feet</button><button class="mdl-button mdl-js-button" href="http://flyto://' + t + ', 3048, 0, true">10,000 feet</button><button class="mdl-button mdl-js-button" href="http://flyto://' + t + ', 10668, 0, true">35,000 Feet</button><span type="button" class="mdl-chip" title="Add GPS FIX" onclick="let navaid = geofs.nav.addGPSFIX([' + t + ']);geofs.api.map.closeAllPopups();" style="cursor: pointer;" ><span class="geofs-map-radio-chipIcon geofs-map-radio-chipIcon-FIX mdl-chip__contact mdl-color-text--white"><i class="material-icons">change_history</i></span><span class="mdl-chip__text">GPS FIX</span></span></div>'
  },
  mapClickHandler: function(e) {
      var t = $(e.target).closest("[href]").attr("href");
      if (t && "flyto" == (t = t.split("://"))[1]) {
          var a = t[2].split(",")
            , o = parseFloat(a[3])
            , r = [parseFloat(a[0]), parseFloat(a[1]), parseFloat(a[2]), o];
          if ("approach" == a[4]) {
              var n = DEGREES_TO_RAD * o
                , s = xy2ll(V2.scale([Math.sin(n), Math.cos(n)], parseFloat(a[5])), r);
              r[0] = r[0] - s[0],
              r[1] = r[1] - s[1],
              r[2] = r[2] * FEET_TO_METERS + parseFloat(a[6]),
              r[4] = !1
          } else
              r[4] = a[4];
          geofs.flyTo(r),
          geofs.api.map.closeAllPopups(),
          e.preventDefault()
      }
  },
  setMouseClickBehavior: function() {
      geofs.api.map._map.on("contextmenu click", e => {
          if (2 == e.originalEvent.button || "contextmenu" == e.type && geofs.isMobileDevice || "ios" == geofs.platform) {
              if ("ios" == geofs.platform && geofs.api.map.genericPopupIsOpenForIOS)
                  geofs.api.map.genericPopupIsOpenForIOS = !1;
              else {
                  let t = geofs.api.map.getCoordsFromMouseEvent(e);
                  geofs.api.map.openGenericPopup(this.getLocationPopupContent(t), t),
                  geofs.api.map.genericPopupIsOpenForIOS = !0
              }
              e.originalEvent.preventDefault()
          }
      }
      ),
      $(geofs.api.map._holder).click(e => {
          try {
              this.mapClickHandler && (this.mapClickHandler(e),
              this.stopMovingMap())
          } catch (t) {}
      }
      ).on("mousedown touchstart", () => {
          this.stopMovingMap(!0)
      }
      ).on("mouseup touchend", () => {
          this.stopMovingMap()
      }
      )
  },
  stopMap: function() {
      this.mapActive = !1
  },
  startMap: function() {
      this.stopMap(),
      this.resize(),
      geofs.preferences.weather.manual ? this.hideWeather() : this.showWeather(),
      this.mapActive = !0,
      geofs.nav.loadNavaidsAndRunways()
  },
  stopMovingMap: function(e) {
      clearTimeout(this.dontMoveTimeout),
      e || (this.dontMoveTimeout = setTimeout( () => {
          this.dontMove = !1,
          this.updateMap(geofs.aircraft.instance.llaLocation, !0)
      }
      , this.dontMoveTimeoutValue)),
      this.dontMove = !0
  },
  updateMap: function(e, t) {
      let a = e[0]
        , o = e[1];
      var r = geofs.utils.now();
      if ((!(r - this.lastMapUpdate < this.mapUpdateInterval) || t) && (this.lastMapUpdate = r,
      geofs.api.map && this.mapActive)) {
          if (!this.dontMove && geofs.preferences.interface.recenterMap) {
              geofs.api.map.getCenterLla();
              let n = geofs.api.map.getPixelSize()
                , s = {
                  x: n.x / 2,
                  y: n.y / 2
              }
                , c = geofs.api.map.llaToPixel(e)
                , d = [0, 0];
              geofs.flightPlan.isOpen && (d = [0, -$(".geofs-flightPlan")[0].offsetHeight / 3]);
              (Math.max(Math.abs(c.x - s.x + d[0]), Math.abs(c.y - s.y + d[1])) > n.x * this.minimumPanRatio || t) && geofs.api.map.updateMap(a, o, d)
          }
          this.updatePlaneMarker(a, o, geofs.aircraft.instance.htr[0]),
          this.weatherOverlay && geofs.utils.updateTime(this, this.cloudLayerUpdatePeriod) && (this.hideWeather(),
          this.showWeather())
      }
  },
  updatePlaneMarker: function(e, t, a) {
      this.planeMarker.update(e, t, a)
  },
  addPlayerMarker: function(e, t, a) {
      if (!ui.playerMarkers[e]) {
          var o = {
              coords: [0, 0],
              icon: geofs.api.map.getIcon(t, geofs.map.icons[t || "blue"]),
              label: a || "-"
          };
          ui.playerMarkers[e] = new geofs.api.map.marker(o)
      }
      return geofs.api.map._map && this.mapActive && ui.playerMarkers[e].addToMap(),
      ui.playerMarkers[e]
  },
  updatePlayerMarker: function(e, t, a, o, r, n) {
      if (geofs.api.map._map && this.mapActive && (ui.playerMarkers[e] || this.addPlayerMarker(e, o, a),
      ui.playerMarkers[e])) {
          var s = parseInt(t[2] * METERS_TO_FEET)
            , c = fixAngle360(t[3])
            , d = (a || "-") + "<br/>" + ("unknown" != r ? "" + r + "<br/>" : "") + n + "kt " + parseInt(c) + "dg<br/>" + geofs.utils.displayAltitude(s);
          ui.playerMarkers[e].update(t[0], t[1], c, d)
      }
  },
  deletePlayerMarker: function(e) {
      ui.playerMarkers[e] && ui.playerMarkers[e].destroy(),
      ui.playerMarkers[e] = null,
      delete ui.playerMarkers[e]
  },
  toggleATCMode: function() {
      this.ATCMode = !this.ATCMode,
      this.setTooltipVisibility(this.ATCMode),
      $(geofs.api.map._holder).toggleClass("geofs-atc-map")
  },
  setTooltipVisibility: function(e) {
      if (this.tooltipVisibility = e,
      geofs.api.map.setTooltipVisibility(e),
      geofs.api.map._map && this.mapActive)
          for (var t in ui.playerMarkers)
              ui.playerMarkers[t].resetTooltip()
  },
  showWeather: function() {
      this.weatherOverlay || (this.weatherOverlay = geofs.api.map.addImageLayer(weather.realTimeCloudMap + "?t=" + geofs.utils.hourStamp(), 1, [[70, -180], [-70, 180]]),
      this.weatherOverlayZoomHandler = () => {
          this.weatherOverlay.setOpacity(clamp(1.3 - .1 * geofs.api.map._map.getZoom(), 0, 1))
      }
      ,
      geofs.api.map._map.on("zoomend", this.weatherOverlayZoomHandler))
  },
  hideWeather: function() {
      this.weatherOverlay && geofs.api.map.removeImageLayer(this.weatherOverlay),
      this.weatherOverlayZoomHandler && geofs.api.map._map.off("zoomend", this.weatherOverlayZoomHandler),
      this.weatherOverlay = null
  }
},
geofs.nav = {
  navaidsAndRunwaysLoaded: !1,
  fixesLoaded: !1,
  navaids: [],
  navaidsICAOMap: {},
  frequencies: [],
  units: {
      GPS: {},
      NAV1: {},
      ADF: {}
  },
  currentNAVUnit: null,
  HDG: 0,
  ADFManCourse: 0,
  types: {
      RNW: {
          range: 1 / 0,
          GPS: !0,
          DME: !0,
          LNAV: !0,
          VNAV: !1,
          RNAV: !1
      },
      WPT: {
          range: 1 / 0,
          GPS: !0,
          DME: !0,
          LNAV: !0,
          VNAV: !1,
          RNAV: !0
      },
      FIX: {
          range: 1 / 0,
          GPS: !0,
          DME: !0,
          LNAV: !0,
          VNAV: !1,
          RNAV: !0
      },
      DST: {
          range: 1 / 0,
          ILS: !0,
          GPS: !0,
          DME: !0,
          LNAV: !0,
          VNAV: !0,
          RNAV: !1
      },
      ILS: {
          range: 33e3,
          ILS: !0,
          DME: !0,
          LNAV: !0,
          VNAV: !0,
          RNAV: !1
      },
      DME: {
          range: 48e4,
          DME: !0,
          LNAV: !1,
          VNAV: !1,
          RNAV: !1
      },
      NDB: {
          range: 14e4,
          ADF: !0,
          LNAV: !1,
          VNAV: !1,
          RNAV: !1
      },
      "NDB-DME": {
          range: 14e4,
          ADF: !0,
          DME: !0,
          LNAV: !1,
          VNAV: !1,
          RNAV: !1
      },
      VOR: {
          range: 24e4,
          VOR: !0,
          LNAV: !0,
          VNAV: !1,
          RNAV: !1
      },
      "VOR-DME": {
          range: 24e4,
          VOR: !0,
          DME: !0,
          LNAV: !0,
          VNAV: !1,
          RNAV: !1
      },
      TACAN: {
          range: 24e4,
          VOR: !0,
          DME: !0,
          LNAV: !0,
          VNAV: !1,
          RNAV: !1
      },
      VORTAC: {
          range: 24e4,
          VOR: !0,
          DME: !0,
          LNAV: !0,
          VNAV: !1,
          RNAV: !1
      }
  },
  init: function() {
      this.$NAVFrenquency = $(".geofs-nav-frequency"),
      this.$NAVModeButton = $('[name="NAV1MODE"]'),
      this.$GPSModeButton = $('[name="GPSMODE"]')
  },
  loadFixes: function() {
      geofs.nav.FixesLoaded || $.getJSON("data/fixes.json" + geofs.killCache, e => {
          geofs.nav.fixes = e[0],
          geofs.nav.FixesLoaded = !0
      }
      )
  },
  loadNavaidsAndRunways: function() {
      geofs.nav.navaidsAndRunwaysLoaded || ($.getJSON("data/navaids.json" + geofs.killCache, e => {
          e.forEach(e => {
              let t = {
                  icao: e[0],
                  ident: e[1],
                  name: e[2],
                  type: e[3],
                  lat: e[4],
                  lon: e[5],
                  freq: e[6],
                  magDec: e[7],
                  DMEfreq: e[8]
              };
              this.addNavaid(t)
          }
          ),
          geofs.api.map.updateMarkerLayers(),
          geofs.nav.navaidsAndRunwaysLoaded = !0
      }
      ),
      $.getJSON("data/runways.json" + geofs.killCache, e => {
          e.forEach(e => {
              let t = (runway = {
                  name: e[0],
                  heading: e[1],
                  lat: e[2],
                  lon: e[3],
                  major: e[4],
                  freq: e[5],
                  ident: e[6],
                  slope: e[7]
              }).name.split("|");
              runway.icao = t[2],
              runway.ident = t[0],
              runway.type = runway.freq ? "ILS" : "RNW",
              geofs.nav.addNavaid(runway),
              geofs.map.addRunwayMarker(runway)
          }
          ),
          geofs.api.map.updateMarkerLayers()
      }
      ))
  },
  addNavaid: function(e) {
      e.id = this.navaids.length,
      this.navaids.push(e),
      this.navaidsICAOMap[e.icao] = this.navaidsICAOMap[e.icao] || [];
      let t = [e.lat, e.lon];
      return t.navaid = e,
      this.navaidsICAOMap[e.icao].push(t),
      this.frequencies[e.freq] = this.frequencies[e.freq] || [],
      this.frequencies[e.freq].push(e),
      e.marker = geofs.map.addNavaidMarker(e),
      e
  },
  getNavaid: function(e) {
      return this.navaids[e]
  },
  removeNavaid: function(e) {
      let t = this.navaids[e];
      t && (t.assignedToUnit && this.clear(t.assignedToUnit),
      t.marker && t.marker.destroy(),
      this.navaids[e] = null,
      delete this.navaidsICAOMap[t.icao])
  },
  addWaypoint: function(e, t, a) {
      return this.addNavaid({
          icao: t || "WPT",
          ident: "",
          name: t || "WPT",
          type: a || "WPT",
          lat: e[0],
          lon: e[1],
          freq: "GPS",
          magDec: 0,
          DMEfreq: null
      })
  },
  addGPSFIX: function(e, t) {
      return this.addNavaid(geofs.nav.generateGPSFIXNavaid(e, t))
  },
  generateGPSFIXNavaid: function(e, t, a, o) {
      let r = e[0].toFixed(3) + " " + e[1].toFixed(3);
      return {
          icao: t || "FIX",
          ident: o || "",
          name: a || "GPS: " + r,
          type: "FIX",
          lat: e[0],
          lon: e[1],
          freq: "GPS",
          magDec: 0,
          DMEfreq: null
      }
  },
  selectNavaid: function(e, t) {
      var a = geofs.nav.navaids[e];
      if (!a)
          return;
      let o = geofs.nav.types[a.type];
      o.GPS ? (geofs.nav.setNavaid(a, "GPS"),
      geofs.nav.setNAVMode("GPS", "GPS", t)) : o.ADF ? geofs.radio.tuneADFFrequency(a.freq) : (geofs.radio.tuneNAVFrequency(a.freq, null, "NAV1"),
      o.LNAV && geofs.nav.setNAVMode("NAV", "NAV1", t)),
      geofs.radio.scanFrequenciesAround(),
      geofs.radio.show(),
      geofs.autopilot.setMode()
  },
  setNAVMode: function(e, t, a) {
      if (this.currentNAVUnit) {
          if (this.currentNAVUnit.NAVMode == e && !a)
              return;
          this.currentNAVUnit.isCurrentNAV = !1,
          this.currentNAVUnit.NAVMode = null,
          this.currentNAVUnit = null,
          this.currentNAVUnitName = null
      }
      if (e && t) {
          let o = this.units[t];
          if ("NAV" == e && (this.$NAVFrenquency.removeClass("GPS"),
          this.$NAVModeButton.addClass("on"),
          this.$GPSModeButton.removeClass("on"),
          geofs.radio.displayNAVFrequency(null, "NAV1"),
          geofs.radio.displayOBS(o.OBS)),
          "GPS" == e) {
              if (!o.navaid)
                  return;
              this.$NAVFrenquency.addClass("GPS"),
              this.$NAVModeButton.removeClass("on"),
              this.$GPSModeButton.addClass("on"),
              geofs.radio.displayNAVFrequency(o.navaid.type),
              geofs.radio.displayOBS(o.OBS)
          }
          o.NAVMode = e,
          o.isCurrentNAV = !0,
          this.currentNAVUnit = o,
          this.currentNAVUnitName = t
      }
      geofs.autopilot.setMode(),
      geofs.animation.setValue("NAVMODE", e)
  },
  setNavaid: function(e, t) {
      let a = geofs.nav.types[e.type];
      e = $.extend(!0, e, a),
      t = a.ADF ? "ADF" : t || "NAV1",
      (!(unit = this.units[t]).navaid || (unit.navaid.id != e.id && geofs.nav.currentNAVUnitName != t && this.clear(t),
      unit.navaid.id != e.id)) && (unit.navaid = e,
      e.assignedToUnit = t,
      unit.inRange = this.isNavaidInRange(e),
      unit.LNAVCapable = a.LNAV,
      unit.VNAVCapable = a.VNAV,
      unit.RNAVCapable = a.RNAV,
      unit.LNAV = unit.inRange && a.LNAV,
      unit.VNAV = unit.inRange && a.VNAV,
      unit.RNAV = unit.inRange && a.RNAV,
      unit.course = 0,
      unit.glideAngleDeviation = 0,
      unit.bearingToStation = 0,
      unit.courseDeviation = 0,
      a.VOR ? this.setOBS(t, parseInt(this.computeBearingToNavaid(e)), null, !0) : a.ILS ? e.runway || (e.runway = geofs.runways.newRunwayFromNavaidObject(e),
      e.lat = e.runway.aimingPointLla1[0],
      e.lon = e.runway.aimingPointLla1[1]) : a.GPS && this.setOBS(t, "TRK"),
      e.elevation || (e.elevation = 0,
      geofs.api.getGuarantiedGroundAltitude([e.lat, e.lon, 0]).then(t => {
          e.elevation = t[0].height || 0
      }
      )))
  },
  setOBS: function(e, t, a, o) {
      e = e || geofs.nav.currentNAVUnitName || "NAV1";
      let r = this.units[e];
      "TRK" == t ? r.OBS = t : ("TRK" == r.OBS && (r.OBS = parseInt(r.bearing || 0)),
      r.OBS = fixAngle360(null != t ? t : r.OBS + parseInt(a))),
      o && geofs.radio.displayOBS(r.OBS)
  },
  setHDG: function(e, t, a) {
      this.HDG = fixAngle360(null != e ? e : this.HDG + t),
      a && geofs.autopilot.setCourse(this.HDG),
      geofs.animation.setValue("navHDG", this.HDG)
  },
  setADFManCourse: function(e, t) {
      this.ADFManCourse = fixAngle360(null != e ? e : this.ADFManCourse + t),
      geofs.animation.setValue("ADFManCourse", this.ADFManCourse)
  },
  clear: function(e) {
      if (e) {
          let t = this.units[e];
          t && (t.navaid && (t.navaid.assignedToUnit = null,
          t.navaid.runway && t.navaid.runway.destroy()),
          t.OBS = null,
          t.navaid = null,
          t.inRange = !1,
          t.LNAVCapable = !1,
          t.VNAVCapable = !1,
          t.RNAVCapable = !1,
          t.LNAV = !1,
          t.VNAV = !1,
          t.RNAV = !1,
          t.isCurrentNAV && this.setNAVMode(null))
      } else
          for (var a in this.units)
              this.clear(a)
  },
  isNavaidInRange: function(e) {
      let t = [geofs.aircraft.instance.llaLocation[0], geofs.aircraft.instance.llaLocation[1]], a;
      return geofs.utils.distanceBetweenLocations(t, [e.lat, e.lon]) < geofs.nav.types[e.type].range
  },
  update: function(e) {
      for (var t in this.hasDME = !1,
      this.units)
          this.updateUnit(e, t)
  },
  computeBearingToNavaid: function(e) {
      let t = [geofs.aircraft.instance.llaLocation[0], geofs.aircraft.instance.llaLocation[1]];
      return geofs.utils.bearingBetweenLocations(t, [e.lat, e.lon])
  },
  updateUnit: function(e, t) {
      let a = this.units[t]
        , o = a.navaid;
      if (!o)
          return;
      let r = geofs.nav.types[o.type]
        , n = [geofs.aircraft.instance.llaLocation[0], geofs.aircraft.instance.llaLocation[1]]
        , s = geofs.aircraft.instance.htr[0]
        , c = geofs.utils.distanceBetweenLocations(n, [o.lat, o.lon])
        , d = Math.abs(c - a.distance);
      if (a.distance = c,
      a.bearing = this.computeBearingToNavaid(o),
      a.height = geofs.aircraft.instance.llaLocation[2] - o.elevation,
      a.glideAngle = Math.atan2(a.height, a.distance) * RAD_TO_DEGREES,
      a.glideAngleDeviation = 0,
      r.VOR ? (a.course = a.OBS,
      a.LNAV = a.inRange,
      a.VNAV = !1,
      a.RNAV = !1) : r.ILS ? (a.course = o.heading,
      a.glideAngleDeviation = (o.slope || STANDARD_GLIDE_ANGLE) - a.glideAngle,
      a.LNAV = a.inRange || o.fromFlightPlan,
      a.VNAV = a.inRange || o.fromFlightPlan,
      a.RNAV = !1) : r.ADF ? (a.course = s,
      a.LNAV = !1,
      a.VNAV = !1,
      a.RNAV = !1) : r.GPS && (a.course = "TRK" == a.OBS ? a.bearing : a.OBS,
      a.LNAV = !0,
      a.VNAV = !1,
      a.RNAV = !0),
      a.bearingToStation = fixAngle(s - a.bearing),
      a.courseDeviation = fixAngle(a.bearing - a.course),
      Math.abs(a.courseDeviation) > 90 ? (a.direction = "from",
      a.courseDeviation = -fixAngle(a.courseDeviation - 180)) : a.direction = "to",
      r.DME && a.inRange) {
          this.hasDME = !0;
          let u = Math.sqrt(a.distance * a.distance + a.height * a.height);
          a.DME = (u * METERS_TO_NM).toFixed(1),
          a.speedToSignal = Math.round(d / e * MS_TO_KNOTS),
          a.timeToSignal = Math.round(a.distance / geofs.aircraft.instance.groundSpeed / 60)
      } else
          a.DME = "---",
          a.speedToSignal = "---",
          a.timeToSignal = "---";
      a.distance > r.range || a.glideAngle > 50 && !r.GPS && !o.fromFlightPlan ? (a.inRange = !1,
      a.course = 0,
      a.courseDeviation = 0,
      a.glideAngleDeviation = 0,
      a.direction = "",
      a.distance = 0,
      a.DME = "---",
      a.speedToSignal = "---",
      a.timeToSignal = "---") : a.inRange = !0,
      this.setUnitAnimationValue(a, t),
      a.isCurrentNAV && this.setUnitAnimationValue(a, "NAV")
  },
  setUnitAnimationValue: function(e, t) {
      geofs.animation.setValue(t + "Course", e.course),
      geofs.animation.setValue(t + "OBS", e.OBS),
      geofs.animation.setValue(t + "BearingToStation", e.bearingToStation),
      geofs.animation.setValue(t + "CourseDeviation", e.courseDeviation),
      geofs.animation.setValue(t + "Direction", e.direction),
      geofs.animation.setValue(t + "Distance", e.distance),
      geofs.animation.setValue(t + "DME", e.DME),
      geofs.animation.setValue(t + "SpeedToSignal", e.speedToSignal),
      geofs.animation.setValue(t + "TimeToSignal", e.timeToSignal),
      geofs.animation.setValue(t + "Bearing", e.bearing),
      geofs.animation.setValue(t + "GlideAngleDeviation", e.glideAngleDeviation),
      geofs.animation.setValue(t + "InRange", e.inRange),
      geofs.animation.setValue(t + "LNAV", e.LNAV),
      geofs.animation.setValue(t + "VNAV", e.VNAV),
      geofs.debug.watch(t + "LNAV", e.LNAV),
      geofs.debug.watch(t + "VNAV", e.VNAV)
  }
},
geofs.flightPlan = {
  mapPath: [],
  waypointArray: [],
  isInitialized: !1,
  isOpen: !1,
  trackedWaypoint: null,
  totalDistance: 0,
  totalTime: 0,
  DMEMargin: 6e-4,
  legColor: "#f67df6",
  activeLegColor: "#b100b1",
  init: function() {
      this.isInitialized || (this.isInitialized = !0,
      ui.addMouseUpHandler(geofs.flightPlan.closeWaypointDropdown),
      $(".geofs-flightPlan").on("keyup", e => {
          27 == e.which && geofs.flightPlan.closeWaypointDropdown()
      }
      ),
      $(document).on("flyto", geofs.flightPlan.refreshWaypoints))
  },
  toggle: function() {
      geofs.flightPlan.isOpen ? ($(".geofs-map-list").removeClass("geofs-flightPlanOpen"),
      $(".geofs-flightPlan-pad").removeClass("blue-pad"),
      geofs.flightPlan.isOpen = !1) : ($(".geofs-map-list").addClass("geofs-flightPlanOpen"),
      $(".geofs-flightPlan-pad").addClass("blue-pad"),
      geofs.flightPlan.isOpen = !0,
      geofs.nav.loadFixes(),
      this.init(),
      componentHandler.upgradeDom())
  },
  gotoWaypoint: function(e) {
      let t = geofs.flightPlan.waypointArray[e];
      if (e < geofs.flightPlan.waypointArray.length - 1) {
          let a = "" === t.alt ? geofs.aircraft.instance.llaLocation[2] : geofs.utils.parseAltitude(t.alt) * FEET_TO_METERS;
          geofs.flyTo([t.lat, t.lon, a, t.heading || geofs.flightPlan.waypointArray[e + 1].track, !0]),
          this.selectWaypoint(e + 1)
      }
  },
  update: function(e) {
      if (!geofs.flightPlan.waypointArray.length)
          return;
      if (!geofs.flightPlan.trackedWaypoint) {
          geofs.flightPlan.selectWaypoint(0);
          return
      }
      if (geofs.flightPlan.trackedWaypoint.id == geofs.flightPlan.waypointArray.length - 1)
          return;
      let t = geofs.animation.getValue(geofs.nav.currentNAVUnitName + "DME")
        , a = clamp(geofs.flightPlan.DMEMargin * geofs.aircraft.instance.llaLocation[2], 1, 100);
      t < a && geofs.flightPlan.selectWaypoint(geofs.flightPlan.trackedWaypoint.id + 1),
      geofs.flightPlan.isOpen && (geofs.flightPlan.distanceLeft = geofs.flightPlan.totalDistance - (geofs.flightPlan.trackedWaypoint.distanceThusfar - t),
      $(".flightPlanDistance").html("(" + parseInt(geofs.flightPlan.distanceLeft) + "nm)"))
  },
  selectWaypoint: function(e) {
      let t = geofs.flightPlan.waypointArray[e];
      if (t) {
          if (!t.valid) {
              geofs.flightPlan.selectWaypoint(e + 1);
              return
          }
          if (geofs.flightPlan.trackedWaypoint && (geofs.flightPlan.trackedWaypoint.selected = !1,
          $(".geofs-flightPlanWaypoint.geofs-selected").removeClass("geofs-selected")),
          t.navaid || (t.navaid = geofs.nav.addWaypoint([t.lat, t.lon], t.ident),
          "DST" == t.type && (t.navaid.type = "DST",
          t.navaid.heading = t.heading),
          geofs.nav.types[t.navaid.type] || (t.navaid.type = "WPT"),
          t.navaid.fromFlightPlan = !0),
          "" !== t.alt) {
              let a = parseInt((alt = geofs.utils.parseAltitude(t.alt)) * FEET_TO_METERS);
              if (isNaN(a) || isNaN(alt))
                  return;
              geofs.autopilot.setAltitude(alt, !0)
          }
          if (t.spd) {
              let o = parseInt(t.spd);
              if (geofs.autopilot.setSpeedMode("knots"),
              "M" == (t.spd + "").toUpperCase().substr(0, 1) && (geofs.autopilot.setSpeedMode("mach"),
              o = parseFloat(t.spd.substr(1))),
              isNaN(o))
                  return;
              geofs.autopilot.setSpeed(o, !0)
          }
          geofs.radio.clear("NAV1"),
          geofs.nav.selectNavaid(t.navaid.id, !0),
          geofs.flightPlan.trackedWaypoint = t,
          geofs.flightPlan.trackedWaypoint.selected = !0,
          geofs.flightPlan.refreshWaypoints()
      }
  },
  setDeparture: function(e) {
      geofs.flightPlan.addNavaidAsWaypoint(e, "DPT")
  },
  setDestination: function(e) {
      geofs.flightPlan.addNavaidAsWaypoint(e, "DST")
  },
  addFixAsWaypoint: function(e, t, a) {
      geofs.flightPlan.setWaypoint({
          id: a,
          ident: e,
          lat: t[0],
          lon: t[1],
          type: "FIX"
      })
  },
  addNavaidAsWaypoint: function(e, t, a) {
      let o = geofs.nav.navaids[e];
      geofs.flightPlan.setWaypoint({
          id: a,
          ident: o.icao || o.ident,
          lon: o.lon,
          lat: o.lat,
          type: t || o.type,
          heading: o.heading
      })
  },
  setWaypoint: function(e) {
      e = Object.assign({
          ident: "",
          lat: "",
          lon: "",
          distance: "",
          track: "",
          alt: "",
          spd: ""
      }, e);
      let t = geofs.flightPlan.waypointArray.length;
      void 0 !== e.id ? geofs.flightPlan.waypointArray[e.id] = e : (e.id = t,
      "DPT" == e.type ? (e.alt = 0,
      geofs.flightPlan.waypointArray.unshift(e)) : "DST" == e.type ? (e.alt = 0,
      geofs.flightPlan.waypointArray.push(e)) : t && "DST" == geofs.flightPlan.waypointArray[t - 1].type ? geofs.flightPlan.waypointArray.splice(-1, 0, e) : geofs.flightPlan.waypointArray.push(e)),
      geofs.flightPlan.refreshWaypoints()
  },
  createWaypointHTML: function(e) {
      let t = e.lat ? e.lat.toFixed(2) + "," + e.lon.toFixed(2) : ""
        , a = '<div class="geofs-flightPlanWaypoint' + (e.selected ? " geofs-selected" : "") + '" id="flightPlanWaypoint' + e.id + '"><span class="geofs-waypointIdent" onclick="geofs.flightPlan.selectWaypoint(' + e.id + ');">' + e.ident + '<span class="geofs-waypointCoords">' + t + '</span></span><span class="geofs-waypointProperty">' + e.distanceNM.toFixed(1) + 'nm<span class="geofs-waypointCoords">(' + e.distanceThusfar + 'nm)</span></span><span class="geofs-waypointProperty">' + e.track + '\xb0</span><div class="mdl-textfield mdl-js-textfield"><input class="mdl-textfield__input" type="text" id="alt' + e.id + '" value="' + e.alt + '" onchange="geofs.flightPlan.setWaypointAltitude(this, ' + e.id + ');"><label class="mdl-textfield__label" for="alt' + e.id + '">Ft.</label></div><div class="mdl-textfield mdl-js-textfield" style="margin-right: 0px;"><input class="mdl-textfield__input" type="text" id="spd' + e.id + '" value="' + e.spd + '" onchange="geofs.flightPlan.setWaypointSpeed(this, ' + e.id + ');"><label class="mdl-textfield__label" for="spd' + e.id + '">Kts/M.</label></div><button class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons" onclick="geofs.flightPlan.selectWaypoint(' + e.id + ');">check</i></button><button class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons" onclick="geofs.flightPlan.gotoWaypoint(' + e.id + ');">fast_forward</i></button>' + ("DPT" != e.type && "DST" != e.type ? '<button class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons" onclick="geofs.flightPlan.moveWaypoint(' + e.id + ', -1);">arrow_upward</i></button>' : "") + ("DPT" != e.type && "DST" != e.type ? '<button class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons" onclick="geofs.flightPlan.moveWaypoint(' + e.id + ', 1);">arrow_downward</i></button>' : "") + '<button class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons" onclick="geofs.flightPlan.deleteWaypoint(' + e.id + ');">close_small</i></button></div>';
      $(".geofs-flightPlanList").append(a)
  },
  setWaypointAltitude: function(e, t) {
      let a = $(e).val();
      geofs.flightPlan.waypointArray[t].alt = a
  },
  setWaypointSpeed: function(e, t) {
      let a = $(e).val();
      geofs.flightPlan.waypointArray[t].spd = a
  },
  setFixDistance: function(e, t) {
      for (let a = 0, o = t.length; a < o; a++)
          t[a].distance = geofs.utils.llaDistanceInMeters(e, t[a])
  },
  searchWaypoint: function(e, t) {
      let a;
      try {
          a = $(e).val().toUpperCase().trim()
      } catch (o) {}
      if (!a)
          return;
      let r = [], n, s = a.split(",");
      if (!(s.length > 1) || isNaN(s[0]) || isNaN(s[1]) ? n = a : (r[0] = [parseFloat(s[0]), parseFloat(s[1])],
      n = "FIX"),
      (r = (r = r.concat(geofs.nav.fixes[n] ?? [])).concat(geofs.nav.navaidsICAOMap[n] ?? [])).length > 1)
          geofs.flightPlan.setFixDistance(geofs.aircraft.instance.llaLocation, r),
          r.sort( (e, t) => e.distance - t.distance),
          geofs.flightPlan.generateWaypointDropdown(n, r, t);
      else if (r[0]) {
          let c = r[0];
          c.navaid ? geofs.flightPlan.addNavaidAsWaypoint(c.navaid.id, c.navaid.type, t) : geofs.flightPlan.addFixAsWaypoint(n, c, t),
          geofs.flightPlan.refreshWaypoints()
      }
  },
  closeWaypointDropdown: function() {
      $(".geofs-waypointDropdown").remove(),
      $(".geofs-addWaypoint input").val("")
  },
  generateWaypointDropdown: function(e, t, a) {
      void 0 == a && (a = "");
      let o = '<div class="geofs-waypointDropdown control-pad control-pad-label">';
      t.forEach(t => {
          ("RNW" == t.navaid.type || "ILS" == t.navaid.type) && (o += '<i class="material-icons" style="vertical-align: middle;" title="Set as departure" onmouseup="geofs.flightPlan.setDeparture(' + t.navaid.id + ');geofs.flightPlan.closeWaypointDropdown();">flight_takeoff</i>',
          o += '<i class="material-icons" style="vertical-align: middle;" title="Set as destination" onmouseup="geofs.flightPlan.setDestination(' + t.navaid.id + ');geofs.flightPlan.closeWaypointDropdown();">flight_land</i>'),
          o += '<div class="geofs-waypointResult" ',
          t.navaid ? (o += 'onmouseup="geofs.flightPlan.addNavaidAsWaypoint(' + t.navaid.id + ",'" + t.navaid.type + "'",
          o += "" != a ? ",'" + a + "'" : "",
          o += ');geofs.flightPlan.closeWaypointDropdown();">',
          o += " " + t.navaid.name + " [" + t.navaid.type + "]",
          o += " (" + (t.distance * METERS_TO_NM).toFixed(1) + "nm)</div>") : (o += "onmouseup=\"geofs.flightPlan.addFixAsWaypoint('" + e + "',[" + t[0] + "," + t[1] + "]",
          o += "" !== a ? ",'" + a + "'" : "",
          o += ');geofs.flightPlan.closeWaypointDropdown();">',
          o += " lat: " + t[0] + ", lon: " + t[1],
          o += " (" + (t.distance * METERS_TO_NM).toFixed(1) + "nm)</div>"),
          o += "<br/>"
      }
      ),
      o += "</div>",
      geofs.flightPlan.closeWaypointDropdown(),
      $("#flightPlanWaypoint" + a).append(o)
  },
  moveWaypoint: function(e, t) {
      let a = clamp(e + t, 0, geofs.flightPlan.waypointArray.length - 1);
      if ("DPT" == geofs.flightPlan.waypointArray[a].type || "DST" == geofs.flightPlan.waypointArray[a].type)
          return;
      let o = geofs.flightPlan.waypointArray.splice(e, 1)[0];
      geofs.flightPlan.waypointArray.splice(a, 0, o),
      geofs.flightPlan.refreshWaypoints()
  },
  deleteWaypoint: function(e) {
      let t = geofs.flightPlan.waypointArray.splice(e, 1)[0];
      t && (geofs.flightPlan.selectWaypoint(t.id),
      t.navaid && t.navaid.fromFlightPlan && geofs.nav.removeNavaid(t.navaid.id),
      geofs.flightPlan.refreshWaypoints())
  },
  refreshWaypoints: function() {
      $(".geofs-flightPlanList").html(""),
      geofs.api.map.clearPath(geofs.flightPlan.mapPath);
      let e = [geofs.aircraft.instance.llaLocation[0], geofs.aircraft.instance.llaLocation[1]], t;
      geofs.flightPlan.totalDistance = 0,
      geofs.flightPlan.totalTime = 0,
      geofs.flightPlan.waypointArray.forEach( (a, o) => {
          if (a.id = o,
          o > 0) {
              let r = geofs.flightPlan.waypointArray[o - 1];
              r.lat && r.lon && (e = [r.lat, r.lon])
          } else
              e = [a.lat, a.lon];
          a.lat && a.lon && (t = [a.lat, a.lon],
          a.distanceNM = geofs.utils.distanceBetweenLocations(e, t) * METERS_TO_NM,
          geofs.flightPlan.totalDistance = parseInt(geofs.flightPlan.totalDistance + a.distanceNM),
          a.distanceThusfar = geofs.flightPlan.totalDistance,
          a.track = parseInt(geofs.utils.bearingBetweenLocations(e, t)),
          a.valid = !0),
          geofs.flightPlan.createWaypointHTML(a),
          o > 0 && geofs.api.map.createGreatCirclePath(geofs.flightPlan.mapPath, e, t, {
              weight: 3,
              color: a.selected ? geofs.flightPlan.activeLegColor : geofs.flightPlan.legColor
          })
      }
      ),
      componentHandler.upgradeDom()
  },
  paste: async function(e) {
      try {
          let t = await navigator.clipboard.readText();
          geofs.flightPlan.import(t)
      } catch (a) {
          geofs.debug.log(a)
      }
  },
  copy: async function() {
      try {
          await navigator.clipboard.writeText(geofs.flightPlan.export())
      } catch (e) {
          geofs.debug.log(e)
      }
  },
  importSimBrief: function() {
      if (!geofs.preferences.simBriefUsername) {
          geofs.api.notify('Please setup a <a href="https://dispatch.simbrief.com/home" target="_blank" rel="nofollow">SimBrief</a> account and enter your username in the GeoFS option panel to be able to use this import function');
          return
      }
      try {
          let e = "https://www.simbrief.com/api/xml.fetcher.php?username=" + geofs.preferences.simBriefUsername + "&json=v2";
          $.getJSON(e, t => {
              e = t.fms_downloads.directory + t.fms_downloads.gfs.link,
              $.getJSON(e, e => {
                  geofs.flightPlan.import(e)
              }
              )
          }
          )
      } catch (t) {
          geofs.api.notify("Failed to load SimBrief flightplan."),
          geofs.debug.log(t)
      }
  },
  import: function(e) {
      let t = [];
      e instanceof Object || (e = JSON.parse(e)),
      (t = e.nodes ? e.nodes : e).forEach( (e, t) => {
          e.ident || (e.ident = "----"),
          void 0 == e.alt && (e.alt = ""),
          void 0 == e.spd && (e.spd = "")
      }
      ),
      geofs.flightPlan.waypointArray = t,
      geofs.flightPlan.refreshWaypoints()
  },
  export: function() {
      let e = [], t;
      return geofs.flightPlan.waypointArray.forEach( (a, o) => {
          t = {
              ident: a.ident,
              type: a.type,
              lat: a.lat,
              lon: a.lon
          },
          void 0 != a.alt && (t.alt = a.alt),
          void 0 != a.spd && (t.spd = a.spd),
          void 0 != a.heading && (t.heading = a.heading),
          e.push(t)
      }
      ),
      JSON.stringify(e)
  },
  upload: function(e) {
      let t = e.files[0]
        , a = new FileReader;
      a.onload = e => {
          let t = e.target.result;
          geofs.flightPlan.import(t)
      }
      ,
      a.onerror = e => {
          geofs.debug.log(e)
      }
      ,
      a.readAsText(t)
  },
  download: function(e) {
      if (geofs.flightPlan.waypointArray.length < 2)
          return;
      let t = geofs.flightPlan.waypointArray[0].ident + "-" + geofs.flightPlan.waypointArray[geofs.flightPlan.waypointArray.length - 1].ident + ".json"
        , a = new Blob([geofs.flightPlan.export()],{
          type: "text/plain"
      });
      window.URL.createObjectURL(a),
      e.download = t,
      e.href = window.URL.createObjectURL(a)
  },
  clear: function() {
      window.confirm("Clear the whole flight plan?") && (geofs.flightPlan.waypointArray = [],
      geofs.flightPlan.trackedWaypoint = null,
      geofs.flightPlan.refreshWaypoints(),
      $(".flightPlanDistance").html(""))
  }
},
geofs.radio = {
  visible: !1,
  pushToTalk: !1,
  units: {
      NAV1: {
          frequency: 0,
          rawFrequency: 0
      },
      ADF: {
          frequency: 0,
          rawFrequency: 0
      }
  },
  frequencyScanInterval: 5e3,
  NAVFrequencyRange: [108e3, 117950],
  ADFFrequencyRange: [190, 1750],
  init: function() {
      this.$radioNavFreq = $('[name="NAVFrequency"]'),
      this.$radioADFFreq = $('[name="ADFFrequency"]'),
      this.$radioOBSDisplay = $('[name="radioOBS"]'),
      this.$radioDMEDisplay = $('[name="dme"]'),
      this.$radioGroundSpeedDisplay = $('[name="groundSpeed"]'),
      this.$radioTTSDisplay = $('[name="timeToStation"]'),
      $(document).on("keydown keyup change", ".geofs-radio-display", e => {
          let t = $(e.currentTarget)
            , a = t.val();
          switch (t.attr("name")) {
          case "ADFFrequency":
              geofs.radio.tuneADFFrequency(a);
              break;
          case "NAVFrequency":
              geofs.radio.tuneNAVFrequency(a, null, "NAV1");
              break;
          case "radioOBS":
              geofs.nav.setOBS(null, a)
          }
          e.stopImmediatePropagation()
      }
      ),
      $(document).on("click", ".geofs-radio-pad", e => {
          geofs.radio.toggle(),
          e.preventDefault(),
          e.stopImmediatePropagation()
      }
      ),
      $(document).on("click", ".geofs-radio-ident", e => {
          let t = e.currentTarget
            , a = t.getAttribute("data-unit");
          $(".geofs-radio-ident").removeClass("on"),
          this.units[a].identEnabled ? geofs.radio.disableAllIdent() : (t.classList.add("on"),
          geofs.radio.disableAllIdent(),
          geofs.radio.enableUnitIdent(a))
      }
      ),
      this.navKnob = new Indicator({
          container: ".geofs-nav-frequency",
          overlay: {
              url: "images/instruments/radioknob.png",
              class: "geofs-radio-knob",
              size: {
                  x: 40,
                  y: 40
              },
              anchor: {
                  x: 20,
                  y: 20
              },
              position: {
                  x: -5,
                  y: 25
              },
              rescale: !1,
              rescalePosition: !1,
              manipulator(e, t) {
                  geofs.radio.tuneNAVFrequency(null, t, "NAV1")
              },
              animations: [{
                  type: "rotate",
                  value: "NAV1Frequency",
                  ratio: -.1
              }]
          }
      }),
      this.adfKnob = new Indicator({
          container: ".geofs-adf-frequency",
          overlay: {
              url: "images/instruments/radioknob.png",
              class: "geofs-radio-knob",
              size: {
                  x: 40,
                  y: 40
              },
              anchor: {
                  x: 20,
                  y: 20
              },
              position: {
                  x: -5,
                  y: 25
              },
              rescale: !1,
              rescalePosition: !1,
              manipulator(e, t) {
                  geofs.radio.tuneADFFrequency(null, t)
              },
              animations: [{
                  type: "rotate",
                  value: "ADFFrequency",
                  ratio: -2
              }]
          }
      }),
      this.OBSKnob = new Indicator({
          container: ".geofs-radio-OBS",
          overlay: {
              url: "images/instruments/radioknob.png",
              class: "geofs-radio-knob",
              size: {
                  x: 40,
                  y: 40
              },
              anchor: {
                  x: 20,
                  y: 20
              },
              position: {
                  x: -5,
                  y: 25
              },
              rescale: !1,
              rescalePosition: !1,
              manipulator(e, t) {
                  instruments.manipulators.setNAVOBS(null, t)
              },
              animations: [{
                  type: "rotate",
                  value: "NAV1OBS",
                  ratio: -1
              }]
          }
      }),
      setInterval( () => {
          this.scanFrequenciesAround()
      }
      , this.frequencyScanInterval),
      geofs.radio.atc.init()
  },
  scanUnitFrequency: function(e) {
      let t = this.units[e]
        , a = geofs.nav.frequencies[t.frequency];
      return a && a.length ? (geofs.utils.sortLocationByDistance(geofs.aircraft.instance.llaLocation, a),
      geofs.nav.setNavaid(a[0], e),
      this.startIdent(e),
      a[0]) : (this.stopIdent(e),
      geofs.nav.clear(e),
      !1)
  },
  scanFrequenciesAround: function() {
      for (var e in this.units)
          this.scanUnitFrequency(e)
  },
  tuneNAVFrequency: function(e, t, a) {
      var o = this.units[a];
      if (o.rawFrequency = e || parseFloat(o.rawFrequency) || 0,
      void 0 != t && (o.rawFrequency = o.rawFrequency + 10 * t),
      o.rawFrequency = clamp(o.rawFrequency, this.NAVFrequencyRange[0], this.NAVFrequencyRange[1]),
      (e = Math.round(o.rawFrequency / 100 * 2) / .02) != o.frequency) {
          o.frequency = e,
          geofs.animation.setValue(a + "Frequency", o.frequency),
          this.displayNAVFrequency(null, a);
          this.scanUnitFrequency(a) && geofs.nav.setNAVMode("NAV", "NAV1")
      }
  },
  tuneADFFrequency: function(e, t) {
      var a = this.units.ADF;
      a.rawFrequency = e || parseFloat(a.rawFrequency) || 0,
      t && (a.rawFrequency += .5 * t),
      a.rawFrequency = clamp(a.rawFrequency, this.ADFFrequencyRange[0], this.ADFFrequencyRange[1]),
      (e = Math.round(a.rawFrequency)) != a.frequency && (a.frequency = e,
      geofs.animation.setValue("ADFFrequency", a.frequency),
      this.displayADFFrequency(),
      this.scanUnitFrequency("ADF"))
  },
  displayNAVFrequency: function(e, t) {
      t = t || "NAV1";
      let a = this.units[t];
      this.$radioNavFreq.val(e || (a.frequency / 1e3).toFixed(2))
  },
  displayADFFrequency: function(e) {
      this.$radioADFFreq.val(e || this.units.ADF.frequency)
  },
  displayOBS: function(e) {
      this.$radioOBSDisplay.val(e)
  },
  clear: function(e) {
      if (e) {
          let t = this.units[e];
          if (!t)
              return;
          t.frequency = 0,
          t.rawFrequency = 0
      } else
          for (var a in this.units)
              this.clear(a);
      switch (e) {
      case "NAV1":
      case "NAV2":
          this.displayNAVFrequency(" "),
          this.displayOBS(" ");
          break;
      case "ADF":
          this.displayADFFrequency(" ")
      }
      this.$radioDMEDisplay.val(""),
      this.$radioGroundSpeedDisplay.val(""),
      this.$radioTTSDisplay.val("")
  },
  enableUnitIdent: function(e) {
      this.units[e].identEnabled = !0,
      this.startIdent(e)
  },
  disableAllIdent: function() {
      for (var e in this.units)
          this.units[e].identEnabled = !1;
      this.stopIdent()
  },
  startIdent: function(e) {
      if (!this.units[e].identEnabled)
          return;
      let t = geofs.nav.units[e]
        , a = t.navaid;
      if (!a)
          return;
      let o = a.ident;
      if (!t.inRange) {
          this.stopIdent();
          return
      }
      if (o != this.units[e].indenting) {
          this.stopIdent(),
          this.units[e].indenting = o;
          var r = o.split("").map(e => "sounds/morse/" + e + ".ogg");
          this.identSequencer = audio.impl.html5.playSequence(r, 1e4)
      }
  },
  stopIdent: function(e) {
      if (!e || this.units[e].identEnabled) {
          for (var t in this.units)
              this.units[t].indenting = null;
          this.identSequencer && (this.identSequencer.stop(),
          this.identSequencer = null)
      }
  },
  update: function(e) {
      this.visible && (this.$radioDMEDisplay.val(geofs.animation.getValue("NAVDME")),
      this.$radioGroundSpeedDisplay.val(geofs.animation.getValue("NAVSpeedToSignal")),
      this.$radioTTSDisplay.val(geofs.animation.getValue("NAVTimeToSignal")),
      this.navKnob.update(),
      this.adfKnob.update(),
      this.OBSKnob.update())
  },
  toggle: function() {
      geofs.radio.visible ? geofs.radio.hide() : geofs.radio.show()
  },
  show: function() {
      geofs.radio.visible || (geofs.radio.visible = !0,
      $(".geofs-radio-pad").addClass("blue-pad"),
      $(".geofs-radio-controls").show(),
      geofs.nav.loadNavaidsAndRunways())
  },
  hide: function() {
      geofs.radio.visible && (geofs.radio.visible = !1,
      $(".geofs-radio-pad").removeClass("blue-pad"),
      $(".geofs-radio-controls").hide())
  }
},
geofs.radio.atc = {
  ATCMessages: [],
  ATCMessagesLength: 100,
  init() {
      $(document).on("pushedtotalk", () => {
          geofs.radio.pushedToTalk = !0,
          setTimeout( () => {
              geofs.radio.pushedToTalk = !1
          }
          , 5e3)
      }
      ),
      $(document).on("textSpoken", () => {
          geofs.radio.pushedToTalk && (geofs.radio.pushedToTalk = !1,
          geofs.radio.atc.callAI(geofs.speech.textSpoken)),
          "atc" == geofs.speech.commandSpoken && geofs.radio.atc.callAI(geofs.speech.textSpoken)
      }
      )
  },
  callAI: function(e) {
      let t = []
        , a = [];
      t.push({
          role: "system",
          content: geofs.aiSystemMessage
      }),
      a.push({
          role: "user",
          content: "time is " + new Date().toLocaleTimeString()
      }),
      a.push({
          role: "user",
          content: "my latitude is " + geofs.aircraft.instance.llaLocation[0].toFixed(4)
      }),
      a.push({
          role: "user",
          content: "my longitude is " + geofs.aircraft.instance.llaLocation[1].toFixed(4)
      }),
      a.push({
          role: "user",
          content: "my altitude is " + parseInt(geofs.animation.values.altitude) + " feet"
      }),
      a.push({
          role: "user",
          content: "my heading is " + parseInt(geofs.animation.values.heading360) + " degrees"
      }),
      a.push({
          role: "user",
          content: "my airspeed is " + parseInt(geofs.animation.values.kias) + " knots"
      });
      let o = [];
      for (var r in geofs.runways.nearRunways) {
          let n = geofs.runways.nearRunways[r];
          o.push({
              icao: n.icao,
              ident: n.ident,
              heading: parseInt(fixAngle360(n.heading)),
              length: n.lengthFeet,
              latitude: n.location[0],
              longitude: n.location[1]
          })
      }
      let s = {
          role: "user",
          content: e
      }
        , c = [];
      c = (c = (c = (c = c.concat(t)).concat(geofs.radio.atc.ATCMessages)).concat(a)).concat(s),
      geofs.radio.atc.ATCMessages.push(s),
      geofs.radio.atc.ATCMessages = geofs.radio.atc.ATCMessages.slice(-geofs.radio.atc.ATCMessagesLength);
      let d = JSON.stringify({
          model: geofs.aiModel,
          messages: c,
          options: {
              temperature: .5
          },
          stream: !1
      });
      $.ajax(geofs.aiServer, {
          data: d,
          crossDomain: !0,
          method: "POST",
          dataType: "json",
          success(e, t, a) {
              let o = e.message.content;
              geofs.radio.atc.ATCMessages.push({
                  role: "assistant",
                  content: o
              }),
              geofs.speech.speak(o)
          },
          error(e, t) {
              geofs.debug.log(e)
          }
      })
  }
};
var weather = window.weather || {};
geofs.weatherServer = geofs.weatherServer || "/backend/weather/",
weather.METARProxy = geofs.weatherServer + "metar.php?icao=",
weather.realTimeCloudTexture = geofs.weatherServer + "clouds-2048.jpg",
weather.realTimeCloudMap = geofs.weatherServer + "clouds.png",
weather.minimumCloudCover = 10,
weather.updateRate = 6e4,
weather.timeRatio = 1,
weather.seasonRatio = 1,
weather.contrailTemperatureThreshold = -30,
weather.contrailAltitude = 1e4,
weather.defaults = {
  cloudCover: 0,
  cloudBase: 1e3,
  cloudTop: 3e3,
  cloudThickness: 4e3,
  cloudCoverThickness: 200,
  fogDensity: 0,
  fogCeiling: 1e3,
  fogBottom: 0,
  precipitationType: "none",
  precipitationAmount: 0,
  thunderstorm: 0,
  visibility: 1e4,
  windDirection: 0,
  windSpeedMS: 0,
  windGustMS: 0,
  windLayerHeight: 7e3,
  windLayerNb: 3,
  turbulences: 0,
  thermals: 0,
  airPressureSL: AIR_PRESSURE_SL,
  airTemperatureSL: AIR_TEMP_SL
},
weather.definition = Object.assign({}, weather.defaults),
weather.definitionBounds = {
  cloudCover: [0, 100],
  cloudBase: [0, 1e4],
  cloudTop: [0, 1e4],
  fogDensity: [0, 1],
  precipitationAmount: [0, 1],
  thunderstorm: [0, 1],
  windDirection: [0, 360],
  windSpeedMS: [0, 100],
  windGustMS: [0, 100],
  turbulences: [0, 1],
  thermals: [0, 1]
},
weather.init = function(e) {
  weather.currentWindVector = [0, 0, 0],
  weather.currentWindVectorWC = new Cesium.Cartesian3(0,0,0),
  weather.currentWindDirection = 0,
  weather.currentWindSpeed = 0,
  weather.currentWindSpeedMs = 0,
  weather.activeWindLayer = 0,
  weather.windLayers = [],
  geofs.fx.cloudManager.init(e),
  weather.reset(e),
  weather.interval = setInterval( () => {
      weather.refresh()
  }
  , weather.updateRate),
  weather.generateDefinition(e),
  weather.refresh(e),
  weather.atmosphere.init();
  var t = function(e, t) {
      var a = ("00" + parseInt(60 * (t % 1).toFixed(2))).slice(-2)
        , o = parseInt(t);
      $(this).find(".slider-input-overlay").html(o + ":" + a)
  };
  $(document).on("change", ".geofs-timeSlider", t),
  t.call($(".geofs-timeSlider"), null, geofs.preferences.weather.localTime);
  var a = function(e, t) {
      var a;
      t >= 0 && (a = "Spring"),
      t > 25 && (a = "Summer"),
      t > 50 && (a = "Autumn"),
      t > 75 && (a = "Winter"),
      $(this).find(".slider-input-overlay").html(a)
  };
  $(document).on("change", ".geofs-seasonSlider", a),
  a.call($(".geofs-seasonSlider"), null, geofs.preferences.weather.season),
  weather.manualWeatherUIContainer = $(".geofs-manualWeather")
}
,
weather.reset = function(e) {
  weather.set(Object.assign({}, weather.defaults), e),
  weather.refresh(e)
}
,
weather.refresh = function(e) {
  e = e || geofs.camera.lla;
  var t = function(t) {
      var a;
      if (t)
          try {
              a = JSON.parse(t)
          } catch (o) {
              geofs.debug.error(o, "weather.refresh error parsing JSON data")
          }
      (a = a || []).timestamp = geofs.utils.now(),
      weather.set(Object.assign({}, weather.defaults, weather.definition, a), e)
  };
  if (Math.abs(parseInt(Math.abs(e[0]))) > 39 || geofs.groundElevation > 3e3 ? weather.isSnowable = !0 : weather.isSnowable = !1,
  geofs.preferences.weather.manual)
      weather.generateDefinition(e),
      weather.set(weather.manualDefinition, e);
  else {
      var a = geofs.runways.getNearRunways(e)
        , o = [];
      if (a.map(function(e) {
          o.push(e[0])
      }),
      "" != (o = o.join(","))) {
          var r = weather.METARProxy + o + "&kc" + geofs.utils.now();
          $.ajax(r, {
              success: t,
              error: t
          })
      } else
          t()
  }
}
,
weather.sanitizedDefinition = function(e) {
  for (var t in weather.definitionBounds)
      e[t] = clamp(e[t], weather.definitionBounds[0], weather.definitionBounds[1]);
  return e
}
,
weather.generateDefinition = function(e, t) {
  let a = parseInt(Math.abs((e = e || geofs.camera.lla)[0]))
    , o = geofs.preferences.weather.localTime
    , r = weather.timeRatio
    , n = geofs.preferences.weather.quality
    , s = n / 100
    , c = geofs.preferences.weather.season;
  return weather.roundedLatitude = a,
  weather.manualQuality = n,
  weather.manualSeason = c,
  weather.manualTimeOfDay = o,
  t && (geofs.preferences.weather.advanced.clouds = Math.min(100, 2 * n),
  geofs.preferences.weather.advanced.cloudBase = weather.defaults.cloudBase,
  geofs.preferences.weather.advanced.cloudThickness = 500 + weather.defaults.cloudThickness * n * .02,
  geofs.preferences.weather.advanced.cloudTop = weather.defaults.cloudBase + (geofs.preferences.weather.advanced.cloudThickness || weather.defaults.cloudThickness),
  geofs.preferences.weather.advanced.fog = (1 - 2 * Math.abs(r - .5)) * (s > .45 ? 1 - s : 0) * 100,
  geofs.preferences.weather.advanced.fogCeiling = 2 * geofs.groundElevation + 50 || 0,
  geofs.preferences.weather.advanced.precipitationAmount = n > 50 ? (n - 50) * 2 : 0,
  geofs.preferences.weather.advanced.windSpeedMS = n / 6,
  geofs.preferences.weather.advanced.windSpeedKts = geofs.preferences.weather.advanced.windSpeedMS * MS_TO_KNOTS,
  geofs.preferences.weather.advanced.turbulences = s * Math.abs(r - .5) * 2,
  geofs.preferences.weather.advanced.thermals = Math.min(1, 4 * s) * Math.abs(r - .5) * 2),
  weather.manualDefinition = {
      cloudCover: geofs.preferences.weather.advanced.clouds || weather.defaults.cloudCover,
      cloudBase: geofs.preferences.weather.advanced.cloudBase || weather.defaults.cloudBase,
      cloudTop: (geofs.preferences.weather.advanced.cloudBase || weather.defaults.cloudBase) + (geofs.preferences.weather.advanced.cloudThickness || weather.defaults.cloudThickness),
      fogDensity: geofs.preferences.weather.advanced.fog || weather.defaults.fogDensity,
      fogBottom: 0,
      fogCeiling: geofs.preferences.weather.advanced.fogCeiling || weather.defaults.fogCeiling,
      precipitationAmount: geofs.preferences.weather.advanced.precipitationAmount || weather.defaults.precipitationAmount,
      precipitationType: c > 75 && weather.isSnowable ? "snow" : "rain",
      thunderstorm: n > 90 ? (n - 90) * 10 : 0,
      visibility: 1e4,
      windDirection: geofs.preferences.weather.advanced.windDirection || weather.defaults.windDirection,
      windSpeedMS: geofs.preferences.weather.advanced.windSpeedMS || weather.defaults.windSpeedMS,
      windGustMS: (geofs.preferences.weather.advanced.windSpeedMS || weather.defaults.windSpeedMS) / 4,
      windLayerHeight: 7e3,
      windLayerNb: 3,
      turbulences: geofs.preferences.weather.advanced.turbulences || weather.defaults.turbulences,
      thermals: geofs.preferences.weather.advanced.thermals || weather.defaults.thermals,
      airTemperatureSL: clamp((100 - c - Math.abs(a)) * .4 * (1 - r), -50, 50),
      timestamp: geofs.utils.now()
  },
  weather.manualDefinition
}
,
weather.setManual = function() {
  $('[gespref="geofs.preferences.weather.quality"]').removeClass("geofs-disabled"),
  $(".geofs-advancedWeather .slider").addClass("geofs-disabled");
  var e = weather.generateDefinition(null, !0);
  geofs.preferences.weather.advanced.windSpeedMS = geofs.preferences.weather.advanced.windSpeedKts * KNOTS_TO_MS,
  weather.set(e),
  geofs.setPreferenceValues(weather.manualWeatherUIContainer, !0)
}
,
weather.setAdvanced = function() {
  $('[gespref="geofs.preferences.weather.quality"]').addClass("geofs-disabled"),
  $(".geofs-advancedWeather .slider").removeClass("geofs-disabled"),
  geofs.preferences.weather.advanced.precipitationAmount > 0 && (geofs.preferences.weather.advanced.clouds = Math.max(geofs.preferences.weather.advanced.clouds, 2 * geofs.preferences.weather.advanced.precipitationAmount)),
  geofs.setPreferenceValues(weather.manualWeatherUIContainer, !0);
  var e = weather.generateDefinition();
  geofs.preferences.weather.advanced.windSpeedMS = geofs.preferences.weather.advanced.windSpeedKts * KNOTS_TO_MS,
  weather.set(e)
}
,
weather.set = function(e, t) {
  e = weather.sanitizedDefinition(e || weather.definition || {}),
  t = t || geofs.camera.lla,
  weather.setDateAndTime(t),
  geofs.fx.dayNightManager.init(),
  geofs.preferences.weather.manual ? ($(".geofs-manualWeather").show(),
  $(".geofs-metarDisplay").html("").parent().hide(),
  weather.generateDefinition()) : ($(".geofs-manualWeather").hide(),
  $(".geofs-metarDisplay").html(e.METAR).parent().show()),
  weather.definition = Object.assign({}, weather.defaults, e);
  var a = .01 * weather.definition.precipitationAmount;
  weather.initWind(weather.definition.windDirection, weather.definition.windSpeedMS),
  weather.definition.windSpeedMS > 0 ? (weather.windActive = !0,
  weather.setWindIndicatorVisibility(!0)) : (weather.windActive = !1,
  weather.windOff(),
  weather.setWindIndicatorVisibility(!1)),
  weather.definition.fog = .01 * weather.definition.fogDensity,
  weather.definition.backgroundFogDensity = clamp((a - .5) * 4, 0, 2),
  weather.definition.coverHalfThickness = weather.definition.cloudCoverThickness / 2;
  var o = weather.definition.cloudCover;
  o < weather.minimumCloudCover && (weather.definition.cloudCover = 0),
  geofs.api.renderingSettings.volumetricClouds && (o = 0),
  geofs.fx.cloudManager.instance.setCloudCover(o),
  weather.definition.precipitationAmount > 0 ? geofs.fx.precipitation.create(weather.definition.precipitationType, weather.definition.precipitationAmount) : geofs.fx.precipitation.destroy(),
  weather.belowCloudsBrightness = clamp(1 - a, 0, 1),
  weather.currentWindVectorWC = new Cesium.Cartesian3(0,0,0),
  weather.windLayers.length && (weather.currentWindVectorWC = weather.windLayers[0].vectorWC),
  geofs.fx.atmosphere.setConditions(weather.currentWindVectorWC, .01 * weather.definition.cloudCover),
  geofs.fx.water.setConditions(weather.currentWindSpeedMs),
  setTimeout( () => {
      geofs.fx.dayNightManager.update()
  }
  , 0),
  "snow" == weather.definition.precipitationType ? (geofs.isSnow = !0,
  geofs.api.setImageryColorModifier("snow", {
      brightness: 2.5,
      contrast: 1.5,
      saturation: .1
  })) : (geofs.isSnow = !1,
  geofs.api.removeImageryColorModifier("snow")),
  geofs.fx.cloudManager.instance.triggerUpdate(),
  window.fireBasicEvent("geofsWeatherChange")
}
,
weather.animationRate = -5,
weather.update = function(e) {
  weather.animate && ((0 == geofs.preferences.weather.quality || 100 == geofs.preferences.weather.quality) && (weather.animationRate *= -1),
  geofs.preferences.weather.quality = clamp(geofs.preferences.weather.quality + e * weather.animationRate, 0, 100),
  weather.setManual());
  var t = geofs.camera.lla;
  if (weather.windLayers.length > 0) {
      for (var a = geofs.aircraft.instance.llaLocation[2], o = 0, r = 1; r < weather.windLayers.length && !(a < weather.windLayers[r].floor); r++)
          o = r;
      weather.windLayers[o].computeAndSet(t),
      weather.activeWindLayer = o
  }
  weather.setThermals(t, e),
  geofs.fx.cloudManager.update(t, e),
  geofs.fx.precipitation.update(t, e),
  geofs.fx.dayNightManager.update(t, e)
}
,
weather.setWindIndicatorVisibility = function(e) {
  instruments.list.wind && (e ? instruments.visible && instruments.list.wind.show() : instruments.list.wind.hide())
}
,
weather.setDateAndTime = function(e) {
  var t = (e = e || geofs.camera.lla || [0, 0, 0])[1] * LONGITUDE_TO_HOURS;
  if (geofs.preferences.weather.manual) {
      weather.localTime = geofs.preferences.weather.localTime || 12,
      weather.localSeason = geofs.preferences.weather.season,
      weather.zuluTime = boundHours24(weather.localTime - t);
      var a = 3600 * weather.zuluTime;
      geofs.api.setTimeAndDate(a, Math.floor(3.65 * weather.localSeason))
  } else {
      var o = new Date;
      geofs.api.setClock(o),
      weather.zuluTime = o.getUTCHours(),
      weather.localTime = boundHours24(weather.zuluTime + t);
      var r = (Date.UTC(o.getFullYear(), o.getMonth(), o.getDate()) - Date.UTC(o.getFullYear(), 0, 0)) / 24 / 60 / 60 / 1e3;
      weather.localSeason = (r - 60) * .27
  }
  weather.timeRatio = Math.abs(weather.localTime / 12 - 1),
  weather.timeRatio = Number.parseFloat(weather.timeRatio.toFixed(2)),
  weather.seasonRatio = Math.sin(2.7 * weather.localSeason * DEGREES_TO_RAD),
  geofs.isSnowy = !1,
  weather.localSeason >= 0 && (geofs.season = "spring"),
  weather.localSeason > 25 && (geofs.season = "summer"),
  weather.localSeason > 50 && (geofs.season = "autumn"),
  (weather.localSeason < 0 || weather.localSeason > 75) && (geofs.season = "winter",
  weather.isSnowable && (geofs.isSnowy = !0)),
  geofs.animation.values.season != geofs.season && $("body").trigger("seasonChange"),
  geofs.animation.values.night = geofs.isNight,
  geofs.animation.values.season = geofs.season,
  geofs.animation.values.minutes = 60 * (weather.localTime % 1).toFixed(2),
  geofs.animation.values.hours = weather.localTime,
  window.fireBasicEvent("geofsTimeChange")
}
,
weather.getLocalTurbulence = function(e) {
  var t = 2500;
  return [0, 0, geofs.perlin.get(e[0], e[1], t) * weather.definition.turbulences * 4]
}
,
weather.thermals = {
  currentVector: [0, 0, 0],
  minradius: 200,
  maxradius: 1e3,
  minspeed: 0,
  maxspeed: 7,
  invertionRange: 500
},
weather.setThermals = function(e) {
  weather.thermals.currentVector = weather.getLocalThermal(e)
}
,
weather.getLocalThermal = function(e) {
  if (0 == weather.definition.thermals)
      return [0, 0, 0];
  var t = clamp(e[2] / (weather.definition.cloudBase - geofs.groundElevation), 0, 1)
    , a = clamp((1 - t) * 5, 0, 1)
    , o = 1 + weather.definition.thermals
    , r = 200;
  e = V3.sub(e, V3.scale(weather.currentWindVectorLla, .1 * e[2]));
  var n = geofs.perlin.get(e[0], e[1], r)
    , s = 0;
  return s = clamp(Math.pow(Math.abs(n) * o, 3) * Math.sign(n) * weather.thermals.maxspeed * weather.definition.thermals, weather.thermals.minspeed, weather.thermals.maxspeed) * a,
  isNaN(s) && (s = 0),
  [0, 0, s]
}
,
weather.Wind = function(e, t, a, o) {
  this.mainDirection = e,
  this.speedKnots = t * MS_TO_KNOTS,
  this.speedMs = t;
  var r = this.mainDirection * DEGREES_TO_RAD;
  this.vector = [Math.sin(r), Math.cos(r), 0],
  this.vectorMs = V3.scale(this.vector, this.speedMs),
  this.vectorCross = V3.cross(this.vector, [0, 0, 1]),
  this.floor = a,
  this.ceiling = o,
  this.direction = this.mainDirection,
  this.speed = this.speedMs;
  var n = new Cesium.HeadingPitchRoll(e * DEGREES_TO_RAD,0,0)
    , s = Cesium.Transforms.headingPitchRollToFixedFrame(geofs.camera.cam.position, n);
  this.vectorWC = Cesium.Matrix4.multiplyByPointAsVector(s, new Cesium.Cartesian3(0,-t,0), new Cesium.Cartesian3)
}
,
weather.Wind.prototype.randomize = function() {
  var e = clamp(weather.definition.cloudBase / geofs.animation.values.altitudeMeters, 0, 1)
    , t = weather.definition.windGustMS * (Math.random() - .5) * e;
  this.speed = this.speedMs + exponentialSmoothing("windGust", t, .1)
}
,
weather.Wind.prototype.computeAndSet = function(e) {
  e = e || [0, 0, 0],
  this.randomize();
  var t = [0, 0, 0];
  this.speed && (t = this.computeTerrainLift()),
  weather.currentWindVector = V3.scale(t, this.speed),
  weather.currentWindVectorLla = xyz2lla(weather.currentWindVector, e),
  weather.currentWindDirection = this.direction,
  weather.currentWindSpeedMs = this.speed,
  weather.currentWindSpeed = this.speed * MS_TO_KNOTS
}
,
weather.Wind.prototype.computeTerrainLift = function(e) {
  var t = 100
    , a = 10
    , o = 500
    , r = 5
    , n = e || geofs.aircraft.instance.llaLocation
    , s = V3.sub(n, xyz2lla(V3.scale(this.vector, t), n))
    , c = geofs.groundElevation
    , d = geofs.api.getGroundAltitude(s, weather.Wind);
  geofs.debugOn && geofs.debug.placeProbe([s[0], s[1], d]);
  var u = n[2] - c
    , p = c - d
    , h = clamp(p * r, a, o)
    , m = Math.atan(p / t)
    , f = clamp(h - u, 0, h) / h;
  m *= f;
  var g = V3.rotate(this.vector, this.vectorCross, m);
  return g.origin = [n[0], n[2], c],
  g
}
,
weather.initWind = function(e, t) {
  weather.windLayers = [],
  e = fixAngle(e + 180);
  var a = 0
    , o = weather.definition.windLayerHeight + Math.random() * weather.definition.windLayerHeight;
  if (weather.windLayers.push(new weather.Wind(e,t,a,o)),
  t) {
      weather.windLayers[0].computeAndSet();
      for (var r = 1; r < weather.windLayerNb; r++) {
          o = (a = o) + weather.windLayerHeight + Math.random() * weather.definition.windLayerHeight;
          var n = t + (10 * Math.random() - 5)
            , s = fixAngle(e + 360 * Math.random());
          weather.windLayers.push(new weather.Wind(s,n,a,o))
      }
  }
}
,
weather.windOff = function() {
  weather.windLayers = [],
  weather.currentWindVector = [0, 0, 0],
  weather.currentWindVectorLla = [0, 0, 0],
  weather.currentWindVectorWC = new Cesium.Cartesian3(0,0,0),
  weather.currentWindDirection = 0,
  weather.currentWindSpeed = 0,
  weather.currentWindSpeedMs = 0
}
,
weather.atmosphere = {},
weather.atmosphere.init = function() {
  weather.atmosphere.update()
}
,
weather.atmosphere.update = function(e) {
  e = e || geofs.aircraft.instance.altitude || 0;
  var t = weather.definition.airTemperatureSL + KELVIN_OFFSET;
  weather.atmosphere.airTempAtAltitude = weather.definition.airTemperatureSL - e * TEMPERATURE_LAPSE_RATE,
  weather.atmosphere.airTempAtAltitudeKelvin = weather.atmosphere.airTempAtAltitude + KELVIN_OFFSET,
  weather.atmosphere.airPressureAtAltitude = weather.definition.airPressureSL * Math.pow(clamp(1 - e * TEMPERATURE_LAPSE_RATE / t, 0, 1), GM_RL),
  weather.atmosphere.airDensityAtAltitude = weather.atmosphere.airPressureAtAltitude * MOLAR_MASS_DRY_AIR / (IDEAL_GAS_CONSTANT * weather.atmosphere.airTempAtAltitudeKelvin),
  weather.contrailAltitude = -((weather.contrailTemperatureThreshold - weather.definition.airTemperatureSL) / TEMPERATURE_LAPSE_RATE)
}
,
window.geofs = window.geofs || {},
geofs.camera = {
  animations: {
      orbitHorizontal: {
          rate: 5
      },
      orbitVertical: {
          rate: 2,
          min: -60,
          max: 60
      }
  },
  currentMode: 0,
  currentModeName: "follow",
  currentDefinition: {},
  lastCurrentMode: 0,
  worldPosition: [0, 0, 0],
  openSlave: !1,
  motionRange: .3,
  rotationRange: 40,
  FOVIncrement: .1,
  defaultFOV: 1.4,
  currentFOV: 1.4,
  minFOV: .2,
  maxFOV: 2.5,
  groundAvoidanceMargin: .5,
  groundAvoidanceIgnore: 100,
  shortestDistance: 5,
  init: function(e) {
      geofs.camera.cam = geofs.api.initAndGetCamera(),
      geofs.camera.lla = e || [0, 0, 0],
      geofs.camera.htr = [0, 0, 0],
      geofs.camera.hasMoved = !1,
      $(document).on("click", "[data-cameraAnim]", e => {
          var t = $(e.currentTarget).attr("data-cameraAnim");
          geofs.camera.animations[t].active = !geofs.camera.animations[t].active
      }
      ).on("click", ".geofs-stopAllAnim", () => {
          for (var e in geofs.camera.animations)
              geofs.camera.animations[e].active = !1
      }
      ).on("click", ".geofs-startAllAnim", () => {
          for (var e in geofs.camera.animations)
              geofs.camera.animations[e].active = !0
      }
      )
  },
  setFOV: function(e) {
      geofs.camera.currentFOV = e || geofs.camera.defaultFOV,
      geofs.camera.currentFOV = clamp(geofs.camera.currentFOV, geofs.camera.minFOV, geofs.camera.maxFOV),
      geofs.api.setFOV(geofs.camera.cam, geofs.camera.currentFOV),
      geofs.getViewportDimentions(),
      "cockpit" == geofs.camera.currentModeName && instruments.updateCockpitPositions()
  },
  increaseFOV: function(e) {
      var t = geofs.api.getFOV(geofs.camera.cam);
      (t += e || geofs.camera.FOVIncrement) > geofs.camera.maxFOV && (t = geofs.camera.maxFOV),
      geofs.camera.setFOV(t)
  },
  decreaseFOV: function(e) {
      var t = geofs.api.getFOV(geofs.camera.cam);
      (t -= e || geofs.camera.FOVIncrement) < geofs.camera.minFOV && (t = geofs.camera.minFOV),
      geofs.camera.setFOV(t)
  },
  reset: function() {
      geofs.camera.definitions = {
          follow: {
              distance: 5,
              lookAtHeight: -1,
              orientation: [0, 10, 0]
          },
          cockpit: {
              offsetBounds: [0, 0, 0, 0, 0, 0],
              insideView: !0
          },
          cockpitless: {
              insideView: !0
          },
          chase: {
              reset: !0
          },
          free: {
              reset: !0
          },
          fixed: {}
      };
      var e = "";
      for (var t in geofs.aircraft.instance.definition.cameras)
          geofs.camera.definitions[t] || (e += '<li class="mdl-menu__item" data-camera="' + t + '">' + t + "</li>");
      e.length ? $(".geofs-extra-views").show().find(".geofs-extra-views-holder").html(e) : $(".geofs-extra-views").hide();
      var a = $.extend(!0, {}, geofs.camera.definitions, geofs.aircraft.instance.definition.cameras)
        , o = 0;
      for (t in geofs.camera.modes = [],
      a) {
          var r = a[t];
          r.name = t,
          r.mode = o,
          r.view = r.view || r.name,
          r.insideView = r.insideView || "cockpit" == r.view,
          r.position = r.position || [0, 0, 0],
          r.orientations = {},
          r.orientations.neutral = r.orientation || [0, 0, 0],
          r.orientations.current = V3.dup(r.orientations.neutral),
          r.orientations.last = V3.dup(r.orientations.neutral),
          r.offsets = {},
          r.offsets.neutral = [0, 0, 0 + (r.lookAtHeight || 0)],
          r.offsets.current = V3.dup(r.offsets.neutral),
          r.offsets.last = V3.dup(r.offsets.neutral),
          geofs.camera.definitions[t] = r,
          geofs.camera.modes.push(geofs.camera.definitions[t]),
          o++
      }
      for (var t in geofs.camera.definitions) {
          var r = geofs.camera.definitions[t];
          r.orientations.current = V3.dup(r.orientations.neutral),
          r.orientations.last = V3.dup(r.orientations.neutral),
          r.offsets.current = V3.dup(r.offsets.neutral),
          r.offsets.last = V3.dup(r.offsets.neutral)
      }
      geofs.camera.definitions.follow.distance /= geofs.camera.defaultFOV,
      geofs.camera.definitions.follow.lastUsedHtr = V3.dup(geofs.aircraft.instance.htr),
      geofs.camera.definitions.fixed.lastUsedHtr = V3.dup(geofs.aircraft.instance.htr),
      geofs.camera.definitions.fixed.distance = geofs.camera.definitions.follow.distance,
      geofs.camera.definitions.fixed.offsets.neutral[1] = -geofs.camera.definitions.follow.distance,
      geofs.camera.definitions.fixed.offsets.current[1] = -geofs.camera.definitions.follow.distance,
      geofs.camera.definitions.fixed.offsets.last[1] = -geofs.camera.definitions.follow.distance,
      geofs.camera.set(0),
      geofs.camera.setToNeutral(),
      geofs.camera.lla = [0, 0, 0],
      geofs.camera.htr = [0, 0, 0],
      geofs.camera.update(1)
  },
  cycle: function() {
      var e = geofs.camera.currentMode + 1;
      e >= geofs.camera.modes.length && (e = 0),
      geofs.camera.set(e)
  },
  set: function(e, t) {
      if (-1 == e) {
          geofs.camera.reset();
          return
      }
      if (geofs.camera.currentDefinition = geofs.camera.modes[e] || geofs.camera.definitions[t] || geofs.camera.definitions[0],
      geofs.camera.currentMode = geofs.camera.currentDefinition.mode,
      geofs.camera.currentModeName = geofs.camera.currentDefinition.name,
      geofs.camera.currentView = geofs.camera.currentDefinition.view,
      geofs.camera.setFOV(geofs.camera.currentDefinition.FOV),
      "follow" == geofs.camera.currentModeName || "fixed" == geofs.camera.currentModeName) {
          var a = xyz2lla(V3.scale(geofs.aircraft.instance.object3d.getWorldFrame()[1], -geofs.camera.definitions.follow.distance), geofs.aircraft.instance.llaLocation);
          geofs.camera.lla = V3.add(geofs.aircraft.instance.llaLocation, a),
          geofs.camera.avoidGround();
          var o = lookAt(geofs.aircraft.instance.llaLocation, geofs.camera.lla, [0, 0, 1]);
          o = [o[0], -o[1] + 90, 0],
          geofs.api.setCameraPositionAndOrientation(geofs.camera.cam, geofs.camera.lla, o)
      }
      "free" == geofs.camera.currentModeName || "chase" == geofs.camera.currentModeName ? ($(".geofs-canvas-mouse-overlay").css("pointer-events", "none"),
      geofs.api.nativeMouseHandling = !0) : ($(".geofs-canvas-mouse-overlay").css("pointer-events", "auto"),
      geofs.api.nativeMouseHandling = !1),
      geofs.aircraft.instance && ("cockpitless" == geofs.camera.currentModeName ? geofs.aircraft.instance.setVisibility(!1) : geofs.aircraft.instance.setVisibility(!0)),
      "cockpit" == geofs.camera.currentModeName || geofs.camera.currentDefinition.nearClipping ? (geofs.aircraft.instance.definition.cockpitScaleFix && geofs.aircraft.instance.fixCockpitScale(geofs.aircraft.instance.definition.cockpitScaleFix),
      geofs.aircraft.instance.loadCockpit(),
      instruments.updateCockpitPositions(),
      geofs.api.configureInsideView(),
      geofs.camera.motionOffset = [0, 0, 0],
      geofs.camera.rotationOffset = [0, 0, 0],
      $("body").addClass("geofs-cockpitView"),
      geofs.animation.values.overlaysVisibility = "hidden") : (geofs.aircraft.instance.fixCockpitScale(1),
      geofs.camera.currentDefinition.insideView ? geofs.api.configureInsideView() : geofs.api.configureOutsideView(),
      $("body").removeClass("geofs-cockpitView"),
      geofs.animation.values.overlaysVisibility = "visible"),
      geofs.animation.values.view = geofs.camera.currentView,
      geofs.animation.values.cameraMode = geofs.camera.currentModeName,
      geofs.aircraft.instance.placeParts(),
      geofs.aircraft.instance.render(),
      instruments.updateScreenPositions(),
      instruments.update(),
      $(document).trigger("cameraChange"),
      geofs.camera.hasMoved = !0,
      geofs.camera.update(1)
  },
  lookAround: function(e, t) {
      if (geofs.camera.isHandlingMouseRotation()) {
          var a = geofs.camera.definitions[geofs.camera.currentModeName];
          return void 0 != e && (a.orientations.current[0] = e),
          void 0 != t && (a.orientations.current[1] = t),
          geofs.camera.saveRotation(),
          "cockpit" == geofs.camera.currentModeName && (geofs.camera.hasMoved = !0),
          !0
      }
      return !1
  },
  rotate: function(e, t, a) {
      if (e = e || 0,
      t = t || 0,
      a = a || 0,
      geofs.camera.isHandlingMouseRotation()) {
          var o = geofs.camera.definitions[geofs.camera.currentModeName];
          return o.orientations.current[0] = o.orientations.current[0] - e,
          o.orientations.current[1] = o.orientations.current[1] + t,
          o.orientations.current[2] = o.orientations.current[2] + (a || 0),
          "cockpit" == geofs.camera.currentModeName && (geofs.camera.hasMoved = !0),
          !0
      }
      return !1
  },
  translate: function(e, t, a) {
      if (e = e || 0,
      t = t || 0,
      a = a || 0,
      geofs.camera.isHandlingMouseRotation()) {
          var o, r = geofs.camera.definitions[geofs.camera.currentModeName], n = geofs.aircraft.instance.object3d.getWorldFrame(), s = M33.rotationXYZ(M33.identity(), [-geofs.camera.htr[1] * DEGREES_TO_RAD, 0, geofs.camera.htr[0] * DEGREES_TO_RAD]);
          return "follow" == geofs.camera.currentModeName ? (r.distance += t,
          o = [e, 0, a]) : (o = M33.transform(s, [e, t, a]),
          o = M33.transformByTranspose(n, o)),
          r.offsets.current = V3.add(r.offsets.current, o),
          r.offsetBounds && (r.offsets.current[0] = clamp(r.offsets.current[0], r.offsetBounds[0], r.offsetBounds[1]),
          r.offsets.current[1] = clamp(r.offsets.current[1], r.offsetBounds[2], r.offsetBounds[3]),
          r.offsets.current[2] = clamp(r.offsets.current[2], r.offsetBounds[4], r.offsetBounds[5])),
          "cockpit" == geofs.camera.currentModeName && (geofs.camera.hasMoved = !0),
          !0
      }
      return !1
  },
  setPosition: function(e, t, a) {
      if (e = e || 0,
      t = t || 0,
      a = a || 0,
      geofs.camera.isHandlingMouseRotation()) {
          var o, r = geofs.camera.definitions[geofs.camera.currentModeName], n = geofs.aircraft.instance.object3d.getWorldFrame(), s = M33.rotationXYZ(M33.identity(), [-geofs.camera.htr[1] * DEGREES_TO_RAD, 0, geofs.camera.htr[0] * DEGREES_TO_RAD]);
          return "follow" == geofs.camera.currentModeName ? (r.distance += t,
          o = [e, 0, a]) : (o = M33.transform(s, [e, t, a]),
          o = M33.transformByTranspose(n, o)),
          r.offsets.current = V3.dup(o),
          "cockpit" == geofs.camera.currentModeName && (geofs.camera.hasMoved = !0),
          !0
      }
      return !1
  },
  setOffsets: function(e, t, a) {
      e = e || 0,
      t = t || 0,
      a = a || 0,
      geofs.camera.definitions[geofs.camera.currentModeName].offsets.current = [e, t, a]
  },
  isHandlingMouseRotation: function() {
      return "follow" == geofs.camera.currentModeName || "cockpit" == geofs.camera.currentModeName || "fixed" == geofs.camera.currentModeName || !!geofs.camera.currentDefinition.rotatable
  },
  setRotation: function(e, t, a) {
      var o = geofs.camera.definitions[geofs.camera.currentModeName];
      return "follow" == geofs.camera.currentModeName || "fixed" == geofs.camera.currentModeName ? (o.orientations.current[0] = e || o.orientations.last[0],
      o.orientations.current[1] = t || o.orientations.last[1],
      o.orientations.current[2] = a || o.orientations.last[2],
      !0) : "cockpit" == geofs.camera.currentModeName && (o.orientations.current[0] = e || o.orientations.last[0],
      o.orientations.current[1] = t || o.orientations.last[1],
      o.orientations.current[2] = a || o.orientations.last[2],
      geofs.camera.hasMoved = !0,
      !0)
  },
  saveRotation: function() {
      if (geofs.camera.definitions) {
          var e = geofs.camera.definitions[geofs.camera.currentModeName];
          e.orientations.last = V3.dup(e.orientations.current)
      }
  },
  saveOffset: function() {
      if (geofs.camera.definitions) {
          var e = geofs.camera.definitions[geofs.camera.currentModeName];
          e.offsets.last = V3.dup(e.offsets.current)
      }
  },
  setToNeutral: function() {
      var e = geofs.camera.definitions[geofs.camera.currentModeName];
      e.orientations.current = V3.dup(e.orientations.neutral),
      e.orientations.last = V3.dup(e.orientations.neutral),
      e.offsets.current = V3.dup(e.offsets.neutral),
      e.offsets.last = V3.dup(e.offsets.neutral),
      geofs.camera.setFOV(e.FOV || geofs.camera.defaultFOV),
      "cockpit" == geofs.camera.currentModeName && (geofs.camera.hasMoved = !0)
  },
  setGroundAltitude: function() {
      let e = geofs.getCollisionResult(geofs.camera.lla, geofs.camera.worldPosition, geofs.aircraft.instance.collResult, geofs.camera);
      geofs.camera.groundAltitude = e.location[2]
  },
  avoidGround: function() {
      if (!(geofs.relativeAltitude > geofs.camera.groundAvoidanceIgnore)) {
          var e;
          geofs.camera.setGroundAltitude(),
          geofs.camera.lla[2] - geofs.camera.groundAltitude <= geofs.camera.groundAvoidanceMargin && (geofs.camera.lla[2] = geofs.camera.groundAltitude + geofs.camera.groundAvoidanceMargin),
          geofs.camera.hasMoved = !0
      }
  },
  getFlytToCoordinates: function() {
      geofs.camera.setGroundAltitude();
      var e = clone(geofs.camera.lla);
      return e[2] = clamp(e[2], 0, 3e4),
      e[3] = geofs.camera.htr[0],
      geofs.camera.lla[2] - geofs.camera.groundAltitude < geofs.camera.groundAvoidanceMargin ? (e[2] = 0,
      e[4] = !1) : e[4] = !0,
      e
  },
  update: function(e) {
      var t = geofs.aircraft.instance;
      if (!geofs.aircraft.instance.object3d)
          return;
      var a = geofs.aircraft.instance.object3d.getWorldFrame()
        , o = geofs.camera.currentDefinition;
      if (geofs.camera.animations.orbitHorizontal.active && (geofs.camera.rotate(geofs.camera.animations.orbitHorizontal.rate * e),
      geofs.camera.saveRotation()),
      geofs.camera.animations.orbitVertical.active) {
          var r = geofs.camera.animations.orbitVertical;
          fixAngle(geofs.camera.htr[1]),
          geofs.camera.rotate(null, r.rate * e),
          geofs.camera.saveRotation()
      }
      if (o.animations)
          for (var n in o.animations) {
              var s = o.animations[n]
                , c = geofs.animation.filter(s);
              switch (s.type) {
              case "tilt":
                  if (s.lastValue == c)
                      continue;
                  geofs.camera.setRotation(null, c);
                  break;
              case "offset":
                  if (s.lastValue == c)
                      continue;
                  var d = V3.scale(s.axis, c);
                  geofs.camera.setOffsets(d[0], d[1], d[2]);
                  break;
              case "translate":
                  if (s.lastValue == c)
                      continue;
                  var d = V3.scale(s.axis, c);
                  geofs.camera.translate(d[0], d[1], d[2]);
                  break;
              case "distance":
                  if (s.lastValue == c)
                      continue;
                  o.distance = c
              }
              s.lastValue = c
          }
      if ("follow" == geofs.camera.currentModeName) {
          var u = o.orientations.current[0]
            , p = o.orientations.current[1]
            , h = 1 - Math.exp(-e / .5)
            , m = o.lastUsedHtr[0] + fixAngle(t.htr[0] - o.lastUsedHtr[0]) * h
            , f = o.lastUsedHtr[1] + fixAngle(t.htr[1] - o.lastUsedHtr[1]) * h;
          o.lastUsedHtr = [m, f, 0];
          var g = m + u
            , y = f + p
            , v = M33.rotationXYZ(M33.identity(), [y * DEGREES_TO_RAD, 0, g * DEGREES_TO_RAD]);
          geofs.camera.worldPosition = V3.add(o.position, o.offsets.current);
          var _ = M33.transform(v, geofs.camera.worldPosition)
            , b = V3.add(t.llaLocation, xyz2lla(_, t.llaLocation))
            , x = xyz2lla(V3.scale(v[1], -o.distance), b);
          geofs.camera.lla = V3.add(b, x),
          geofs.camera.avoidGround(),
          geofs.camera.htr = lookAt(b, geofs.camera.lla, [0, 0, 1]),
          geofs.camera.htr = [fixAngle360(geofs.camera.htr[0]), fixAngle360(-geofs.camera.htr[1]), 0],
          geofs.api.setCameraPositionAndOrientation(geofs.camera.cam, geofs.camera.lla, geofs.camera.htr)
      } else if ("chase" == geofs.camera.currentModeName)
          geofs.camera.avoidGround(),
          geofs.camera.lla = geofs.api.getCameraLla(geofs.camera.cam),
          controls.mouse.down || (geofs.camera.htr = lookAt(t.llaLocation, geofs.camera.lla, [0, 0, 1]),
          geofs.camera.htr = [fixAngle360(geofs.camera.htr[0]), fixAngle360(-geofs.camera.htr[1]), 0],
          geofs.api.setCameraPositionAndOrientation(geofs.camera.cam, geofs.camera.lla, geofs.camera.htr));
      else if ("free" == geofs.camera.currentModeName)
          geofs.camera.avoidGround(),
          geofs.camera.lla = geofs.api.getCameraLla(geofs.camera.cam),
          geofs.camera.htr[0] = geofs.api.getHeading(geofs.camera.cam),
          geofs.camera.htr[1] = geofs.api.getTilt(geofs.camera.cam);
      else {
          var g = o.orientations.current[0]
            , y = o.orientations.current[1]
            , S = o.orientations.current[2]
            , P = a;
          o.parent && (P = geofs.aircraft.instance.parts[o.parent].object3d.getWorldFrame());
          var v = M33.rotationXYZ(P, [-y * DEGREES_TO_RAD, S * DEGREES_TO_RAD, g * DEGREES_TO_RAD]);
          if (geofs.camera.htr = M33.getOrientation(v),
          geofs.camera.worldPosition = V3.add(o.position, o.offsets.current),
          "cockpit" == geofs.camera.currentModeName && geofs.preferences.camera.headMotion) {
              var A = V3.scale([-geofs.animation.values.accX, -geofs.animation.values.accY, -geofs.animation.values.accZ], .001 * t.definition.motionSensitivity);
              A = V3.exponentialSmoothing("lasmooth", A, .1),
              geofs.camera.motionOffset[0] = A[0] / (geofs.camera.motionRange / (geofs.camera.motionRange - geofs.camera.motionOffset[0])),
              geofs.camera.motionOffset[1] = A[1] / (geofs.camera.motionRange / (geofs.camera.motionRange - geofs.camera.motionOffset[1])),
              geofs.camera.motionOffset[2] = A[2] / (geofs.camera.motionRange / (geofs.camera.motionRange - geofs.camera.motionOffset[2])),
              geofs.camera.motionOffset = V3.clamp(geofs.camera.motionOffset, -geofs.camera.motionRange, geofs.camera.motionRange),
              geofs.camera.worldPosition = V3.add(geofs.camera.worldPosition, geofs.camera.motionOffset);
              var k = V3.scale([-geofs.animation.values.aAccX, -geofs.animation.values.aAccY, -geofs.animation.values.aAccZ], 2 * t.definition.motionSensitivity);
              k = V3.exponentialSmoothing("rasmooth", k, .1),
              geofs.camera.rotationOffset[0] = k[0] / (geofs.camera.rotationRange / (geofs.camera.rotationRange - geofs.camera.rotationOffset[0])),
              geofs.camera.rotationOffset[1] = k[1] / (geofs.camera.rotationRange / (geofs.camera.rotationRange - geofs.camera.rotationOffset[1])),
              geofs.camera.rotationOffset[2] = k[2] / (geofs.camera.rotationRange / (geofs.camera.rotationRange - geofs.camera.rotationOffset[2])),
              geofs.camera.rotationOffset = V3.clamp(geofs.camera.rotationOffset, -geofs.camera.rotationRange, geofs.camera.rotationRange),
              geofs.camera.htr = V3.add(geofs.camera.htr, [geofs.camera.rotationOffset[2], geofs.camera.rotationOffset[0], geofs.camera.rotationOffset[1]]),
              geofs.camera.hasMoved = !0
          }
          geofs.camera.worldPosition = t.object3d.setVectorWorldPosition(geofs.camera.worldPosition),
          "cockpit" == geofs.camera.currentModeName && (geofs.camera.worldPosition = V3.scale(geofs.camera.worldPosition, geofs.aircraft.instance.definition.cockpitScaleFix)),
          o.parent && (geofs.camera.worldPosition = V3.add(geofs.camera.worldPosition, geofs.aircraft.instance.parts[o.parent].object3d.getWorldPosition())),
          geofs.camera.lla = V3.add(t.llaLocation, xyz2lla(geofs.camera.worldPosition, t.llaLocation)),
          geofs.camera.avoidGround(),
          geofs.camera.htr = [fixAngle360(geofs.camera.htr[0]), fixAngle360(-geofs.camera.htr[1]), -geofs.camera.htr[2]],
          geofs.api.setCameraPositionAndOrientation(geofs.camera.cam, geofs.camera.lla, geofs.camera.htr)
      }
      geofs.camera.radianRoll = geofs.camera.htr[2] * DEGREES_TO_RAD;
      let T = V3.normalize(lla2xyz(V3.sub(geofs.camera.lla, t.llaLocation), geofs.camera.lla));
      geofs.camera.dotAircraftForward = V3.dot(T, a[1]),
      geofs.camera.openSlave && geofs.camera.updateSlaveData(),
      "cockpit" == geofs.camera.currentModeName && geofs.camera.hasMoved && (instruments.updateCockpitPositions(),
      geofs.camera.hasMoved = !1)
  },
  openSlaveWindow: function(e) {
      var t = "left=" + ((window.screenX || window.screenLeft) + e * (window.outerWidth || 1024));
      window.open("slave.php?order=" + e, ("geofsSlave" + e).replace("-", "l"), t) && (geofs.camera.openSlave = !0)
  },
  updateSlaveData: function() {
      geofs.camera.transform = M33.setFromEuler([-geofs.camera.htr[1] * DEGREES_TO_RAD, -geofs.camera.htr[2] * DEGREES_TO_RAD, geofs.camera.htr[0] * DEGREES_TO_RAD])
  }
};
var instruments = window.instruments || {};
instruments.stackPosition = {
  x: 100,
  y: 0
},
instruments.margins = [0, 0, 0, 0],
instruments.defaultMargin = 10,
instruments.visible = !0,
instruments.list = {},
instruments.gaugesBackgroundOpacity = .4,
instruments.definitions = {
  airspeed: {
      container: ".geofs-instruments-container",
      stackX: !0,
      compositors: "canvas,css",
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              animations: [{
                  type: "rotate",
                  value: "kias",
                  ratio: -1.5,
                  min: 0
              }],
              url: "images/instruments/airspeed-hand.png",
              anchor: {
                  x: 10,
                  y: 34
              },
              size: {
                  x: 20,
                  y: 120
              },
              position: {
                  x: 0,
                  y: 0
              },
              class: "APPLegacyOverlayReordering"
          }, {
              url: "images/instruments/airspeed-raw.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }]
      }
  },
  airspeedArcs: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      stackX: !0,
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              url: "images/instruments/airspeed-raw.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "kias",
                  ratio: -1.5,
                  min: 0
              }],
              url: "images/instruments/airspeed-hand.png",
              anchor: {
                  x: 10,
                  y: 34
              },
              size: {
                  x: 20,
                  y: 120
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              url: "/images/instruments/airspeed-yellow-arc.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              },
              animations: [{
                  type: "rotate",
                  offset: 60,
                  function: "{return geofs.aircraft.instance.definition.Vspeeds.VNE}",
                  ratio: -1.5
              }]
          }, {
              url: "/images/instruments/airspeed-yellow-arc.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              },
              animations: [{
                  type: "rotate",
                  function: "{return geofs.aircraft.instance.definition.Vspeeds.VNO}",
                  ratio: -1.5
              }, {
                  type: "show",
                  function: "{return geofs.aircraft.instance.definition.Vspeeds.VNE - geofs.aircraft.instance.definition.Vspeeds.VNO > 40}"
              }]
          }, {
              url: "/images/instruments/airspeed-red-mark.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              },
              animations: [{
                  type: "rotate",
                  function: "{return geofs.aircraft.instance.definition.Vspeeds.VNE}",
                  ratio: -1.5
              }]
          }, {
              url: "/images/instruments/airspeed-green-arc.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              },
              animations: [{
                  type: "rotate",
                  function: "{return geofs.aircraft.instance.definition.Vspeeds.VS}",
                  ratio: -1.5
              }]
          }, {
              url: "/images/instruments/airspeed-green-arc.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              },
              animations: [{
                  type: "rotate",
                  function: "{return geofs.aircraft.instance.definition.Vspeeds.VS + 40}",
                  ratio: -1.5
              }, {
                  type: "show",
                  function: "{return geofs.aircraft.instance.definition.Vspeeds.VNO - geofs.aircraft.instance.definition.Vspeeds.VS > 80}"
              }]
          }, {
              url: "/images/instruments/airspeed-green-arc.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              },
              animations: [{
                  type: "rotate",
                  offset: 60,
                  function: "{return geofs.aircraft.instance.definition.Vspeeds.VNO}",
                  ratio: -1.5
              }]
          }, {
              url: "/images/instruments/airspeed-white-arc.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              },
              animations: [{
                  type: "rotate",
                  function: "{return geofs.aircraft.instance.definition.Vspeeds.VS0}",
                  ratio: -1.5
              }, {
                  type: "show",
                  function: "{return geofs.aircraft.instance.definition.Vspeeds.VS0 >= 0}"
              }]
          }, {
              url: "/images/instruments/airspeed-white-arc.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              },
              animations: [{
                  type: "rotate",
                  offset: 60,
                  function: "{return geofs.aircraft.instance.definition.Vspeeds.VFE}",
                  ratio: -1.5
              }, {
                  type: "show",
                  function: "{return geofs.aircraft.instance.definition.Vspeeds.VS0 >= 0}"
              }]
          }]
      }
  },
  airspeedJet: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      stackX: !0,
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              animations: [{
                  type: "rotate",
                  value: "kias",
                  ratio: -.6,
                  min: 0
              }],
              url: "images/instruments/airspeed-hand.png",
              anchor: {
                  x: 10,
                  y: 34
              },
              size: {
                  x: 20,
                  y: 120
              },
              position: {
                  x: 0,
                  y: 0
              },
              class: "APPLegacyOverlayReordering"
          }, {
              url: "images/instruments/airspeed-high.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }]
      }
  },
  airspeedSupersonic: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      stackX: !0,
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              animations: [{
                  type: "rotate",
                  value: "kias",
                  ratio: -.3,
                  min: 0
              }],
              url: "images/instruments/airspeed-hand.png",
              anchor: {
                  x: 10,
                  y: 34
              },
              size: {
                  x: 20,
                  y: 120
              },
              position: {
                  x: 0,
                  y: 0
              },
              class: "APPLegacyOverlayReordering"
          }, {
              url: "images/instruments/airspeed-supersonic.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }, {
              url: "images/instruments/machsubindicator.png",
              class: "geofs-overlay-moreTransparence",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "mach",
                  ratio: -72,
                  min: 0
              }],
              url: "images/instruments/mach-hand.png",
              anchor: {
                  x: 5,
                  y: 5
              },
              size: {
                  x: 11,
                  y: 31
              },
              position: {
                  x: -70,
                  y: -70
              }
          }]
      }
  },
  altitude_legacy: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      stackX: !0,
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              url: "images/instruments/altitude.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "altitude",
                  ratio: -.0036
              }],
              url: "images/instruments/tenthousandhand.png",
              anchor: {
                  x: 8,
                  y: 0
              },
              size: {
                  x: 16,
                  y: 91
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "altitude",
                  ratio: -.036
              }],
              url: "images/instruments/small-hand.png",
              anchor: {
                  x: 10,
                  y: 28
              },
              size: {
                  x: 20,
                  y: 87
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "altitude",
                  ratio: -.36
              }],
              url: "images/instruments/airspeed-hand.png",
              anchor: {
                  x: 10,
                  y: 34
              },
              size: {
                  x: 20,
                  y: 120
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  altitude: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      stackX: !0,
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              url: "images/instruments/altitude2/altitude.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "altitude",
                  ratio: -.011,
                  preoffset: -1e4,
                  min: 1e4,
                  max: 15e3
              }],
              url: "images/instruments/altitude2/stripe_mask.png",
              class: "geofs-instrument-background",
              anchor: {
                  x: 58,
                  y: 54
              },
              size: {
                  x: 116,
                  y: 111
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "altitude",
                  ratio: -.0036
              }],
              url: "images/instruments/tenthousandhand.png",
              anchor: {
                  x: 8,
                  y: 0
              },
              size: {
                  x: 16,
                  y: 91
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "altitude",
                  ratio: -.036
              }],
              url: "images/instruments/small-hand.png",
              anchor: {
                  x: 10,
                  y: 28
              },
              size: {
                  x: 20,
                  y: 87
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "altitude",
                  ratio: -.36
              }],
              url: "images/instruments/airspeed-hand.png",
              anchor: {
                  x: 10,
                  y: 34
              },
              size: {
                  x: 20,
                  y: 120
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  vario: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      stackX: !0,
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              url: "images/instruments/vario.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "verticalSpeed",
                  ratio: -.09,
                  max: 1900,
                  min: -1900,
                  offset: 90
              }],
              url: "images/instruments/airspeed-hand.png",
              anchor: {
                  x: 10,
                  y: 34
              },
              size: {
                  x: 20,
                  y: 120
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  varioJet: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      stackX: !0,
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              url: "images/instruments/vario-high.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "verticalSpeed",
                  ratio: -.025,
                  max: 6e3,
                  min: -6e3,
                  offset: 90
              }],
              url: "images/instruments/airspeed-hand.png",
              anchor: {
                  x: 10,
                  y: 34
              },
              size: {
                  x: 20,
                  y: 120
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  compass: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      stackX: !0,
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              animations: [{
                  type: "rotate",
                  value: "heading",
                  ratio: 1
              }],
              url: "images/instruments/compass-grad.png",
              anchor: {
                  x: 90,
                  y: 90
              },
              size: {
                  x: 181,
                  y: 181
              },
              position: {
                  x: 0,
                  y: 0
              },
              overlays: [{
                  animations: [{
                      type: "rotate",
                      value: "navHDG",
                      ratio: -1
                  }],
                  url: "images/instruments/hdg-bug.png",
                  anchor: {
                      x: 100,
                      y: 100
                  },
                  size: {
                      x: 200,
                      y: 200
                  },
                  position: {
                      x: 0,
                      y: 0
                  }
              }]
          }, {
              url: "images/instruments/compass-hand.png",
              anchor: {
                  x: 25,
                  y: 26
              },
              size: {
                  x: 50,
                  y: 109
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              url: "images/instruments/hdg-knob.png",
              class: "geofs-overlay-moreTransparence",
              drawOrder: 200,
              anchor: {
                  x: 22,
                  y: 22
              },
              size: {
                  x: 44,
                  y: 44
              },
              position: {
                  x: 80,
                  y: -80
              },
              iconFrame: {
                  x: 44,
                  y: 44
              },
              manipulator(e, t) {
                  instruments.manipulators.setHDG(e, t)
              },
              animations: [{
                  type: "rotate",
                  value: "navHDG",
                  ratio: -2
              }]
          }]
      }
  },
  turncoordinator: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      stackX: !0,
      overlay: {
          url: "images/instruments/turncoordinator/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              animations: [{
                  type: "rotate",
                  value: "slipball",
                  ratio: -4,
                  fmin: -10,
                  fmax: 10
              }],
              url: "images/instruments/turncoordinator/ball.png",
              anchor: {
                  x: 100,
                  y: 300
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 200
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "turnrate",
                  ratio: -.11,
                  fmin: -40,
                  fmax: 40
              }],
              url: "images/instruments/turncoordinator/hand.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              url: "images/instruments/turncoordinator/markings.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }]
      }
  },
  attitude: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      stackX: !0,
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              url: "images/instruments/attitude.png",
              class: "geofs-instrument-background",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "aroll",
                  name: "attitude",
                  ratio: -1,
                  min: -50,
                  max: 50
              }, {
                  type: "translateY",
                  value: "atilt",
                  ratio: -2,
                  offset: 50,
                  min: -25,
                  max: 25
              }],
              url: "images/instruments/attitude-hand.png",
              maskUrl: "images/instruments/attitude-mask.png",
              clip: [100, 100, 71],
              class: "geofs-overlay-moreTransparence",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 300
              },
              position: {
                  x: 0,
                  y: 0
              },
              iconFrame: {
                  x: 200,
                  y: 200
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "aroll",
                  ratio: -1,
                  min: -60,
                  max: 60
              }],
              url: "images/instruments/attitude-grad.png",
              class: "geofs-overlay-moreTransparence",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              url: "images/instruments/attitude-pointer.png",
              class: "geofs-overlay-keepOpaque",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  attitudeJet: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      stackX: !0,
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              animations: [{
                  type: "rotate",
                  value: "aroll",
                  ratio: -1,
                  min: -180,
                  max: 180
              }, {
                  type: "translateY",
                  value: "atilt",
                  ratio: -2,
                  offset: 300,
                  min: -90,
                  max: 90
              }],
              url: "images/instruments/attitude-jet-hand.png",
              maskUrl: "images/instruments/attitude-jet-mask.png",
              clip: [100, 100, 71],
              class: "geofs-overlay-moreTransparence",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 800
              },
              position: {
                  x: 0,
                  y: 0
              },
              iconFrame: {
                  x: 200,
                  y: 200
              }
          }, {
              url: "images/instruments/attitude-jet.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "aroll",
                  ratio: -1,
                  min: -60,
                  max: 60
              }],
              url: "images/instruments/attitude-jet-pointer.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  rpm3000: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      stackX: !0,
      hideOnMobile: !0,
      position: {
          x: 100,
          y: 100
      },
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 100,
              y: 100
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 50,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              url: "images/instruments/RPM3000/rpm3000.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 100,
                  y: 100
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "rpm",
                  ratio: -.09,
                  offset: 160
              }],
              url: "images/instruments/rpm-hand.png",
              anchor: {
                  x: 14,
                  y: 14
              },
              size: {
                  x: 28,
                  y: 55
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  rpm: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      hideOnMobile: !0,
      stackX: !0,
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 100,
              y: 100
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 50,
              y: 50
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              url: "images/instruments/rpm.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 100,
                  y: 100
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "rpm",
                  ratio: -.03,
                  offset: 120
              }],
              url: "images/instruments/rpm-hand.png",
              anchor: {
                  x: 14,
                  y: 14
              },
              size: {
                  x: 28,
                  y: 55
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  rpmJet: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      hideOnMobile: !0,
      stackX: !0,
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              url: "images/instruments/jet-rpm.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "rpm",
                  ratio: -.036,
                  offset: 0
              }],
              url: "images/instruments/jet-rpm-hand.png",
              anchor: {
                  x: 6,
                  y: 15
              },
              size: {
                  x: 14,
                  y: 34
              },
              position: {
                  x: -38,
                  y: 45
              }
          }, {
              animations: [{
                  type: "rotate",
                  value: "rpm",
                  ratio: -.027,
                  offset: 0
              }],
              url: "images/instruments/airspeed-hand.png",
              anchor: {
                  x: 10,
                  y: 34
              },
              size: {
                  x: 20,
                  y: 120
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  adf: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      stackX: !0,
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              url: "images/instruments/cdi/background.png",
              class: "geofs-instrument-background",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }, {
              url: "images/instruments/adf/needle.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              },
              iconFrame: {
                  x: 200,
                  y: 200
              },
              offset: {
                  x: 0,
                  y: 0
              },
              animations: [{
                  type: "rotate",
                  value: "ADFBearingToStation",
                  ratio: 1
              }]
          }, {
              url: "images/instruments/cdi/compass.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              },
              animations: [{
                  type: "rotate",
                  value: "ADFManCourse",
                  ratio: 1
              }]
          }, {
              url: "images/instruments/adf/cover.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              url: "images/instruments/adf/VARKnob.png",
              class: "geofs-overlay-moreTransparence",
              drawOrder: 200,
              anchor: {
                  x: 22,
                  y: 22
              },
              size: {
                  x: 44,
                  y: 44
              },
              position: {
                  x: -80,
                  y: -80
              },
              iconFrame: {
                  x: 44,
                  y: 44
              },
              manipulator(e, t) {
                  instruments.manipulators.setADFManCourse(e, t)
              },
              animations: [{
                  type: "rotate",
                  value: "ADFManCourse",
                  ratio: -2
              }]
          }]
      }
  },
  rmi: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      stackX: !0,
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              url: "images/instruments/rmi/background.png",
              class: "geofs-instrument-background",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }, {
              url: "images/instruments/rmi/ADFNeedle.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              },
              iconFrame: {
                  x: 200,
                  y: 200
              },
              offset: {
                  x: 0,
                  y: 0
              },
              animations: [{
                  type: "rotate",
                  value: "ADFBearingToStation",
                  ratio: 1
              }]
          }, {
              url: "images/instruments/rmi/VORNeedle.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              },
              iconFrame: {
                  x: 200,
                  y: 200
              },
              offset: {
                  x: 0,
                  y: 0
              },
              animations: [{
                  type: "rotate",
                  value: "NAVBearingToStation",
                  ratio: 1
              }]
          }, {
              url: "images/instruments/rmi/compass.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              },
              animations: [{
                  type: "rotate",
                  value: "heading",
                  ratio: 1
              }]
          }, {
              url: "images/instruments/rmi/cover.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  cdi: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      stackX: !0,
      overlay: {
          url: "images/instruments/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              url: "images/instruments/cdi/background.png",
              class: "geofs-instrument-background",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }, {
              url: "images/instruments/cdi/cross.png",
              class: "geofs-instrument-background",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }, {
              url: "images/instruments/cdi/grads.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              }
          }, {
              url: "images/instruments/cdi/to.png",
              size: {
                  x: 30,
                  y: 13
              },
              position: {
                  x: 17,
                  y: 27
              },
              animations: [{
                  type: "show",
                  value: "NAVDirection",
                  eq: "to"
              }]
          }, {
              url: "images/instruments/cdi/from.png",
              size: {
                  x: 44,
                  y: 13
              },
              position: {
                  x: 17,
                  y: 12
              },
              animations: [{
                  type: "show",
                  value: "NAVDirection",
                  eq: "from"
              }]
          }, {
              url: "images/instruments/cdi/navvloc.png",
              size: {
                  x: 36,
                  y: 24
              },
              position: {
                  x: -50,
                  y: 15
              },
              animations: [{
                  type: "show",
                  value: "NAVMODE",
                  eq: "NAV"
              }]
          }, {
              url: "images/instruments/cdi/gps.png",
              size: {
                  x: 27,
                  y: 10
              },
              position: {
                  x: -45,
                  y: -30
              },
              animations: [{
                  type: "show",
                  value: "NAVMODE",
                  eq: "GPS"
              }]
          }, {
              url: "images/instruments/cdi/navflag.png",
              class: "geofs-overlay-moreTransparence",
              size: {
                  x: 24,
                  y: 11
              },
              position: {
                  x: -12,
                  y: -60
              },
              animations: [{
                  type: "show",
                  value: "NAVLNAV",
                  lt: 1
              }]
          }, {
              url: "images/instruments/cdi/gsflag.png",
              class: "geofs-overlay-moreTransparence",
              size: {
                  x: 11,
                  y: 24
              },
              position: {
                  x: 55,
                  y: -12
              },
              animations: [{
                  type: "show",
                  value: "NAVVNAV",
                  lt: 1
              }]
          }, {
              url: "images/instruments/cdi/coursedeviationneedle.png",
              anchor: {
                  x: 1,
                  y: 100
              },
              size: {
                  x: 6,
                  y: 129
              },
              position: {
                  x: -100,
                  y: -25
              },
              iconFrame: {
                  x: 200,
                  y: 200
              },
              offset: {
                  x: 100,
                  y: 0
              },
              animations: [{
                  type: "translateX",
                  value: "NAVCourseDeviation",
                  ratio: 5,
                  fmin: -50,
                  fmax: 50
              }]
          }, {
              url: "images/instruments/cdi/glideslopeneedle.png",
              anchor: {
                  x: 100,
                  y: 1
              },
              size: {
                  x: 125,
                  y: 6
              },
              position: {
                  x: 25,
                  y: -100
              },
              iconFrame: {
                  x: 200,
                  y: 200
              },
              offset: {
                  x: 0,
                  y: -100
              },
              animations: [{
                  type: "translateY",
                  value: "NAVGlideAngleDeviation",
                  ratio: -60,
                  fmin: -60,
                  fmax: 60
              }]
          }, {
              url: "images/instruments/cdi/compass.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              },
              animations: [{
                  type: "rotate",
                  value: "NAVOBS",
                  ratio: 1
              }]
          }, {
              url: "images/instruments/cdi/cover.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              url: "images/instruments/cdi/obs.png",
              class: "geofs-overlay-moreTransparence",
              drawOrder: 500,
              anchor: {
                  x: 22,
                  y: 22
              },
              size: {
                  x: 44,
                  y: 44
              },
              position: {
                  x: -80,
                  y: -80
              },
              iconFrame: {
                  x: 44,
                  y: 44
              },
              manipulator(e, t) {
                  instruments.manipulators.setNAVOBS(e, t)
              },
              animations: [{
                  type: "rotate",
                  value: "NAVOBS",
                  ratio: -2
              }]
          }]
      }
  },
  hsi: {
      container: ".geofs-instruments-container",
      compositors: "canvas,css",
      stackX: !0,
      overlay: {
          url: "images/instruments/hsi/background.png",
          class: "geofs-instrument-background",
          size: {
              x: 200,
              y: 200
          },
          anchor: {
              x: 100,
              y: 100
          },
          position: {
              x: 100,
              y: 100
          },
          rescale: !0,
          rescalePosition: !0,
          overlays: [{
              url: "images/instruments/hsi/glideslopegrades.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              },
              iconFrame: {
                  x: 200,
                  y: 200
              }
          }, {
              url: "images/instruments/hsi/glideslopeindicators.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 182,
                  y: 13
              },
              position: {
                  x: 0,
                  y: 0
              },
              iconFrame: {
                  x: 200,
                  y: 200
              },
              offset: {
                  x: 9,
                  y: -94
              },
              animations: [{
                  type: "translateY",
                  value: "NAVGlideAngleDeviation",
                  ratio: -60,
                  fmin: -40,
                  fmax: 40
              }]
          }, {
              url: "images/instruments/hsi/compass.png",
              anchor: {
                  x: 100,
                  y: 100
              },
              size: {
                  x: 200,
                  y: 200
              },
              position: {
                  x: 0,
                  y: 0
              },
              animations: [{
                  type: "rotate",
                  value: "heading",
                  ratio: 1
              }],
              overlays: [{
                  url: "images/instruments/hsi/bar.png",
                  class: "geofs-instrument-background",
                  anchor: {
                      x: 100,
                      y: 100
                  },
                  size: {
                      x: 200,
                      y: 200
                  },
                  animations: [{
                      type: "rotate",
                      value: "NAVOBS",
                      ratio: -1
                  }]
              }, {
                  url: "images/instruments/hsi/grads.png",
                  anchor: {
                      x: 100,
                      y: 100
                  },
                  size: {
                      x: 200,
                      y: 200
                  },
                  animations: [{
                      type: "rotate",
                      value: "NAVOBS",
                      ratio: -1
                  }]
              }, {
                  url: "images/instruments/hsi/to.png",
                  anchor: {
                      x: 100,
                      y: 100
                  },
                  size: {
                      x: 15,
                      y: 14
                  },
                  position: {
                      x: 0,
                      y: 0
                  },
                  iconFrame: {
                      x: 200,
                      y: 200
                  },
                  offset: {
                      x: 110,
                      y: 69
                  },
                  animations: [{
                      type: "show",
                      value: "NAVDirection",
                      eq: "to"
                  }, {
                      type: "rotate",
                      value: "NAVOBS",
                      ratio: -1
                  }]
              }, {
                  url: "images/instruments/hsi/from.png",
                  anchor: {
                      x: 100,
                      y: 100
                  },
                  size: {
                      x: 15,
                      y: 14
                  },
                  position: {
                      x: 0,
                      y: 0
                  },
                  iconFrame: {
                      x: 200,
                      y: 200
                  },
                  offset: {
                      x: 110,
                      y: 115
                  },
                  animations: [{
                      type: "show",
                      value: "NAVDirection",
                      eq: "from"
                  }, {
                      type: "rotate",
                      value: "NAVOBS",
                      ratio: -1
                  }]
              }, {
                  url: "images/instruments/hsi/white-needle.png",
                  anchor: {
                      x: 100,
                      y: 100
                  },
                  size: {
                      x: 200,
                      y: 200
                  },
                  position: {
                      x: 0,
                      y: 0
                  },
                  iconFrame: {
                      x: 200,
                      y: 200
                  },
                  offset: {
                      x: 0,
                      y: 0
                  },
                  animations: [{
                      type: "rotate",
                      value: "NAVOBS",
                      ratio: -1
                  }]
              }, {
                  url: "images/instruments/hsi/yellowbar.png",
                  anchor: {
                      x: 100,
                      y: 100
                  },
                  size: {
                      x: 4,
                      y: 80
                  },
                  position: {
                      x: 0,
                      y: 0
                  },
                  iconFrame: {
                      x: 200,
                      y: 200
                  },
                  offset: {
                      x: 98,
                      y: 60
                  },
                  animations: [{
                      type: "translateX",
                      value: "NAVCourseDeviation",
                      ratio: 5,
                      fmin: -50,
                      fmax: 50
                  }, {
                      type: "rotate",
                      value: "NAVOBS",
                      ratio: -1
                  }]
              }, {
                  url: "images/instruments/hsi/bug.png",
                  anchor: {
                      x: 100,
                      y: 100
                  },
                  size: {
                      x: 20,
                      y: 16
                  },
                  position: {
                      x: 0,
                      y: 0
                  },
                  iconFrame: {
                      x: 200,
                      y: 200
                  },
                  offset: {
                      x: 90,
                      y: 21
                  },
                  animations: [{
                      type: "rotate",
                      value: "navHDG",
                      ratio: -1
                  }]
              }]
          }, {
              url: "images/instruments/hsi/nav.png",
              class: "geofs-overlay-moreTransparence",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 41,
                  y: 24
              },
              position: {
                  x: -56,
                  y: 52
              },
              animations: [{
                  type: "show",
                  value: "NAVLNAV",
                  lt: 1
              }]
          }, {
              url: "images/instruments/hsi/courseknob.png",
              class: "geofs-overlay-moreTransparence",
              drawOrder: 200,
              anchor: {
                  x: 22,
                  y: 22
              },
              size: {
                  x: 44,
                  y: 44
              },
              position: {
                  x: -80,
                  y: -80
              },
              iconFrame: {
                  x: 44,
                  y: 44
              },
              manipulator(e, t) {
                  instruments.manipulators.setNAVOBS(e, t)
              },
              animations: [{
                  type: "rotate",
                  value: "NAVOBS",
                  ratio: -2
              }]
          }, {
              url: "images/instruments/hsi/headingknob.png",
              class: "geofs-overlay-moreTransparence",
              drawOrder: 200,
              anchor: {
                  x: 22,
                  y: 22
              },
              size: {
                  x: 44,
                  y: 44
              },
              position: {
                  x: 80,
                  y: -80
              },
              iconFrame: {
                  x: 44,
                  y: 44
              },
              manipulator(e, t) {
                  instruments.manipulators.setHDG(e, t)
              },
              animations: [{
                  type: "rotate",
                  value: "navHDG",
                  ratio: -2
              }]
          }, {
              url: "images/instruments/hsi/plane.png",
              anchor: {
                  x: 21,
                  y: 23
              },
              size: {
                  x: 42,
                  y: 46
              },
              position: {
                  x: 0,
                  y: -7
              }
          }]
      }
  },
  wind: {
      container: ".geofs-wind-container",
      overlay: {
          url: "images/instruments/wind/plane.png",
          anchor: {
              x: 0,
              y: 0
          },
          alignment: {
              x: "left",
              y: "bottom"
          },
          position: {
              x: 0,
              y: 0
          },
          rescale: !1,
          rescalePosition: !1,
          size: {
              x: 50,
              y: 50
          },
          class: "control-pad",
          overlays: [{
              animations: [{
                  type: "rotate",
                  value: "relativeWind",
                  ratio: -1
              }],
              url: "images/instruments/wind/pointer.png",
              anchor: {
                  x: 25,
                  y: 25
              },
              size: {
                  x: 50,
                  y: 50
              },
              position: {
                  x: 26,
                  y: 23
              }
          }, {
              animations: [{
                  type: "text",
                  value: "windSpeedLabel"
              }],
              text: "-",
              class: "control-pad-sticker",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 40,
                  y: 12
              },
              position: {
                  x: 5,
                  y: -8
              }
          }, {
              text: "wind",
              class: "control-pad-label",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 15
              },
              position: {
                  x: 0,
                  y: 40
              }
          }]
      }
  },
  trim: {
      group: "controls",
      container: ".geofs-pads-container",
      overlay: {
          anchor: {
              x: 0,
              y: 0
          },
          alignment: {
              x: "right",
              y: "bottom"
          },
          position: {
              x: 60,
              y: 240
          },
          inline: !0,
          rescale: !1,
          rescalePosition: !1,
          size: {
              x: 50,
              y: 50
          },
          class: "control-pad trim-overlay",
          url: "images/instruments/trim-indicator-background.png",
          overlays: [{
              animations: [{
                  value: "trim",
                  type: "translateY",
                  ratio: 38
              }],
              url: "images/instruments/trim-indicator-hand.png",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 50
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  catapult: {
      group: "alarms",
      container: ".geofs-alarms-container",
      overlay: {
          anchor: {
              x: 0,
              y: 0
          },
          alignment: {
              x: "right",
              y: "bottom"
          },
          position: {
              x: 0,
              y: 0
          },
          inline: !0,
          rescale: !1,
          rescalePosition: !1,
          size: {
              x: 100,
              y: 25
          },
          animations: [{
              value: "onCatapult",
              type: "show",
              when: [1]
          }],
          class: "control-pad-transparent",
          overlays: [{
              class: "control-pad-dyn-label green-pad",
              animations: [{
                  value: "catapult",
                  type: "show",
                  whenNot: [1]
              }],
              text: "ON CATAPULT",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 100,
                  y: 25
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              animations: [{
                  value: "catapult",
                  type: "show",
                  when: [1]
              }],
              text: "CATAPULT",
              class: "control-pad-dyn-label orange-pad",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 100,
                  y: 25
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  stall: {
      group: "alarms",
      container: ".geofs-alarms-container",
      overlay: {
          anchor: {
              x: 0,
              y: 0
          },
          alignment: {
              x: "right",
              y: "bottom"
          },
          position: {
              x: 0,
              y: 0
          },
          inline: !0,
          rescale: !1,
          rescalePosition: !1,
          size: {
              x: 100,
              y: 25
          },
          animations: [{
              value: "stalling",
              type: "show",
              when: [1]
          }],
          class: "control-pad-transparent orange-pad control-pad-dyn-label",
          text: "STALL"
      }
  },
  optionx: {
      group: "controls",
      container: ".geofs-pads-container",
      overlay: {
          anchor: {
              x: 0,
              y: 0
          },
          alignment: {
              x: "right",
              y: "bottom"
          },
          position: {
              x: 60,
              y: 10
          },
          inline: !0,
          rescale: !1,
          rescalePosition: !1,
          size: {
              x: 50,
              y: 25
          },
          class: "control-pad",
          manipulator: {
              setter: "setOptionalAnimatedPart"
          },
          overlays: [{
              class: "control-pad-dyn-label",
              text: "OPTION",
              drawOrder: 1,
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 25
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              animations: [{
                  value: "optionalAnimatedPartPosition",
                  type: "scaleFrameY",
                  ratio: 50
              }],
              class: "blue-pad",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 25
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  optionz: {
      group: "controls",
      container: ".geofs-pads-container",
      overlay: {
          anchor: {
              x: 0,
              y: 0
          },
          alignment: {
              x: "right",
              y: "bottom"
          },
          position: {
              x: 60,
              y: 10
          },
          inline: !0,
          rescale: !1,
          rescalePosition: !1,
          size: {
              x: 50,
              y: 25
          },
          class: "control-pad",
          manipulator: {
              setter: "setAccessories"
          },
          overlays: [{
              class: "control-pad-dyn-label",
              text: "ACCES",
              drawOrder: 1,
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 25
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              animations: [{
                  value: "accessoriesPosition",
                  type: "scaleFrameY",
                  ratio: 50
              }],
              class: "blue-pad",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 25
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  brakes: {
      group: "controls",
      container: ".geofs-pads-container",
      overlay: {
          anchor: {
              x: 0,
              y: 0
          },
          alignment: {
              x: "right",
              y: "bottom"
          },
          position: {
              x: 60,
              y: 10
          },
          inline: !0,
          rescale: !1,
          rescalePosition: !1,
          size: {
              x: 50,
              y: 45
          },
          class: "control-pad brakes-overlay",
          manipulator: {
              setter: "toggleParkingBrake"
          },
          overlays: [{
              animations: [{
                  value: "brakes",
                  type: "show",
                  when: [1]
              }],
              class: "control-pad-dyn-label orange-pad",
              text: "BRAKES<br/>ON",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 45
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              animations: [{
                  value: "brakes",
                  type: "show",
                  when: [0]
              }],
              class: "control-pad-dyn-label",
              text: "BRAKES",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 45
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  gear: {
      group: "controls",
      container: ".geofs-pads-container",
      overlay: {
          anchor: {
              x: 0,
              y: 0
          },
          alignment: {
              x: "right",
              y: "bottom"
          },
          position: {
              x: 60,
              y: 60
          },
          inline: !0,
          rescale: !1,
          rescalePosition: !1,
          size: {
              x: 50,
              y: 45
          },
          class: "control-pad gear-overlay",
          manipulator: {
              setter: "setGear"
          },
          overlays: [{
              animations: [{
                  value: "gearPosition",
                  type: "show",
                  when: [0]
              }],
              drawOrder: 1,
              class: "control-pad-dyn-label green-pad",
              text: "GEAR<br/>DOWN",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 45
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              animations: [{
                  value: "gearPosition",
                  type: "show",
                  when: [1]
              }],
              drawOrder: 1,
              class: "control-pad-dyn-label",
              text: "GEAR<br/>UP",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 45
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              animations: [{
                  value: "gearPosition",
                  type: "show",
                  whenNot: [0, 1]
              }],
              drawOrder: 1,
              class: "control-pad-dyn-label",
              text: "GEAR<br/>TRANS",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 45
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              animations: [{
                  value: "invGearPosition",
                  type: "scaleFrameY",
                  ratio: 50
              }, {
                  value: "gearPosition",
                  type: "show",
                  whenNot: [0, 1]
              }],
              inline: !0,
              class: "orange-pad",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 45
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  flaps: {
      group: "controls",
      container: ".geofs-pads-container",
      overlay: {
          anchor: {
              x: 0,
              y: 0
          },
          alignment: {
              x: "right",
              y: "bottom"
          },
          position: {
              x: 60,
              y: 120
          },
          inline: !0,
          rescale: !1,
          rescalePosition: !1,
          size: {
              x: 50,
              y: 45
          },
          class: "control-pad flaps-overlay",
          manipulator: {
              setter: "cycleFlaps"
          },
          overlays: [{
              animations: [{
                  type: "text",
                  value: "",
                  concat: ["FLAPS<br/>", "flapsTarget", " / ", "flapsSteps"]
              }],
              drawOrder: 1,
              class: "control-pad-dyn-label",
              text: "0",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 45
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              animations: [{
                  value: "flapsPositionRatio",
                  type: "scaleFrameY",
                  ratio: 50
              }, {
                  value: "flapsPositionRatio",
                  type: "show",
                  whenNot: [0]
              }],
              inline: !0,
              alignment: {
                  x: "right",
                  y: "top"
              },
              class: "blue-pad",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 45
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  },
  spoilers: {
      group: "controls",
      container: ".geofs-pads-container",
      overlay: {
          anchor: {
              x: 0,
              y: 0
          },
          alignment: {
              x: "right",
              y: "bottom"
          },
          position: {
              x: 60,
              y: 180
          },
          inline: !0,
          rescale: !1,
          rescalePosition: !1,
          size: {
              x: 50,
              y: 45
          },
          class: "control-pad spoiler-overlay",
          manipulator: {
              setter: "setAirbrakes"
          },
          overlays: [{
              animations: [{
                  value: "airbrakesPosition",
                  type: "show",
                  when: [0]
              }],
              drawOrder: 1,
              class: "control-pad-dyn-label",
              text: "SPLR<br/>RET",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 45
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              animations: [{
                  value: "airbrakesPosition",
                  type: "show",
                  whenNot: [0]
              }],
              drawOrder: 1,
              class: "control-pad-dyn-label",
              text: "SPLR<br/>DEP",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 45
              },
              position: {
                  x: 0,
                  y: 0
              }
          }, {
              animations: [{
                  value: "airbrakesPosition",
                  type: "scaleFrameY",
                  ratio: 50
              }],
              class: "orange-pad",
              anchor: {
                  x: 0,
                  y: 0
              },
              size: {
                  x: 50,
                  y: 45
              },
              position: {
                  x: 0,
                  y: 0
              }
          }]
      }
  }
},
instruments.includesDefinitions = {
  "3d-altimeter": [{
      model: "models/gauges/altimeter/altimeter.gltf"
  }, {
      name: "hundreds",
      node: "hundreds",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "altitude",
          ratio: -.36
      }]
  }, {
      name: "thousands ",
      node: "thousands",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "altitude",
          ratio: -.036
      }]
  }, {
      name: "tenthousands ",
      node: "tenthousands",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "altitude",
          ratio: -.0036
      }]
  }, {
      name: "stripe_hand ",
      node: "stripe_hand",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "altitude",
          ratio: -.011,
          preoffset: -1e4,
          min: 1e4,
          max: 15e3
      }]
  }],
  "3d-ias": [{
      model: "models/gauges/ias/ias.gltf"
  }, {
      name: "hand ",
      node: "hand",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "kias",
          ratio: -1.5,
          min: 0
      }]
  }],
  "3d-ias-arcs": [{
      model: "models/gauges/ias-arcs/ias-arcs.gltf"
  }, {
      name: "hand",
      node: "hand",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "kias",
          ratio: -1.5,
          min: 0
      }]
  }, {
      name: "yellowArc",
      node: "yellowArc",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "VNO",
          ratio: -1.5
      }]
  }, {
      name: "blackArc",
      node: "blackArc",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "VNE",
          ratio: -1.5
      }]
  }, {
      name: "greenArc",
      node: "greenArc",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "VS",
          ratio: -1.5
      }]
  }, {
      name: "whiteArc",
      node: "whiteArc",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "VS0",
          ratio: -1.5
      }]
  }, {
      name: "blackArc2",
      node: "blackArc2",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "VFE",
          ratio: -1.5
      }]
  }, ],
  "3d-ias-high": [{
      model: "models/gauges/kias-high/kiashigh.gltf"
  }, {
      name: "hand ",
      node: "kiashand",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "kias",
          ratio: -.6,
          min: 0
      }]
  }],
  "3d-ias-supersonic": [{
      model: "models/gauges/kias-supersonic/kiassupersonic.gltf"
  }, {
      name: "hand ",
      node: "kiashand",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "kias",
          ratio: -.3,
          min: 0
      }]
  }],
  "3d-compass": [{
      model: "models/gauges/compass/compass.gltf"
  }, {
      name: "compass-hand ",
      node: "compass-hand",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "heading",
          ratio: 1
      }]
  }],
  "3d-vario": [{
      model: "models/gauges/vario/vario.gltf"
  }, {
      name: "hand ",
      node: "hand",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "climbrate",
          ratio: -.09,
          max: 1900,
          min: -1900,
          offset: 90
      }]
  }],
  "3d-vario-high": [{
      model: "models/gauges/vario-high/vario-high.gltf"
  }, {
      name: "hand ",
      node: "hand",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "climbrate",
          ratio: -.025,
          max: 6e3,
          min: -6e3,
          offset: 90
      }]
  }],
  "3d-attitude": [{
      model: "models/gauges/attitude/attitude.gltf"
  }, {
      name: "hand",
      node: "hand",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "aroll",
          ratio: -1,
          min: -50,
          max: 50
      }, {
          type: "translate",
          axis: "Z",
          value: "atilt",
          ratio: 7e-4,
          min: -25,
          max: 25
      }]
  }, {
      name: "ring",
      node: "ring",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "aroll",
          ratio: -1,
          min: -50,
          max: 50
      }]
  }],
  "3d-attitude-jet": [{
      model: "models/gauges/attitude-jet/attitude.gltf"
  }, {
      name: "ball",
      node: "ball",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "aroll",
          ratio: -1
      }, {
          type: "rotate",
          axis: "X",
          value: "atilt",
          ratio: 1
      }]
  }, {
      name: "hand",
      node: "hand",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "aroll",
          ratio: -1,
          min: -50,
          max: 50
      }]
  }],
  "3d-attitude-jet2": [{
      model: "models/gauges/attitude-jet2/attitudejet.gltf"
  }, {
      name: "ball",
      node: "ball",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "aroll",
          ratio: -1
      }, {
          type: "rotate",
          axis: "X",
          value: "atilt",
          ratio: 1
      }]
  }, {
      name: "hand",
      node: "hand",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "aroll",
          ratio: -1,
          min: -50,
          max: 50
      }]
  }],
  "3d-rpm-3000": [{
      model: "models/gauges/rpm3000/rpm3000.gltf"
  }, {
      name: "hand",
      node: "hand",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "rpm",
          ratio: -.09,
          offset: 160
      }]
  }],
  "3d-rpm": [{
      model: "models/gauges/rpm/rpm.gltf"
  }, {
      name: "hand",
      node: "hand",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "rpm",
          ratio: -.03,
          offset: 120
      }]
  }],
  "3d-jet-rpm": [{
      model: "models/gauges/jet-rpm/rpm.gltf"
  }, {
      name: "hand",
      node: "hand",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "rpm",
          ratio: -.027
      }]
  }, {
      name: "smallhand",
      node: "smallhand",
      animations: [{
          type: "rotate",
          axis: "Z",
          value: "rpm",
          ratio: .036
      }]
  }],
  "3d-turn-coordinator": [{
      model: "models/gauges/turn-coordinator/turncoordinator.gltf"
  }, {
      name: "turn-rate-hand",
      node: "turn-rate-hand",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "turnrate",
          ratio: -.11,
          fmin: -40,
          fmax: 40
      }]
  }, {
      name: "ball",
      node: "ball",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "accX",
          ratio: -4,
          fmin: -15,
          fmax: 15
      }]
  }],
  "3d-gmeter": [{
      model: "models/gauges/gmeter/gmeter.gltf"
  }, {
      name: "hand ",
      node: "hand",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "accZ",
          ratio: -2.25,
          min: -30,
          max: 180,
          offset: 0
      }]
  }],
  "3d-compassball": [{
      model: "models/gauges/compassball/compassball.gltf"
  }, {
      name: "ball ",
      node: "ball",
      animations: [{
          type: "rotate",
          axis: "X",
          value: "atilt",
          ratio: -1,
          fmin: -10,
          fmax: 10
      }, {
          type: "rotate",
          axis: "Y",
          value: "aroll",
          ratio: 1,
          fmin: -10,
          fmax: 10
      }, {
          type: "rotate",
          axis: "Z",
          value: "heading360",
          ratio: -1,
          offset: 0
      }]
  }],
  "3d-manifold": [{
      model: "models/gauges/manifold/manifold.gltf"
  }, {
      name: "handmanifoldpressure",
      node: "handmanifoldpressure",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "rpm",
          ratio: -.018,
          offset: 0
      }]
  }, {
      name: "handfuelflow",
      node: "handfuelflow",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "rpm",
          ratio: -.028,
          offset: 0
      }]
  }],
  "3d-oil": [{
      model: "models/gauges/oil/oil.gltf"
  }, {
      name: "handoilpressure",
      node: "handoilpressure",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "rpm",
          ratio: -.3,
          offset: 0,
          fmin: -120
      }]
  }, {
      name: "handoiltemp",
      node: "handoiltemp",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "rpm",
          ratio: -.1,
          offset: 0,
          fmin: -120
      }]
  }],
  "3d-cdi": [{
      model: "models/gauges/cdi/cdi.gltf"
  }, {
      name: "obsKnob",
      node: "obsKnob",
      manipulator(e, t) {
          instruments.manipulators.setNAVOBS(e, t)
      },
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "NAVOBS",
          ratio: -1
      }]
  }, {
      name: "compass",
      node: "compass",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "NAVOBS",
          ratio: 1
      }]
  }, {
      name: "courseDeviation",
      node: "courseDeviation",
      animations: [{
          type: "translate",
          axis: "X",
          value: "NAVCourseDeviation",
          ratio: .0015,
          fmin: -.02,
          fmax: .02
      }]
  }, {
      name: "glideSlope",
      node: "glideSlope",
      animations: [{
          type: "translate",
          axis: "Z",
          value: "NAVGlideAngleDeviation",
          ratio: .015,
          fmin: -.02,
          fmax: .02
      }]
  }, {
      name: "toMask",
      node: "toMask",
      animations: [{
          type: "show",
          value: "NAVDirection",
          eq: "from"
      }]
  }, {
      name: "fromMask",
      node: "fromMask",
      animations: [{
          type: "show",
          value: "NAVDirection",
          eq: "to"
      }]
  }, {
      name: "navvlocmask",
      node: "navvlocmask",
      animations: [{
          type: "hide",
          value: "NAVMODE",
          eq: "NAV"
      }]
  }, {
      name: "gpsmask",
      node: "gpsmask",
      animations: [{
          type: "hide",
          value: "NAVMODE",
          eq: "GPS"
      }]
  }, {
      name: "navflag",
      node: "navflag",
      animations: [{
          type: "show",
          value: "NAVLNAV",
          lt: 1
      }]
  }, {
      name: "gsflag",
      node: "gsflag",
      animations: [{
          type: "show",
          value: "NAVVNAV",
          lt: 1
      }]
  }],
  "3d-hsi": [{
      model: "models/gauges/hsi/hsi.gltf"
  }, {
      name: "courseKnob",
      node: "courseKnob",
      manipulator(e, t) {
          instruments.manipulators.setNAVOBS(e, t)
      },
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "NAVOBS",
          ratio: -1
      }]
  }, {
      name: "headingKnob",
      node: "headingKnob",
      manipulator(e, t) {
          instruments.manipulators.setHDG(e, t)
      },
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "navHDG",
          ratio: -1
      }]
  }, {
      name: "course",
      node: "course",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "NAVOBS",
          ratio: -1
      }]
  }, {
      name: "compass",
      node: "compass",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "heading",
          ratio: 1
      }]
  }, {
      name: "bug",
      node: "bug",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "navHDG",
          ratio: -1
      }]
  }, {
      name: "deviation",
      node: "deviation",
      animations: [{
          type: "translate",
          axis: "X",
          value: "NAVCourseDeviation",
          ratio: .001,
          fmin: -.02,
          fmax: .02
      }]
  }, {
      name: "direction",
      node: "direction",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "NAVDirection",
          eq: "from",
          ratio: 180
      }]
  }, {
      name: "glideSlope",
      node: "glideSlope",
      animations: [{
          type: "translate",
          axis: "Z",
          value: "NAVGlideAngleDeviation",
          ratio: .015,
          fmin: -.02,
          fmax: .02
      }]
  }, {
      name: "nav_flag",
      node: "nav_flag",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "NAVLNAV",
          ratio: 25
      }]
  }],
  "3d-rmi": [{
      model: "models/gauges/rmi/rmi.gltf"
  }, {
      name: "compass",
      node: "compass",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "heading",
          ratio: 1
      }]
  }, {
      name: "ADFNeedle",
      node: "ADFNeedle",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "ADFBearingToStation",
          ratio: 1
      }]
  }, {
      name: "VORNeedle",
      node: "VORNeedle",
      animations: [{
          type: "rotate",
          axis: "Y",
          value: "NAVBearingToStation",
          ratio: 1
      }]
  }],
  "3d-BoeingPFD": [{
      model: {
          url: "models/gauges/glassPanel/glassPanel.gltf",
          shader: {
              name: "glassPanel",
              textures: {
                  diffuse: ""
              }
          }
      },
      shadows: "SHADOWS_NONE",
      renderer: {
          willReadFrequently: !0,
          name: "PFDBoeing",
          width: 512,
          height: 512,
          images: {
              background: "images/instruments/BoeingPFD/background.png",
              attitude: "images/instruments/BoeingPFD/attitude.png",
              overlays: "images/instruments/BoeingPFD/overlays.png"
          }
      },
      animations: [{
          type: "render",
          value: "geofsTime"
      }]
  }],
  "3d-AirbusPFD": [{
      model: {
          url: "models/gauges/glassPanel/glassPanel.gltf",
          shader: {
              name: "glassPanel",
              textures: {
                  diffuse: ""
              }
          }
      },
      shadows: "SHADOWS_NONE",
      renderer: {
          name: "PFDAirbus",
          width: 512,
          height: 512,
          images: {
              background: "images/instruments/airbusPFD/background.png",
              attitude: "images/instruments/airbusPFD/attitude.png",
              overlays: "images/instruments/airbusPFD/overlays.png"
          }
      },
      animations: [{
          type: "render",
          value: "geofsTime"
      }]
  }],
  "3d-EICAS": [{
      model: {
          url: "models/gauges/glassPanel/EICAS.gltf",
          shader: {
              name: "glassPanel",
              textures: {
                  diffuse: ""
              }
          }
      },
      shadows: "SHADOWS_NONE",
      renderer: {
          name: "genericEICAS",
          width: 512,
          height: 512,
          images: {
              background: "images/instruments/EICAS/background.png"
          }
      },
      animations: [{
          type: "render",
          value: "geofsTime"
      }]
  }],
  "3d-HUD": [{
      model: {
          url: "models/gauges/glassPanel/HUD.gltf",
          shader: {
              name: "HUD",
              textures: {
                  diffuse: ""
              },
              translucent: !0
          }
      },
      safeTransparency: !0,
      renderer: {
          name: "genericHUD",
          width: 512,
          height: 512,
          images: {
              background: "images/instruments/glassHUD/background.png",
              overlays: "images/instruments/glassHUD/overlays.png"
          }
      },
      animations: [{
          type: "render",
          value: "geofsTime"
      }],
      shadows: "SHADOWS_NONE"
  }],
  "3d-G1000": [{
      model: {
          url: "models/gauges/glassPanel/g1000.gltf",
          shader: {
              name: "glassPanel",
              textures: {
                  diffuse: ""
              }
          }
      },
      renderer: {
          name: "G1000",
          width: 1024,
          height: 1024,
          images: {
              background: "images/instruments/G1000/background.png",
              overlays: "images/instruments/G1000/overlays.png"
          }
      },
      animations: [{
          type: "render",
          value: "geofsTime"
      }],
      shadows: "SHADOWS_NONE"
  }]
},
instruments.manipulators = {
  setNAV1OBS(e, t) {
      geofs.nav.setOBS("NAV1", null, t, !0)
  },
  setNAVOBS(e, t) {
      geofs.nav.setOBS(null, null, t, !0)
  },
  setHDG(e, t) {
      geofs.nav.setHDG(null, t, !0)
  },
  setADFManCourse(e, t) {
      geofs.nav.setADFManCourse(null, t)
  }
},
instruments.init = function(e) {
  for (var t in instruments.stackPosition = {
      x: 100,
      y: 0
  },
  geofs.includes = Object.assign(geofs.includes, instruments.includesDefinitions),
  e && "default" != e || (e = {
      compass: "",
      airspeed: "",
      attitude: "",
      altitude2: "",
      vario: "",
      rpm: "",
      brakes: ""
  }),
  "jet" == e && (e = {
      compass: "",
      airspeedJet: "",
      attitudeJet: "",
      altitude2: "",
      varioJet: "",
      rpmJet: "",
      brakes: ""
  }),
  e.stall = "",
  instruments.list)
      instruments.list[t].destroy();
  for (var t in instruments.list = {},
  instruments.groups = {},
  instruments.containers = {},
  e) {
      let a = $.extend(!0, {}, instruments.definitions[t], e[t]);
      if (a) {
          if (a.container && (instruments.containers[a.container] = instruments.containers[a.container] || $(a.container)[0]),
          a.overlay) {
              instruments.list[t] = new Indicator(a);
              var o = a.group || "all";
              instruments.groups[o] = instruments.groups[o] || {},
              instruments.groups[o][t] = instruments.list[t]
          } else
              a.include && (geofs.aircraft.instance.addParts([a]),
              geofs.aircraft.instance.parts[a.name].animations.push({
                  value: "overlaysVisibility",
                  type: "hide",
                  eq: "hidden"
              }))
      }
  }
  instruments.list.wind || (instruments.definitions.wind.visibility = !!weather.windActive,
  instruments.list.wind = new Indicator($.extend(!0, {}, instruments.definitions.wind))),
  instruments.resizeHandler || (instruments.resizeHandler = geofs.addResizeHandler( () => {
      instruments.updateScreenPositions()
  }
  ))
}
,
instruments.reset = function() {
  instruments.updateScreenPositions()
}
,
instruments.toggle = function() {
  instruments.visible ? instruments.hide() : instruments.show()
}
,
instruments.add = function(e, t) {
  instruments.list[t] = e
}
,
instruments.hide = function(e) {
  var t = instruments.list;
  for (var a in e && (t = instruments.groups[e] || {}),
  t)
      t[a].hide();
  e || (geofs.animation.values.overlaysVisibility = "hidden"),
  instruments.visible = !1
}
,
instruments.show = function(e) {
  var t = instruments.list;
  for (var a in e && (t = instruments.groups[e] || {}),
  t)
      t[a].show();
  e || (geofs.animation.values.overlaysVisibility = "visible"),
  instruments.visible = !0
}
,
instruments.setOpacity = function(e) {
  for (var t in instruments.list)
      instruments.list[t].overlay.setOpacity(e)
}
,
instruments.rescale = function() {
  for (var e in instruments.list)
      instruments.list[e].scale();
  instruments.updateCockpitPositions()
}
,
instruments.update = function(e) {
  for (var t in instruments.list)
      instruments.list[t].update(e)
}
,
instruments.updateCockpitPositions = function() {
  for (var e in instruments.list)
      instruments.list[e].updateCockpitPosition();
  instruments.update(!0)
}
,
instruments.updateScreenPositions = function() {
  let e = {};
  for (var t in instruments.list) {
      var a = instruments.list[t];
      "cockpit" == geofs.camera.currentModeName && a.definition.cockpit ? a.updateCockpitPosition() : a.overlay && (a.overlay.rotation = 0,
      a.overlay.scaleAndPlace(),
      a.definition.container && (e[a.definition.container] = e[a.definition.container] || {
          x: 0,
          y: 0
      },
      e[a.definition.container].x = Math.max(e[a.definition.container].x, a.overlay.position.x + a.overlay.size.x - a.overlay.anchor.x),
      e[a.definition.container].y = Math.max(e[a.definition.container].y, a.overlay.position.y + a.overlay.size.y - a.overlay.anchor.y)))
  }
  if ("css" == geofs.api.preferredCompositor)
      for (var t in instruments.containers)
          instruments.containers[t].style.width = e[t].x + "px",
          instruments.containers[t].style.height = e[t].y + "px";
  instruments.update(!0)
}
;
var Indicator = function(e) {
  this.definition = Object.assign({}, this.definition, e),
  this.scale();
  var t = e.overlay;
  if (t.cockpit = !!this.definition.cockpit,
  t.compositors = this.definition.compositors,
  this.visibility = void 0 == e.visibility || e.visibility,
  "css" == geofs.api.preferredCompositor) {
      if (e.stackX) {
          var a = t.position.x;
          t.position.x = instruments.stackPosition.x + a,
          instruments.stackPosition.x += t.size.x + instruments.defaultMargin
      }
      if (e.stackY) {
          var o = t.size.y / 2
            , r = t.position.y;
          t.position.y = instruments.stackPosition.y + o + r,
          instruments.stackPosition.y += t.size.y + instruments.defaultMargin + r
      }
      t.alignment && "top" == t.alignment.y ? t.position.y = t.position.y + instruments.margins[0] : t.position.y = t.position.y + instruments.margins[2],
      t.alignment && "right" == t.alignment.x ? t.position.x = t.position.x + instruments.margins[1] : t.position.x = t.position.x + instruments.margins[3]
  }
  return this.overlay = new Overlay(t,null,this.definition.container),
  this.setVisibility(this.visibility),
  this
};
Indicator.prototype.scale = function() {
  if (this.definition.cockpit && this.definition.cockpit.position) {
      var e = geofs.aircraft.instance.definition.scale * geofs.aircraft.instance.definition.cockpitScaleFix;
      this.definition.cockpit.originalScale = this.definition.cockpit.originalScale || this.definition.cockpit.scale,
      this.definition.cockpit.scale = this.definition.cockpit.originalScale * e
  }
}
,
Indicator.prototype.show = function() {
  this.overlay.setVisibility(!0),
  this.visibility = !0
}
,
Indicator.prototype.hide = function() {
  this.overlay.setVisibility(!1),
  this.visibility = !1
}
,
Indicator.prototype.setVisibility = function(e) {
  this.overlay.setVisibility(e),
  this.visibility = e
}
,
Indicator.prototype.updateCockpitPosition = function() {
  if (this.definition.cockpit) {
      var e = this.definition.cockpit.position;
      geofs.aircraft.instance.object3d.setVectorWorldPosition(e),
      e.worldPosition = V3.scale(e.worldPosition, geofs.aircraft.instance.definition.cockpitScaleFix);
      var t = V3.add(geofs.aircraft.instance.llaLocation, xyz2lla(e.worldPosition, geofs.aircraft.instance.llaLocation))
        , a = geofs.api.getScreenCoordFromLla(t);
      if (a) {
          var o = a.x
            , r = a.y
            , n = .8 / V3.length(V3.sub(geofs.camera.worldPosition, e.worldPosition)) * this.definition.cockpit.scale;
          this.overlay.scale = {
              x: n * geofs.fovScale,
              y: n * geofs.fovScale
          },
          this.overlay.position = {
              x: o,
              y: geofs.viewportHeight - r
          },
          this.overlay.rotation = .3 * fixAngle(geofs.camera.currentDefinition.orientations.current[0]),
          this.overlay.scaleAndPlace(this.overlay.scale, this.overlay.position, null, !0)
      }
  }
}
,
Indicator.prototype.update = function(e) {
  if (this.overlay.animate(e),
  this.definition.animations)
      for (var t = 0; t < this.definition.animations.length; t++) {
          var a = this.definition.animations[t]
            , o = geofs.animation.filter(a);
          if (a.lastValue == o)
              return;
          a.lastValue = o,
          "show" === a.type && this.visibility && this.overlay.setVisibility(o)
      }
}
,
Indicator.prototype.destroy = function() {
  this.overlay && this.overlay.destroy()
}
,
instruments.rendererInstancesByName = {},
instruments.Renderer = function(e) {
  if (this.definition = Object.assign({}, e),
  instruments.rendererInstancesByName[this.definition.name]) {
      this.reuseExistingRenderer = instruments.rendererInstancesByName[this.definition.name];
      return
  }
  this.canvasAPI = new geofs.api.Canvas(e),
  this.loadImages(),
  instruments.rendererInstancesByName[this.definition.name] = this
}
,
instruments.Renderer.prototype = {
  loadImages: function() {
      for (var e in this.images = {},
      this.definition.images)
          this.images[e] = new Image,
          this.images[e].src = this.definition.images[e]
  },
  update: function(e, t) {
      var a;
      if (this.reuseExistingRenderer ? a = instruments.rendererInstancesByName[this.definition.name].canvasAPI : (instruments.renderers[this.definition.name](this),
      a = this.canvasAPI),
      e) {
          if (e.safeTransparency)
              try {
                  geofs.version >= 4 ? e.object3d.model._model._nodesByName.glassPanel._runtimeNode.runtimePrimitives[0].drawCommand._originalCommand.command._pass = 10 : e.object3d.model._model._nodeCommands[0].command._pass = 9,
                  e.safeTransparency = !1
              } catch (o) {}
          e.object3d.model.setTextureFromCanvas(a, this.definition.textureIndex)
      }
  },
  destroy: function() {
      for (var e in this.images)
          this.images[e] = null,
          delete this.images[e];
      this.images = null,
      this.canvasAPI && this.canvasAPI.destroy(),
      instruments.rendererInstancesByName[this.definition.name] = null,
      delete instruments.rendererInstancesByName[this.definition.name]
  },
  drawGrads: function(e, t) {
      let a = e.context
        , o = t.pattern.length;
      t.position.x = t.position[0],
      t.position.y = t.position[1],
      t.center = t.center || [0, 0],
      t.center.x = t.center[0],
      t.center.y = t.center[1],
      t.size.x = t.size[0],
      t.size.y = t.size[1],
      t.rotation && (a.translate(t.position[0], t.position[1]),
      a.rotate(t.rotation),
      t.position = [0, 0]);
      let r = V2.sub(t.position, t.center);
      t.x = r[0],
      t.y = r[1],
      t.value = t.value || 0,
      t.zero = t.zero || [0, 0],
      t.zero.x = t.zero[0],
      t.zero.y = t.zero[1];
      let n = t.size[t.orientation] - t.zero[t.orientation]
        , s = t.interval * o
        , c = s * t.pixelRatio
        , d = n / c * s;
      t.value = t.value - d;
      let u = t.value % s;
      t.value = t.value - u;
      let p = u * t.pixelRatio;
      p <= -(.5 * c) && (p += c,
      t.value -= s),
      t[t.orientation] = t[t.orientation] - p * t.direction,
      t.direction < 0 && (t[t.orientation] += t.size[t.orientation]);
      let h = "x" == t.orientation ? "y" : "x";
      t[h] += t.zero[h];
      let m = Math.ceil(t.size[t.orientation] / (t.interval * t.pixelRatio));
      a.beginPath();
      for (var f = 0; f <= m + o; f++) {
          let g = f % o
            , y = t.pattern[g]
            , v = Math.round(t[t.orientation] + f * t.interval * t.direction * t.pixelRatio);
          y.forEach(e => {
              let o = t.x
                , r = t.y;
              if (e.offset = e.offset || {
                  x: 0,
                  y: 0
              },
              "x" == t.orientation ? ("bottom" == t.align && (r += t.size.y),
              "middle" == t.align && (r += t.center.y),
              a.moveTo(v, r),
              a.lineTo(v, r + e.length)) : ("right" == t.align && (o += t.size.x),
              "center" == t.align && (o += t.center.x),
              a.moveTo(o + e.offset.x, v + e.offset.y),
              a.lineTo(o + e.offset.x + e.length, v + e.offset.y)),
              e.legend) {
                  let n = t.value + t.interval * f;
                  e.process && (n = e.process(n)),
                  "x" == t.orientation ? a.fillText(n, v + e.legendOffset.x, r + e.legendOffset.y) : a.fillText(n, o + e.legendOffset.x, v + e.legendOffset.y)
              }
          }
          )
      }
      a.stroke(),
      t.sprites && t.sprites.forEach(a => {
          let o = t[t.orientation] + (a.value - t.value) * t.pixelRatio * t.direction;
          a.clamp && (o = clamp(o, t.position[t.orientation], t.position[t.orientation] + t.height)),
          a.destination = [t[h], o],
          e.drawSprite(a)
      }
      )
  }
},
instruments.renderers = {
  PFDBoeing(e) {
      let t = exponentialSmoothing("smoothKias", geofs.animation.getValue("kias"), .1)
        , a = [893, 980]
        , o = .25;
      a = V2.parseInt(V2.scale(a, o));
      let r = e.canvasAPI.context;
      e.canvasAPI.clear("#000000"),
      e.canvasAPI.drawRotatedSprite({
          image: e.images.attitude,
          origin: [0, 0],
          size: [350, 1400],
          center: [175, 700],
          destination: a,
          rotation: geofs.animation.getValue("aroll") * DEGREES_TO_RAD,
          translation: [0, 5 * geofs.animation.getValue("atilt")]
      }),
      e.canvasAPI.drawRotatedSprite({
          image: e.images.overlays,
          origin: [245, 56],
          size: [23, 21],
          center: [11, 120],
          destination: a,
          rotation: geofs.animation.getValue("aroll") * DEGREES_TO_RAD,
          translation: [0, 0]
      }),
      r.drawImage(e.images.background, 0, 0),
      r.fillStyle = "#00ff08",
      r.textAlign = "center",
      r.font = "18px sans-serif";
      let n = ""
        , s = ""
        , c = "";
      geofs.autopilot.on && (n = "SPD",
      "NAV" == geofs.autopilot.mode ? (s = "LNAV",
      c = geofs.autopilot.VNAV ? "V/S" : "ALT") : (s = "HDG SEL",
      c = "ALT")),
      r.fillText(n, 133, 20),
      r.fillText(s, 230, 20),
      r.fillText(c, 325, 20),
      r.fillStyle = "#ffffff",
      r.textAlign = "center",
      r.font = "14px sans-serif";
      let d = ""
        , u = "";
      "GPS" == geofs.animation.getValue("NAVMODE") && (d = "GPS"),
      "NAV" == geofs.animation.getValue("NAVMODE") && (d = "VOR/LOC"),
      geofs.autopilot.VNAV && (u = "G/S"),
      r.fillText(d, 230, 33),
      r.fillText(u, 325, 33),
      2500 >= geofs.animation.getValue("haglFeet") && (r.fillStyle = "#ffffff",
      r.textAlign = "right",
      r.font = "bold 20px sans-serif",
      r.fillText(Math.floor(geofs.animation.getValue("haglFeet")), 350, 95)),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [101, 0],
          size: [13, 20],
          center: [6, 10],
          destination: [355, a[1]],
          translation: [0, clamp(-107 * geofs.animation.getValue("NAVGlideAngleDeviation"), -75, 75)]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [114, 0],
          size: [20, 13],
          center: [10, 6],
          destination: [a[0], 390],
          translation: [clamp(6.5 * geofs.animation.getValue("NAVCourseDeviation"), -75, 75), 0]
      }),
      e.canvasAPI.drawRotatedSprite({
          image: e.images.overlays,
          origin: [101, 101],
          size: [310, 310],
          center: [155, 155],
          destination: [a[0], 602],
          rotation: -geofs.animation.getValue("heading") * DEGREES_TO_RAD
      }),
      e.canvasAPI.drawRotatedSprite({
          image: e.images.overlays,
          origin: [243, 88],
          size: [26, 13],
          center: [12, 165],
          destination: [a[0], 602],
          rotation: (-geofs.animation.getValue("heading") + geofs.autopilot.values.course) * DEGREES_TO_RAD
      }),
      r.lineWidth = 2,
      r.fillStyle = "#FFFFFF",
      r.strokeStyle = "#FFFFFF",
      r.textAlign = "right",
      r.font = "22px sans-serif",
      r.save(),
      r.beginPath(),
      r.rect(11, 60, 90, 381),
      r.rect(5, 210, 50, 70),
      r.clip("evenodd"),
      e.drawGrads(e.canvasAPI, {
          position: [64, 60],
          zero: [0, 190],
          size: [90, 380],
          orientation: "y",
          direction: -1,
          value: t,
          interval: 10,
          pixelRatio: 3.16,
          pattern: [[{
              length: 10,
              legend: !0,
              legendOffset: {
                  x: -8,
                  y: 7
              }
          }], [{
              length: 10
          }]],
          sprites: [{
              image: e.images.overlays,
              origin: [134, 0],
              size: [31, 19],
              center: [5, 10],
              value: geofs.autopilot.values.speed,
              clamp: !0
          }]
      }),
      r.restore(),
      r.save(),
      r.beginPath(),
      r.rect(365, 60, 84, 381),
      r.rect(400, 210, 65, 70),
      r.clip("evenodd"),
      r.font = "16px sans-serif",
      e.drawGrads(e.canvasAPI, {
          position: [385, 60],
          zero: [0, 190],
          size: [84, 380],
          orientation: "y",
          direction: -1,
          value: geofs.animation.getValue("altitude"),
          interval: 100,
          pixelRatio: .475,
          pattern: [[{
              length: 10,
              legend: !0,
              legendOffset: {
                  x: 60,
                  y: 7
              }
          }], [{
              length: 10
          }]],
          sprites: [{
              image: e.images.overlays,
              origin: [223, 0],
              size: [33, 56],
              center: [5, 28],
              value: geofs.autopilot.values.altitude,
              clamp: !0
          }, {
              image: e.images.overlays,
              origin: [256, 0],
              size: [64, 25],
              center: [2, 0],
              value: geofs.animation.getValue("groundElevationFeet")
          }]
      }),
      r.restore(),
      r.save(),
      r.beginPath(),
      r.rect(7, 220, 48, 50),
      r.rect(404, 220, 65, 50),
      r.rect(475, 116, 28, 262),
      r.clip(),
      r.beginPath(),
      r.lineWidth = 3,
      r.strokeStyle = "#FFFFFF";
      let p = clamp(35 * Math.log(Math.abs(geofs.animation.getValue("verticalSpeed") / 1e3)) + 60, 0, 125) * Math.sign(geofs.animation.getValue("verticalSpeed"));
      r.moveTo(530, a[1]),
      r.lineTo(482, a[1] - p),
      r.stroke(),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [166, 0],
          size: [13, 5],
          center: [0, 2],
          destination: [480, a[1]],
          translation: [0, -clamp(35 * Math.log(Math.abs(geofs.autopilot.values.verticalSpeed / 1e3)) + 60, 0, 125) * Math.sign(geofs.autopilot.values.verticalSpeed)]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [0, 0],
          size: [16, 512],
          center: [0, 512],
          destination: [8, 256],
          translation: [0, 48 * geofs.utils.stickyRounding(t % 1e3 * .01, .01)]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [0, 0],
          size: [16, 512],
          center: [0, 512],
          destination: [24, 256],
          translation: [0, 48 * geofs.utils.stickyRounding(t % 100 * .1, .1)]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [16, 0],
          size: [16, 512],
          center: [0, 487],
          destination: [40, 256],
          translation: [0, t % 10 * 25]
      }),
      geofs.animation.getValue("altTenThousands") > 9999 ? e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [0, 0],
          sprite: [16, 512],
          size: [14, 512],
          center: [0, 512],
          destination: [406, 256],
          translation: [0, 48 * geofs.utils.stickyRounding(1e-4 * geofs.animation.getValue("altTenThousands"), .01)]
      }) : e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [70, 490],
          size: [16, 21],
          center: [0, 21],
          destination: [406, 256],
          translation: [0, 0]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [0, 0],
          sprite: [16, 512],
          size: [14, 512],
          center: [0, 512],
          destination: [420, 256],
          translation: [0, 48 * geofs.utils.stickyRounding(.001 * geofs.animation.getValue("altThousands"), .01)]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [32, 0],
          size: [12, 512],
          center: [0, 512],
          destination: [434, 253],
          translation: [0, 40 * geofs.utils.stickyRounding(.01 * geofs.animation.getValue("altHundreds"), .1)]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [44, 0],
          size: [24, 512],
          center: [0, 496],
          destination: [445, 256],
          translation: [0, .8 * geofs.animation.getValue("altTens")]
      }),
      r.restore()
  },
  PFDAirbus(e) {
      let t = exponentialSmoothing("smoothKias", geofs.animation.getValue("kias"), .1)
        , a = [893, 980]
        , o = .25;
      a = V2.parseInt(V2.scale(a, o));
      let r = e.canvasAPI.context;
      e.canvasAPI.clear("#000000"),
      e.canvasAPI.drawRotatedSprite({
          image: e.images.attitude,
          origin: [0, 0],
          size: [350, 1400],
          center: [175, 700],
          destination: a,
          rotation: geofs.animation.getValue("aroll") * DEGREES_TO_RAD,
          translation: [0, 5 * geofs.animation.getValue("atilt")]
      }),
      e.canvasAPI.drawRotatedSprite({
          image: e.images.overlays,
          origin: [248, 0],
          size: [36, 28],
          center: [18, 135],
          destination: a,
          rotation: geofs.animation.getValue("aroll") * DEGREES_TO_RAD,
          translation: [0, 0]
      }),
      r.drawImage(e.images.background, 0, 0),
      r.fillStyle = "#00ff08",
      r.textAlign = "center",
      r.font = "18px sans-serif";
      let n = ""
        , s = ""
        , c = "";
      geofs.autopilot.on && (n = "SPD",
      "NAV" == geofs.autopilot.mode ? (s = "NAV",
      geofs.autopilot.VNAV ? (s = "LOC",
      c = "G/S") : c = "ALT") : (s = "HDG SEL",
      c = "ALT")),
      r.fillText(n, 80, 20),
      r.fillText(c, 170, 20),
      r.fillText(s, 280, 20),
      2500 >= geofs.animation.getValue("haglFeet") && (r.fillStyle = "#ffffff",
      r.textAlign = "right",
      r.font = "bold 20px sans-serif",
      r.fillText(Math.floor(geofs.animation.getValue("haglFeet")), 350, 95)),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [99, 0],
          size: [16, 24],
          center: [8, 12],
          destination: [355, a[1]],
          translation: [0, clamp(-107 * geofs.animation.getValue("NAVGlideAngleDeviation"), -75, 75)]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [116, 0],
          size: [24, 16],
          center: [12, 8],
          destination: [a[0], 410],
          translation: [clamp(6.5 * geofs.animation.getValue("NAVCourseDeviation"), -75, 75), 0]
      }),
      r.lineWidth = 2,
      r.fillStyle = "#FFFFFF",
      r.strokeStyle = "#FFFFFF",
      r.font = "20px sans-serif",
      r.textAlign = "right",
      r.save(),
      r.beginPath(),
      r.rect(14, 110, 80, 270),
      r.clip("evenodd"),
      e.drawGrads(e.canvasAPI, {
          position: [62, 110],
          zero: [0, 135],
          size: [80, 270],
          orientation: "y",
          direction: -1,
          value: t,
          interval: 10,
          pixelRatio: 3.2,
          pattern: [[{
              length: 10,
              legend: !0,
              legendOffset: {
                  x: -8,
                  y: 7
              }
          }], [{
              length: 10
          }]],
          sprites: [{
              image: e.images.overlays,
              origin: [143, 0],
              size: [25, 27],
              center: [-8, 13],
              value: geofs.autopilot.values.speed,
              clamp: !0
          }]
      }),
      r.restore(),
      r.save(),
      r.beginPath(),
      r.rect(376, 110, 50, 270),
      r.rect(382, 227, 45, 36),
      r.clip("evenodd"),
      e.drawGrads(e.canvasAPI, {
          position: [418, 110],
          size: [50, 270],
          zero: [0, 135],
          orientation: "y",
          direction: -1,
          value: geofs.animation.getValue("altitude"),
          interval: 100,
          pixelRatio: .25,
          pattern: [[{
              length: 6,
              legend: !0,
              legendOffset: {
                  x: -2,
                  y: 7
              },
              process: e => Math.round(e / 100)
          }], [{
              length: 6
          }], [{
              length: 6
          }], [{
              length: 6
          }], [{
              length: 6
          }]],
          sprites: [{
              image: e.images.overlays,
              origin: [223, 0],
              size: [25, 62],
              center: [5, 31],
              value: geofs.autopilot.values.altitude,
              clamp: !0
          }, {
              image: e.images.overlays,
              origin: [383, 0],
              size: [42, 255],
              center: [0, 0],
              value: geofs.animation.getValue("groundElevationFeet")
          }]
      }),
      r.restore(),
      r.save(),
      r.beginPath(),
      r.rect(105, 455, 236, 37),
      r.clip("evenodd"),
      r.textAlign = "center",
      e.drawGrads(e.canvasAPI, {
          position: [105, 455],
          zero: [118, 0],
          size: [236, 37],
          orientation: "x",
          direction: 1,
          value: geofs.animation.getValue("heading360"),
          interval: 5,
          pixelRatio: 4.75,
          pattern: [[{
              length: 10,
              legend: !0,
              legendOffset: {
                  x: 0,
                  y: 30
              },
              process: e => Math.round(fixAngle360(e) / 10)
          }], [{
              length: 5
          }]]
      }),
      r.restore(),
      r.save(),
      r.beginPath(),
      r.rect(382, 232, 45, 26),
      r.rect(428, 223, 29, 45),
      r.rect(473, 90, 28, 314),
      r.clip(),
      r.beginPath(),
      r.lineWidth = 3,
      r.strokeStyle = "#FFFFFF";
      let d = clamp(100 * Math.log(Math.abs(geofs.animation.getValue("verticalSpeed") / 1e3)) + 75, 0, 125) * Math.sign(geofs.animation.getValue("verticalSpeed"));
      r.moveTo(530, a[1]),
      r.lineTo(482, a[1] - d),
      r.stroke(),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [166, 0],
          size: [13, 5],
          center: [0, 2],
          destination: [480, a[1]],
          translation: [0, -clamp(35 * Math.log(Math.abs(geofs.autopilot.values.verticalSpeed / 1e3)) + 60, 0, 160) * Math.sign(geofs.autopilot.values.verticalSpeed)]
      }),
      geofs.animation.getValue("altTenThousands") > 9999 && e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [16, 0],
          sprite: [16, 512],
          size: [16, 512],
          center: [0, 487],
          destination: [382, 256],
          translation: [0, 25 * geofs.utils.stickyRounding(1e-4 * geofs.animation.getValue("altTenThousands"), .01)]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [16, 0],
          sprite: [16, 512],
          size: [16, 512],
          center: [0, 487],
          destination: [397, 256],
          translation: [0, 25 * geofs.utils.stickyRounding(.001 * geofs.animation.getValue("altThousands"), .01)]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [16, 0],
          sprite: [16, 512],
          size: [16, 512],
          center: [0, 487],
          destination: [412, 256],
          translation: [0, 25 * geofs.utils.stickyRounding(.01 * geofs.animation.getValue("altHundreds"), .1)]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [44, 0],
          size: [24, 512],
          center: [0, 496],
          destination: [430, 246],
          translation: [0, .8 * geofs.animation.getValue("altTens")]
      }),
      r.restore()
  },
  genericHUD(e) {
      let t = exponentialSmoothing("smoothKias", geofs.animation.getValue("kias"), .1)
        , a = [256, 256]
        , o = e.canvasAPI.context;
      e.canvasAPI.clear(),
      o.fillStyle = "#00ff00",
      o.strokeStyle = "#00ff00",
      o.save(),
      o.beginPath(),
      o.arc(a[0], a[1], 200, 0, 6.28),
      o.clip(),
      o.textAlign = "left",
      e.drawGrads(e.canvasAPI, {
          position: a,
          center: [100, 100],
          zero: [100, 100],
          size: [200, 200],
          orientation: "y",
          direction: -1,
          rotation: geofs.animation.getValue("aroll") * DEGREES_TO_RAD,
          value: -geofs.animation.getValue("atilt"),
          interval: 5,
          pixelRatio: 20,
          pattern: [[{
              length: 40,
              offset: {
                  x: -50,
                  y: 0
              },
              legend: !0,
              legendOffset: {
                  x: -80,
                  y: 5
              },
              process: e => Math.round(e)
          }, {
              length: 40,
              offset: {
                  x: 10,
                  y: 0
              },
              legend: !0,
              legendOffset: {
                  x: 60,
                  y: 5
              },
              process: e => Math.round(e)
          }], ]
      }),
      o.restore(),
      e.canvasAPI.drawRotatedSprite({
          image: e.images.overlays,
          origin: [248, 0],
          size: [36, 28],
          center: [18, 210],
          destination: [256, 256],
          rotation: geofs.animation.getValue("aroll") * DEGREES_TO_RAD,
          translation: [0, 0]
      }),
      o.drawImage(e.images.background, 0, 0),
      o.lineWidth = 2,
      o.font = "20px sans-serif",
      o.textAlign = "right",
      o.save(),
      o.beginPath(),
      o.rect(84, 130, 90, 280),
      o.rect(68, 243, 75, 25),
      o.clip("evenodd"),
      e.drawGrads(e.canvasAPI, {
          position: [104, 116],
          zero: [0, 140],
          size: [50, 280],
          orientation: "y",
          direction: -1,
          value: t,
          interval: 10,
          pixelRatio: 1.3,
          align: "right",
          pattern: [[{
              length: -10,
              legend: !0,
              legendOffset: {
                  x: -14,
                  y: 7
              }
          }], [{
              length: -7
          }], [{
              length: -7
          }], [{
              length: -7
          }], [{
              length: -7
          }], [{
              length: -10
          }], [{
              length: -7
          }], [{
              length: -7
          }], [{
              length: -7
          }], [{
              length: -7
          }]],
          sprites: [{
              image: e.images.overlays,
              origin: [143, 0],
              size: [15, 27],
              center: [-50, 13],
              value: geofs.autopilot.values.speed,
              clamp: !0
          }]
      }),
      o.restore(),
      o.save(),
      o.beginPath(),
      o.rect(350, 116, 60, 280),
      o.rect(368, 243, 75, 25),
      o.clip("evenodd"),
      e.drawGrads(e.canvasAPI, {
          position: [358, 116],
          zero: [0, 140],
          size: [47, 280],
          orientation: "y",
          direction: -1,
          value: geofs.animation.getValue("altitude"),
          interval: 100,
          pixelRatio: .13,
          pattern: [[{
              length: 10,
              legend: !0,
              legendOffset: {
                  x: 47,
                  y: 7
              },
              process: e => Math.round(e / 100)
          }], [{
              length: 7
          }], [{
              length: 7
          }], [{
              length: 7
          }], [{
              length: 7
          }]],
          sprites: [{
              image: e.images.overlays,
              origin: [223, 0],
              size: [25, 62],
              center: [9, 31],
              value: geofs.autopilot.values.altitude,
              clamp: !0
          }, {
              image: e.images.overlays,
              origin: [383, 0],
              size: [42, 255],
              center: [0, 0],
              value: geofs.animation.getValue("groundElevationFeet")
          }]
      }),
      o.restore(),
      o.save(),
      o.beginPath(),
      o.rect(173, 440, 165, 30),
      o.clip("evenodd"),
      o.textAlign = "center",
      e.drawGrads(e.canvasAPI, {
          position: [173, 440],
          zero: [82, 0],
          size: [165, 30],
          orientation: "x",
          direction: 1,
          value: geofs.animation.getValue("heading360"),
          interval: 5,
          pixelRatio: 7.25,
          pattern: [[{
              length: 10,
              legend: !0,
              legendOffset: {
                  x: 0,
                  y: 30
              },
              process: e => Math.round(fixAngle360(e) / 10)
          }], [{
              length: 5
          }]]
      }),
      o.restore(),
      o.font = "20px sans-serif",
      o.textAlign = "right",
      o.fillText(Math.round(geofs.animation.getValue("kias")), 129, 264),
      o.fillText(Math.round(geofs.animation.getValue("altitude")), 441, 264),
      2500 >= geofs.animation.getValue("haglFeet") && o.fillText(Math.round(geofs.animation.getValue("haglFeet")), 410, 426);
      let r = ""
        , n = ""
        , s = "";
      geofs.autopilot.on && (r = "SPD",
      "NAV" == geofs.autopilot.mode ? (n = "NAV",
      geofs.autopilot.VNAV ? (n = "LOC",
      s = "G/S") : s = "ALT") : (n = "HDG",
      s = "ALT")),
      o.fillText(r, 143, 430),
      o.fillText(s, 143, 450),
      o.fillText(n, 143, 470),
      o.fillText(geofs.animation.getValue("mach").toFixed(2), 140, 125),
      o.fillText("G" + geofs.animation.getValue("loadFactor").toFixed(1), 408, 455),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [99, 0],
          size: [16, 24],
          center: [8, 12],
          destination: [349, a[1]],
          translation: [0, clamp(-107 * geofs.animation.getValue("NAVGlideAngleDeviation"), -75, 75)]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [116, 0],
          size: [24, 16],
          center: [12, 8],
          destination: [a[0], 401],
          translation: [clamp(6.5 * geofs.animation.getValue("NAVCourseDeviation"), -75, 75), 0]
      })
  },
  G1000(e) {
      let t = exponentialSmoothing("smoothKias", geofs.animation.getValue("kias"), .1)
        , a = [460, 288]
        , o = e.canvasAPI.context
        , r = "#ff00ff";
      o.fillStyle = "#ffffff",
      o.strokeStyle = "#ffffff",
      e.canvasAPI.clear(),
      o.save(),
      o.translate(a[0], a[1]);
      let n = clamp(8 * geofs.animation.getValue("atilt"), -1e3, 1e3)
        , s = geofs.animation.getValue("aroll") * DEGREES_TO_RAD;
      o.rotate(s),
      o.fillStyle = "#004bff",
      o.beginPath(),
      o.rect(-1e3, -2e3 - n, 2e3, 2e3),
      o.fill(),
      o.fillStyle = "#553108",
      o.beginPath(),
      o.rect(-1e3, 0 - n, 2e3, 2e3),
      o.fill(),
      o.lineWidth = 2,
      o.moveTo(-1e3, 0 - n),
      o.lineTo(1e3, 0 - n),
      o.stroke(),
      o.restore(),
      o.save(),
      o.beginPath(),
      o.arc(a[0], a[1], 200, 0, 6.28),
      o.clip(),
      o.font = "24px sans-serif",
      o.lineWidth = 2,
      o.textAlign = "center",
      e.drawGrads(e.canvasAPI, {
          position: a,
          center: [100, 100],
          zero: [100, 100],
          size: [200, 200],
          orientation: "y",
          direction: -1,
          rotation: geofs.animation.getValue("aroll") * DEGREES_TO_RAD,
          value: -geofs.animation.getValue("atilt"),
          interval: 2.5,
          pixelRatio: 8,
          pattern: [[{
              length: 50,
              offset: {
                  x: -50,
                  y: 0
              },
              legend: !0,
              legendOffset: {
                  x: -65,
                  y: 8
              },
              process: e => Math.abs(Math.round(e))
          }, {
              length: 50,
              offset: {
                  x: 0,
                  y: 0
              },
              legend: !0,
              legendOffset: {
                  x: 65,
                  y: 8
              },
              process: e => Math.abs(Math.round(e))
          }], [{
              length: 20,
              offset: {
                  x: -10,
                  y: 0
              }
          }], [{
              length: 40,
              offset: {
                  x: -20,
                  y: 0
              }
          }], [{
              length: 20,
              offset: {
                  x: -10,
                  y: 0
              }
          }]]
      }),
      o.restore(),
      e.canvasAPI.drawRotatedSprite({
          image: e.images.overlays,
          origin: [101, 27],
          size: [32, 32],
          center: [16, 187],
          destination: a,
          rotation: geofs.animation.getValue("aroll") * DEGREES_TO_RAD,
          translation: [0, 0]
      });
      let c = (-geofs.animation.getValue("heading") + geofs.animation.getValue("NAVOBS")) * DEGREES_TO_RAD;
      o.fillStyle = "#00000055",
      o.beginPath(),
      o.arc(a[0], 586, 145, 0, 6.28),
      o.fill(),
      e.canvasAPI.drawRotatedSprite({
          image: e.images.overlays,
          origin: [101, 101],
          size: [310, 310],
          center: [155, 155],
          destination: [a[0], 586],
          rotation: -geofs.animation.getValue("heading") * DEGREES_TO_RAD
      }),
      e.canvasAPI.drawRotatedSprite({
          image: e.images.overlays,
          origin: [422, 101],
          size: [30, 13],
          center: [15, 153],
          destination: [a[0], 586],
          rotation: (geofs.animation.getValue("navHDG") - geofs.animation.getValue("heading")) * DEGREES_TO_RAD
      }),
      e.canvasAPI.drawRotatedSprite({
          image: e.images.overlays,
          origin: [184, 71],
          size: [144, 16],
          center: [72, 8],
          destination: [a[0], 586],
          rotation: c
      }),
      e.canvasAPI.drawRotatedSprite({
          image: e.images.overlays,
          origin: [422, 128],
          size: [30, 258],
          center: [15, 129],
          destination: [a[0], 586],
          rotation: c
      }),
      e.canvasAPI.drawRotatedSprite({
          image: e.images.overlays,
          origin: [455, 185],
          size: [22, 14],
          center: [11, 71],
          destination: [a[0], 586],
          rotation: c + ("to" == geofs.animation.getValue("NAVDirection") ? 0 : PI)
      }),
      e.canvasAPI.drawRotatedSprite({
          image: e.images.overlays,
          origin: [455, 202],
          size: [4, 106],
          center: [2, 53],
          destination: [a[0], 586],
          rotation: c,
          translation: [clamp(-(6.5 * geofs.animation.getValue("NAVCourseDeviation")), -75, 75), 0]
      }),
      o.drawImage(e.images.background, 0, 0),
      o.lineWidth = 2,
      o.font = "20px monospace",
      o.textAlign = "right",
      o.fillStyle = "#ffffff",
      o.strokeStyle = "#ffffff",
      o.save(),
      o.beginPath(),
      o.rect(154, 114, 87, 342),
      o.rect(160, 268, 46, 42),
      o.rect(206, 253, 22, 70),
      o.clip("evenodd"),
      e.drawGrads(e.canvasAPI, {
          position: [154, 114],
          zero: [0, 171],
          size: [87, 342],
          orientation: "y",
          direction: -1,
          value: t,
          interval: 5,
          pixelRatio: 6,
          align: "right",
          pattern: [[{
              length: -10,
              legend: !0,
              legendOffset: {
                  x: -14,
                  y: 7
              }
          }], [{
              length: -7
          }]],
          sprites: [{
              image: e.images.overlays,
              origin: [143, 0],
              size: [25, 27],
              center: [-8, 13],
              value: geofs.autopilot.values.speed,
              clamp: !0
          }]
      }),
      o.restore(),
      o.save(),
      o.beginPath(),
      o.rect(680, 114, 131, 342),
      o.rect(720, 268, 54, 42),
      o.rect(774, 257, 34, 64),
      o.textAlign = "left",
      o.clip("evenodd"),
      e.drawGrads(e.canvasAPI, {
          position: [705, 114],
          size: [108, 342],
          zero: [0, 171],
          orientation: "y",
          direction: -1,
          value: geofs.animation.getValue("altitude"),
          interval: 20,
          pixelRatio: .5,
          pattern: [[{
              length: 10,
              legend: !0,
              legendOffset: {
                  x: 15,
                  y: 7
              },
              process: e => Math.round(e)
          }], [{
              length: 5
          }], [{
              length: 5
          }], [{
              length: 5
          }], [{
              length: 5
          }]],
          sprites: [{
              image: e.images.overlays,
              origin: [68, 0],
              size: [13, 26],
              center: [0, 13],
              value: geofs.autopilot.values.altitude,
              clamp: !0
          }]
      }),
      o.restore(),
      o.save(),
      o.beginPath(),
      o.rect(160, 268, 46, 42),
      o.rect(206, 253, 22, 70),
      o.rect(720, 268, 54, 42),
      o.rect(774, 257, 34, 64),
      o.clip(),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [16, 0],
          size: [16, 512],
          center: [0, 446],
          destination: [164, 272],
          translation: [0, 35 * geofs.utils.stickyRounding(t % 1e3 * .01, .01)]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [16, 0],
          size: [16, 512],
          center: [0, 446],
          destination: [185, 272],
          translation: [0, 35 * geofs.utils.stickyRounding(t % 100 * .1, .1)]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [16, 0],
          size: [16, 512],
          center: [0, 446],
          destination: [208, 272],
          translation: [0, t % 10 * 35]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [16, 0],
          sprite: [16, 512],
          size: [16, 512],
          center: [0, 446],
          destination: [720, 272],
          translation: [0, 35 * geofs.utils.stickyRounding(1e-4 * geofs.animation.getValue("altTenThousands"), .01)]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [16, 0],
          sprite: [16, 512],
          size: [16, 512],
          center: [0, 446],
          destination: [740, 272],
          translation: [0, 35 * geofs.utils.stickyRounding(.001 * geofs.animation.getValue("altThousands"), .01)]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [32, 0],
          size: [12, 512],
          center: [0, 442],
          destination: [761, 269],
          translation: [0, 40 * geofs.utils.stickyRounding(.01 * geofs.animation.getValue("altHundreds"), .1)]
      }),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [44, 0],
          size: [24, 512],
          center: [0, 458],
          destination: [780, 270],
          translation: [0, 1.5 * geofs.animation.getValue("altTens")]
      }),
      o.restore(),
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [101, 0],
          size: [13, 21],
          center: [0, 10],
          destination: [685, a[1]],
          translation: [0, clamp(-107 * geofs.animation.getValue("NAVGlideAngleDeviation"), -90, 90)]
      });
      let d = clamp(.07 * geofs.animation.getValue("verticalSpeed"), -150, 150);
      e.canvasAPI.drawSprite({
          image: e.images.overlays,
          origin: [133, 36],
          size: [68, 20],
          center: [0, 10],
          destination: [811, 288],
          translation: [0, -d]
      }),
      o.font = "22px monospace",
      o.textAlign = "right",
      o.fillText(10 * Math.round(geofs.animation.getValue("verticalSpeed") / 10), 877, 295 - d),
      o.font = "32px monospace",
      o.textAlign = "center",
      o.fillText(Math.round(geofs.animation.getValue("heading360")) + "\xb0", 460, 425),
      o.font = "26px monospace",
      o.textAlign = "left",
      o.fillStyle = r;
      let u = ""
        , p = ""
        , h = "";
      geofs.autopilot.on && (u = "SPD",
      "NAV" == geofs.autopilot.mode ? (p = "NAV",
      geofs.autopilot.VNAV ? (p = "LOC",
      h = "G/S") : h = "ALT") : (p = "HDG",
      h = "ALT")),
      o.fillText(u, 270, 24),
      o.fillText(h, 397, 24),
      o.fillText(p, 489, 24)
  },
  genericEICAS(e) {
      let t = e.canvasAPI.context;
      e.canvasAPI.clear("#000000FF"),
      t.fillStyle = "#000000",
      t.lineWidth = 2,
      t.strokeStyle = "#ffffff",
      t.beginPath();
      for (var a = 64, o = 42, r = 128, n = 3.48 / geofs.aircraft.instance.definition.maxRPM, s = 0; s < geofs.aircraft.instance.engines.length; s++) {
          let c = geofs.aircraft.instance.engines[s].rpm;
          e.canvasAPI.drawSprite({
              image: e.images.background,
              origin: [0, 0],
              size: [128, 512],
              center: [0, 0],
              destination: [s * r, 0]
          });
          var d = 68;
          a += s * r,
          t.moveTo(a, d);
          let u = Math.cos(c * n)
            , p = Math.sin(c * n);
          t.lineTo(a + u * o, d + p * o)
      }
      t.stroke()
  }
};
var audio = window.audio || {};
audio.init = function(e) {
  audio.maxFilterFreq = 24e3,
  e = e || [],
  audio.soundplayer = audio.impl.webAudio.createPlayer(),
  audio.sounds = {};
  for (var t = 0, a = e.length; t < a; t++) {
      var o = e[t];
      o.file += geofs.killCache,
      o.file = o.file.replace(".ogg", ".mp3"),
      audio.sounds[o.id] = o,
      o.playing = !1,
      o.loading = !1,
      o.loaded = !1;
      var r = o.effects;
      for (var n in r) {
          var s = r[n];
          s.lastValue = null,
          "volume" == n && (s.ratio = 100 * (s.ratio || 1))
      }
  }
  geofs.preferences.sound ? !1 !== audio.on && (audio.on = !0) : audio.mute()
}
,
audio.update = function() {
  if (audio.on && audio.soundplayer && !geofs.pause)
      for (var e in audio.sounds) {
          var t = audio.sounds[e]
            , a = t.effects;
          for (var o in a) {
              var r = a[o]
                , n = geofs.animation.filter(r);
              if (t.loaded || t.loading || audio.soundplayer.loadSound(t),
              t.loaded) {
                  switch (o) {
                  case "filter":
                      if (r.lastValue == n)
                          continue;
                      audio.soundplayer.setFilter(t, n);
                      break;
                  case "volume":
                      t.playing || audio.soundplayer.startSound(t, !0);
                      let s = 1;
                      geofs.animation.values.cameraAircraftDistance && (s = clamp(1 / Math.pow(.001 * geofs.animation.values.cameraAircraftDistance, 2), 0, 1)),
                      n *= s,
                      audio.soundplayer.setVolume(t, n);
                      break;
                  case "pitch":
                      t.playing || audio.soundplayer.startSound(t, !0),
                      n += .001 * geofs.animation.values.cameraAircraftSpeed;
                      try {
                          audio.soundplayer.setRate(t, n)
                      } catch (c) {}
                      break;
                  case "play":
                      if (r.lastValue == n)
                          continue;
                      n > 0 && audio.soundplayer.startSound(t);
                      break;
                  case "start":
                      if (r.lastValue == n)
                          continue;
                      n > 0 ? (audio.soundplayer.startSound(t),
                      t.stopped = !1) : (audio.soundplayer.stopSound(t),
                      t.stopped = !0);
                      break;
                  case "stop":
                      if (r.lastValue == n)
                          continue;
                      n > 0 ? (audio.soundplayer.stopSound(t),
                      t.stopped = !0) : (audio.soundplayer.startSound(t),
                      t.stopped = !1)
                  }
                  r.lastValue = n
              }
          }
      }
}
,
audio.toggleMute = function() {
  audio.on ? audio.mute() : audio.unmute(),
  geofs.savePreferences()
}
,
audio.stop = function() {
  try {
      if (audio.soundplayer && audio.soundplayer.stopSound)
          for (var e in audio.sounds) {
              var t = audio.sounds[e];
              audio.soundplayer.stopSound(t);
              var a = t.effects;
              for (var o in a)
                  a[o].lastValue = null
          }
  } catch (r) {}
}
,
audio.mute = function() {
  audio.stop(),
  audio.on = !1,
  geofs.preferences.sound = !1,
  ui.toggleButton(".geofs-button-mute", !0)
}
,
audio.unmute = function() {
  audio.on = !0,
  geofs.preferences.sound = !0,
  ui.toggleButton(".geofs-button-mute", !1)
}
,
audio.playStartup = function() {
  if (audio.on && audio.soundplayer)
      try {
          audio.soundplayer.playSound(audio.sounds.startup, !1)
      } catch (e) {}
}
,
audio.playShutdown = function() {
  if (audio.on && audio.soundplayer)
      try {
          audio.soundplayer.playSound(audio.sounds.shutdown, !1)
      } catch (e) {}
}
,
audio.playSoundLoop = function(e, t) {
  if (audio.on && audio.soundplayer)
      try {
          audio.soundplayer.playSound(audio.sounds[e], t)
      } catch (a) {}
}
,
audio.stopSoundLoop = function(e) {
  if (audio.soundplayer && audio.soundplayer.stopSound)
      try {
          audio.soundplayer.stopSound(audio.sounds[e])
      } catch (t) {}
}
,
audio.impl = {},
audio.impl.webAudio = {
  decodingStack: [],
  createPlayer: function() {
      return (audio.impl.webAudio.destroyPlayer(),
      (window.AudioContext || window.webkitAudioContext) && (audio.impl.webAudio.context = audio.impl.webAudio.context || new (window.AudioContext || window.webkitAudioContext),
      audio.impl.webAudio.context)) ? audio.impl.webAudio : null
  },
  stackDecoding: function(e) {
      var t = function() {
          e(),
          audio.impl.webAudio.decodingStack.shift(),
          audio.impl.webAudio.decodingStack.length > 0 && audio.impl.webAudio.decodingStack[0]()
      };
      audio.impl.webAudio.decodingStack.push(t),
      1 == audio.impl.webAudio.decodingStack.length && audio.impl.webAudio.decodingStack[0]()
  },
  setupSoundNodes: function(e) {
      e.buffer && (e.filterNode || (e.filterNode = audio.impl.webAudio.context.createBiquadFilter(),
      e.filterNode.type = "lowpass",
      e.filterNode.Q.value = 1,
      e.filterNode.frequency.value = 24e3,
      e.filterNode.connect(audio.impl.webAudio.context.destination)),
      e.gainNode || (e.gainNode = audio.impl.webAudio.context.createGain(),
      e.gainNode.connect(e.filterNode)),
      e.sourceNode || (e.sourceNode = audio.impl.webAudio.context.createBufferSource(),
      e.sourceNode.buffer = e.buffer,
      e.sourceNode.connect(e.gainNode)))
  },
  loadSound: function(e, t) {
      e.loading = !0;
      var a = new XMLHttpRequest;
      a.open("GET", e.file, !0),
      a.responseType = "arraybuffer",
      a.onload = () => {
          audio.impl.webAudio.stackDecoding( () => {
              audio.impl.webAudio.context.decodeAudioData(a.response, a => {
                  a && (e.buffer = a,
                  e.loaded = !0,
                  this.setupSoundNodes(e),
                  t && t())
              }
              , e => {
                  throw "Error with decoding audio data" + e
              }
              )
          }
          )
      }
      ,
      a.send()
  },
  playSound: function(e, t, a) {
      this.loadSound(e, () => {
          this.startSound(e, t)
      }
      )
  },
  startSound: function(e, t, a) {
      if (e.loaded && !e.stopped && !e.playing) {
          if ("suspended" == audio.impl.webAudio.context.state) {
              audio.impl.webAudio.context.resume();
              return
          }
          (!e.sourceNode || e.sourceNode.started) && (this.stopSound(e),
          this.setupSoundNodes(e)),
          e.sourceNode.addEventListener("ended", () => {
              this.stopSound(e),
              a && a()
          }
          ),
          t = e.loop || t,
          e.sourceNode.loop = t,
          e.sourceNode.start(0),
          e.sourceNode.started = !0,
          e.playing = !0
      }
  },
  stopSound: function(e) {
      e.sourceNode && (e.sourceNode.started && e.sourceNode.stop(),
      e.sourceNode.disconnect,
      e.sourceNode = null,
      e.playing = !1)
  },
  setVolume: function(e, t) {
      e.volume = t,
      e.gainNode && (e.gainNode.gain.value = clamp(t / 100 * geofs.preferences.volume, 0, 1))
  },
  setRate: function(e, t) {
      e.rate = t || e.rate,
      e.sourceNode && (e.sourceNode.playbackRate.value = t || e.rate || 1)
  },
  setFilter: function(e, t, a) {
      e.filterNode && (e.frequencyOffset = a || e.frequencyOffset || 0,
      e.frequency = t || e.frequency || audio.maxFilterFreq,
      e.filterNode.type = "lowpass",
      e.filterNode.Q.value = 1,
      e.filterNode.frequency.value = clamp(e.frequency + e.frequencyOffset, 0, audio.maxFilterFreq))
  },
  unsetFilter: function(e) {
      e.filter.disconnect()
  },
  destroySound: function(e) {
      this.stopSound(e),
      e.sourceNode && e.sourceNode.disconnect(),
      e.gainNode && e.gainNode.disconnect(),
      e.filter && e.filter.disconnect()
  },
  destroyPlayer: function() {
      for (var e in audio.sounds) {
          let t = audio.sounds[e];
          this.destroySound(t),
          audio.sounds[e] = null,
          delete audio.sounds[e]
      }
  },
  setMasterVolume: function() {
      for (var e in audio.sounds)
          this.setVolume(audio.sounds[e], audio.sounds[e].volume)
  }
},
audio.impl.html5 = {
  player: null,
  createPlayer: function() {
      return (audio.impl.html5.destroyPlayer(),
      window.Audio) ? audio.impl.html5 : null
  },
  loadMP3: function(e, t, a) {
      var o = audio.sounds[e] || {};
      return o.element = new Audio(t),
      o.loop && o.element.addEventListener("timeupdate", function() {
          var e = 3;
          this.currentTime > this.duration - e && (this.currentTime = 0,
          this.play())
      }, !1),
      o.loaded = !0,
      a && o.element.play(),
      o
  },
  playFile: function(e, t, a) {
      if (geofs.preferences.sound) {
          var o = new Audio(e);
          return t && o.addEventListener("timeupdate", function() {
              var e = 3;
              this.currentTime > this.duration - e && (this.currentTime = 0,
              this.play())
          }, !1),
          o.play(),
          a && o.addEventListener("ended", a),
          o
      }
  },
  playSequence: function(e, t) {
      var a = {
          index: 0,
          files: e,
          loop: t || 0,
          stop: function() {
              this.loop = 0,
              clearTimeout(this.playTimeout),
              this.audioElement && (this.audioElement.pause(),
              this.audioElement = null)
          }
      };
      return a.player = function() {
          let e = 50;
          if (a.index == a.files.length) {
              if (--a.loop >= 0)
                  a.index = 0,
                  e = 1e3;
              else {
                  a.stop(),
                  a = null;
                  return
              }
          }
          a.playTimeout = setTimeout(function() {
              a.audioElement = audio.impl.html5.playFile(a.files[a.index], !1, a.player),
              a.index++
          }, e)
      }
      ,
      a.player(),
      a
  },
  playSound: function(e) {
      var t = audio.sounds[e];
      t.element && t.element.play()
  },
  stopSound: function(e) {
      var t = audio.sounds[e];
      t.element && t.element.pause(),
      audio.stopped(e)
  },
  setVolume: function(e, t) {
      var a = audio.sounds[e];
      a.volume = t,
      a.element && (a.element.volume = t / 100)
  },
  setRate: function(e, t) {},
  destroyPlayer: function() {
      for (var e in audio.sounds) {
          var t = audio.sounds[e].element;
          t && t.close && t.close()
      }
  },
  setMasterVolume: function() {
      for (var e in audio.sounds)
          this.setVolume(e, audio.sounds[e].volume)
  }
};
var multiplayer = window.multiplayer || {};
function executeWebXRCommands(e, t, a) {
  let o = e._view
    , r = o.camera
    , n = e._environmentState
    , s = n.renderTranslucentDepthForPick;
  updateAndClearFramebuffers(e, t, a),
  updateAndRenderPrimitives(e),
  o.createPotentiallyVisibleSet(e),
  executeComputeCommands(e),
  s || executeShadowMapCastCommands(e);
  var c = Camera.clone(r, e._cameraVR);
  if (c.frustum = r.frustum,
  t.XRViews)
      for (let d of t.XRViews) {
          let u = t.XRglLayer.getViewport(d);
          t.viewport.x = u.x,
          t.viewport.y = u.y,
          t.viewport.width = u.width,
          t.viewport.height = u.height,
          r.frustum.aspectRatio = u.width / u.height,
          geofs.camera.setPosition(d.transform.position.x, -d.transform.position.z, d.transform.position.y);
          var p = M33.getOrientation(M4.fromColumnMajorArray(d.transform.matrix));
          geofs.camera.setRotation(-p[2], p[1], p[0]),
          geofs.camera.update(1e-5),
          executeCommands$1(e, t)
      }
  Camera.clone(c, r)
}
geofs.multiplayerHost = geofs.multiplayerHost || "https://mps.geo-fs.com",
multiplayer.nbUsers = 0,
multiplayer.users = {},
multiplayer.visibleUsers = {},
multiplayer.numberOfLOD = 3,
multiplayer.captainIconUrl = "images/captain-tag.png",
multiplayer.premiumIconUrl = "images/premium-tag.png",
multiplayer.minUpdateDelay = geofs.MPSMinUpdateDelay || 500,
multiplayer.mapUpdatePeriod = geofs.MPSMapUpdatePeriod || 1e4,
multiplayer.hearbeatTimeout,
multiplayer.hearbeatLife = 9e3,
multiplayer.userLife = 2e4,
multiplayer.userHalfLife = 1e4,
multiplayer.userHeartBeatPeriod = 1e3,
multiplayer.trafficLife = 24e4,
multiplayer.trafficHalfLife = 12e4,
multiplayer.trafficHeartBeatPeriod = 1e4,
multiplayer.contrailEmitters = {
  1: {
      lod: 2,
      anchor: null,
      duration: 1e10,
      rate: .01,
      life: 3e4,
      startScale: .05,
      endScale: .1,
      randomizeStartScale: .1,
      randomizeEndScale: .4,
      startOpacity: .1,
      endOpacity: 1e-5,
      startRotation: "random",
      texture: "whitesmoke"
  },
  2: {
      lod: 2,
      anchor: null,
      duration: 1e10,
      rate: .01,
      life: 6e4,
      startScale: .05,
      endScale: .1,
      randomizeStartScale: .1,
      randomizeEndScale: .4,
      startOpacity: .1,
      endOpacity: 1e-5,
      startRotation: "random",
      texture: "whitesmoke"
  }
},
multiplayer.myId = "",
multiplayer.lastRequest = null,
multiplayer.lastResponse = null,
multiplayer.lastJoinedCoordinates = "",
multiplayer.lastRequestTime = Date.now(),
multiplayer.serverTimeOffset = null,
multiplayer.labelVisibilityRange = 5e4,
multiplayer.farVisibilityRange = 1e4,
multiplayer.lowVisibilityRange = 1e3,
multiplayer.nearVisibilityRange = 10,
multiplayer.chatMessage = "",
multiplayer.chatMessageId = 0,
multiplayer.on = !1,
multiplayer.started = !1,
multiplayer.callsignPlacemarkAltitude = 5,
multiplayer.updateFunctions = [],
multiplayer.init = function() {
  multiplayer.labelOptions = {
      default: {
          font: "bold 12pt sans-serif",
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          eyeOffset: new Cesium.Cartesian3(0,6,0),
          fillColor: Cesium.Color.fromCssColorString("#00597b"),
          outlineColor: Cesium.Color.WHITE,
          outlineWidth: 4
      },
      xavier: {
          font: "bold 12pt sans-serif",
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          eyeOffset: new Cesium.Cartesian3(0,6,0),
          fillColor: Cesium.Color.fromCssColorString("#ffc107"),
          outlineColor: Cesium.Color.WHITE,
          outlineWidth: 4
      },
      premium: {
          font: "bold 12pt sans-serif",
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          eyeOffset: new Cesium.Cartesian3(0,6,0),
          fillColor: Cesium.Color.fromCssColorString("#ffc107"),
          outlineColor: Cesium.Color.WHITE,
          outlineWidth: 4
      },
      traffic: {
          font: "bold 11pt sans-serif",
          style: Cesium.LabelStyle.FILL_AND_OUTLINE,
          horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          eyeOffset: new Cesium.Cartesian3(0,6,0),
          fillColor: Cesium.Color.fromCssColorString("#79abbd"),
          outlineColor: Cesium.Color.WHITE,
          outlineWidth: 2
      }
  },
  multiplayer.iconOptions = {
      premium: {
          image: multiplayer.premiumIconUrl,
          horizontalOrigin: Cesium.HorizontalOrigin.RIGHT,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          eyeOffset: new Cesium.Cartesian3(0,6,0),
          pixelOffset: new Cesium.Cartesian2(-25,1),
          width: 25,
          height: 25
      },
      xavier: {
          image: multiplayer.captainIconUrl,
          horizontalOrigin: Cesium.HorizontalOrigin.RIGHT,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
          eyeOffset: new Cesium.Cartesian3(0,6,0),
          pixelOffset: new Cesium.Cartesian2(-25,1),
          width: 25,
          height: 25
      }
  },
  multiplayer.flightSharing.init()
}
,
multiplayer.stop = function() {
  for (var e in multiplayer.stopUpdates(),
  multiplayer.users)
      multiplayer.users[e].remove();
  $(".geofs-player-count").hide()
}
,
multiplayer.start = function() {
  multiplayer.startUpdates(),
  $(".geofs-player-count").show()
}
,
multiplayer.startUpdates = function() {
  geofs.preferences.multiplayer && !multiplayer.started && (multiplayer.started = !0,
  multiplayer.nextUpdateTime = Date.now(),
  multiplayer.sendUpdate(),
  multiplayer.startMapUpdate())
}
,
multiplayer.stopUpdates = function(e) {
  clearTimeout(multiplayer.hearbeatTimeout),
  clearInterval(multiplayer.mapInterval),
  multiplayer.nextUpdateTime = null,
  multiplayer.started = !1
}
,
multiplayer.getServerTime = function() {
  return Date.now() - multiplayer.serverTimeOffset
}
,
multiplayer.getUser = function(e) {
  return multiplayer.users[e]
}
,
multiplayer.flightSharing = {
  requestTimeout: 3e4,
  host: !1,
  control: !1,
  status: null,
  willpeer: null,
  waspeer: null,
  peer: null,
  init() {
      $(document).on("click", ".geofs-stopSharing", multiplayer.flightSharing.stop).on("click", ".geofs-acceptSharing", function() {
          multiplayer.flightSharing.accept(multiplayer.flightSharing.willpeer)
      }).on("click", ".geofs-refuseSharing", function() {
          multiplayer.flightSharing.refuse(multiplayer.flightSharing.willpeer)
      }).on("click", ".geofs-blockUser", function() {
          multiplayer.blockUser(multiplayer.flightSharing.willpeer.acid)
      }).on("click", ".geofs-controlSwap", function() {
          multiplayer.flightSharing.swapControl()
      })
  },
  request(e) {
      multiplayer.flightSharing.peer = e,
      e.isPeer = !0,
      multiplayer.flightSharing.control = !0,
      multiplayer.flightSharing.host = !0,
      multiplayer.flightSharing.status = "requested",
      $(".geofs-flightSharing-status").html('Flight sharing requested.<br/>Waiting for<span class="geofs-callsign">' + e.callsign + '</span><button class="geofs-stopSharing mdl-button mdl-button--raised">Cancel</button>').show(),
      clearTimeout(multiplayer.flightSharing.timeout),
      multiplayer.flightSharing.timeout = setTimeout(multiplayer.flightSharing.stop, multiplayer.flightSharing.requestTimeout)
  },
  incoming(e) {
      if ("established" != multiplayer.flightSharing.status && "incoming" != multiplayer.flightSharing.status && "disconnected" != multiplayer.flightSharing.status) {
          if (multiplayer.flightSharing.host)
              e.isPeer && multiplayer.flightSharing.accepted(e);
          else {
              if (geofs.userRecord.muteListMap[e.acid])
                  return;
              multiplayer.flightSharing.willpeer = e,
              multiplayer.flightSharing.peer = null,
              multiplayer.flightSharing.status = "incoming",
              $(".geofs-flightSharing-status").html('Flight sharing request from<span class="geofs-callsign">' + e.callsign + '</span><button class="geofs-acceptSharing mdl-button mdl-button--raised">accept</button><button class="geofs-refuseSharing mdl-button mdl-button--raised">refuse</button><button class="geofs-blockUser mdl-button mdl-button--raised mdl-button--colored">block user</button>').show(),
              clearTimeout(multiplayer.flightSharing.timeout),
              multiplayer.flightSharing.timeout = setTimeout(multiplayer.flightSharing.stop, multiplayer.flightSharing.requestTimeout)
          }
      }
  },
  accept(e) {
      flight.sharing.start(),
      multiplayer.flightSharing.status = "established",
      multiplayer.flightSharing.control = !1,
      multiplayer.flightSharing.willpeer = null,
      multiplayer.flightSharing.peer = e,
      multiplayer.flightSharing.waspeer = e,
      e.isPeer = !0,
      e.aircraft != geofs.aircraft.instance.aircraftRecord.id && geofs.aircraft.instance.change(e.aircraft, e.currentLivery),
      $(".geofs-flightSharing-status").addClass("geofs-established").html('Sharing flight with<span class="geofs-callsign">' + e.callsign + '</span><span class="geofs-controlStatus">Peer has control</span><button class="geofs-stopSharing mdl-button mdl-button--raised">stop sharing</button>').show()
  },
  accepted(e) {
      multiplayer.flightSharing.status = "established",
      multiplayer.flightSharing.waspeer = e,
      multiplayer.flightSharing.control = !0,
      $(".geofs-flightSharing-status").addClass("geofs-established").html('Sharing flight with<span class="geofs-callsign">' + e.callsign + '</span><span class="geofs-controlStatus">You have control</span><button class="geofs-controlSwap mdl-button mdl-button--accent mdl-button--raised">give control</button><button class="geofs-stopSharing mdl-button mdl-button--raised">stop sharing</button>').show()
  },
  peerUpdate(e, t) {
      if ("established" == multiplayer.flightSharing.status) {
          var a = e.st.sh;
          !a || a.pe != geofs.userRecord.id || a.ca ? multiplayer.flightSharing.stop() : (multiplayer.flightSharing.host || !!a.hct != multiplayer.flightSharing.control || multiplayer.flightSharing.swapControl(!a.hct),
          multiplayer.flightSharing.control || flight.sharing.peerUpdate({
              ti: e.ti,
              co: e.co,
              ct: e.st.sh.ct,
              st: e.st.sh.st,
              ve: e.st.sh.ve,
              acc: e.st.sh.acc || [0, 0, 0, 0, 0, 0]
          }, t)),
          clearTimeout(multiplayer.flightSharing.timeout),
          multiplayer.flightSharing.timeout = setTimeout( () => {
              multiplayer.flightSharing.stop(),
              geofs.debug.log("flightSharing timedout")
          }
          , multiplayer.flightSharing.requestTimeout)
      }
  },
  swapControl(e) {
      multiplayer.flightSharing.host && (e = !multiplayer.flightSharing.control,
      $(".geofs-flightSharing-status").find(".geofs-controlSwap").text(e ? "Give control" : "take control")),
      $(".geofs-flightSharing-status").find(".geofs-controlStatus").text(e ? "You have control" : "Peer has control"),
      multiplayer.flightSharing.control = e,
      e ? flight.sharing.stop() : flight.sharing.start(flight.recorder.makeRecord(Date.now()))
  },
  refuse(e) {
      multiplayer.flightSharing.status = "canceling",
      multiplayer.flightSharing.willpeer = null,
      multiplayer.flightSharing.peer = e,
      multiplayer.flightSharing.waspeer = e
  },
  stop() {
      flight.sharing.stop(),
      multiplayer.flightSharing.willpeer = null,
      multiplayer.flightSharing.waspeer = null,
      multiplayer.flightSharing.peer && (multiplayer.flightSharing.peer.isPeer = !1,
      multiplayer.flightSharing.peer = null),
      multiplayer.flightSharing.status = "disconnected",
      multiplayer.flightSharing.control = !1,
      multiplayer.flightSharing.host = !1,
      clearTimeout(multiplayer.flightSharing.timeout);
      setTimeout( () => {
          multiplayer.flightSharing.status = null,
          $(".geofs-flightSharing-status").hide()
      }
      , 5e3),
      $(".geofs-flightSharing-status").html("Flight sharing ended").show()
  }
},
multiplayer.updateUsers = function(e) {
  e = e || [];
  for (var t = 0, a = e.length; t < a; t++) {
      var o = e[t]
        , r = o.id;
      if ((!o.ad || geofs.preferences.adsb) && multiplayer.myId != r)
          try {
              multiplayer.users[r] ? multiplayer.users[r].update(o) : multiplayer.users[r] = new multiplayer.User(o)
          } catch (n) {
              geofs.debug.error(n, "exception in multiplayer.updateUsers")
          }
  }
}
,
multiplayer.startMapUpdate = function() {
  var e = function(e) {
      if (multiplayer.setNbUsers(e.userCount),
      e && e.users) {
          e.users.sort( (e, t) => {
              try {
                  var a = e.cs.toLowerCase()
                    , o = t.cs.toLowerCase();
                  if (a > o)
                      return 1;
                  if (a < o)
                      return -1;
                  return 0
              } catch (r) {
                  return 0
              }
          }
          );
          for (var t = $(".geofs-player-list"), a = t.is(":visible"), o = 0, r = "", n = 0, s = e.users.length; n < s; n++) {
              var c = e.users[n]
                , d = c ? c.id : null;
              if (d && multiplayer.myId != d) {
                  var u = multiplayer.users[d] || new multiplayer.User(c);
                  u.update(c, !0),
                  a && ("Foo" == u.callsign ? o++ : r += '<li data-player="' + d + '">' + u.callsign + " (" + u.aircraftName + ")</li>")
              }
          }
          a && (o > 0 && (r += "<li>    ...and " + o + " Foos</li>"),
          t.html(r))
      }
  };
  clearInterval(multiplayer.mapInterval);
  let t = "/map" + (geofs.userRecord.licenseid ? "?gid=" + geofs.userRecord.licenseid : "");
  multiplayer.mapInterval = setInterval( () => {
      geofs.ajax.post(geofs.multiplayerHost + t, {
          id: multiplayer.myId,
          gid: geofs.userRecord.licenseid
      }, e)
  }
  , multiplayer.mapUpdatePeriod),
  geofs.ajax.post(geofs.multiplayerHost + t, {
      id: multiplayer.myId,
      gid: geofs.userRecord.licenseid
  }, e)
}
,
multiplayer.update = function(e) {
  try {
      for (var t in multiplayer.lastResponse && (multiplayer.updateUsers(multiplayer.lastResponse.users),
      multiplayer.lastResponse = null),
      multiplayer.nextUpdateTime && Date.now() > multiplayer.nextUpdateTime && multiplayer.sendUpdate(),
      multiplayer.visibleUsers) {
          var a, o = multiplayer.visibleUsers[t];
          o.currentServerTime = multiplayer.getServerTime(),
          o.model ? (o.elapsedTime = o.elapsedTime + e,
          (a = M3.add(o.referenceCoord, M3.scale(o.correctedVelocity, o.elapsedTime)))[3] = fixAngle(a[3]),
          a[4] = fixAngle(a[4]),
          a[5] = fixAngle(a[5]),
          o.currentInterpolatedCoord = a,
          o.referencePoint.lla = o.currentInterpolatedCoord,
          o.model.setPositionOrientationAndScale([a[0], a[1], a[2]], [a[3], a[4], a[5]])) : a = o.lastUpdate.co;
          var r = [a[0], a[1], a[2]];
          geofs.api.setLabelPosition(o.label, r),
          o.icon && o.icon.setLocation(r)
      }
  } catch (n) {
      geofs.debug.error(n, "multiplayer.update")
  }
}
,
multiplayer.errorCallback = function(e) {
  multiplayer.lastRequest = null;
  var t = Date.now();
  multiplayer.nextUpdateTime = t + multiplayer.minUpdateDelay
}
,
multiplayer.updateCallback = function(e) {
  multiplayer.lastResponse = e,
  multiplayer.lastRequest = null;
  var t = Date.now()
    , a = t - multiplayer.lastRequestTime;
  multiplayer.avgPing = exponentialSmoothing("avgPing", a).toPrecision(2),
  multiplayer.minPing = Math.min(multiplayer.minPing, a).toPrecision(2);
  var o = a / 2
    , r = t - (e.serverTime + o);
  multiplayer.serverTimeOffset = exponentialSmoothing("serverTimeOffset", r, null, .01);
  var n = clamp(multiplayer.minUpdateDelay - a, 0, multiplayer.minUpdateDelay);
  if (multiplayer.myId = e.myId || null,
  multiplayer.chatMessageId = e.lastMsgId || multiplayer.chatMessageId,
  multiplayer.started && (multiplayer.nextUpdateTime = t + n),
  e.chatMessages)
      for (var s = 0, c = e.chatMessages.length; s < c; s++) {
          var d = e.chatMessages[s];
          geofs.userRecord.muteListMap[d.acid] || ui.chat.publish(d)
      }
}
,
multiplayer.sendUpdate = function() {
  try {
      if (multiplayer.lastRequest || flight.recorder.playing)
          return;
      var e = geofs.aircraft.instance
        , t = Date.now();
      multiplayer.lastRequestTime = t;
      let a = [geofs.utils.toFixedFloat(e.llaLocation[0], 7), geofs.utils.toFixedFloat(e.llaLocation[1], 7), geofs.utils.toFixedFloat(e.llaLocation[2], 2)]
        , o = geofs.utils.arrayToFixed(e.htr, 2);
      var r = $.merge($.merge([], a), o)
        , n = V3.scale(xyz2lla(e.rigidBody.getLinearVelocity(), e.llaLocation), .001)
        , s = geofs.utils.arrayToFixed($.merge(n, e.htrAngularSpeed), 8)
        , c = {
          gr: 1 != controls.gear.position ? 1 : 0,
          as: Math.round(geofs.animation.values.kias)
      };
      e.liveryId && (c.lv = e.liveryId);
      let d = {
          ad: geofs.preferences.adsb ? 1 : 0
      };
      var u = {
          acid: geofs.userRecord.id,
          sid: geofs.userRecord.sessionId,
          id: multiplayer.myId,
          ro: d,
          ac: e.aircraftRecord.id,
          co: r,
          ve: s,
          st: c,
          ti: multiplayer.getServerTime(),
          m: multiplayer.chatMessage,
          ci: multiplayer.chatMessageId
      };
      if (multiplayer.flightSharing.status && multiplayer.flightSharing.peer) {
          let p = {
              ti: u.ti,
              co: r,
              ct: [controls.rawPitch, controls.roll, controls.yaw, controls.throttle, controls.gear.position, controls.flaps.position, controls.airbrakes.position, controls.brakes, controls.elevatorTrim],
              st: [geofs.aircraft.instance.groundContact, geofs.aircraft.instance.engine.on, controls.flaps.target],
              ve: geofs.aircraft.instance.rigidBody.getLinearVelocity().concat(geofs.aircraft.instance.rigidBody.getAngularVelocity()),
              acc: geofs.aircraft.instance.rigidBody.getLinearAcceleration().concat(geofs.aircraft.instance.rigidBody.getAngularAcceleration())
          };
          u.st.sh = {
              pe: multiplayer.flightSharing.peer.acid,
              ca: "canceling" == multiplayer.flightSharing.status,
              hct: multiplayer.flightSharing.control,
              ct: p.ct,
              ve: p.ve,
              acc: p.acc,
              st: p.st
          }
      }
      multiplayer.chatMessage && (multiplayer.chatMessage = "");
      let h = parseInt(e.llaLocation[1]);
      multiplayer.lastRequest = geofs.ajax.post(geofs.multiplayerHost + "/update?l=" + h, u, multiplayer.updateCallback, multiplayer.errorCallback)
  } catch (m) {
      geofs.debug.error(m, "multiplayer.sendUpdate")
  }
}
,
multiplayer.User = function(e) {
  var t = e.id;
  multiplayer.users[t] = this,
  this.id = t,
  this.acid = e.acid,
  geofs.userRecord.muteListMap && !geofs.userRecord.muteListMap[this.id] ? this.callsign = e.cs : this.callsign = "",
  this.aircraft = null,
  this.lod = 0,
  this.lastUpdate = null,
  this.model = null,
  this.visibleGear = !0,
  this.referencePoint = {
      lla: [0, 0, 0]
  },
  this.currentServerTime = multiplayer.getServerTime(),
  this.lastHeartbeatTime = Date.now(),
  this.isTraffic = e.ad,
  this.updated = !0,
  this.heartBeat()
}
,
multiplayer.User.prototype = {
  heartBeat: function() {
      var e = Date.now()
        , t = e - this.lastHeartbeatTime;
      if (this.updated)
          this.updated = !1,
          this.lastHeartbeatTime = e;
      else if (t > (this.isTraffic ? multiplayer.trafficHalfLife : multiplayer.userHalfLife) && this.removeFromWorld(),
      t > (this.isTraffic ? multiplayer.trafficLife : multiplayer.userLife)) {
          this.remove();
          return
      }
      clearTimeout(this.heartBeatTimeout),
      this.heartBeatTimeout = setTimeout( () => {
          this.heartBeat()
      }
      , this.isTraffic ? multiplayer.trafficHeartBeatPeriod : multiplayer.userHeartBeatPeriod)
  },
  update: function(e, t) {
      var a = e.st.sh;
      if (a ? (a.pe == geofs.userRecord.id && "established" != multiplayer.flightSharing.status && multiplayer.flightSharing.incoming(this),
      a.ca && multiplayer.flightSharing.stop()) : !t && (multiplayer.flightSharing.willpeer && multiplayer.flightSharing.willpeer.acid == this.acid || multiplayer.flightSharing.waspeer && multiplayer.flightSharing.waspeer.acid == this.acid) && multiplayer.flightSharing.stop(),
      this.updateAircraft(e),
      !this.lastUpdate) {
          if (this.lastUpdate = Object.assign({}, e),
          !t)
              return;
          var o = !0
      }
      if (!(e.ti - this.lastUpdate.ti <= 0) || o) {
          if (geofs.map && geofs.map.mapActive && geofs.map.updatePlayerMarker(e.id, e.co, this.callsign, e.ad ? "traffic" : null, this.aircraftName, this.lastUpdate.st.as),
          this.isPeer && (multiplayer.visibleUsers[this.id] = this,
          multiplayer.flightSharing.peerUpdate(e, t)),
          this.updated = !0,
          !t) {
              if (this.lastUpdate = Object.assign({}, e),
              this.updateModel(e),
              this.model || this.isPeer) {
                  if (this.lastUpdate.ad && (0 == this.lastUpdate.co[2] || this.lastUpdate.st.gr) && (this.lastUpdate.co[2] = geofs.api.getFastTerrainElevation([this.lastUpdate.co[0], this.lastUpdate.co[1], 0])),
                  this.model && this.visibleGear != this.lastUpdate.st.gr && this.model.setNodeVisibilityByName("gear", this.lastUpdate.st.gr) && (this.visibleGear = this.lastUpdate.st.gr),
                  this.elapsedTime = this.currentServerTime - this.lastUpdate.ti,
                  this.correctedVelocity = M3.dup(this.lastUpdate.ve),
                  this.elapsedTime,
                  this.currentInterpolatedCoord) {
                      var r = M3.add(this.lastUpdate.co, M3.scale(this.lastUpdate.ve, this.elapsedTime))
                        , n = M3.sub(r, this.currentInterpolatedCoord);
                      n[3] = fixAngle(n[3]),
                      n[4] = fixAngle(n[4]),
                      n[5] = fixAngle(n[5]);
                      var s = Math.abs(V3.length(lla2xyz(n, r)))
                        , c = Math.max(Math.abs(n[3]), Math.abs(n[4]), Math.abs(n[5]));
                      if (this.lastUpdate.ad) {
                          if (s > 5e3 || c > 30)
                              this.currentInterpolatedCoord = null,
                              this.deviationFix = [0, 0, 0, 0, 0, 0];
                          else {
                              var d = 1e5;
                              this.deviationFix = M3.scale(n, 1 / d),
                              this.correctedVelocity = M3.add(this.correctedVelocity, this.deviationFix)
                          }
                      } else if (s > 40 || c > 30)
                          this.currentInterpolatedCoord = null,
                          this.deviationFix = null;
                      else {
                          var d = 10 * multiplayer.minUpdateDelay;
                          this.deviationFix = M3.scale(n, 1 / d),
                          this.correctedVelocity = M3.add(this.correctedVelocity, this.deviationFix)
                      }
                  }
                  this.currentInterpolatedCoord ? (this.elapsedTime = 0,
                  this.referenceCoord = this.currentInterpolatedCoord) : this.referenceCoord = this.lastUpdate.co
              }
              this.referencePoint.lla = this.currentInterpolatedCoord || this.lastUpdate.co,
              this.currentInterpolatedCoord = null,
              this.updateContrails()
          }
      }
  },
  getLOD: function(e) {
      var t = this.currentInterpolatedCoord || e.co;
      if (this.distance = geofs.utils.llaDistanceInMeters(t, geofs.aircraft.instance.llaLocation, geofs.aircraft.instance.llaLocation),
      this.distance > multiplayer.nearVisibilityRange) {
          if (this.distance < multiplayer.farVisibilityRange)
              return this.distance > multiplayer.lowVisibilityRange ? 2 : 1;
          if (this.distance < multiplayer.labelVisibilityRange)
              return 3
      }
      return 0
  },
  updateAircraft: function(e) {
      this.aircraft != e.ac && (this.removeModels(),
      this.aircraft = e.ac,
      this.aircraftName = null,
      this.isPeer && !multiplayer.flightSharing.host && geofs.aircraft.instance.change(this.aircraft, this.currentLivery)),
      this.aircraftName || (geofs.aircraftList[this.aircraft] ? this.aircraftName = geofs.aircraftList[this.aircraft].name : this.aircraftName = "unknown")
  },
  updateContrails: function() {
      if (geofs.preferences.graphics.contrails && this.referencePoint.lla[2] > weather.contrailAltitude) {
          if (this.contrailEmitter && this.contrailLod != this.lod && (this.contrailEmitter.destroy(),
          this.contrailEmitter = null),
          this.contrailLod != this.lod && multiplayer.contrailEmitters[this.lod]) {
              var e = Object.assign({}, multiplayer.contrailEmitters[this.lod]);
              e.anchor = this.referencePoint,
              this.contrailEmitter = new geofs.fx.ParticleEmitter(e)
          }
      } else
          this.contrailEmitter && (this.contrailEmitter.destroy(),
          this.contrailEmitter = null);
      this.contrailLod = this.lod
  },
  updateModel: function(e) {
      var t = this.getLOD(e);
      if (this.isPeer) {
          this.removeModels(),
          multiplayer.visibleUsers[this.id] = this,
          this.lod = t;
          return
      }
      var a = !(!geofs.preferences.showCommunityMultiplayer && geofs.aircraftList[this.aircraft] && geofs.aircraftList[this.aircraft].community);
      if (this.models && 0 != this.models.length ? a || this.removeModels() : t > 0 && t < multiplayer.numberOfLOD && a && (this.models = multiplayer.loadModels(e.ac),
      this.lod = null),
      t != this.lod) {
          this.removeFromWorld(),
          t > 0 && t <= multiplayer.numberOfLOD ? multiplayer.visibleUsers[this.id] = this : delete multiplayer.visibleUsers[this.id];
          var o = t - 1;
          this.models.length > o && o >= 0 && (this.model = this.models[o],
          this.model.addToWorld()),
          this.lod = t
      }
      if (multiplayer.visibleUsers[this.id] && 1 == this.lod && e.st.lv && this.currentLivery != e.st.lv && this.model.isReady() && (this.currentLivery = e.st.lv,
      this.model.changeTexture(geofs.aircraftList[this.aircraft].path + "texture-low_" + this.currentLivery + ".jpg", {
          index: 0
      })),
      (this.premium != e.p || this.callsign != e.cs) && (this.premium = e.p,
      this.callsign = e.cs,
      this.removeCallsign()),
      !this.label) {
          var r = "default";
          r = e.p ? "premium" : r,
          r = this.isTraffic ? "traffic" : r,
          r = 1 == e.acid ? "xavier" : r,
          this.addCallsign(this.callsign, r)
      }
  },
  addCallsign: function(e, t) {
      if (this.label = geofs.api.addLabel(e, null, multiplayer.labelOptions[t]),
      multiplayer.iconOptions[t]) {
          var a = Object.assign({}, multiplayer.iconOptions[t], {
              pixelOffset: new Cesium.Cartesian2(-(4 * e.length + 5),2)
          });
          this.icon = new geofs.api.billboard(null,null,a)
      }
  },
  removeCallsign: function() {
      geofs.api.removeLabel(this.label),
      this.label = null,
      this.icon && (this.icon.destroy(),
      this.icon = null)
  },
  removeFromWorld: function() {
      this.model && this.model.removeFromWorld(),
      this.model = null,
      this.lod = null,
      this.removeCallsign()
  },
  removeModels: function() {
      if (this.removeFromWorld(),
      this.models)
          for (var e = 0; e < this.models.length; e++)
              this.models[e].destroy();
      this.lod = null,
      this.currentLivery = null,
      this.models = []
  },
  remove: function() {
      clearTimeout(this.heartBeatTimeout),
      this.removeModels(),
      this.contrailEmitter && (this.contrailEmitter.destroy(),
      this.contrailEmitter = null),
      geofs.map && geofs.map.deletePlayerMarker(this.id),
      delete multiplayer.visibleUsers[this.id],
      delete multiplayer.users[this.id]
  },
  getCoordinates: function() {
      return this.lastUpdate.co
  },
  isOnGround: function() {
      return this.lastUpdate.st.gr
  }
},
multiplayer.blockUser = function(e) {
  ui.chat.removeUserMessages(e),
  $.ajax("/backend/accounts/api.php?action=muteplayer&offenderid=" + e),
  geofs.userRecord.muteListMap[e] = 1
}
,
multiplayer.banUser = function(e) {
  $.ajax("/backend/accounts/api.php?action=ban&offenderid=" + e)
}
,
multiplayer.loadModels = function(e) {
  var t, a, o = [];
  if (geofs.aircraftList[e]) {
      var r = ["multiplayer.glb", "multiplayer-low.glb"];
      geofs.aircraftList[e].multiplayerFiles && (r = geofs.aircraftList[e].multiplayerFiles.split(",")),
      t = geofs.aircraftList[e].path + r[0],
      a = geofs.aircraftList[e].path + r[1],
      o.push(new geofs.api.Model(t,{
          justLoad: !0,
          shadows: SHADOWS_CAST,
          incrementallyLoadTextures: !1,
          cacheKey: Math.random()
      })),
      o.push(new geofs.api.Model(a,{
          justLoad: !0,
          shadows: SHADOWS_CAST,
          incrementallyLoadTextures: !1
      }))
  }
  return o
}
,
multiplayer.setNbUsers = function(e) {
  var t = e - 1;
  multiplayer.nbUsers != t && ($(".geofs-player-count").html(t + " pilots online"),
  multiplayer.nbUsers = t)
}
,
multiplayer.setChatMessage = function(e) {
  multiplayer.chatMessage = e
}
,
geofs.debug = {},
geofs.debug.logStack = [],
geofs.debug.logStackMaxLength = 10,
geofs.debug.init = function() {
  geofs.debug.$panel = $(".geofs-debug"),
  geofs.debug.axis = null;
  var e = function(e) {
      e.stopPropagation()
  };
  geofs.debug.$panel.keydown(e),
  geofs.debug.$panel.keyup(e)
}
,
geofs.debug.turnOn = function() {
  geofs.debug.$panel || geofs.debug.init(),
  geofs.debug.$debugFrame = $(".geofs-debugFrame"),
  geofs.debug.$debugWatch = $(".geofs-debugWatch"),
  geofs.debug.$debugLog = $(".geofs-debugLog"),
  geofs.debugOn = !0
}
,
geofs.debug.afterWorldInit = function() {
  geofs.api.debug(geofs.debugOn)
}
,
geofs.debug.turnOff = function() {
  geofs.debugOn = !1,
  geofs.api.debug(!1)
}
,
geofs.debug.watch = function(e, t) {
  geofs.debugOn && geofs.debug.$debugFrame && (geofs.debug[e] || (geofs.debug[e] = document.createElement("div"),
  geofs.debug.$debugFrame.append(geofs.debug[e])),
  geofs.debug[e].innerHTML = e + ": " + t)
}
,
geofs.debug.error = function(e, t) {
  t = t || "unknown",
  e ? (t = t + ": " + e.message,
  geofs.debug.log(t),
  geofs.debug.throw(e)) : geofs.debug.log(t)
}
,
geofs.debug.log = function(e) {
  geofs.debugOn && (geofs.debug.$debugLog && geofs.debug.$debugLog.html(geofs.debug.$debugLog.html() + "<br/>" + e),
  window.console && window.console.log && console.log(e)),
  geofs.debug.stackLog(e)
}
,
geofs.debug.debugger = function() {
  geofs.debugOn
}
,
geofs.debug.throw = function(e) {
  geofs.debugOn && e && setTimeout( () => {
      throw e
  }
  , 0)
}
,
geofs.debug.alert = function(e, t) {
  if (geofs.debugOn && t)
      throw t;
  geofs.debug.stackLog(e)
}
,
geofs.debug.stackLog = function(e) {
  geofs.debug.logStack.push(e),
  geofs.debug.logStack.length > geofs.debug.logStackMaxLength && geofs.debug.logStack.shift()
}
,
geofs.debug.update = function(e) {
  if (geofs.debug.fps = exponentialSmoothing("fps", 1e3 / e).toPrecision(2),
  geofs.debugOn) {
      var t = $(".debugPartName")[0];
      if (t) {
          t = t.value;
          var a = geofs.aircraft.instance.parts[t]
            , o = instruments.list[t];
          if (a) {
              var r = $(".debugCollisionPointIndex")[0].value;
              if (r) {
                  var n = a.collisionPoints[parseInt(r)] || a.points[r];
                  geofs.debug.placeAxis(a.object3d.getWorldFrame(), n.worldPosition)
              } else
                  $(".debugShowForceSource")[0].checked && geofs.debug.placeAxis(a.object3d.getWorldFrame(), a.points.forceSourcePoint.worldPosition),
                  $(".debugShowForceDirection")[0].checked && geofs.debug.placeAxis(a.object3d.getWorldFrame(), a.points.forceDirection.worldPosition),
                  $(".debugShowLocalPosition")[0].checked && geofs.debug.placeAxis(a.object3d.getWorldFrame(), a.object3d.worldPosition),
                  $(".debugShowsuspensionOrigin")[0].checked && geofs.debug.placeAxis(a.object3d.getWorldFrame(), a.points.suspensionOrigin.worldPosition);
              $(".debugPartData").text("Node Origin: " + a.object3d._nodeOrigin)
          }
          if (o && o.definition.cockpit) {
              var s = o.definition.cockpit.position;
              geofs.debug.placeAxis(geofs.aircraft.instance.object3d.getWorldFrame(), s.worldPosition)
          }
          if ("camera" == t) {
              var s = geofs.aircraft.instance.definition.camera.cockpit;
              geofs.aircraft.instance.object3d.setVectorWorldPosition(s),
              geofs.debug.placeAxis(geofs.aircraft.instance.object3d.getWorldFrame(), s.worldPosition)
          }
      }
      geofs.debug.placingObjectId = $(".objectId").val(),
      geofs.debug.placingObjectId && $(".geofs-debugObjectLlaHtr").text(geofs.objects.getLla(geofs.debug.placingObjectId) + " " + geofs.objects.getHtr(geofs.debug.placingObjectId) + " " + geofs.objects.getScale(geofs.debug.placingObjectId))
  }
}
,
geofs.debug.loadAxis = function() {
  var e = "models/debug/axis.glb";
  geofs.debug.axis = {},
  geofs.debug.axis.model = new geofs.api.Model(e)
}
,
geofs.debug.placeProbe = function(e) {
  geofs.debug.probe ? geofs.debug.probe.model.setPositionOrientationAndScale([e[0], e[1], e[2]]) : geofs.debug.loadProbe()
}
,
geofs.debug.loadProbe = function() {
  var e = "models/debug/probe.glb";
  geofs.debug.probe = {},
  geofs.debug.probe.model = new geofs.api.Model(e)
}
,
geofs.debug.placeAxis = function(e, t) {
  geofs.debug.axis || geofs.debug.loadAxis();
  try {
      var a = V3.add(geofs.aircraft.instance.llaLocation, xyz2lla(t, geofs.aircraft.instance.llaLocation))
        , o = M33.getOrientation(e);
      geofs.debug.axis.model.setPositionOrientationAndScale(a, o)
  } catch (r) {
      geofs.debug.error(r, "placeAxis")
  }
}
,
geofs.debug.toggleDebug = function() {
  ui.panel.toggle(".geofs-debug")
}
,
geofs.debug.atmosphereSize = [.02, .02, 1500],
geofs.debug.atmosphereResolution = [.001, .001, 200],
geofs.debug.drawAtmosphere = function(e) {
  geofs.debug.dataSource ? geofs.debug.dataSource.entities.removeAll() : (geofs.debug.dataSource = new Cesium.CustomDataSource("windDebug"),
  geofs.api.viewer.dataSources.add(geofs.debug.dataSource)),
  e = e || geofs.aircraft.instance.llaLocation;
  for (var t = weather.windLayers[weather.activeWindLayer], a = e[0] - geofs.debug.atmosphereSize[0]; a <= e[0] + geofs.debug.atmosphereSize[0]; a += geofs.debug.atmosphereResolution[0])
      for (var o = e[1] - geofs.debug.atmosphereSize[1]; o <= e[1] + geofs.debug.atmosphereSize[1]; o += geofs.debug.atmosphereResolution[1])
          for (var r = 50; r <= geofs.debug.atmosphereSize[2]; r += geofs.debug.atmosphereResolution[2]) {
              var n = [a, o, r]
                , s = t.computeTerrainLift(n);
              n[2] = s.origin[2] + r,
              s = V3.scale(s, t.speed);
              var c = weather.getLocalThermal(n)
                , d = clamp((s = V3.add(s, c))[2], .5, 10)
                , u = Cesium.Color.fromHsl(clamp(.7 - .5 * c[2], 0, .9), clamp(.5 + .5 * s[2], 0, 1), .5);
              s = V3.scale(s, 15);
              var p = Cesium.Cartesian3.fromDegrees(n[1], n[0], n[2])
                , h = V3.add(n, xyz2lla(s, n))
                , m = Cesium.Cartesian3.fromDegrees(h[1], h[0], h[2])
                , f = new Cesium.PolylineGraphics;
              f.material = new Cesium.ColorMaterialProperty(u),
              f.width = new Cesium.ConstantProperty(d),
              f.arcType = new Cesium.ConstantProperty(Cesium.ArcType.NONE),
              f.positions = new Cesium.ConstantProperty([p, m]);
              var g = new Cesium.Entity({
                  show: !0,
                  polyline: f
              });
              geofs.debug.dataSource.entities.add(g)
          }
}
,
geofs.mobile = {
  configuration: {
      physicsDeltaMs: [20, 20, 20, 20, 20, 15, 10, 10],
      renderingQualityLevels: {
          0: {
              resolutionScale: .5,
              tileCacheSize: 0,
              fxaa: !1,
              globeLighting: !1,
              dropShadow: !1,
              cloudCoverToCloudNumber: 15,
              scatteringQuality: 0,
              shadowMapSize: 1024,
              viewingDistance: 0,
              degradedCollisions: !1,
              lowResRunways: !1
          },
          1: {
              resolutionScale: .5,
              tileCacheSize: 50,
              fxaa: !1,
              globeLighting: !0,
              dropShadow: !1,
              cloudCoverToCloudNumber: 1,
              scatteringQuality: 0,
              shadowMapSize: 1024,
              viewingDistance: 1,
              degradedCollisions: !0,
              lowResRunways: !0
          },
          2: {
              resolutionScale: .6,
              tileCacheSize: 50,
              fxaa: !0,
              globeLighting: !0,
              dropShadow: !1,
              cloudCoverToCloudNumber: 5,
              scatteringQuality: 1,
              shadowMapSize: 1024,
              viewingDistance: 2,
              degradedCollisions: !0,
              lowResRunways: !0
          },
          3: {
              resolutionScale: .7,
              tileCacheSize: 50,
              fxaa: !0,
              globeLighting: !0,
              dropShadow: !1,
              cloudCoverToCloudNumber: 10,
              scatteringQuality: 2,
              shadowMapSize: 1024,
              viewingDistance: 3,
              degradedCollisions: !0,
              lowResRunways: !0
          },
          4: {
              resolutionScale: .8,
              tileCacheSize: 50,
              fxaa: !0,
              globeLighting: !0,
              dropShadow: !1,
              cloudCoverToCloudNumber: 12,
              scatteringQuality: 3,
              shadowMapSize: 2048,
              viewingDistance: 4,
              degradedCollisions: !0,
              lowResRunways: !1
          },
          5: {
              resolutionScale: .9,
              tileCacheSize: 50,
              fxaa: !0,
              globeLighting: !0,
              dropShadow: !1,
              cloudCoverToCloudNumber: 14,
              scatteringQuality: 4,
              shadowMapSize: 2048,
              viewingDistance: 5,
              degradedCollisions: !0,
              lowResRunways: !1
          },
          6: {
              resolutionScale: 1,
              tileCacheSize: 100,
              fxaa: !0,
              globeLighting: !0,
              dropShadow: !1,
              cloudCoverToCloudNumber: 15,
              scatteringQuality: 5,
              shadowMapSize: 2048,
              viewingDistance: 6,
              degradedCollisions: !0,
              lowResRunways: !1
          }
      },
      screenSpacePresets: {
          maximumScreenSpaceError: [5, 4, 3, 2, 2, 2, 1.5, 1],
          fogScreenSpaceErrorFactor: [2, 2, 2, 2, 2, 2, 1.5, 1],
          fogDensity: [.001, 8e-4, 6e-4, 4e-4, 3e-4, 2e-4, 15e-5, 1e-4]
      },
      qualityToBuildingTexture: {
          1: "low",
          2: "low",
          3: "low",
          4: "low",
          5: "low",
          6: "med",
          7: "high"
      }
  },
  init: function() {
      geofs.api.testIfMobileDevice() ? ($("body").addClass("geofs-mobileDevice"),
      geofs.isMobileDevice = !0) : ($("body").removeClass("geofs-mobileDevice"),
      geofs.isMobileDevice = !1)
  },
  configure: function() {
      geofs.preferencesDefault.mobile = !0,
      geofs.preferencesDefault.chat = !1,
      geofs.preferencesDefault.interface.transparent = !0,
      geofs.preferencesDefault.controlMode = "touch"
  },
  turnOn: function() {
      if (!geofs.mobile.on) {
          if (geofs.mobile.on = !0,
          $("body").addClass("geofs-mobile"),
          geofs.buildings.GLSLReflection = !1,
          geofs.api.preferredCompositor = "canvas",
          "ios" == geofs.api.getPlatform())
              for (var e in geofs.mobile.configuration.renderingQualityLevels)
                  geofs.mobile.configuration.renderingQualityLevels[e].tileCacheSize = 1;
          geofs.configuration.applyConfiguration(geofs.mobile.configuration),
          geofs.api.renderingQuality();
          try {
              geofs.isApp || (document.documentElement.requestFullscreen(),
              screen.orientation.lock("landscape-primary"))
          } catch (t) {}
      }
  },
  turnOff: function() {
      geofs.mobile.on && (geofs.mobile.on = !1,
      geofs.preferences.mobile = !1,
      geofs.savePreferences(),
      $("body").removeClass("geofs-mobile"),
      screen.orientation.unlock(),
      geofs.preferencesDefault.controlMode = "mouse",
      geofs.api.preferredCompositor = "css",
      geofs.configuration.applyConfiguration(),
      geofs.api.renderingQuality())
  },
  setMobileMode: function() {
      geofs.preferences.mobile ? geofs.mobile.turnOn() : geofs.mobile.turnOff()
  }
},
geofs.speech = geofs.speech || {
  init(e) {
      geofs.speech.initialized || (e = e || {},
      geofs.speech.synthesis = window.speechSynthesis,
      geofs.speech.pitch = 1,
      geofs.speech.rate = 1,
      geofs.speech.volume = 1,
      geofs.speech.recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition),
      geofs.speech.recognition.continuous = !0,
      geofs.speech.recognition.interimResults = !1,
      geofs.speech.recognition.maxAlternatives = 1,
      geofs.speech.recognition.onresult = e => {
          let t = e.results[e.results.length - 1]
            , a = t[0].transcript;
          geofs.speech.recognitionListeners.forEach(e => {
              e.call(null, a)
          }
          )
      }
      ,
      geofs.speech.recognitionListeners = [],
      geofs.speech.startRecognition(),
      geofs.speech.addRecognitionListener(e => {
          geofs.speech.wordsSpoken = null,
          geofs.speech.commandSpoken = null,
          geofs.speech.textSpoken = null,
          e && (geofs.speech.textSpoken = e.trim().toLowerCase(),
          geofs.speech.wordsSpoken = geofs.speech.textSpoken.split(" "),
          geofs.speech.commandSpoken = geofs.speech.wordsSpoken[0],
          geofs.speech.valueSpoken = geofs.speech.wordsSpoken[1],
          $(document).trigger("textSpoken"))
      }
      ),
      geofs.speech.initialized = !0)
  },
  getVoices: () => window.speechSynthesis.getVoices(),
  setLanguage(e) {
      geofs.speech.stopRecognition(),
      geofs.speech.recognition.lang = e,
      geofs.speech.setVoice(null, e),
      setTimeout( () => {
          geofs.speech.startRecognition()
      }
      , 1e3)
  },
  setVoice(e, t) {
      geofs.speech.selectedVoice = geofs.speech.getVoice(e, t)
  },
  getVoice(e, t) {
      if (geofs.speech.availableVoices = geofs.speech.getVoices(),
      t) {
          for (var a = 0; a < geofs.speech.availableVoices.length; a++)
              if (geofs.speech.availableVoices[a].lang == t) {
                  e = a;
                  break
              }
      }
      return geofs.speech.availableVoices[e || 0]
  },
  speak(e, t) {
      if (!e)
          return;
      t = t || {};
      let a = new SpeechSynthesisUtterance(e);
      a.voice = t.voice ? geofs.speech.getVoice(t.voice) : geofs.speech.selectedVoice || geofs.speech.getVoice(0),
      geofs.speech.synthesis.cancel(),
      geofs.speech.stopRecognition(),
      a.onend = () => {
          geofs.speech.startRecognition()
      }
      ,
      a.pitch = t.pitch || geofs.speech.pitch,
      a.rate = t.rate || geofs.speech.rate,
      a.volume = t.volume || geofs.speech.volume,
      geofs.speech.synthesis.speak(a)
  },
  cancel() {
      geofs.speech.synthesis.cancel()
  },
  startRecognition() {
      geofs.speech.recognition.start(),
      geofs.speech.recognition.onend = geofs.speech.startRecognition
  },
  stopRecognition() {
      geofs.speech.recognition.onend = null,
      geofs.speech.recognition.stop()
  },
  addRecognitionListener(e) {
      geofs.speech.recognitionListeners.push(e)
  },
  destroy() {
      geofs.speech.initialized && (geofs.speech.stopRecognition(),
      geofs.speech.initialized = !1)
  }
};
