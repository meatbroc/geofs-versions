/* @preserve
 * Leaflet 1.9.4+v1.d15112c, a JS library for interactive maps. https://leafletjs.com
 * (c) 2010-2023 Vladimir Agafonkin, (c) 2010-2011 CloudMade
 */
!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).leaflet = {}) }(this, function (t) { "use strict"; function l(t) { for (var e, i, n = 1, o = arguments.length; n < o; n++)for (e in i = arguments[n]) t[e] = i[e]; return t } var R = Object.create || function (t) { return N.prototype = t, new N }; function N() { } function a(t, e) { var i, n = Array.prototype.slice; return t.bind ? t.bind.apply(t, n.call(arguments, 1)) : (i = n.call(arguments, 2), function () { return t.apply(e, i.length ? i.concat(n.call(arguments)) : arguments) }) } var D = 0; function h(t) { return "_leaflet_id" in t || (t._leaflet_id = ++D), t._leaflet_id } function j(t, e, i) { var n, o, s = function () { n = !1, o && (r.apply(i, o), o = !1) }, r = function () { n ? o = arguments : (t.apply(i, arguments), setTimeout(s, e), n = !0) }; return r } function H(t, e, i) { var n = e[1], e = e[0], o = n - e; return t === n && i ? t : ((t - e) % o + o) % o + e } function u() { return !1 } function i(t, e) { return !1 === e ? t : (e = Math.pow(10, void 0 === e ? 6 : e), Math.round(t * e) / e) } function W(t) { return t.trim ? t.trim() : t.replace(/^\s+|\s+$/g, "") } function F(t) { return W(t).split(/\s+/) } function c(t, e) { for (var i in Object.prototype.hasOwnProperty.call(t, "options") || (t.options = t.options ? R(t.options) : {}), e) t.options[i] = e[i]; return t.options } function U(t, e, i) { var n, o = []; for (n in t) o.push(encodeURIComponent(i ? n.toUpperCase() : n) + "=" + encodeURIComponent(t[n])); return (e && -1 !== e.indexOf("?") ? "&" : "?") + o.join("&") } var V = /\{ *([\w_ -]+) *\}/g; function q(t, i) { return t.replace(V, function (t, e) { e = i[e]; if (void 0 === e) throw new Error("No value provided for variable " + t); return e = "function" == typeof e ? e(i) : e }) } var d = Array.isArray || function (t) { return "[object Array]" === Object.prototype.toString.call(t) }; function G(t, e) { for (var i = 0; i < t.length; i++)if (t[i] === e) return i; return -1 } var K = "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="; function Y(t) { return window["webkit" + t] || window["moz" + t] || window["ms" + t] } var X = 0; function J(t) { var e = +new Date, i = Math.max(0, 16 - (e - X)); return X = e + i, window.setTimeout(t, i) } var $ = window.requestAnimationFrame || Y("RequestAnimationFrame") || J, Q = window.cancelAnimationFrame || Y("CancelAnimationFrame") || Y("CancelRequestAnimationFrame") || function (t) { window.clearTimeout(t) }; function x(t, e, i) { if (!i || $ !== J) return $.call(window, a(t, e)); t.call(e) } function r(t) { t && Q.call(window, t) } var tt = { __proto__: null, extend: l, create: R, bind: a, get lastId() { return D }, stamp: h, throttle: j, wrapNum: H, falseFn: u, formatNum: i, trim: W, splitWords: F, setOptions: c, getParamString: U, template: q, isArray: d, indexOf: G, emptyImageUrl: K, requestFn: $, cancelFn: Q, requestAnimFrame: x, cancelAnimFrame: r }; function et() { } et.extend = function (t) { function e() { c(this), this.initialize && this.initialize.apply(this, arguments), this.callInitHooks() } var i, n = e.__super__ = this.prototype, o = R(n); for (i in (o.constructor = e).prototype = o, this) Object.prototype.hasOwnProperty.call(this, i) && "prototype" !== i && "__super__" !== i && (e[i] = this[i]); if (t.statics && l(e, t.statics), t.includes) { var s = t.includes; if ("undefined" != typeof L && L && L.Mixin) { s = d(s) ? s : [s]; for (var r = 0; r < s.length; r++)s[r] === L.Mixin.Events && console.warn("Deprecated include of L.Mixin.Events: this property will be removed in future releases, please inherit from L.Evented instead.", (new Error).stack) } l.apply(null, [o].concat(t.includes)) } return l(o, t), delete o.statics, delete o.includes, o.options && (o.options = n.options ? R(n.options) : {}, l(o.options, t.options)), o._initHooks = [], o.callInitHooks = function () { if (!this._initHooksCalled) { n.callInitHooks && n.callInitHooks.call(this), this._initHooksCalled = !0; for (var t = 0, e = o._initHooks.length; t < e; t++)o._initHooks[t].call(this) } }, e }, et.include = function (t) { var e = this.prototype.options; return l(this.prototype, t), t.options && (this.prototype.options = e, this.mergeOptions(t.options)), this }, et.mergeOptions = function (t) { return l(this.prototype.options, t), this }, et.addInitHook = function (t) { var e = Array.prototype.slice.call(arguments, 1), i = "function" == typeof t ? t : function () { this[t].apply(this, e) }; return this.prototype._initHooks = this.prototype._initHooks || [], this.prototype._initHooks.push(i), this }; var e = { on: function (t, e, i) { if ("object" == typeof t) for (var n in t) this._on(n, t[n], e); else for (var o = 0, s = (t = F(t)).length; o < s; o++)this._on(t[o], e, i); return this }, off: function (t, e, i) { if (arguments.length) if ("object" == typeof t) for (var n in t) this._off(n, t[n], e); else { t = F(t); for (var o = 1 === arguments.length, s = 0, r = t.length; s < r; s++)o ? this._off(t[s]) : this._off(t[s], e, i) } else delete this._events; return this }, _on: function (t, e, i, n) { "function" != typeof e ? console.warn("wrong listener type: " + typeof e) : !1 === this._listens(t, e, i) && (e = { fn: e, ctx: i = i === this ? void 0 : i }, n && (e.once = !0), this._events = this._events || {}, this._events[t] = this._events[t] || [], this._events[t].push(e)) }, _off: function (t, e, i) { var n, o, s; if (this._events && (n = this._events[t])) if (1 === arguments.length) { if (this._firingCount) for (o = 0, s = n.length; o < s; o++)n[o].fn = u; delete this._events[t] } else "function" != typeof e ? console.warn("wrong listener type: " + typeof e) : !1 !== (e = this._listens(t, e, i)) && (i = n[e], this._firingCount && (i.fn = u, this._events[t] = n = n.slice()), n.splice(e, 1)) }, fire: function (t, e, i) { if (this.listens(t, i)) { var n = l({}, e, { type: t, target: this, sourceTarget: e && e.sourceTarget || this }); if (this._events) { var o = this._events[t]; if (o) { this._firingCount = this._firingCount + 1 || 1; for (var s = 0, r = o.length; s < r; s++) { var a = o[s], h = a.fn; a.once && this.off(t, h, a.ctx), h.call(a.ctx || this, n) } this._firingCount-- } } i && this._propagateEvent(n) } return this }, listens: function (t, e, i, n) { "string" != typeof t && console.warn('"string" type argument expected'); var o = e, s = ("function" != typeof e && (n = !!e, i = o = void 0), this._events && this._events[t]); if (s && s.length && !1 !== this._listens(t, o, i)) return !0; if (n) for (var r in this._eventParents) if (this._eventParents[r].listens(t, e, i, n)) return !0; return !1 }, _listens: function (t, e, i) { if (this._events) { var n = this._events[t] || []; if (!e) return !!n.length; i === this && (i = void 0); for (var o = 0, s = n.length; o < s; o++)if (n[o].fn === e && n[o].ctx === i) return o } return !1 }, once: function (t, e, i) { if ("object" == typeof t) for (var n in t) this._on(n, t[n], e, !0); else for (var o = 0, s = (t = F(t)).length; o < s; o++)this._on(t[o], e, i, !0); return this }, addEventParent: function (t) { return this._eventParents = this._eventParents || {}, this._eventParents[h(t)] = t, this }, removeEventParent: function (t) { return this._eventParents && delete this._eventParents[h(t)], this }, _propagateEvent: function (t) { for (var e in this._eventParents) this._eventParents[e].fire(t.type, l({ layer: t.target, propagatedFrom: t.target }, t), !0) } }, it = (e.addEventListener = e.on, e.removeEventListener = e.clearAllEventListeners = e.off, e.addOneTimeEventListener = e.once, e.fireEvent = e.fire, e.hasEventListeners = e.listens, et.extend(e)); function p(t, e, i) { this.x = i ? Math.round(t) : t, this.y = i ? Math.round(e) : e } var nt = Math.trunc || function (t) { return 0 < t ? Math.floor(t) : Math.ceil(t) }; function m(t, e, i) { return t instanceof p ? t : d(t) ? new p(t[0], t[1]) : null == t ? t : "object" == typeof t && "x" in t && "y" in t ? new p(t.x, t.y) : new p(t, e, i) } function f(t, e) { if (t) for (var i = e ? [t, e] : t, n = 0, o = i.length; n < o; n++)this.extend(i[n]) } function _(t, e) { return !t || t instanceof f ? t : new f(t, e) } function s(t, e) { if (t) for (var i = e ? [t, e] : t, n = 0, o = i.length; n < o; n++)this.extend(i[n]) } function g(t, e) { return t instanceof s ? t : new s(t, e) } function v(t, e, i) { if (isNaN(t) || isNaN(e)) throw new Error("Invalid LatLng object: (" + t + ", " + e + ")"); this.lat = +t, this.lng = +e, void 0 !== i && (this.alt = +i) } function w(t, e, i) { return t instanceof v ? t : d(t) && "object" != typeof t[0] ? 3 === t.length ? new v(t[0], t[1], t[2]) : 2 === t.length ? new v(t[0], t[1]) : null : null == t ? t : "object" == typeof t && "lat" in t ? new v(t.lat, "lng" in t ? t.lng : t.lon, t.alt) : void 0 === e ? null : new v(t, e, i) } p.prototype = { clone: function () { return new p(this.x, this.y) }, add: function (t) { return this.clone()._add(m(t)) }, _add: function (t) { return this.x += t.x, this.y += t.y, this }, subtract: function (t) { return this.clone()._subtract(m(t)) }, _subtract: function (t) { return this.x -= t.x, this.y -= t.y, this }, divideBy: function (t) { return this.clone()._divideBy(t) }, _divideBy: function (t) { return this.x /= t, this.y /= t, this }, multiplyBy: function (t) { return this.clone()._multiplyBy(t) }, _multiplyBy: function (t) { return this.x *= t, this.y *= t, this }, scaleBy: function (t) { return new p(this.x * t.x, this.y * t.y) }, unscaleBy: function (t) { return new p(this.x / t.x, this.y / t.y) }, round: function () { return this.clone()._round() }, _round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, floor: function () { return this.clone()._floor() }, _floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, ceil: function () { return this.clone()._ceil() }, _ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, trunc: function () { return this.clone()._trunc() }, _trunc: function () { return this.x = nt(this.x), this.y = nt(this.y), this }, distanceTo: function (t) { var e = (t = m(t)).x - this.x, t = t.y - this.y; return Math.sqrt(e * e + t * t) }, equals: function (t) { return (t = m(t)).x === this.x && t.y === this.y }, contains: function (t) { return t = m(t), Math.abs(t.x) <= Math.abs(this.x) && Math.abs(t.y) <= Math.abs(this.y) }, toString: function () { return "Point(" + i(this.x) + ", " + i(this.y) + ")" } }, f.prototype = { extend: function (t) { var e, i; if (t) { if (t instanceof p || "number" == typeof t[0] || "x" in t) e = i = m(t); else if (e = (t = _(t)).min, i = t.max, !e || !i) return this; this.min || this.max ? (this.min.x = Math.min(e.x, this.min.x), this.max.x = Math.max(i.x, this.max.x), this.min.y = Math.min(e.y, this.min.y), this.max.y = Math.max(i.y, this.max.y)) : (this.min = e.clone(), this.max = i.clone()) } return this }, getCenter: function (t) { return m((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, t) }, getBottomLeft: function () { return m(this.min.x, this.max.y) }, getTopRight: function () { return m(this.max.x, this.min.y) }, getTopLeft: function () { return this.min }, getBottomRight: function () { return this.max }, getSize: function () { return this.max.subtract(this.min) }, contains: function (t) { var e, i; return (t = ("number" == typeof t[0] || t instanceof p ? m : _)(t)) instanceof f ? (e = t.min, i = t.max) : e = i = t, e.x >= this.min.x && i.x <= this.max.x && e.y >= this.min.y && i.y <= this.max.y }, intersects: function (t) { t = _(t); var e = this.min, i = this.max, n = t.min, t = t.max, o = t.x >= e.x && n.x <= i.x, t = t.y >= e.y && n.y <= i.y; return o && t }, overlaps: function (t) { t = _(t); var e = this.min, i = this.max, n = t.min, t = t.max, o = t.x > e.x && n.x < i.x, t = t.y > e.y && n.y < i.y; return o && t }, isValid: function () { return !(!this.min || !this.max) }, pad: function (t) { var e = this.min, i = this.max, n = Math.abs(e.x - i.x) * t, t = Math.abs(e.y - i.y) * t; return _(m(e.x - n, e.y - t), m(i.x + n, i.y + t)) }, equals: function (t) { return !!t && (t = _(t), this.min.equals(t.getTopLeft()) && this.max.equals(t.getBottomRight())) } }, s.prototype = { extend: function (t) { var e, i, n = this._southWest, o = this._northEast; if (t instanceof v) i = e = t; else { if (!(t instanceof s)) return t ? this.extend(w(t) || g(t)) : this; if (e = t._southWest, i = t._northEast, !e || !i) return this } return n || o ? (n.lat = Math.min(e.lat, n.lat), n.lng = Math.min(e.lng, n.lng), o.lat = Math.max(i.lat, o.lat), o.lng = Math.max(i.lng, o.lng)) : (this._southWest = new v(e.lat, e.lng), this._northEast = new v(i.lat, i.lng)), this }, pad: function (t) { var e = this._southWest, i = this._northEast, n = Math.abs(e.lat - i.lat) * t, t = Math.abs(e.lng - i.lng) * t; return new s(new v(e.lat - n, e.lng - t), new v(i.lat + n, i.lng + t)) }, getCenter: function () { return new v((this._southWest.lat + this._northEast.lat) / 2, (this._southWest.lng + this._northEast.lng) / 2) }, getSouthWest: function () { return this._southWest }, getNorthEast: function () { return this._northEast }, getNorthWest: function () { return new v(this.getNorth(), this.getWest()) }, getSouthEast: function () { return new v(this.getSouth(), this.getEast()) }, getWest: function () { return this._southWest.lng }, getSouth: function () { return this._southWest.lat }, getEast: function () { return this._northEast.lng }, getNorth: function () { return this._northEast.lat }, contains: function (t) { t = ("number" == typeof t[0] || t instanceof v || "lat" in t ? w : g)(t); var e, i, n = this._southWest, o = this._northEast; return t instanceof s ? (e = t.getSouthWest(), i = t.getNorthEast()) : e = i = t, e.lat >= n.lat && i.lat <= o.lat && e.lng >= n.lng && i.lng <= o.lng }, intersects: function (t) { t = g(t); var e = this._southWest, i = this._northEast, n = t.getSouthWest(), t = t.getNorthEast(), o = t.lat >= e.lat && n.lat <= i.lat, t = t.lng >= e.lng && n.lng <= i.lng; return o && t }, overlaps: function (t) { t = g(t); var e = this._southWest, i = this._northEast, n = t.getSouthWest(), t = t.getNorthEast(), o = t.lat > e.lat && n.lat < i.lat, t = t.lng > e.lng && n.lng < i.lng; return o && t }, toBBoxString: function () { return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(",") }, equals: function (t, e) { return !!t && (t = g(t), this._southWest.equals(t.getSouthWest(), e) && this._northEast.equals(t.getNorthEast(), e)) }, isValid: function () { return !(!this._southWest || !this._northEast) } }; var ot = { latLngToPoint: function (t, e) { t = this.projection.project(t), e = this.scale(e); return this.transformation._transform(t, e) }, pointToLatLng: function (t, e) { e = this.scale(e), t = this.transformation.untransform(t, e); return this.projection.unproject(t) }, project: function (t) { return this.projection.project(t) }, unproject: function (t) { return this.projection.unproject(t) }, scale: function (t) { return 256 * Math.pow(2, t) }, zoom: function (t) { return Math.log(t / 256) / Math.LN2 }, getProjectedBounds: function (t) { var e; return this.infinite ? null : (e = this.projection.bounds, t = this.scale(t), new f(this.transformation.transform(e.min, t), this.transformation.transform(e.max, t))) }, infinite: !(v.prototype = { equals: function (t, e) { return !!t && (t = w(t), Math.max(Math.abs(this.lat - t.lat), Math.abs(this.lng - t.lng)) <= (void 0 === e ? 1e-9 : e)) }, toString: function (t) { return "LatLng(" + i(this.lat, t) + ", " + i(this.lng, t) + ")" }, distanceTo: function (t) { return st.distance(this, w(t)) }, wrap: function () { return st.wrapLatLng(this) }, toBounds: function (t) { var t = 180 * t / 40075017, e = t / Math.cos(Math.PI / 180 * this.lat); return g([this.lat - t, this.lng - e], [this.lat + t, this.lng + e]) }, clone: function () { return new v(this.lat, this.lng, this.alt) } }), wrapLatLng: function (t) { var e = this.wrapLng ? H(t.lng, this.wrapLng, !0) : t.lng; return new v(this.wrapLat ? H(t.lat, this.wrapLat, !0) : t.lat, e, t.alt) }, wrapLatLngBounds: function (t) { var e = t.getCenter(), i = this.wrapLatLng(e), n = e.lat - i.lat, e = e.lng - i.lng; return 0 == n && 0 == e ? t : (i = t.getSouthWest(), t = t.getNorthEast(), new s(new v(i.lat - n, i.lng - e), new v(t.lat - n, t.lng - e))) } }, st = l({}, ot, { wrapLng: [-180, 180], R: 6371e3, distance: function (t, e) { var i = Math.PI / 180, n = t.lat * i, o = e.lat * i, s = Math.sin((e.lat - t.lat) * i / 2), e = Math.sin((e.lng - t.lng) * i / 2), t = s * s + Math.cos(n) * Math.cos(o) * e * e, i = 2 * Math.atan2(Math.sqrt(t), Math.sqrt(1 - t)); return this.R * i } }), rt = 6378137, rt = { R: rt, MAX_LATITUDE: 85.0511287798, project: function (t) { var e = Math.PI / 180, i = this.MAX_LATITUDE, i = Math.max(Math.min(i, t.lat), -i), i = Math.sin(i * e); return new p(this.R * t.lng * e, this.R * Math.log((1 + i) / (1 - i)) / 2) }, unproject: function (t) { var e = 180 / Math.PI; return new v((2 * Math.atan(Math.exp(t.y / this.R)) - Math.PI / 2) * e, t.x * e / this.R) }, bounds: new f([-(rt = rt * Math.PI), -rt], [rt, rt]) }; function at(t, e, i, n) { d(t) ? (this._a = t[0], this._b = t[1], this._c = t[2], this._d = t[3]) : (this._a = t, this._b = e, this._c = i, this._d = n) } function ht(t, e, i, n) { return new at(t, e, i, n) } at.prototype = { transform: function (t, e) { return this._transform(t.clone(), e) }, _transform: function (t, e) { return t.x = (e = e || 1) * (this._a * t.x + this._b), t.y = e * (this._c * t.y + this._d), t }, untransform: function (t, e) { return new p((t.x / (e = e || 1) - this._b) / this._a, (t.y / e - this._d) / this._c) } }; var lt = l({}, st, { code: "EPSG:3857", projection: rt, transformation: ht(lt = .5 / (Math.PI * rt.R), .5, -lt, .5) }), ut = l({}, lt, { code: "EPSG:900913" }); function ct(t) { return document.createElementNS("http://www.w3.org/2000/svg", t) } function dt(t, e) { for (var i, n, o, s, r = "", a = 0, h = t.length; a < h; a++) { for (i = 0, n = (o = t[a]).length; i < n; i++)r += (i ? "L" : "M") + (s = o[i]).x + " " + s.y; r += e ? b.svg ? "z" : "x" : "" } return r || "M0 0" } var _t = document.documentElement.style, pt = "ActiveXObject" in window, mt = pt && !document.addEventListener, n = "msLaunchUri" in navigator && !("documentMode" in document), ft = y("webkit"), gt = y("android"), vt = y("android 2") || y("android 3"), yt = parseInt(/WebKit\/([0-9]+)|$/.exec(navigator.userAgent)[1], 10), yt = gt && y("Google") && yt < 537 && !("AudioNode" in window), xt = !!window.opera, wt = !n && y("chrome"), bt = y("gecko") && !ft && !xt && !pt, Pt = !wt && y("safari"), Lt = y("phantom"), o = "OTransition" in _t, Tt = 0 === navigator.platform.indexOf("Win"), Mt = pt && "transition" in _t, zt = "WebKitCSSMatrix" in window && "m11" in new window.WebKitCSSMatrix && !vt, _t = "MozPerspective" in _t, Ct = !window.L_DISABLE_3D && (Mt || zt || _t) && !o && !Lt, Zt = "undefined" != typeof orientation || y("mobile"), St = Zt && ft, Et = Zt && zt, kt = !window.PointerEvent && window.MSPointerEvent, Ot = !(!window.PointerEvent && !kt), At = "ontouchstart" in window || !!window.TouchEvent, Bt = !window.L_NO_TOUCH && (At || Ot), It = Zt && xt, Rt = Zt && bt, Nt = 1 < (window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI), Dt = function () { var t = !1; try { var e = Object.defineProperty({}, "passive", { get: function () { t = !0 } }); window.addEventListener("testPassiveEventSupport", u, e), window.removeEventListener("testPassiveEventSupport", u, e) } catch (t) { } return t }(), jt = !!document.createElement("canvas").getContext, Ht = !(!document.createElementNS || !ct("svg").createSVGRect), Wt = !!Ht && ((Wt = document.createElement("div")).innerHTML = "<svg/>", "http://www.w3.org/2000/svg" === (Wt.firstChild && Wt.firstChild.namespaceURI)); function y(t) { return 0 <= navigator.userAgent.toLowerCase().indexOf(t) } var b = { ie: pt, ielt9: mt, edge: n, webkit: ft, android: gt, android23: vt, androidStock: yt, opera: xt, chrome: wt, gecko: bt, safari: Pt, phantom: Lt, opera12: o, win: Tt, ie3d: Mt, webkit3d: zt, gecko3d: _t, any3d: Ct, mobile: Zt, mobileWebkit: St, mobileWebkit3d: Et, msPointer: kt, pointer: Ot, touch: Bt, touchNative: At, mobileOpera: It, mobileGecko: Rt, retina: Nt, passiveEvents: Dt, canvas: jt, svg: Ht, vml: !Ht && function () { try { var t = document.createElement("div"), e = (t.innerHTML = '<v:shape adj="1"/>', t.firstChild); return e.style.behavior = "url(#default#VML)", e && "object" == typeof e.adj } catch (t) { return !1 } }(), inlineSvg: Wt, mac: 0 === navigator.platform.indexOf("Mac"), linux: 0 === navigator.platform.indexOf("Linux") }, Ft = b.msPointer ? "MSPointerDown" : "pointerdown", Ut = b.msPointer ? "MSPointerMove" : "pointermove", Vt = b.msPointer ? "MSPointerUp" : "pointerup", qt = b.msPointer ? "MSPointerCancel" : "pointercancel", Gt = { touchstart: Ft, touchmove: Ut, touchend: Vt, touchcancel: qt }, Kt = { touchstart: function (t, e) { e.MSPOINTER_TYPE_TOUCH && e.pointerType === e.MSPOINTER_TYPE_TOUCH && O(e); ee(t, e) }, touchmove: ee, touchend: ee, touchcancel: ee }, Yt = {}, Xt = !1; function Jt(t, e, i) { return "touchstart" !== e || Xt || (document.addEventListener(Ft, $t, !0), document.addEventListener(Ut, Qt, !0), document.addEventListener(Vt, te, !0), document.addEventListener(qt, te, !0), Xt = !0), Kt[e] ? (i = Kt[e].bind(this, i), t.addEventListener(Gt[e], i, !1), i) : (console.warn("wrong event specified:", e), u) } function $t(t) { Yt[t.pointerId] = t } function Qt(t) { Yt[t.pointerId] && (Yt[t.pointerId] = t) } function te(t) { delete Yt[t.pointerId] } function ee(t, e) { if (e.pointerType !== (e.MSPOINTER_TYPE_MOUSE || "mouse")) { for (var i in e.touches = [], Yt) e.touches.push(Yt[i]); e.changedTouches = [e], t(e) } } var ie = 200; function ne(t, i) { t.addEventListener("dblclick", i); var n, o = 0; function e(t) { var e; 1 !== t.detail ? n = t.detail : "mouse" === t.pointerType || t.sourceCapabilities && !t.sourceCapabilities.firesTouchEvents || ((e = Ne(t)).some(function (t) { return t instanceof HTMLLabelElement && t.attributes.for }) && !e.some(function (t) { return t instanceof HTMLInputElement || t instanceof HTMLSelectElement }) || ((e = Date.now()) - o <= ie ? 2 === ++n && i(function (t) { var e, i, n = {}; for (i in t) e = t[i], n[i] = e && e.bind ? e.bind(t) : e; return (t = n).type = "dblclick", n.detail = 2, n.isTrusted = !1, n._simulated = !0, n }(t)) : n = 1, o = e)) } return t.addEventListener("click", e), { dblclick: i, simDblclick: e } } var oe, se, re, ae, he, le, ue = we(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), ce = we(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]), de = "webkitTransition" === ce || "OTransition" === ce ? ce + "End" : "transitionend"; function _e(t) { return "string" == typeof t ? document.getElementById(t) : t } function pe(t, e) { var i = t.style[e] || t.currentStyle && t.currentStyle[e]; return "auto" === (i = i && "auto" !== i || !document.defaultView ? i : (t = document.defaultView.getComputedStyle(t, null)) ? t[e] : null) ? null : i } function P(t, e, i) { t = document.createElement(t); return t.className = e || "", i && i.appendChild(t), t } function T(t) { var e = t.parentNode; e && e.removeChild(t) } function me(t) { for (; t.firstChild;)t.removeChild(t.firstChild) } function fe(t) { var e = t.parentNode; e && e.lastChild !== t && e.appendChild(t) } function ge(t) { var e = t.parentNode; e && e.firstChild !== t && e.insertBefore(t, e.firstChild) } function ve(t, e) { return void 0 !== t.classList ? t.classList.contains(e) : 0 < (t = xe(t)).length && new RegExp("(^|\\s)" + e + "(\\s|$)").test(t) } function M(t, e) { var i; if (void 0 !== t.classList) for (var n = F(e), o = 0, s = n.length; o < s; o++)t.classList.add(n[o]); else ve(t, e) || ye(t, ((i = xe(t)) ? i + " " : "") + e) } function z(t, e) { void 0 !== t.classList ? t.classList.remove(e) : ye(t, W((" " + xe(t) + " ").replace(" " + e + " ", " "))) } function ye(t, e) { void 0 === t.className.baseVal ? t.className = e : t.className.baseVal = e } function xe(t) { return void 0 === (t = t.correspondingElement ? t.correspondingElement : t).className.baseVal ? t.className : t.className.baseVal } function C(t, e) { if ("opacity" in t.style) t.style.opacity = e; else if ("filter" in t.style) { var i = !1, n = "DXImageTransform.Microsoft.Alpha"; try { i = t.filters.item(n) } catch (t) { if (1 === e) return } e = Math.round(100 * e), i ? (i.Enabled = 100 !== e, i.Opacity = e) : t.style.filter += " progid:" + n + "(opacity=" + e + ")" } } function we(t) { for (var e = document.documentElement.style, i = 0; i < t.length; i++)if (t[i] in e) return t[i]; return !1 } function be(t, e, i) { e = e || new p(0, 0); t.style[ue] = (b.ie3d ? "translate(" + e.x + "px," + e.y + "px)" : "translate3d(" + e.x + "px," + e.y + "px,0)") + (i ? " scale(" + i + ")" : "") } function Z(t, e) { t._leaflet_pos = e, b.any3d ? be(t, e) : (t.style.left = e.x + "px", t.style.top = e.y + "px") } function Pe(t) { return t._leaflet_pos || new p(0, 0) } function Le() { S(window, "dragstart", O) } function Te() { k(window, "dragstart", O) } function Me(t) { for (; -1 === t.tabIndex;)t = t.parentNode; t.style && (ze(), le = (he = t).style.outlineStyle, t.style.outlineStyle = "none", S(window, "keydown", ze)) } function ze() { he && (he.style.outlineStyle = le, le = he = void 0, k(window, "keydown", ze)) } function Ce(t) { for (; !((t = t.parentNode).offsetWidth && t.offsetHeight || t === document.body);); return t } function Ze(t) { var e = t.getBoundingClientRect(); return { x: e.width / t.offsetWidth || 1, y: e.height / t.offsetHeight || 1, boundingClientRect: e } } ae = "onselectstart" in document ? (re = function () { S(window, "selectstart", O) }, function () { k(window, "selectstart", O) }) : (se = we(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]), re = function () { var t; se && (t = document.documentElement.style, oe = t[se], t[se] = "none") }, function () { se && (document.documentElement.style[se] = oe, oe = void 0) }); pt = { __proto__: null, TRANSFORM: ue, TRANSITION: ce, TRANSITION_END: de, get: _e, getStyle: pe, create: P, remove: T, empty: me, toFront: fe, toBack: ge, hasClass: ve, addClass: M, removeClass: z, setClass: ye, getClass: xe, setOpacity: C, testProp: we, setTransform: be, setPosition: Z, getPosition: Pe, get disableTextSelection() { return re }, get enableTextSelection() { return ae }, disableImageDrag: Le, enableImageDrag: Te, preventOutline: Me, restoreOutline: ze, getSizedParentNode: Ce, getScale: Ze }; function S(t, e, i, n) { if (e && "object" == typeof e) for (var o in e) ke(t, o, e[o], i); else for (var s = 0, r = (e = F(e)).length; s < r; s++)ke(t, e[s], i, n); return this } var E = "_leaflet_events"; function k(t, e, i, n) { if (1 === arguments.length) Se(t), delete t[E]; else if (e && "object" == typeof e) for (var o in e) Oe(t, o, e[o], i); else if (e = F(e), 2 === arguments.length) Se(t, function (t) { return -1 !== G(e, t) }); else for (var s = 0, r = e.length; s < r; s++)Oe(t, e[s], i, n); return this } function Se(t, e) { for (var i in t[E]) { var n = i.split(/\d/)[0]; e && !e(n) || Oe(t, n, null, null, i) } } var Ee = { mouseenter: "mouseover", mouseleave: "mouseout", wheel: !("onwheel" in window) && "mousewheel" }; function ke(e, t, i, n) { var o, s, r = t + h(i) + (n ? "_" + h(n) : ""); e[E] && e[E][r] || (s = o = function (t) { return i.call(n || e, t || window.event) }, !b.touchNative && b.pointer && 0 === t.indexOf("touch") ? o = Jt(e, t, o) : b.touch && "dblclick" === t ? o = ne(e, o) : "addEventListener" in e ? "touchstart" === t || "touchmove" === t || "wheel" === t || "mousewheel" === t ? e.addEventListener(Ee[t] || t, o, !!b.passiveEvents && { passive: !1 }) : "mouseenter" === t || "mouseleave" === t ? e.addEventListener(Ee[t], o = function (t) { t = t || window.event, We(e, t) && s(t) }, !1) : e.addEventListener(t, s, !1) : e.attachEvent("on" + t, o), e[E] = e[E] || {}, e[E][r] = o) } function Oe(t, e, i, n, o) { o = o || e + h(i) + (n ? "_" + h(n) : ""); var s, r, i = t[E] && t[E][o]; i && (!b.touchNative && b.pointer && 0 === e.indexOf("touch") ? (n = t, r = i, Gt[s = e] ? n.removeEventListener(Gt[s], r, !1) : console.warn("wrong event specified:", s)) : b.touch && "dblclick" === e ? (n = i, (r = t).removeEventListener("dblclick", n.dblclick), r.removeEventListener("click", n.simDblclick)) : "removeEventListener" in t ? t.removeEventListener(Ee[e] || e, i, !1) : t.detachEvent("on" + e, i), t[E][o] = null) } function Ae(t) { return t.stopPropagation ? t.stopPropagation() : t.originalEvent ? t.originalEvent._stopped = !0 : t.cancelBubble = !0, this } function Be(t) { return ke(t, "wheel", Ae), this } function Ie(t) { return S(t, "mousedown touchstart dblclick contextmenu", Ae), t._leaflet_disable_click = !0, this } function O(t) { return t.preventDefault ? t.preventDefault() : t.returnValue = !1, this } function Re(t) { return O(t), Ae(t), this } function Ne(t) { if (t.composedPath) return t.composedPath(); for (var e = [], i = t.target; i;)e.push(i), i = i.parentNode; return e } function De(t, e) { var i, n; return e ? (n = (i = Ze(e)).boundingClientRect, new p((t.clientX - n.left) / i.x - e.clientLeft, (t.clientY - n.top) / i.y - e.clientTop)) : new p(t.clientX, t.clientY) } var je = b.linux && b.chrome ? window.devicePixelRatio : b.mac ? 3 * window.devicePixelRatio : 0 < window.devicePixelRatio ? 2 * window.devicePixelRatio : 1; function He(t) { return b.edge ? t.wheelDeltaY / 2 : t.deltaY && 0 === t.deltaMode ? -t.deltaY / je : t.deltaY && 1 === t.deltaMode ? 20 * -t.deltaY : t.deltaY && 2 === t.deltaMode ? 60 * -t.deltaY : t.deltaX || t.deltaZ ? 0 : t.wheelDelta ? (t.wheelDeltaY || t.wheelDelta) / 2 : t.detail && Math.abs(t.detail) < 32765 ? 20 * -t.detail : t.detail ? t.detail / -32765 * 60 : 0 } function We(t, e) { var i = e.relatedTarget; if (!i) return !0; try { for (; i && i !== t;)i = i.parentNode } catch (t) { return !1 } return i !== t } var mt = { __proto__: null, on: S, off: k, stopPropagation: Ae, disableScrollPropagation: Be, disableClickPropagation: Ie, preventDefault: O, stop: Re, getPropagationPath: Ne, getMousePosition: De, getWheelDelta: He, isExternalTarget: We, addListener: S, removeListener: k }, Fe = it.extend({ run: function (t, e, i, n) { this.stop(), this._el = t, this._inProgress = !0, this._duration = i || .25, this._easeOutPower = 1 / Math.max(n || .5, .2), this._startPos = Pe(t), this._offset = e.subtract(this._startPos), this._startTime = +new Date, this.fire("start"), this._animate() }, stop: function () { this._inProgress && (this._step(!0), this._complete()) }, _animate: function () { this._animId = x(this._animate, this), this._step() }, _step: function (t) { var e = +new Date - this._startTime, i = 1e3 * this._duration; e < i ? this._runFrame(this._easeOut(e / i), t) : (this._runFrame(1), this._complete()) }, _runFrame: function (t, e) { t = this._startPos.add(this._offset.multiplyBy(t)); e && t._round(), Z(this._el, t), this.fire("step") }, _complete: function () { r(this._animId), this._inProgress = !1, this.fire("end") }, _easeOut: function (t) { return 1 - Math.pow(1 - t, this._easeOutPower) } }), A = it.extend({ options: { crs: lt, center: void 0, zoom: void 0, minZoom: void 0, maxZoom: void 0, layers: [], maxBounds: void 0, renderer: void 0, zoomAnimation: !0, zoomAnimationThreshold: 4, fadeAnimation: !0, markerZoomAnimation: !0, transform3DLimit: 8388608, zoomSnap: 1, zoomDelta: 1, trackResize: !0 }, initialize: function (t, e) { e = c(this, e), this._handlers = [], this._layers = {}, this._zoomBoundLayers = {}, this._sizeChanged = !0, this._initContainer(t), this._initLayout(), this._onResize = a(this._onResize, this), this._initEvents(), e.maxBounds && this.setMaxBounds(e.maxBounds), void 0 !== e.zoom && (this._zoom = this._limitZoom(e.zoom)), e.center && void 0 !== e.zoom && this.setView(w(e.center), e.zoom, { reset: !0 }), this.callInitHooks(), this._zoomAnimated = ce && b.any3d && !b.mobileOpera && this.options.zoomAnimation, this._zoomAnimated && (this._createAnimProxy(), S(this._proxy, de, this._catchTransitionEnd, this)), this._addLayers(this.options.layers) }, setView: function (t, e, i) { if ((e = void 0 === e ? this._zoom : this._limitZoom(e), t = this._limitCenter(w(t), e, this.options.maxBounds), i = i || {}, this._stop(), this._loaded && !i.reset && !0 !== i) && (void 0 !== i.animate && (i.zoom = l({ animate: i.animate }, i.zoom), i.pan = l({ animate: i.animate, duration: i.duration }, i.pan)), this._zoom !== e ? this._tryAnimatedZoom && this._tryAnimatedZoom(t, e, i.zoom) : this._tryAnimatedPan(t, i.pan))) return clearTimeout(this._sizeTimer), this; return this._resetView(t, e, i.pan && i.pan.noMoveStart), this }, setZoom: function (t, e) { return this._loaded ? this.setView(this.getCenter(), t, { zoom: e }) : (this._zoom = t, this) }, zoomIn: function (t, e) { return t = t || (b.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom + t, e) }, zoomOut: function (t, e) { return t = t || (b.any3d ? this.options.zoomDelta : 1), this.setZoom(this._zoom - t, e) }, setZoomAround: function (t, e, i) { var n = this.getZoomScale(e), o = this.getSize().divideBy(2), t = (t instanceof p ? t : this.latLngToContainerPoint(t)).subtract(o).multiplyBy(1 - 1 / n), n = this.containerPointToLatLng(o.add(t)); return this.setView(n, e, { zoom: i }) }, _getBoundsCenterZoom: function (t, e) { e = e || {}, t = t.getBounds ? t.getBounds() : g(t); var i = m(e.paddingTopLeft || e.padding || [0, 0]), n = m(e.paddingBottomRight || e.padding || [0, 0]), o = this.getBoundsZoom(t, !1, i.add(n)); return (o = "number" == typeof e.maxZoom ? Math.min(e.maxZoom, o) : o) === 1 / 0 ? { center: t.getCenter(), zoom: o } : (e = n.subtract(i).divideBy(2), n = this.project(t.getSouthWest(), o), i = this.project(t.getNorthEast(), o), { center: this.unproject(n.add(i).divideBy(2).add(e), o), zoom: o }) }, fitBounds: function (t, e) { if ((t = g(t)).isValid()) return t = this._getBoundsCenterZoom(t, e), this.setView(t.center, t.zoom, e); throw new Error("Bounds are not valid.") }, fitWorld: function (t) { return this.fitBounds([[-90, -180], [90, 180]], t) }, panTo: function (t, e) { return this.setView(t, this._zoom, { pan: e }) }, panBy: function (t, e) { var i; return e = e || {}, (t = m(t).round()).x || t.y ? (!0 === e.animate || this.getSize().contains(t) ? (this._panAnim || (this._panAnim = new Fe, this._panAnim.on({ step: this._onPanTransitionStep, end: this._onPanTransitionEnd }, this)), e.noMoveStart || this.fire("movestart"), !1 !== e.animate ? (M(this._mapPane, "leaflet-pan-anim"), i = this._getMapPanePos().subtract(t).round(), this._panAnim.run(this._mapPane, i, e.duration || .25, e.easeLinearity)) : (this._rawPanBy(t), this.fire("move").fire("moveend"))) : this._resetView(this.unproject(this.project(this.getCenter()).add(t)), this.getZoom()), this) : this.fire("moveend") }, flyTo: function (n, o, t) { if (!1 === (t = t || {}).animate || !b.any3d) return this.setView(n, o, t); this._stop(); var s = this.project(this.getCenter()), r = this.project(n), e = this.getSize(), a = this._zoom, h = (n = w(n), o = void 0 === o ? a : o, Math.max(e.x, e.y)), i = h * this.getZoomScale(a, o), l = r.distanceTo(s) || 1, u = 1.42, c = u * u; function d(t) { t = (i * i - h * h + (t ? -1 : 1) * c * c * l * l) / (2 * (t ? i : h) * c * l), t = Math.sqrt(t * t + 1) - t; return t < 1e-9 ? -18 : Math.log(t) } function _(t) { return (Math.exp(t) - Math.exp(-t)) / 2 } function p(t) { return (Math.exp(t) + Math.exp(-t)) / 2 } var m = d(0); function f(t) { return h * (p(m) * (_(t = m + u * t) / p(t)) - _(m)) / c } var g = Date.now(), v = (d(1) - m) / u, y = t.duration ? 1e3 * t.duration : 1e3 * v * .8; return this._moveStart(!0, t.noMoveStart), function t() { var e = (Date.now() - g) / y, i = (1 - Math.pow(1 - e, 1.5)) * v; e <= 1 ? (this._flyToFrame = x(t, this), this._move(this.unproject(s.add(r.subtract(s).multiplyBy(f(i) / l)), a), this.getScaleZoom(h / (e = i, h * (p(m) / p(m + u * e))), a), { flyTo: !0 })) : this._move(n, o)._moveEnd(!0) }.call(this), this }, flyToBounds: function (t, e) { t = this._getBoundsCenterZoom(t, e); return this.flyTo(t.center, t.zoom, e) }, setMaxBounds: function (t) { return t = g(t), this.listens("moveend", this._panInsideMaxBounds) && this.off("moveend", this._panInsideMaxBounds), t.isValid() ? (this.options.maxBounds = t, this._loaded && this._panInsideMaxBounds(), this.on("moveend", this._panInsideMaxBounds)) : (this.options.maxBounds = null, this) }, setMinZoom: function (t) { var e = this.options.minZoom; return this.options.minZoom = t, this._loaded && e !== t && (this.fire("zoomlevelschange"), this.getZoom() < this.options.minZoom) ? this.setZoom(t) : this }, setMaxZoom: function (t) { var e = this.options.maxZoom; return this.options.maxZoom = t, this._loaded && e !== t && (this.fire("zoomlevelschange"), this.getZoom() > this.options.maxZoom) ? this.setZoom(t) : this }, panInsideBounds: function (t, e) { this._enforcingBounds = !0; var i = this.getCenter(), t = this._limitCenter(i, this._zoom, g(t)); return i.equals(t) || this.panTo(t, e), this._enforcingBounds = !1, this }, panInside: function (t, e) { var i = m((e = e || {}).paddingTopLeft || e.padding || [0, 0]), n = m(e.paddingBottomRight || e.padding || [0, 0]), o = this.project(this.getCenter()), t = this.project(t), s = this.getPixelBounds(), i = _([s.min.add(i), s.max.subtract(n)]), s = i.getSize(); return i.contains(t) || (this._enforcingBounds = !0, n = t.subtract(i.getCenter()), i = i.extend(t).getSize().subtract(s), o.x += n.x < 0 ? -i.x : i.x, o.y += n.y < 0 ? -i.y : i.y, this.panTo(this.unproject(o), e), this._enforcingBounds = !1), this }, invalidateSize: function (t) { if (!this._loaded) return this; t = l({ animate: !1, pan: !0 }, !0 === t ? { animate: !0 } : t); var e = this.getSize(), i = (this._sizeChanged = !0, this._lastCenter = null, this.getSize()), n = e.divideBy(2).round(), o = i.divideBy(2).round(), n = n.subtract(o); return n.x || n.y ? (t.animate && t.pan ? this.panBy(n) : (t.pan && this._rawPanBy(n), this.fire("move"), t.debounceMoveend ? (clearTimeout(this._sizeTimer), this._sizeTimer = setTimeout(a(this.fire, this, "moveend"), 200)) : this.fire("moveend")), this.fire("resize", { oldSize: e, newSize: i })) : this }, stop: function () { return this.setZoom(this._limitZoom(this._zoom)), this.options.zoomSnap || this.fire("viewreset"), this._stop() }, locate: function (t) { var e, i; return t = this._locateOptions = l({ timeout: 1e4, watch: !1 }, t), "geolocation" in navigator ? (e = a(this._handleGeolocationResponse, this), i = a(this._handleGeolocationError, this), t.watch ? this._locationWatchId = navigator.geolocation.watchPosition(e, i, t) : navigator.geolocation.getCurrentPosition(e, i, t)) : this._handleGeolocationError({ code: 0, message: "Geolocation not supported." }), this }, stopLocate: function () { return navigator.geolocation && navigator.geolocation.clearWatch && navigator.geolocation.clearWatch(this._locationWatchId), this._locateOptions && (this._locateOptions.setView = !1), this }, _handleGeolocationError: function (t) { var e; this._container._leaflet_id && (e = t.code, t = t.message || (1 === e ? "permission denied" : 2 === e ? "position unavailable" : "timeout"), this._locateOptions.setView && !this._loaded && this.fitWorld(), this.fire("locationerror", { code: e, message: "Geolocation error: " + t + "." })) }, _handleGeolocationResponse: function (t) { if (this._container._leaflet_id) { var e, i, n = new v(t.coords.latitude, t.coords.longitude), o = n.toBounds(2 * t.coords.accuracy), s = this._locateOptions, r = (s.setView && (e = this.getBoundsZoom(o), this.setView(n, s.maxZoom ? Math.min(e, s.maxZoom) : e)), { latlng: n, bounds: o, timestamp: t.timestamp }); for (i in t.coords) "number" == typeof t.coords[i] && (r[i] = t.coords[i]); this.fire("locationfound", r) } }, addHandler: function (t, e) { return e && (e = this[t] = new e(this), this._handlers.push(e), this.options[t] && e.enable()), this }, remove: function () { if (this._initEvents(!0), this.options.maxBounds && this.off("moveend", this._panInsideMaxBounds), this._containerId !== this._container._leaflet_id) throw new Error("Map container is being reused by another instance"); try { delete this._container._leaflet_id, delete this._containerId } catch (t) { this._container._leaflet_id = void 0, this._containerId = void 0 } for (var t in void 0 !== this._locationWatchId && this.stopLocate(), this._stop(), T(this._mapPane), this._clearControlPos && this._clearControlPos(), this._resizeRequest && (r(this._resizeRequest), this._resizeRequest = null), this._clearHandlers(), this._loaded && this.fire("unload"), this._layers) this._layers[t].remove(); for (t in this._panes) T(this._panes[t]); return this._layers = [], this._panes = [], delete this._mapPane, delete this._renderer, this }, createPane: function (t, e) { e = P("div", "leaflet-pane" + (t ? " leaflet-" + t.replace("Pane", "") + "-pane" : ""), e || this._mapPane); return t && (this._panes[t] = e), e }, getCenter: function () { return this._checkIfLoaded(), this._lastCenter && !this._moved() ? this._lastCenter.clone() : this.layerPointToLatLng(this._getCenterLayerPoint()) }, getZoom: function () { return this._zoom }, getBounds: function () { var t = this.getPixelBounds(); return new s(this.unproject(t.getBottomLeft()), this.unproject(t.getTopRight())) }, getMinZoom: function () { return void 0 === this.options.minZoom ? this._layersMinZoom || 0 : this.options.minZoom }, getMaxZoom: function () { return void 0 === this.options.maxZoom ? void 0 === this._layersMaxZoom ? 1 / 0 : this._layersMaxZoom : this.options.maxZoom }, getBoundsZoom: function (t, e, i) { t = g(t), i = m(i || [0, 0]); var n = this.getZoom() || 0, o = this.getMinZoom(), s = this.getMaxZoom(), r = t.getNorthWest(), t = t.getSouthEast(), i = this.getSize().subtract(i), t = _(this.project(t, n), this.project(r, n)).getSize(), r = b.any3d ? this.options.zoomSnap : 1, a = i.x / t.x, i = i.y / t.y, t = e ? Math.max(a, i) : Math.min(a, i), n = this.getScaleZoom(t, n); return r && (n = Math.round(n / (r / 100)) * (r / 100), n = e ? Math.ceil(n / r) * r : Math.floor(n / r) * r), Math.max(o, Math.min(s, n)) }, getSize: function () { return this._size && !this._sizeChanged || (this._size = new p(this._container.clientWidth || 0, this._container.clientHeight || 0), this._sizeChanged = !1), this._size.clone() }, getPixelBounds: function (t, e) { t = this._getTopLeftPoint(t, e); return new f(t, t.add(this.getSize())) }, getPixelOrigin: function () { return this._checkIfLoaded(), this._pixelOrigin }, getPixelWorldBounds: function (t) { return this.options.crs.getProjectedBounds(void 0 === t ? this.getZoom() : t) }, getPane: function (t) { return "string" == typeof t ? this._panes[t] : t }, getPanes: function () { return this._panes }, getContainer: function () { return this._container }, getZoomScale: function (t, e) { var i = this.options.crs; return e = void 0 === e ? this._zoom : e, i.scale(t) / i.scale(e) }, getScaleZoom: function (t, e) { var i = this.options.crs, t = (e = void 0 === e ? this._zoom : e, i.zoom(t * i.scale(e))); return isNaN(t) ? 1 / 0 : t }, project: function (t, e) { return e = void 0 === e ? this._zoom : e, this.options.crs.latLngToPoint(w(t), e) }, unproject: function (t, e) { return e = void 0 === e ? this._zoom : e, this.options.crs.pointToLatLng(m(t), e) }, layerPointToLatLng: function (t) { t = m(t).add(this.getPixelOrigin()); return this.unproject(t) }, latLngToLayerPoint: function (t) { return this.project(w(t))._round()._subtract(this.getPixelOrigin()) }, wrapLatLng: function (t) { return this.options.crs.wrapLatLng(w(t)) }, wrapLatLngBounds: function (t) { return this.options.crs.wrapLatLngBounds(g(t)) }, distance: function (t, e) { return this.options.crs.distance(w(t), w(e)) }, containerPointToLayerPoint: function (t) { return m(t).subtract(this._getMapPanePos()) }, layerPointToContainerPoint: function (t) { return m(t).add(this._getMapPanePos()) }, containerPointToLatLng: function (t) { t = this.containerPointToLayerPoint(m(t)); return this.layerPointToLatLng(t) }, latLngToContainerPoint: function (t) { return this.layerPointToContainerPoint(this.latLngToLayerPoint(w(t))) }, mouseEventToContainerPoint: function (t) { return De(t, this._container) }, mouseEventToLayerPoint: function (t) { return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(t)) }, mouseEventToLatLng: function (t) { return this.layerPointToLatLng(this.mouseEventToLayerPoint(t)) }, _initContainer: function (t) { t = this._container = _e(t); if (!t) throw new Error("Map container not found."); if (t._leaflet_id) throw new Error("Map container is already initialized."); S(t, "scroll", this._onScroll, this), this._containerId = h(t) }, _initLayout: function () { var t = this._container, e = (this._fadeAnimated = this.options.fadeAnimation && b.any3d, M(t, "leaflet-container" + (b.touch ? " leaflet-touch" : "") + (b.retina ? " leaflet-retina" : "") + (b.ielt9 ? " leaflet-oldie" : "") + (b.safari ? " leaflet-safari" : "") + (this._fadeAnimated ? " leaflet-fade-anim" : "")), pe(t, "position")); "absolute" !== e && "relative" !== e && "fixed" !== e && "sticky" !== e && (t.style.position = "relative"), this._initPanes(), this._initControlPos && this._initControlPos() }, _initPanes: function () { var t = this._panes = {}; this._paneRenderers = {}, this._mapPane = this.createPane("mapPane", this._container), Z(this._mapPane, new p(0, 0)), this.createPane("tilePane"), this.createPane("overlayPane"), this.createPane("shadowPane"), this.createPane("markerPane"), this.createPane("tooltipPane"), this.createPane("popupPane"), this.options.markerZoomAnimation || (M(t.markerPane, "leaflet-zoom-hide"), M(t.shadowPane, "leaflet-zoom-hide")) }, _resetView: function (t, e, i) { Z(this._mapPane, new p(0, 0)); var n = !this._loaded, o = (this._loaded = !0, e = this._limitZoom(e), this.fire("viewprereset"), this._zoom !== e); this._moveStart(o, i)._move(t, e)._moveEnd(o), this.fire("viewreset"), n && this.fire("load") }, _moveStart: function (t, e) { return t && this.fire("zoomstart"), e || this.fire("movestart"), this }, _move: function (t, e, i, n) { void 0 === e && (e = this._zoom); var o = this._zoom !== e; return this._zoom = e, this._lastCenter = t, this._pixelOrigin = this._getNewPixelOrigin(t), n ? i && i.pinch && this.fire("zoom", i) : ((o || i && i.pinch) && this.fire("zoom", i), this.fire("move", i)), this }, _moveEnd: function (t) { return t && this.fire("zoomend"), this.fire("moveend") }, _stop: function () { return r(this._flyToFrame), this._panAnim && this._panAnim.stop(), this }, _rawPanBy: function (t) { Z(this._mapPane, this._getMapPanePos().subtract(t)) }, _getZoomSpan: function () { return this.getMaxZoom() - this.getMinZoom() }, _panInsideMaxBounds: function () { this._enforcingBounds || this.panInsideBounds(this.options.maxBounds) }, _checkIfLoaded: function () { if (!this._loaded) throw new Error("Set map center and zoom first.") }, _initEvents: function (t) { this._targets = {}; var e = t ? k : S; e((this._targets[h(this._container)] = this)._container, "click dblclick mousedown mouseup mouseover mouseout mousemove contextmenu keypress keydown keyup", this._handleDOMEvent, this), this.options.trackResize && e(window, "resize", this._onResize, this), b.any3d && this.options.transform3DLimit && (t ? this.off : this.on).call(this, "moveend", this._onMoveEnd) }, _onResize: function () { r(this._resizeRequest), this._resizeRequest = x(function () { this.invalidateSize({ debounceMoveend: !0 }) }, this) }, _onScroll: function () { this._container.scrollTop = 0, this._container.scrollLeft = 0 }, _onMoveEnd: function () { var t = this._getMapPanePos(); Math.max(Math.abs(t.x), Math.abs(t.y)) >= this.options.transform3DLimit && this._resetView(this.getCenter(), this.getZoom()) }, _findEventTargets: function (t, e) { for (var i, n = [], o = "mouseout" === e || "mouseover" === e, s = t.target || t.srcElement, r = !1; s;) { if ((i = this._targets[h(s)]) && ("click" === e || "preclick" === e) && this._draggableMoved(i)) { r = !0; break } if (i && i.listens(e, !0)) { if (o && !We(s, t)) break; if (n.push(i), o) break } if (s === this._container) break; s = s.parentNode } return n = n.length || r || o || !this.listens(e, !0) ? n : [this] }, _isClickDisabled: function (t) { for (; t && t !== this._container;) { if (t._leaflet_disable_click) return !0; t = t.parentNode } }, _handleDOMEvent: function (t) { var e, i = t.target || t.srcElement; !this._loaded || i._leaflet_disable_events || "click" === t.type && this._isClickDisabled(i) || ("mousedown" === (e = t.type) && Me(i), this._fireDOMEvent(t, e)) }, _mouseEvents: ["click", "dblclick", "mouseover", "mouseout", "contextmenu"], _fireDOMEvent: function (t, e, i) { "click" === t.type && ((a = l({}, t)).type = "preclick", this._fireDOMEvent(a, a.type, i)); var n = this._findEventTargets(t, e); if (i) { for (var o = [], s = 0; s < i.length; s++)i[s].listens(e, !0) && o.push(i[s]); n = o.concat(n) } if (n.length) { "contextmenu" === e && O(t); var r, a = n[0], h = { originalEvent: t }; for ("keypress" !== t.type && "keydown" !== t.type && "keyup" !== t.type && (r = a.getLatLng && (!a._radius || a._radius <= 10), h.containerPoint = r ? this.latLngToContainerPoint(a.getLatLng()) : this.mouseEventToContainerPoint(t), h.layerPoint = this.containerPointToLayerPoint(h.containerPoint), h.latlng = r ? a.getLatLng() : this.layerPointToLatLng(h.layerPoint)), s = 0; s < n.length; s++)if (n[s].fire(e, h, !0), h.originalEvent._stopped || !1 === n[s].options.bubblingMouseEvents && -1 !== G(this._mouseEvents, e)) return } }, _draggableMoved: function (t) { return (t = t.dragging && t.dragging.enabled() ? t : this).dragging && t.dragging.moved() || this.boxZoom && this.boxZoom.moved() }, _clearHandlers: function () { for (var t = 0, e = this._handlers.length; t < e; t++)this._handlers[t].disable() }, whenReady: function (t, e) { return this._loaded ? t.call(e || this, { target: this }) : this.on("load", t, e), this }, _getMapPanePos: function () { return Pe(this._mapPane) || new p(0, 0) }, _moved: function () { var t = this._getMapPanePos(); return t && !t.equals([0, 0]) }, _getTopLeftPoint: function (t, e) { return (t && void 0 !== e ? this._getNewPixelOrigin(t, e) : this.getPixelOrigin()).subtract(this._getMapPanePos()) }, _getNewPixelOrigin: function (t, e) { var i = this.getSize()._divideBy(2); return this.project(t, e)._subtract(i)._add(this._getMapPanePos())._round() }, _latLngToNewLayerPoint: function (t, e, i) { i = this._getNewPixelOrigin(i, e); return this.project(t, e)._subtract(i) }, _latLngBoundsToNewLayerBounds: function (t, e, i) { i = this._getNewPixelOrigin(i, e); return _([this.project(t.getSouthWest(), e)._subtract(i), this.project(t.getNorthWest(), e)._subtract(i), this.project(t.getSouthEast(), e)._subtract(i), this.project(t.getNorthEast(), e)._subtract(i)]) }, _getCenterLayerPoint: function () { return this.containerPointToLayerPoint(this.getSize()._divideBy(2)) }, _getCenterOffset: function (t) { return this.latLngToLayerPoint(t).subtract(this._getCenterLayerPoint()) }, _limitCenter: function (t, e, i) { var n, o; return !i || (n = this.project(t, e), o = this.getSize().divideBy(2), o = new f(n.subtract(o), n.add(o)), o = this._getBoundsOffset(o, i, e), Math.abs(o.x) <= 1 && Math.abs(o.y) <= 1) ? t : this.unproject(n.add(o), e) }, _limitOffset: function (t, e) { var i; return e ? (i = new f((i = this.getPixelBounds()).min.add(t), i.max.add(t)), t.add(this._getBoundsOffset(i, e))) : t }, _getBoundsOffset: function (t, e, i) { e = _(this.project(e.getNorthEast(), i), this.project(e.getSouthWest(), i)), i = e.min.subtract(t.min), e = e.max.subtract(t.max); return new p(this._rebound(i.x, -e.x), this._rebound(i.y, -e.y)) }, _rebound: function (t, e) { return 0 < t + e ? Math.round(t - e) / 2 : Math.max(0, Math.ceil(t)) - Math.max(0, Math.floor(e)) }, _limitZoom: function (t) { var e = this.getMinZoom(), i = this.getMaxZoom(), n = b.any3d ? this.options.zoomSnap : 1; return n && (t = Math.round(t / n) * n), Math.max(e, Math.min(i, t)) }, _onPanTransitionStep: function () { this.fire("move") }, _onPanTransitionEnd: function () { z(this._mapPane, "leaflet-pan-anim"), this.fire("moveend") }, _tryAnimatedPan: function (t, e) { t = this._getCenterOffset(t)._trunc(); return !(!0 !== (e && e.animate) && !this.getSize().contains(t)) && (this.panBy(t, e), !0) }, _createAnimProxy: function () { var t = this._proxy = P("div", "leaflet-proxy leaflet-zoom-animated"); this._panes.mapPane.appendChild(t), this.on("zoomanim", function (t) { var e = ue, i = this._proxy.style[e]; be(this._proxy, this.project(t.center, t.zoom), this.getZoomScale(t.zoom, 1)), i === this._proxy.style[e] && this._animatingZoom && this._onZoomTransitionEnd() }, this), this.on("load moveend", this._animMoveEnd, this), this._on("unload", this._destroyAnimProxy, this) }, _destroyAnimProxy: function () { T(this._proxy), this.off("load moveend", this._animMoveEnd, this), delete this._proxy }, _animMoveEnd: function () { var t = this.getCenter(), e = this.getZoom(); be(this._proxy, this.project(t, e), this.getZoomScale(e, 1)) }, _catchTransitionEnd: function (t) { this._animatingZoom && 0 <= t.propertyName.indexOf("transform") && this._onZoomTransitionEnd() }, _nothingToAnimate: function () { return !this._container.getElementsByClassName("leaflet-zoom-animated").length }, _tryAnimatedZoom: function (t, e, i) { if (!this._animatingZoom) { if (i = i || {}, !this._zoomAnimated || !1 === i.animate || this._nothingToAnimate() || Math.abs(e - this._zoom) > this.options.zoomAnimationThreshold) return !1; var n = this.getZoomScale(e), n = this._getCenterOffset(t)._divideBy(1 - 1 / n); if (!0 !== i.animate && !this.getSize().contains(n)) return !1; x(function () { this._moveStart(!0, i.noMoveStart || !1)._animateZoom(t, e, !0) }, this) } return !0 }, _animateZoom: function (t, e, i, n) { this._mapPane && (i && (this._animatingZoom = !0, this._animateToCenter = t, this._animateToZoom = e, M(this._mapPane, "leaflet-zoom-anim")), this.fire("zoomanim", { center: t, zoom: e, noUpdate: n }), this._tempFireZoomEvent || (this._tempFireZoomEvent = this._zoom !== this._animateToZoom), this._move(this._animateToCenter, this._animateToZoom, void 0, !0), setTimeout(a(this._onZoomTransitionEnd, this), 250)) }, _onZoomTransitionEnd: function () { this._animatingZoom && (this._mapPane && z(this._mapPane, "leaflet-zoom-anim"), this._animatingZoom = !1, this._move(this._animateToCenter, this._animateToZoom, void 0, !0), this._tempFireZoomEvent && this.fire("zoom"), delete this._tempFireZoomEvent, this.fire("move"), this._moveEnd(!0)) } }); function Ue(t) { return new B(t) } var B = et.extend({ options: { position: "topright" }, initialize: function (t) { c(this, t) }, getPosition: function () { return this.options.position }, setPosition: function (t) { var e = this._map; return e && e.removeControl(this), this.options.position = t, e && e.addControl(this), this }, getContainer: function () { return this._container }, addTo: function (t) { this.remove(), this._map = t; var e = this._container = this.onAdd(t), i = this.getPosition(), t = t._controlCorners[i]; return M(e, "leaflet-control"), -1 !== i.indexOf("bottom") ? t.insertBefore(e, t.firstChild) : t.appendChild(e), this._map.on("unload", this.remove, this), this }, remove: function () { return this._map && (T(this._container), this.onRemove && this.onRemove(this._map), this._map.off("unload", this.remove, this), this._map = null), this }, _refocusOnMap: function (t) { this._map && t && 0 < t.screenX && 0 < t.screenY && this._map.getContainer().focus() } }), Ve = (A.include({ addControl: function (t) { return t.addTo(this), this }, removeControl: function (t) { return t.remove(), this }, _initControlPos: function () { var i = this._controlCorners = {}, n = "leaflet-", o = this._controlContainer = P("div", n + "control-container", this._container); function t(t, e) { i[t + e] = P("div", n + t + " " + n + e, o) } t("top", "left"), t("top", "right"), t("bottom", "left"), t("bottom", "right") }, _clearControlPos: function () { for (var t in this._controlCorners) T(this._controlCorners[t]); T(this._controlContainer), delete this._controlCorners, delete this._controlContainer } }), B.extend({ options: { collapsed: !0, position: "topright", autoZIndex: !0, hideSingleBase: !1, sortLayers: !1, sortFunction: function (t, e, i, n) { return i < n ? -1 : n < i ? 1 : 0 } }, initialize: function (t, e, i) { for (var n in c(this, i), this._layerControlInputs = [], this._layers = [], this._lastZIndex = 0, this._handlingClick = !1, this._preventClick = !1, t) this._addLayer(t[n], n); for (n in e) this._addLayer(e[n], n, !0) }, onAdd: function (t) { this._initLayout(), this._update(), (this._map = t).on("zoomend", this._checkDisabledLayers, this); for (var e = 0; e < this._layers.length; e++)this._layers[e].layer.on("add remove", this._onLayerChange, this); return this._container }, addTo: function (t) { return B.prototype.addTo.call(this, t), this._expandIfNotCollapsed() }, onRemove: function () { this._map.off("zoomend", this._checkDisabledLayers, this); for (var t = 0; t < this._layers.length; t++)this._layers[t].layer.off("add remove", this._onLayerChange, this) }, addBaseLayer: function (t, e) { return this._addLayer(t, e), this._map ? this._update() : this }, addOverlay: function (t, e) { return this._addLayer(t, e, !0), this._map ? this._update() : this }, removeLayer: function (t) { t.off("add remove", this._onLayerChange, this); t = this._getLayer(h(t)); return t && this._layers.splice(this._layers.indexOf(t), 1), this._map ? this._update() : this }, expand: function () { M(this._container, "leaflet-control-layers-expanded"), this._section.style.height = null; var t = this._map.getSize().y - (this._container.offsetTop + 50); return t < this._section.clientHeight ? (M(this._section, "leaflet-control-layers-scrollbar"), this._section.style.height = t + "px") : z(this._section, "leaflet-control-layers-scrollbar"), this._checkDisabledLayers(), this }, collapse: function () { return z(this._container, "leaflet-control-layers-expanded"), this }, _initLayout: function () { var t = "leaflet-control-layers", e = this._container = P("div", t), i = this.options.collapsed, n = (e.setAttribute("aria-haspopup", !0), Ie(e), Be(e), this._section = P("section", t + "-list")), o = (i && (this._map.on("click", this.collapse, this), S(e, { mouseenter: this._expandSafely, mouseleave: this.collapse }, this)), this._layersLink = P("a", t + "-toggle", e)); o.href = "#", o.title = "Layers", o.setAttribute("role", "button"), S(o, { keydown: function (t) { 13 === t.keyCode && this._expandSafely() }, click: function (t) { O(t), this._expandSafely() } }, this), i || this.expand(), this._baseLayersList = P("div", t + "-base", n), this._separator = P("div", t + "-separator", n), this._overlaysList = P("div", t + "-overlays", n), e.appendChild(n) }, _getLayer: function (t) { for (var e = 0; e < this._layers.length; e++)if (this._layers[e] && h(this._layers[e].layer) === t) return this._layers[e] }, _addLayer: function (t, e, i) { this._map && t.on("add remove", this._onLayerChange, this), this._layers.push({ layer: t, name: e, overlay: i }), this.options.sortLayers && this._layers.sort(a(function (t, e) { return this.options.sortFunction(t.layer, e.layer, t.name, e.name) }, this)), this.options.autoZIndex && t.setZIndex && (this._lastZIndex++, t.setZIndex(this._lastZIndex)), this._expandIfNotCollapsed() }, _update: function () { if (this._container) { me(this._baseLayersList), me(this._overlaysList), this._layerControlInputs = []; for (var t, e, i, n = 0, o = 0; o < this._layers.length; o++)i = this._layers[o], this._addItem(i), e = e || i.overlay, t = t || !i.overlay, n += i.overlay ? 0 : 1; this.options.hideSingleBase && (this._baseLayersList.style.display = (t = t && 1 < n) ? "" : "none"), this._separator.style.display = e && t ? "" : "none" } return this }, _onLayerChange: function (t) { this._handlingClick || this._update(); var e = this._getLayer(h(t.target)), t = e.overlay ? "add" === t.type ? "overlayadd" : "overlayremove" : "add" === t.type ? "baselayerchange" : null; t && this._map.fire(t, e) }, _createRadioElement: function (t, e) { t = '<input type="radio" class="leaflet-control-layers-selector" name="' + t + '"' + (e ? ' checked="checked"' : "") + "/>", e = document.createElement("div"); return e.innerHTML = t, e.firstChild }, _addItem: function (t) { var e, i = document.createElement("label"), n = this._map.hasLayer(t.layer), n = (t.overlay ? ((e = document.createElement("input")).type = "checkbox", e.className = "leaflet-control-layers-selector", e.defaultChecked = n) : e = this._createRadioElement("leaflet-base-layers_" + h(this), n), this._layerControlInputs.push(e), e.layerId = h(t.layer), S(e, "click", this._onInputClick, this), document.createElement("span")), o = (n.innerHTML = " " + t.name, document.createElement("span")); return i.appendChild(o), o.appendChild(e), o.appendChild(n), (t.overlay ? this._overlaysList : this._baseLayersList).appendChild(i), this._checkDisabledLayers(), i }, _onInputClick: function () { if (!this._preventClick) { var t, e, i = this._layerControlInputs, n = [], o = []; this._handlingClick = !0; for (var s = i.length - 1; 0 <= s; s--)t = i[s], e = this._getLayer(t.layerId).layer, t.checked ? n.push(e) : t.checked || o.push(e); for (s = 0; s < o.length; s++)this._map.hasLayer(o[s]) && this._map.removeLayer(o[s]); for (s = 0; s < n.length; s++)this._map.hasLayer(n[s]) || this._map.addLayer(n[s]); this._handlingClick = !1, this._refocusOnMap() } }, _checkDisabledLayers: function () { for (var t, e, i = this._layerControlInputs, n = this._map.getZoom(), o = i.length - 1; 0 <= o; o--)t = i[o], e = this._getLayer(t.layerId).layer, t.disabled = void 0 !== e.options.minZoom && n < e.options.minZoom || void 0 !== e.options.maxZoom && n > e.options.maxZoom }, _expandIfNotCollapsed: function () { return this._map && !this.options.collapsed && this.expand(), this }, _expandSafely: function () { var t = this._section, e = (this._preventClick = !0, S(t, "click", O), this.expand(), this); setTimeout(function () { k(t, "click", O), e._preventClick = !1 }) } })), qe = B.extend({ options: { position: "topleft", zoomInText: '<span aria-hidden="true">+</span>', zoomInTitle: "Zoom in", zoomOutText: '<span aria-hidden="true">&#x2212;</span>', zoomOutTitle: "Zoom out" }, onAdd: function (t) { var e = "leaflet-control-zoom", i = P("div", e + " leaflet-bar"), n = this.options; return this._zoomInButton = this._createButton(n.zoomInText, n.zoomInTitle, e + "-in", i, this._zoomIn), this._zoomOutButton = this._createButton(n.zoomOutText, n.zoomOutTitle, e + "-out", i, this._zoomOut), this._updateDisabled(), t.on("zoomend zoomlevelschange", this._updateDisabled, this), i }, onRemove: function (t) { t.off("zoomend zoomlevelschange", this._updateDisabled, this) }, disable: function () { return this._disabled = !0, this._updateDisabled(), this }, enable: function () { return this._disabled = !1, this._updateDisabled(), this }, _zoomIn: function (t) { !this._disabled && this._map._zoom < this._map.getMaxZoom() && this._map.zoomIn(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1)) }, _zoomOut: function (t) { !this._disabled && this._map._zoom > this._map.getMinZoom() && this._map.zoomOut(this._map.options.zoomDelta * (t.shiftKey ? 3 : 1)) }, _createButton: function (t, e, i, n, o) { i = P("a", i, n); return i.innerHTML = t, i.href = "#", i.title = e, i.setAttribute("role", "button"), i.setAttribute("aria-label", e), Ie(i), S(i, "click", Re), S(i, "click", o, this), S(i, "click", this._refocusOnMap, this), i }, _updateDisabled: function () { var t = this._map, e = "leaflet-disabled"; z(this._zoomInButton, e), z(this._zoomOutButton, e), this._zoomInButton.setAttribute("aria-disabled", "false"), this._zoomOutButton.setAttribute("aria-disabled", "false"), !this._disabled && t._zoom !== t.getMinZoom() || (M(this._zoomOutButton, e), this._zoomOutButton.setAttribute("aria-disabled", "true")), !this._disabled && t._zoom !== t.getMaxZoom() || (M(this._zoomInButton, e), this._zoomInButton.setAttribute("aria-disabled", "true")) } }), Ge = (A.mergeOptions({ zoomControl: !0 }), A.addInitHook(function () { this.options.zoomControl && (this.zoomControl = new qe, this.addControl(this.zoomControl)) }), B.extend({ options: { position: "bottomleft", maxWidth: 100, metric: !0, imperial: !0 }, onAdd: function (t) { var e = "leaflet-control-scale", i = P("div", e), n = this.options; return this._addScales(n, e + "-line", i), t.on(n.updateWhenIdle ? "moveend" : "move", this._update, this), t.whenReady(this._update, this), i }, onRemove: function (t) { t.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this) }, _addScales: function (t, e, i) { t.metric && (this._mScale = P("div", e, i)), t.imperial && (this._iScale = P("div", e, i)) }, _update: function () { var t = this._map, e = t.getSize().y / 2, t = t.distance(t.containerPointToLatLng([0, e]), t.containerPointToLatLng([this.options.maxWidth, e])); this._updateScales(t) }, _updateScales: function (t) { this.options.metric && t && this._updateMetric(t), this.options.imperial && t && this._updateImperial(t) }, _updateMetric: function (t) { var e = this._getRoundNum(t); this._updateScale(this._mScale, e < 1e3 ? e + " m" : e / 1e3 + " km", e / t) }, _updateImperial: function (t) { var e, i, t = 3.2808399 * t; 5280 < t ? (i = this._getRoundNum(e = t / 5280), this._updateScale(this._iScale, i + " mi", i / e)) : (i = this._getRoundNum(t), this._updateScale(this._iScale, i + " ft", i / t)) }, _updateScale: function (t, e, i) { t.style.width = Math.round(this.options.maxWidth * i) + "px", t.innerHTML = e }, _getRoundNum: function (t) { var e = Math.pow(10, (Math.floor(t) + "").length - 1), t = t / e; return e * (t = 10 <= t ? 10 : 5 <= t ? 5 : 3 <= t ? 3 : 2 <= t ? 2 : 1) } })), Ke = B.extend({ options: { position: "bottomright", prefix: '<a href="https://leafletjs.com" title="A JavaScript library for interactive maps">' + (b.inlineSvg ? '<svg aria-hidden="true" xmlns="http://www.w3.org/2000/svg" width="12" height="8" viewBox="0 0 12 8" class="leaflet-attribution-flag"><path fill="#4C7BE1" d="M0 0h12v4H0z"/><path fill="#FFD500" d="M0 4h12v3H0z"/><path fill="#E0BC00" d="M0 7h12v1H0z"/></svg> ' : "") + "Leaflet</a>" }, initialize: function (t) { c(this, t), this._attributions = {} }, onAdd: function (t) { for (var e in (t.attributionControl = this)._container = P("div", "leaflet-control-attribution"), Ie(this._container), t._layers) t._layers[e].getAttribution && this.addAttribution(t._layers[e].getAttribution()); return this._update(), t.on("layeradd", this._addAttribution, this), this._container }, onRemove: function (t) { t.off("layeradd", this._addAttribution, this) }, _addAttribution: function (t) { t.layer.getAttribution && (this.addAttribution(t.layer.getAttribution()), t.layer.once("remove", function () { this.removeAttribution(t.layer.getAttribution()) }, this)) }, setPrefix: function (t) { return this.options.prefix = t, this._update(), this }, addAttribution: function (t) { return t && (this._attributions[t] || (this._attributions[t] = 0), this._attributions[t]++, this._update()), this }, removeAttribution: function (t) { return t && this._attributions[t] && (this._attributions[t]--, this._update()), this }, _update: function () { if (this._map) { var t, e = []; for (t in this._attributions) this._attributions[t] && e.push(t); var i = []; this.options.prefix && i.push(this.options.prefix), e.length && i.push(e.join(", ")), this._container.innerHTML = i.join(' <span aria-hidden="true">|</span> ') } } }), n = (A.mergeOptions({ attributionControl: !0 }), A.addInitHook(function () { this.options.attributionControl && (new Ke).addTo(this) }), B.Layers = Ve, B.Zoom = qe, B.Scale = Ge, B.Attribution = Ke, Ue.layers = function (t, e, i) { return new Ve(t, e, i) }, Ue.zoom = function (t) { return new qe(t) }, Ue.scale = function (t) { return new Ge(t) }, Ue.attribution = function (t) { return new Ke(t) }, et.extend({ initialize: function (t) { this._map = t }, enable: function () { return this._enabled || (this._enabled = !0, this.addHooks()), this }, disable: function () { return this._enabled && (this._enabled = !1, this.removeHooks()), this }, enabled: function () { return !!this._enabled } })), ft = (n.addTo = function (t, e) { return t.addHandler(e, this), this }, { Events: e }), Ye = b.touch ? "touchstart mousedown" : "mousedown", Xe = it.extend({ options: { clickTolerance: 3 }, initialize: function (t, e, i, n) { c(this, n), this._element = t, this._dragStartTarget = e || t, this._preventOutline = i }, enable: function () { this._enabled || (S(this._dragStartTarget, Ye, this._onDown, this), this._enabled = !0) }, disable: function () { this._enabled && (Xe._dragging === this && this.finishDrag(!0), k(this._dragStartTarget, Ye, this._onDown, this), this._enabled = !1, this._moved = !1) }, _onDown: function (t) { var e, i; this._enabled && (this._moved = !1, ve(this._element, "leaflet-zoom-anim") || (t.touches && 1 !== t.touches.length ? Xe._dragging === this && this.finishDrag() : Xe._dragging || t.shiftKey || 1 !== t.which && 1 !== t.button && !t.touches || ((Xe._dragging = this)._preventOutline && Me(this._element), Le(), re(), this._moving || (this.fire("down"), i = t.touches ? t.touches[0] : t, e = Ce(this._element), this._startPoint = new p(i.clientX, i.clientY), this._startPos = Pe(this._element), this._parentScale = Ze(e), i = "mousedown" === t.type, S(document, i ? "mousemove" : "touchmove", this._onMove, this), S(document, i ? "mouseup" : "touchend touchcancel", this._onUp, this))))) }, _onMove: function (t) { var e; this._enabled && (t.touches && 1 < t.touches.length ? this._moved = !0 : !(e = new p((e = t.touches && 1 === t.touches.length ? t.touches[0] : t).clientX, e.clientY)._subtract(this._startPoint)).x && !e.y || Math.abs(e.x) + Math.abs(e.y) < this.options.clickTolerance || (e.x /= this._parentScale.x, e.y /= this._parentScale.y, O(t), this._moved || (this.fire("dragstart"), this._moved = !0, M(document.body, "leaflet-dragging"), this._lastTarget = t.target || t.srcElement, window.SVGElementInstance && this._lastTarget instanceof window.SVGElementInstance && (this._lastTarget = this._lastTarget.correspondingUseElement), M(this._lastTarget, "leaflet-drag-target")), this._newPos = this._startPos.add(e), this._moving = !0, this._lastEvent = t, this._updatePosition())) }, _updatePosition: function () { var t = { originalEvent: this._lastEvent }; this.fire("predrag", t), Z(this._element, this._newPos), this.fire("drag", t) }, _onUp: function () { this._enabled && this.finishDrag() }, finishDrag: function (t) { z(document.body, "leaflet-dragging"), this._lastTarget && (z(this._lastTarget, "leaflet-drag-target"), this._lastTarget = null), k(document, "mousemove touchmove", this._onMove, this), k(document, "mouseup touchend touchcancel", this._onUp, this), Te(), ae(); var e = this._moved && this._moving; this._moving = !1, Xe._dragging = !1, e && this.fire("dragend", { noInertia: t, distance: this._newPos.distanceTo(this._startPos) }) } }); function Je(t, e, i) { for (var n, o, s, r, a, h, l, u = [1, 4, 2, 8], c = 0, d = t.length; c < d; c++)t[c]._code = si(t[c], e); for (s = 0; s < 4; s++) { for (h = u[s], n = [], c = 0, o = (d = t.length) - 1; c < d; o = c++)r = t[c], a = t[o], r._code & h ? a._code & h || ((l = oi(a, r, h, e, i))._code = si(l, e), n.push(l)) : (a._code & h && ((l = oi(a, r, h, e, i))._code = si(l, e), n.push(l)), n.push(r)); t = n } return t } function $e(t, e) { var i, n, o, s, r, a, h; if (!t || 0 === t.length) throw new Error("latlngs not passed"); I(t) || (console.warn("latlngs are not flat! Only the first ring will be used"), t = t[0]); for (var l = w([0, 0]), u = g(t), c = (u.getNorthWest().distanceTo(u.getSouthWest()) * u.getNorthEast().distanceTo(u.getNorthWest()) < 1700 && (l = Qe(t)), t.length), d = [], _ = 0; _ < c; _++) { var p = w(t[_]); d.push(e.project(w([p.lat - l.lat, p.lng - l.lng]))) } for (_ = r = a = h = 0, i = c - 1; _ < c; i = _++)n = d[_], o = d[i], s = n.y * o.x - o.y * n.x, a += (n.x + o.x) * s, h += (n.y + o.y) * s, r += 3 * s; u = 0 === r ? d[0] : [a / r, h / r], u = e.unproject(m(u)); return w([u.lat + l.lat, u.lng + l.lng]) } function Qe(t) { for (var e = 0, i = 0, n = 0, o = 0; o < t.length; o++) { var s = w(t[o]); e += s.lat, i += s.lng, n++ } return w([e / n, i / n]) } var ti, gt = { __proto__: null, clipPolygon: Je, polygonCenter: $e, centroid: Qe }; function ei(t, e) { if (e && t.length) { var i = t = function (t, e) { for (var i = [t[0]], n = 1, o = 0, s = t.length; n < s; n++)(function (t, e) { var i = e.x - t.x, e = e.y - t.y; return i * i + e * e })(t[n], t[o]) > e && (i.push(t[n]), o = n); o < s - 1 && i.push(t[s - 1]); return i }(t, e = e * e), n = i.length, o = new (typeof Uint8Array != void 0 + "" ? Uint8Array : Array)(n); o[0] = o[n - 1] = 1, function t(e, i, n, o, s) { var r, a, h, l = 0; for (a = o + 1; a <= s - 1; a++)h = ri(e[a], e[o], e[s], !0), l < h && (r = a, l = h); n < l && (i[r] = 1, t(e, i, n, o, r), t(e, i, n, r, s)) }(i, o, e, 0, n - 1); var s, r = []; for (s = 0; s < n; s++)o[s] && r.push(i[s]); return r } return t.slice() } function ii(t, e, i) { return Math.sqrt(ri(t, e, i, !0)) } function ni(t, e, i, n, o) { var s, r, a, h = n ? ti : si(t, i), l = si(e, i); for (ti = l; ;) { if (!(h | l)) return [t, e]; if (h & l) return !1; a = si(r = oi(t, e, s = h || l, i, o), i), s === h ? (t = r, h = a) : (e = r, l = a) } } function oi(t, e, i, n, o) { var s, r, a = e.x - t.x, e = e.y - t.y, h = n.min, n = n.max; return 8 & i ? (s = t.x + a * (n.y - t.y) / e, r = n.y) : 4 & i ? (s = t.x + a * (h.y - t.y) / e, r = h.y) : 2 & i ? (s = n.x, r = t.y + e * (n.x - t.x) / a) : 1 & i && (s = h.x, r = t.y + e * (h.x - t.x) / a), new p(s, r, o) } function si(t, e) { var i = 0; return t.x < e.min.x ? i |= 1 : t.x > e.max.x && (i |= 2), t.y < e.min.y ? i |= 4 : t.y > e.max.y && (i |= 8), i } function ri(t, e, i, n) { var o = e.x, e = e.y, s = i.x - o, r = i.y - e, a = s * s + r * r; return 0 < a && (1 < (a = ((t.x - o) * s + (t.y - e) * r) / a) ? (o = i.x, e = i.y) : 0 < a && (o += s * a, e += r * a)), s = t.x - o, r = t.y - e, n ? s * s + r * r : new p(o, e) } function I(t) { return !d(t[0]) || "object" != typeof t[0][0] && void 0 !== t[0][0] } function ai(t) { return console.warn("Deprecated use of _flat, please use L.LineUtil.isFlat instead."), I(t) } function hi(t, e) { var i, n, o, s, r, a; if (!t || 0 === t.length) throw new Error("latlngs not passed"); I(t) || (console.warn("latlngs are not flat! Only the first ring will be used"), t = t[0]); for (var h = w([0, 0]), l = g(t), u = (l.getNorthWest().distanceTo(l.getSouthWest()) * l.getNorthEast().distanceTo(l.getNorthWest()) < 1700 && (h = Qe(t)), t.length), c = [], d = 0; d < u; d++) { var _ = w(t[d]); c.push(e.project(w([_.lat - h.lat, _.lng - h.lng]))) } for (i = d = 0; d < u - 1; d++)i += c[d].distanceTo(c[d + 1]) / 2; if (0 === i) a = c[0]; else for (n = d = 0; d < u - 1; d++)if (o = c[d], s = c[d + 1], i < (n += r = o.distanceTo(s))) { a = [s.x - (r = (n - i) / r) * (s.x - o.x), s.y - r * (s.y - o.y)]; break } l = e.unproject(m(a)); return w([l.lat + h.lat, l.lng + h.lng]) } var vt = { __proto__: null, simplify: ei, pointToSegmentDistance: ii, closestPointOnSegment: function (t, e, i) { return ri(t, e, i) }, clipSegment: ni, _getEdgeIntersection: oi, _getBitCode: si, _sqClosestPointOnSegment: ri, isFlat: I, _flat: ai, polylineCenter: hi }, yt = { project: function (t) { return new p(t.lng, t.lat) }, unproject: function (t) { return new v(t.y, t.x) }, bounds: new f([-180, -90], [180, 90]) }, xt = { R: 6378137, R_MINOR: 6356752.314245179, bounds: new f([-20037508.34279, -15496570.73972], [20037508.34279, 18764656.23138]), project: function (t) { var e = Math.PI / 180, i = this.R, n = t.lat * e, o = this.R_MINOR / i, o = Math.sqrt(1 - o * o), s = o * Math.sin(n), s = Math.tan(Math.PI / 4 - n / 2) / Math.pow((1 - s) / (1 + s), o / 2), n = -i * Math.log(Math.max(s, 1e-10)); return new p(t.lng * e * i, n) }, unproject: function (t) { for (var e, i = 180 / Math.PI, n = this.R, o = this.R_MINOR / n, s = Math.sqrt(1 - o * o), r = Math.exp(-t.y / n), a = Math.PI / 2 - 2 * Math.atan(r), h = 0, l = .1; h < 15 && 1e-7 < Math.abs(l); h++)e = s * Math.sin(a), e = Math.pow((1 - e) / (1 + e), s / 2), a += l = Math.PI / 2 - 2 * Math.atan(r * e) - a; return new v(a * i, t.x * i / n) } }, wt = { __proto__: null, LonLat: yt, Mercator: xt, SphericalMercator: rt }, Pt = l({}, st, { code: "EPSG:3395", projection: xt, transformation: ht(bt = .5 / (Math.PI * xt.R), .5, -bt, .5) }), li = l({}, st, { code: "EPSG:4326", projection: yt, transformation: ht(1 / 180, 1, -1 / 180, .5) }), Lt = l({}, ot, { projection: yt, transformation: ht(1, 0, -1, 0), scale: function (t) { return Math.pow(2, t) }, zoom: function (t) { return Math.log(t) / Math.LN2 }, distance: function (t, e) { var i = e.lng - t.lng, e = e.lat - t.lat; return Math.sqrt(i * i + e * e) }, infinite: !0 }), o = (ot.Earth = st, ot.EPSG3395 = Pt, ot.EPSG3857 = lt, ot.EPSG900913 = ut, ot.EPSG4326 = li, ot.Simple = Lt, it.extend({ options: { pane: "overlayPane", attribution: null, bubblingMouseEvents: !0 }, addTo: function (t) { return t.addLayer(this), this }, remove: function () { return this.removeFrom(this._map || this._mapToAdd) }, removeFrom: function (t) { return t && t.removeLayer(this), this }, getPane: function (t) { return this._map.getPane(t ? this.options[t] || t : this.options.pane) }, addInteractiveTarget: function (t) { return this._map._targets[h(t)] = this }, removeInteractiveTarget: function (t) { return delete this._map._targets[h(t)], this }, getAttribution: function () { return this.options.attribution }, _layerAdd: function (t) { var e, i = t.target; i.hasLayer(this) && (this._map = i, this._zoomAnimated = i._zoomAnimated, this.getEvents && (e = this.getEvents(), i.on(e, this), this.once("remove", function () { i.off(e, this) }, this)), this.onAdd(i), this.fire("add"), i.fire("layeradd", { layer: this })) } })), ui = (A.include({ addLayer: function (t) { var e; if (t._layerAdd) return e = h(t), this._layers[e] || ((this._layers[e] = t)._mapToAdd = this, t.beforeAdd && t.beforeAdd(this), this.whenReady(t._layerAdd, t)), this; throw new Error("The provided object is not a Layer.") }, removeLayer: function (t) { var e = h(t); return this._layers[e] && (this._loaded && t.onRemove(this), delete this._layers[e], this._loaded && (this.fire("layerremove", { layer: t }), t.fire("remove")), t._map = t._mapToAdd = null), this }, hasLayer: function (t) { return h(t) in this._layers }, eachLayer: function (t, e) { for (var i in this._layers) t.call(e, this._layers[i]); return this }, _addLayers: function (t) { for (var e = 0, i = (t = t ? d(t) ? t : [t] : []).length; e < i; e++)this.addLayer(t[e]) }, _addZoomLimit: function (t) { isNaN(t.options.maxZoom) && isNaN(t.options.minZoom) || (this._zoomBoundLayers[h(t)] = t, this._updateZoomLevels()) }, _removeZoomLimit: function (t) { t = h(t); this._zoomBoundLayers[t] && (delete this._zoomBoundLayers[t], this._updateZoomLevels()) }, _updateZoomLevels: function () { var t, e = 1 / 0, i = -1 / 0, n = this._getZoomSpan(); for (t in this._zoomBoundLayers) var o = this._zoomBoundLayers[t].options, e = void 0 === o.minZoom ? e : Math.min(e, o.minZoom), i = void 0 === o.maxZoom ? i : Math.max(i, o.maxZoom); this._layersMaxZoom = i === -1 / 0 ? void 0 : i, this._layersMinZoom = e === 1 / 0 ? void 0 : e, n !== this._getZoomSpan() && this.fire("zoomlevelschange"), void 0 === this.options.maxZoom && this._layersMaxZoom && this.getZoom() > this._layersMaxZoom && this.setZoom(this._layersMaxZoom), void 0 === this.options.minZoom && this._layersMinZoom && this.getZoom() < this._layersMinZoom && this.setZoom(this._layersMinZoom) } }), o.extend({ initialize: function (t, e) { var i, n; if (c(this, e), this._layers = {}, t) for (i = 0, n = t.length; i < n; i++)this.addLayer(t[i]) }, addLayer: function (t) { var e = this.getLayerId(t); return this._layers[e] = t, this._map && this._map.addLayer(t), this }, removeLayer: function (t) { t = t in this._layers ? t : this.getLayerId(t); return this._map && this._layers[t] && this._map.removeLayer(this._layers[t]), delete this._layers[t], this }, hasLayer: function (t) { return ("number" == typeof t ? t : this.getLayerId(t)) in this._layers }, clearLayers: function () { return this.eachLayer(this.removeLayer, this) }, invoke: function (t) { var e, i, n = Array.prototype.slice.call(arguments, 1); for (e in this._layers) (i = this._layers[e])[t] && i[t].apply(i, n); return this }, onAdd: function (t) { this.eachLayer(t.addLayer, t) }, onRemove: function (t) { this.eachLayer(t.removeLayer, t) }, eachLayer: function (t, e) { for (var i in this._layers) t.call(e, this._layers[i]); return this }, getLayer: function (t) { return this._layers[t] }, getLayers: function () { var t = []; return this.eachLayer(t.push, t), t }, setZIndex: function (t) { return this.invoke("setZIndex", t) }, getLayerId: h })), ci = ui.extend({ addLayer: function (t) { return this.hasLayer(t) ? this : (t.addEventParent(this), ui.prototype.addLayer.call(this, t), this.fire("layeradd", { layer: t })) }, removeLayer: function (t) { return this.hasLayer(t) ? ((t = t in this._layers ? this._layers[t] : t).removeEventParent(this), ui.prototype.removeLayer.call(this, t), this.fire("layerremove", { layer: t })) : this }, setStyle: function (t) { return this.invoke("setStyle", t) }, bringToFront: function () { return this.invoke("bringToFront") }, bringToBack: function () { return this.invoke("bringToBack") }, getBounds: function () { var t, e = new s; for (t in this._layers) { var i = this._layers[t]; e.extend(i.getBounds ? i.getBounds() : i.getLatLng()) } return e } }), di = et.extend({ options: { popupAnchor: [0, 0], tooltipAnchor: [0, 0], crossOrigin: !1 }, initialize: function (t) { c(this, t) }, createIcon: function (t) { return this._createIcon("icon", t) }, createShadow: function (t) { return this._createIcon("shadow", t) }, _createIcon: function (t, e) { var i = this._getIconUrl(t); if (i) return i = this._createImg(i, e && "IMG" === e.tagName ? e : null), this._setIconStyles(i, t), !this.options.crossOrigin && "" !== this.options.crossOrigin || (i.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin), i; if ("icon" === t) throw new Error("iconUrl not set in Icon options (see the docs)."); return null }, _setIconStyles: function (t, e) { var i = this.options, n = i[e + "Size"], n = m(n = "number" == typeof n ? [n, n] : n), o = m("shadow" === e && i.shadowAnchor || i.iconAnchor || n && n.divideBy(2, !0)); t.className = "leaflet-marker-" + e + " " + (i.className || ""), o && (t.style.marginLeft = -o.x + "px", t.style.marginTop = -o.y + "px"), n && (t.style.width = n.x + "px", t.style.height = n.y + "px") }, _createImg: function (t, e) { return (e = e || document.createElement("img")).src = t, e }, _getIconUrl: function (t) { return b.retina && this.options[t + "RetinaUrl"] || this.options[t + "Url"] } }); var _i = di.extend({ options: { iconUrl: "marker-icon.png", iconRetinaUrl: "marker-icon-2x.png", shadowUrl: "marker-shadow.png", iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], tooltipAnchor: [16, -28], shadowSize: [41, 41] }, _getIconUrl: function (t) { return "string" != typeof _i.imagePath && (_i.imagePath = this._detectIconPath()), (this.options.imagePath || _i.imagePath) + di.prototype._getIconUrl.call(this, t) }, _stripUrl: function (t) { function e(t, e, i) { return (e = e.exec(t)) && e[i] } return (t = e(t, /^url\((['"])?(.+)\1\)$/, 2)) && e(t, /^(.*)marker-icon\.png$/, 1) }, _detectIconPath: function () { var t = P("div", "leaflet-default-icon-path", document.body), e = pe(t, "background-image") || pe(t, "backgroundImage"); return document.body.removeChild(t), (e = this._stripUrl(e)) ? e : (t = document.querySelector('link[href$="leaflet.css"]')) ? t.href.substring(0, t.href.length - "leaflet.css".length - 1) : "" } }), pi = n.extend({ initialize: function (t) { this._marker = t }, addHooks: function () { var t = this._marker._icon; this._draggable || (this._draggable = new Xe(t, t, !0)), this._draggable.on({ dragstart: this._onDragStart, predrag: this._onPreDrag, drag: this._onDrag, dragend: this._onDragEnd }, this).enable(), M(t, "leaflet-marker-draggable") }, removeHooks: function () { this._draggable.off({ dragstart: this._onDragStart, predrag: this._onPreDrag, drag: this._onDrag, dragend: this._onDragEnd }, this).disable(), this._marker._icon && z(this._marker._icon, "leaflet-marker-draggable") }, moved: function () { return this._draggable && this._draggable._moved }, _adjustPan: function (t) { var e = this._marker, i = e._map, n = this._marker.options.autoPanSpeed, o = this._marker.options.autoPanPadding, s = Pe(e._icon), r = i.getPixelBounds(), a = i.getPixelOrigin(), a = _(r.min._subtract(a).add(o), r.max._subtract(a).subtract(o)); a.contains(s) || (o = m((Math.max(a.max.x, s.x) - a.max.x) / (r.max.x - a.max.x) - (Math.min(a.min.x, s.x) - a.min.x) / (r.min.x - a.min.x), (Math.max(a.max.y, s.y) - a.max.y) / (r.max.y - a.max.y) - (Math.min(a.min.y, s.y) - a.min.y) / (r.min.y - a.min.y)).multiplyBy(n), i.panBy(o, { animate: !1 }), this._draggable._newPos._add(o), this._draggable._startPos._add(o), Z(e._icon, this._draggable._newPos), this._onDrag(t), this._panRequest = x(this._adjustPan.bind(this, t))) }, _onDragStart: function () { this._oldLatLng = this._marker.getLatLng(), this._marker.closePopup && this._marker.closePopup(), this._marker.fire("movestart").fire("dragstart") }, _onPreDrag: function (t) { this._marker.options.autoPan && (r(this._panRequest), this._panRequest = x(this._adjustPan.bind(this, t))) }, _onDrag: function (t) { var e = this._marker, i = e._shadow, n = Pe(e._icon), o = e._map.layerPointToLatLng(n); i && Z(i, n), e._latlng = o, t.latlng = o, t.oldLatLng = this._oldLatLng, e.fire("move", t).fire("drag", t) }, _onDragEnd: function (t) { r(this._panRequest), delete this._oldLatLng, this._marker.fire("moveend").fire("dragend", t) } }), mi = o.extend({ options: { icon: new _i, interactive: !0, keyboard: !0, title: "", alt: "Marker", zIndexOffset: 0, opacity: 1, riseOnHover: !1, riseOffset: 250, pane: "markerPane", shadowPane: "shadowPane", bubblingMouseEvents: !1, autoPanOnFocus: !0, draggable: !1, autoPan: !1, autoPanPadding: [50, 50], autoPanSpeed: 10 }, initialize: function (t, e) { c(this, e), this._latlng = w(t) }, onAdd: function (t) { this._zoomAnimated = this._zoomAnimated && t.options.markerZoomAnimation, this._zoomAnimated && t.on("zoomanim", this._animateZoom, this), this._initIcon(), this.update() }, onRemove: function (t) { this.dragging && this.dragging.enabled() && (this.options.draggable = !0, this.dragging.removeHooks()), delete this.dragging, this._zoomAnimated && t.off("zoomanim", this._animateZoom, this), this._removeIcon(), this._removeShadow() }, getEvents: function () { return { zoom: this.update, viewreset: this.update } }, getLatLng: function () { return this._latlng }, setLatLng: function (t) { var e = this._latlng; return this._latlng = w(t), this.update(), this.fire("move", { oldLatLng: e, latlng: this._latlng }) }, setZIndexOffset: function (t) { return this.options.zIndexOffset = t, this.update() }, getIcon: function () { return this.options.icon }, setIcon: function (t) { return this.options.icon = t, this._map && (this._initIcon(), this.update()), this._popup && this.bindPopup(this._popup, this._popup.options), this }, getElement: function () { return this._icon }, update: function () { var t; return this._icon && this._map && (t = this._map.latLngToLayerPoint(this._latlng).round(), this._setPos(t)), this }, _initIcon: function () { var t = this.options, e = "leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"), i = t.icon.createIcon(this._icon), n = !1, i = (i !== this._icon && (this._icon && this._removeIcon(), n = !0, t.title && (i.title = t.title), "IMG" === i.tagName && (i.alt = t.alt || "")), M(i, e), t.keyboard && (i.tabIndex = "0", i.setAttribute("role", "button")), this._icon = i, t.riseOnHover && this.on({ mouseover: this._bringToFront, mouseout: this._resetZIndex }), this.options.autoPanOnFocus && S(i, "focus", this._panOnFocus, this), t.icon.createShadow(this._shadow)), o = !1; i !== this._shadow && (this._removeShadow(), o = !0), i && (M(i, e), i.alt = ""), this._shadow = i, t.opacity < 1 && this._updateOpacity(), n && this.getPane().appendChild(this._icon), this._initInteraction(), i && o && this.getPane(t.shadowPane).appendChild(this._shadow) }, _removeIcon: function () { this.options.riseOnHover && this.off({ mouseover: this._bringToFront, mouseout: this._resetZIndex }), this.options.autoPanOnFocus && k(this._icon, "focus", this._panOnFocus, this), T(this._icon), this.removeInteractiveTarget(this._icon), this._icon = null }, _removeShadow: function () { this._shadow && T(this._shadow), this._shadow = null }, _setPos: function (t) { this._icon && Z(this._icon, t), this._shadow && Z(this._shadow, t), this._zIndex = t.y + this.options.zIndexOffset, this._resetZIndex() }, _updateZIndex: function (t) { this._icon && (this._icon.style.zIndex = this._zIndex + t) }, _animateZoom: function (t) { t = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center).round(); this._setPos(t) }, _initInteraction: function () { var t; this.options.interactive && (M(this._icon, "leaflet-interactive"), this.addInteractiveTarget(this._icon), pi && (t = this.options.draggable, this.dragging && (t = this.dragging.enabled(), this.dragging.disable()), this.dragging = new pi(this), t && this.dragging.enable())) }, setOpacity: function (t) { return this.options.opacity = t, this._map && this._updateOpacity(), this }, _updateOpacity: function () { var t = this.options.opacity; this._icon && C(this._icon, t), this._shadow && C(this._shadow, t) }, _bringToFront: function () { this._updateZIndex(this.options.riseOffset) }, _resetZIndex: function () { this._updateZIndex(0) }, _panOnFocus: function () { var t, e, i = this._map; i && (t = (e = this.options.icon.options).iconSize ? m(e.iconSize) : m(0, 0), e = e.iconAnchor ? m(e.iconAnchor) : m(0, 0), i.panInside(this._latlng, { paddingTopLeft: e, paddingBottomRight: t.subtract(e) })) }, _getPopupAnchor: function () { return this.options.icon.options.popupAnchor }, _getTooltipAnchor: function () { return this.options.icon.options.tooltipAnchor } }); var fi = o.extend({ options: { stroke: !0, color: "#3388ff", weight: 3, opacity: 1, lineCap: "round", lineJoin: "round", dashArray: null, dashOffset: null, fill: !1, fillColor: null, fillOpacity: .2, fillRule: "evenodd", interactive: !0, bubblingMouseEvents: !0 }, beforeAdd: function (t) { this._renderer = t.getRenderer(this) }, onAdd: function () { this._renderer._initPath(this), this._reset(), this._renderer._addPath(this) }, onRemove: function () { this._renderer._removePath(this) }, redraw: function () { return this._map && this._renderer._updatePath(this), this }, setStyle: function (t) { return c(this, t), this._renderer && (this._renderer._updateStyle(this), this.options.stroke && t && Object.prototype.hasOwnProperty.call(t, "weight") && this._updateBounds()), this }, bringToFront: function () { return this._renderer && this._renderer._bringToFront(this), this }, bringToBack: function () { return this._renderer && this._renderer._bringToBack(this), this }, getElement: function () { return this._path }, _reset: function () { this._project(), this._update() }, _clickTolerance: function () { return (this.options.stroke ? this.options.weight / 2 : 0) + (this._renderer.options.tolerance || 0) } }), gi = fi.extend({ options: { fill: !0, radius: 10 }, initialize: function (t, e) { c(this, e), this._latlng = w(t), this._radius = this.options.radius }, setLatLng: function (t) { var e = this._latlng; return this._latlng = w(t), this.redraw(), this.fire("move", { oldLatLng: e, latlng: this._latlng }) }, getLatLng: function () { return this._latlng }, setRadius: function (t) { return this.options.radius = this._radius = t, this.redraw() }, getRadius: function () { return this._radius }, setStyle: function (t) { var e = t && t.radius || this._radius; return fi.prototype.setStyle.call(this, t), this.setRadius(e), this }, _project: function () { this._point = this._map.latLngToLayerPoint(this._latlng), this._updateBounds() }, _updateBounds: function () { var t = this._radius, e = this._radiusY || t, i = this._clickTolerance(), t = [t + i, e + i]; this._pxBounds = new f(this._point.subtract(t), this._point.add(t)) }, _update: function () { this._map && this._updatePath() }, _updatePath: function () { this._renderer._updateCircle(this) }, _empty: function () { return this._radius && !this._renderer._bounds.intersects(this._pxBounds) }, _containsPoint: function (t) { return t.distanceTo(this._point) <= this._radius + this._clickTolerance() } }); var vi = gi.extend({ initialize: function (t, e, i) { if (c(this, e = "number" == typeof e ? l({}, i, { radius: e }) : e), this._latlng = w(t), isNaN(this.options.radius)) throw new Error("Circle radius cannot be NaN"); this._mRadius = this.options.radius }, setRadius: function (t) { return this._mRadius = t, this.redraw() }, getRadius: function () { return this._mRadius }, getBounds: function () { var t = [this._radius, this._radiusY || this._radius]; return new s(this._map.layerPointToLatLng(this._point.subtract(t)), this._map.layerPointToLatLng(this._point.add(t))) }, setStyle: fi.prototype.setStyle, _project: function () { var t, e, i, n, o, s = this._latlng.lng, r = this._latlng.lat, a = this._map, h = a.options.crs; h.distance === st.distance ? (n = Math.PI / 180, o = this._mRadius / st.R / n, t = a.project([r + o, s]), e = a.project([r - o, s]), e = t.add(e).divideBy(2), i = a.unproject(e).lat, n = Math.acos((Math.cos(o * n) - Math.sin(r * n) * Math.sin(i * n)) / (Math.cos(r * n) * Math.cos(i * n))) / n, !isNaN(n) && 0 !== n || (n = o / Math.cos(Math.PI / 180 * r)), this._point = e.subtract(a.getPixelOrigin()), this._radius = isNaN(n) ? 0 : e.x - a.project([i, s - n]).x, this._radiusY = e.y - t.y) : (o = h.unproject(h.project(this._latlng).subtract([this._mRadius, 0])), this._point = a.latLngToLayerPoint(this._latlng), this._radius = this._point.x - a.latLngToLayerPoint(o).x), this._updateBounds() } }); var yi = fi.extend({ options: { smoothFactor: 1, noClip: !1 }, initialize: function (t, e) { c(this, e), this._setLatLngs(t) }, getLatLngs: function () { return this._latlngs }, setLatLngs: function (t) { return this._setLatLngs(t), this.redraw() }, isEmpty: function () { return !this._latlngs.length }, closestLayerPoint: function (t) { for (var e = 1 / 0, i = null, n = ri, o = 0, s = this._parts.length; o < s; o++)for (var r = this._parts[o], a = 1, h = r.length; a < h; a++) { var l, u, c = n(t, l = r[a - 1], u = r[a], !0); c < e && (e = c, i = n(t, l, u)) } return i && (i.distance = Math.sqrt(e)), i }, getCenter: function () { if (this._map) return hi(this._defaultShape(), this._map.options.crs); throw new Error("Must add layer to map before using getCenter()") }, getBounds: function () { return this._bounds }, addLatLng: function (t, e) { return e = e || this._defaultShape(), t = w(t), e.push(t), this._bounds.extend(t), this.redraw() }, _setLatLngs: function (t) { this._bounds = new s, this._latlngs = this._convertLatLngs(t) }, _defaultShape: function () { return I(this._latlngs) ? this._latlngs : this._latlngs[0] }, _convertLatLngs: function (t) { for (var e = [], i = I(t), n = 0, o = t.length; n < o; n++)i ? (e[n] = w(t[n]), this._bounds.extend(e[n])) : e[n] = this._convertLatLngs(t[n]); return e }, _project: function () { var t = new f; this._rings = [], this._projectLatlngs(this._latlngs, this._rings, t), this._bounds.isValid() && t.isValid() && (this._rawPxBounds = t, this._updateBounds()) }, _updateBounds: function () { var t = this._clickTolerance(), t = new p(t, t); this._rawPxBounds && (this._pxBounds = new f([this._rawPxBounds.min.subtract(t), this._rawPxBounds.max.add(t)])) }, _projectLatlngs: function (t, e, i) { var n, o, s = t[0] instanceof v, r = t.length; if (s) { for (o = [], n = 0; n < r; n++)o[n] = this._map.latLngToLayerPoint(t[n]), i.extend(o[n]); e.push(o) } else for (n = 0; n < r; n++)this._projectLatlngs(t[n], e, i) }, _clipPoints: function () { var t = this._renderer._bounds; if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t)) if (this.options.noClip) this._parts = this._rings; else for (var e, i, n, o, s = this._parts, r = 0, a = 0, h = this._rings.length; r < h; r++)for (e = 0, i = (o = this._rings[r]).length; e < i - 1; e++)(n = ni(o[e], o[e + 1], t, e, !0)) && (s[a] = s[a] || [], s[a].push(n[0]), n[1] === o[e + 1] && e !== i - 2 || (s[a].push(n[1]), a++)) }, _simplifyPoints: function () { for (var t = this._parts, e = this.options.smoothFactor, i = 0, n = t.length; i < n; i++)t[i] = ei(t[i], e) }, _update: function () { this._map && (this._clipPoints(), this._simplifyPoints(), this._updatePath()) }, _updatePath: function () { this._renderer._updatePoly(this) }, _containsPoint: function (t, e) { var i, n, o, s, r, a, h = this._clickTolerance(); if (this._pxBounds && this._pxBounds.contains(t)) for (i = 0, s = this._parts.length; i < s; i++)for (n = 0, o = (r = (a = this._parts[i]).length) - 1; n < r; o = n++)if ((e || 0 !== n) && ii(t, a[o], a[n]) <= h) return !0; return !1 } }); yi._flat = ai; var xi = yi.extend({ options: { fill: !0 }, isEmpty: function () { return !this._latlngs.length || !this._latlngs[0].length }, getCenter: function () { if (this._map) return $e(this._defaultShape(), this._map.options.crs); throw new Error("Must add layer to map before using getCenter()") }, _convertLatLngs: function (t) { var t = yi.prototype._convertLatLngs.call(this, t), e = t.length; return 2 <= e && t[0] instanceof v && t[0].equals(t[e - 1]) && t.pop(), t }, _setLatLngs: function (t) { yi.prototype._setLatLngs.call(this, t), I(this._latlngs) && (this._latlngs = [this._latlngs]) }, _defaultShape: function () { return (I(this._latlngs[0]) ? this._latlngs : this._latlngs[0])[0] }, _clipPoints: function () { var t = this._renderer._bounds, e = this.options.weight, e = new p(e, e), t = new f(t.min.subtract(e), t.max.add(e)); if (this._parts = [], this._pxBounds && this._pxBounds.intersects(t)) if (this.options.noClip) this._parts = this._rings; else for (var i, n = 0, o = this._rings.length; n < o; n++)(i = Je(this._rings[n], t, !0)).length && this._parts.push(i) }, _updatePath: function () { this._renderer._updatePoly(this, !0) }, _containsPoint: function (t) { var e, i, n, o, s, r, a, h, l = !1; if (!this._pxBounds || !this._pxBounds.contains(t)) return !1; for (o = 0, a = this._parts.length; o < a; o++)for (s = 0, r = (h = (e = this._parts[o]).length) - 1; s < h; r = s++)i = e[s], n = e[r], i.y > t.y != n.y > t.y && t.x < (n.x - i.x) * (t.y - i.y) / (n.y - i.y) + i.x && (l = !l); return l || yi.prototype._containsPoint.call(this, t, !0) } }); var wi = ci.extend({ initialize: function (t, e) { c(this, e), this._layers = {}, t && this.addData(t) }, addData: function (t) { var e, i, n, o = d(t) ? t : t.features; if (o) { for (e = 0, i = o.length; e < i; e++)((n = o[e]).geometries || n.geometry || n.features || n.coordinates) && this.addData(n); return this } var s, r = this.options; return (!r.filter || r.filter(t)) && (s = bi(t, r)) ? (s.feature = Zi(t), s.defaultOptions = s.options, this.resetStyle(s), r.onEachFeature && r.onEachFeature(t, s), this.addLayer(s)) : this }, resetStyle: function (t) { return void 0 === t ? this.eachLayer(this.resetStyle, this) : (t.options = l({}, t.defaultOptions), this._setLayerStyle(t, this.options.style), this) }, setStyle: function (e) { return this.eachLayer(function (t) { this._setLayerStyle(t, e) }, this) }, _setLayerStyle: function (t, e) { t.setStyle && ("function" == typeof e && (e = e(t.feature)), t.setStyle(e)) } }); function bi(t, e) { var i, n, o, s, r = "Feature" === t.type ? t.geometry : t, a = r ? r.coordinates : null, h = [], l = e && e.pointToLayer, u = e && e.coordsToLatLng || Li; if (!a && !r) return null; switch (r.type) { case "Point": return Pi(l, t, i = u(a), e); case "MultiPoint": for (o = 0, s = a.length; o < s; o++)i = u(a[o]), h.push(Pi(l, t, i, e)); return new ci(h); case "LineString": case "MultiLineString": return n = Ti(a, "LineString" === r.type ? 0 : 1, u), new yi(n, e); case "Polygon": case "MultiPolygon": return n = Ti(a, "Polygon" === r.type ? 1 : 2, u), new xi(n, e); case "GeometryCollection": for (o = 0, s = r.geometries.length; o < s; o++) { var c = bi({ geometry: r.geometries[o], type: "Feature", properties: t.properties }, e); c && h.push(c) } return new ci(h); case "FeatureCollection": for (o = 0, s = r.features.length; o < s; o++) { var d = bi(r.features[o], e); d && h.push(d) } return new ci(h); default: throw new Error("Invalid GeoJSON object.") } } function Pi(t, e, i, n) { return t ? t(e, i) : new mi(i, n && n.markersInheritOptions && n) } function Li(t) { return new v(t[1], t[0], t[2]) } function Ti(t, e, i) { for (var n, o = [], s = 0, r = t.length; s < r; s++)n = e ? Ti(t[s], e - 1, i) : (i || Li)(t[s]), o.push(n); return o } function Mi(t, e) { return void 0 !== (t = w(t)).alt ? [i(t.lng, e), i(t.lat, e), i(t.alt, e)] : [i(t.lng, e), i(t.lat, e)] } function zi(t, e, i, n) { for (var o = [], s = 0, r = t.length; s < r; s++)o.push(e ? zi(t[s], I(t[s]) ? 0 : e - 1, i, n) : Mi(t[s], n)); return !e && i && 0 < o.length && o.push(o[0].slice()), o } function Ci(t, e) { return t.feature ? l({}, t.feature, { geometry: e }) : Zi(e) } function Zi(t) { return "Feature" === t.type || "FeatureCollection" === t.type ? t : { type: "Feature", properties: {}, geometry: t } } Tt = { toGeoJSON: function (t) { return Ci(this, { type: "Point", coordinates: Mi(this.getLatLng(), t) }) } }; function Si(t, e) { return new wi(t, e) } mi.include(Tt), vi.include(Tt), gi.include(Tt), yi.include({ toGeoJSON: function (t) { var e = !I(this._latlngs); return Ci(this, { type: (e ? "Multi" : "") + "LineString", coordinates: zi(this._latlngs, e ? 1 : 0, !1, t) }) } }), xi.include({ toGeoJSON: function (t) { var e = !I(this._latlngs), i = e && !I(this._latlngs[0]), t = zi(this._latlngs, i ? 2 : e ? 1 : 0, !0, t); return Ci(this, { type: (i ? "Multi" : "") + "Polygon", coordinates: t = e ? t : [t] }) } }), ui.include({ toMultiPoint: function (e) { var i = []; return this.eachLayer(function (t) { i.push(t.toGeoJSON(e).geometry.coordinates) }), Ci(this, { type: "MultiPoint", coordinates: i }) }, toGeoJSON: function (e) { var i, n, t = this.feature && this.feature.geometry && this.feature.geometry.type; return "MultiPoint" === t ? this.toMultiPoint(e) : (i = "GeometryCollection" === t, n = [], this.eachLayer(function (t) { t.toGeoJSON && (t = t.toGeoJSON(e), i ? n.push(t.geometry) : "FeatureCollection" === (t = Zi(t)).type ? n.push.apply(n, t.features) : n.push(t)) }), i ? Ci(this, { geometries: n, type: "GeometryCollection" }) : { type: "FeatureCollection", features: n }) } }); var Mt = Si, Ei = o.extend({ options: { opacity: 1, alt: "", interactive: !1, crossOrigin: !1, errorOverlayUrl: "", zIndex: 1, className: "" }, initialize: function (t, e, i) { this._url = t, this._bounds = g(e), c(this, i) }, onAdd: function () { this._image || (this._initImage(), this.options.opacity < 1 && this._updateOpacity()), this.options.interactive && (M(this._image, "leaflet-interactive"), this.addInteractiveTarget(this._image)), this.getPane().appendChild(this._image), this._reset() }, onRemove: function () { T(this._image), this.options.interactive && this.removeInteractiveTarget(this._image) }, setOpacity: function (t) { return this.options.opacity = t, this._image && this._updateOpacity(), this }, setStyle: function (t) { return t.opacity && this.setOpacity(t.opacity), this }, bringToFront: function () { return this._map && fe(this._image), this }, bringToBack: function () { return this._map && ge(this._image), this }, setUrl: function (t) { return this._url = t, this._image && (this._image.src = t), this }, setBounds: function (t) { return this._bounds = g(t), this._map && this._reset(), this }, getEvents: function () { var t = { zoom: this._reset, viewreset: this._reset }; return this._zoomAnimated && (t.zoomanim = this._animateZoom), t }, setZIndex: function (t) { return this.options.zIndex = t, this._updateZIndex(), this }, getBounds: function () { return this._bounds }, getElement: function () { return this._image }, _initImage: function () { var t = "IMG" === this._url.tagName, e = this._image = t ? this._url : P("img"); M(e, "leaflet-image-layer"), this._zoomAnimated && M(e, "leaflet-zoom-animated"), this.options.className && M(e, this.options.className), e.onselectstart = u, e.onmousemove = u, e.onload = a(this.fire, this, "load"), e.onerror = a(this._overlayOnError, this, "error"), !this.options.crossOrigin && "" !== this.options.crossOrigin || (e.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin), this.options.zIndex && this._updateZIndex(), t ? this._url = e.src : (e.src = this._url, e.alt = this.options.alt) }, _animateZoom: function (t) { var e = this._map.getZoomScale(t.zoom), t = this._map._latLngBoundsToNewLayerBounds(this._bounds, t.zoom, t.center).min; be(this._image, t, e) }, _reset: function () { var t = this._image, e = new f(this._map.latLngToLayerPoint(this._bounds.getNorthWest()), this._map.latLngToLayerPoint(this._bounds.getSouthEast())), i = e.getSize(); Z(t, e.min), t.style.width = i.x + "px", t.style.height = i.y + "px" }, _updateOpacity: function () { C(this._image, this.options.opacity) }, _updateZIndex: function () { this._image && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._image.style.zIndex = this.options.zIndex) }, _overlayOnError: function () { this.fire("error"); var t = this.options.errorOverlayUrl; t && this._url !== t && (this._url = t, this._image.src = t) }, getCenter: function () { return this._bounds.getCenter() } }), ki = Ei.extend({ options: { autoplay: !0, loop: !0, keepAspectRatio: !0, muted: !1, playsInline: !0 }, _initImage: function () { var t = "VIDEO" === this._url.tagName, e = this._image = t ? this._url : P("video"); if (M(e, "leaflet-image-layer"), this._zoomAnimated && M(e, "leaflet-zoom-animated"), this.options.className && M(e, this.options.className), e.onselectstart = u, e.onmousemove = u, e.onloadeddata = a(this.fire, this, "load"), t) { for (var i = e.getElementsByTagName("source"), n = [], o = 0; o < i.length; o++)n.push(i[o].src); this._url = 0 < i.length ? n : [e.src] } else { d(this._url) || (this._url = [this._url]), !this.options.keepAspectRatio && Object.prototype.hasOwnProperty.call(e.style, "objectFit") && (e.style.objectFit = "fill"), e.autoplay = !!this.options.autoplay, e.loop = !!this.options.loop, e.muted = !!this.options.muted, e.playsInline = !!this.options.playsInline; for (var s = 0; s < this._url.length; s++) { var r = P("source"); r.src = this._url[s], e.appendChild(r) } } } }); var Oi = Ei.extend({ _initImage: function () { var t = this._image = this._url; M(t, "leaflet-image-layer"), this._zoomAnimated && M(t, "leaflet-zoom-animated"), this.options.className && M(t, this.options.className), t.onselectstart = u, t.onmousemove = u } }); var Ai = o.extend({ options: { interactive: !1, offset: [0, 0], className: "", pane: void 0, content: "" }, initialize: function (t, e) { t && (t instanceof v || d(t)) ? (this._latlng = w(t), c(this, e)) : (c(this, t), this._source = e), this.options.content && (this._content = this.options.content) }, openOn: function (t) { return (t = arguments.length ? t : this._source._map).hasLayer(this) || t.addLayer(this), this }, close: function () { return this._map && this._map.removeLayer(this), this }, toggle: function (t) { return this._map ? this.close() : (arguments.length ? this._source = t : t = this._source, this._prepareOpen(), this.openOn(t._map)), this }, onAdd: function (t) { this._zoomAnimated = t._zoomAnimated, this._container || this._initLayout(), t._fadeAnimated && C(this._container, 0), clearTimeout(this._removeTimeout), this.getPane().appendChild(this._container), this.update(), t._fadeAnimated && C(this._container, 1), this.bringToFront(), this.options.interactive && (M(this._container, "leaflet-interactive"), this.addInteractiveTarget(this._container)) }, onRemove: function (t) { t._fadeAnimated ? (C(this._container, 0), this._removeTimeout = setTimeout(a(T, void 0, this._container), 200)) : T(this._container), this.options.interactive && (z(this._container, "leaflet-interactive"), this.removeInteractiveTarget(this._container)) }, getLatLng: function () { return this._latlng }, setLatLng: function (t) { return this._latlng = w(t), this._map && (this._updatePosition(), this._adjustPan()), this }, getContent: function () { return this._content }, setContent: function (t) { return this._content = t, this.update(), this }, getElement: function () { return this._container }, update: function () { this._map && (this._container.style.visibility = "hidden", this._updateContent(), this._updateLayout(), this._updatePosition(), this._container.style.visibility = "", this._adjustPan()) }, getEvents: function () { var t = { zoom: this._updatePosition, viewreset: this._updatePosition }; return this._zoomAnimated && (t.zoomanim = this._animateZoom), t }, isOpen: function () { return !!this._map && this._map.hasLayer(this) }, bringToFront: function () { return this._map && fe(this._container), this }, bringToBack: function () { return this._map && ge(this._container), this }, _prepareOpen: function (t) { if (!(i = this._source)._map) return !1; if (i instanceof ci) { var e, i = null, n = this._source._layers; for (e in n) if (n[e]._map) { i = n[e]; break } if (!i) return !1; this._source = i } if (!t) if (i.getCenter) t = i.getCenter(); else if (i.getLatLng) t = i.getLatLng(); else { if (!i.getBounds) throw new Error("Unable to get source layer LatLng."); t = i.getBounds().getCenter() } return this.setLatLng(t), this._map && this.update(), !0 }, _updateContent: function () { if (this._content) { var t = this._contentNode, e = "function" == typeof this._content ? this._content(this._source || this) : this._content; if ("string" == typeof e) t.innerHTML = e; else { for (; t.hasChildNodes();)t.removeChild(t.firstChild); t.appendChild(e) } this.fire("contentupdate") } }, _updatePosition: function () { var t, e, i; this._map && (e = this._map.latLngToLayerPoint(this._latlng), t = m(this.options.offset), i = this._getAnchor(), this._zoomAnimated ? Z(this._container, e.add(i)) : t = t.add(e).add(i), e = this._containerBottom = -t.y, i = this._containerLeft = -Math.round(this._containerWidth / 2) + t.x, this._container.style.bottom = e + "px", this._container.style.left = i + "px") }, _getAnchor: function () { return [0, 0] } }), Bi = (A.include({ _initOverlay: function (t, e, i, n) { var o = e; return o instanceof t || (o = new t(n).setContent(e)), i && o.setLatLng(i), o } }), o.include({ _initOverlay: function (t, e, i, n) { var o = i; return o instanceof t ? (c(o, n), o._source = this) : (o = e && !n ? e : new t(n, this)).setContent(i), o } }), Ai.extend({ options: { pane: "popupPane", offset: [0, 7], maxWidth: 300, minWidth: 50, maxHeight: null, autoPan: !0, autoPanPaddingTopLeft: null, autoPanPaddingBottomRight: null, autoPanPadding: [5, 5], keepInView: !1, closeButton: !0, autoClose: !0, closeOnEscapeKey: !0, className: "" }, openOn: function (t) { return !(t = arguments.length ? t : this._source._map).hasLayer(this) && t._popup && t._popup.options.autoClose && t.removeLayer(t._popup), t._popup = this, Ai.prototype.openOn.call(this, t) }, onAdd: function (t) { Ai.prototype.onAdd.call(this, t), t.fire("popupopen", { popup: this }), this._source && (this._source.fire("popupopen", { popup: this }, !0), this._source instanceof fi || this._source.on("preclick", Ae)) }, onRemove: function (t) { Ai.prototype.onRemove.call(this, t), t.fire("popupclose", { popup: this }), this._source && (this._source.fire("popupclose", { popup: this }, !0), this._source instanceof fi || this._source.off("preclick", Ae)) }, getEvents: function () { var t = Ai.prototype.getEvents.call(this); return (void 0 !== this.options.closeOnClick ? this.options.closeOnClick : this._map.options.closePopupOnClick) && (t.preclick = this.close), this.options.keepInView && (t.moveend = this._adjustPan), t }, _initLayout: function () { var t = "leaflet-popup", e = this._container = P("div", t + " " + (this.options.className || "") + " leaflet-zoom-animated"), i = this._wrapper = P("div", t + "-content-wrapper", e); this._contentNode = P("div", t + "-content", i), Ie(e), Be(this._contentNode), S(e, "contextmenu", Ae), this._tipContainer = P("div", t + "-tip-container", e), this._tip = P("div", t + "-tip", this._tipContainer), this.options.closeButton && ((i = this._closeButton = P("a", t + "-close-button", e)).setAttribute("role", "button"), i.setAttribute("aria-label", "Close popup"), i.href = "#close", i.innerHTML = '<span aria-hidden="true">&#215;</span>', S(i, "click", function (t) { O(t), this.close() }, this)) }, _updateLayout: function () { var t = this._contentNode, e = t.style, i = (e.width = "", e.whiteSpace = "nowrap", t.offsetWidth), i = Math.min(i, this.options.maxWidth), i = (i = Math.max(i, this.options.minWidth), e.width = i + 1 + "px", e.whiteSpace = "", e.height = "", t.offsetHeight), n = this.options.maxHeight, o = "leaflet-popup-scrolled"; (n && n < i ? (e.height = n + "px", M) : z)(t, o), this._containerWidth = this._container.offsetWidth }, _animateZoom: function (t) { var t = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center), e = this._getAnchor(); Z(this._container, t.add(e)) }, _adjustPan: function () { var t, e, i, n, o, s, r, a; this.options.autoPan && (this._map._panAnim && this._map._panAnim.stop(), this._autopanning ? this._autopanning = !1 : (t = this._map, e = parseInt(pe(this._container, "marginBottom"), 10) || 0, e = this._container.offsetHeight + e, a = this._containerWidth, (i = new p(this._containerLeft, -e - this._containerBottom))._add(Pe(this._container)), i = t.layerPointToContainerPoint(i), o = m(this.options.autoPanPadding), n = m(this.options.autoPanPaddingTopLeft || o), o = m(this.options.autoPanPaddingBottomRight || o), s = t.getSize(), r = 0, i.x + a + o.x > s.x && (r = i.x + a - s.x + o.x), i.x - r - n.x < (a = 0) && (r = i.x - n.x), i.y + e + o.y > s.y && (a = i.y + e - s.y + o.y), i.y - a - n.y < 0 && (a = i.y - n.y), (r || a) && (this.options.keepInView && (this._autopanning = !0), t.fire("autopanstart").panBy([r, a])))) }, _getAnchor: function () { return m(this._source && this._source._getPopupAnchor ? this._source._getPopupAnchor() : [0, 0]) } })), Ii = (A.mergeOptions({ closePopupOnClick: !0 }), A.include({ openPopup: function (t, e, i) { return this._initOverlay(Bi, t, e, i).openOn(this), this }, closePopup: function (t) { return (t = arguments.length ? t : this._popup) && t.close(), this } }), o.include({ bindPopup: function (t, e) { return this._popup = this._initOverlay(Bi, this._popup, t, e), this._popupHandlersAdded || (this.on({ click: this._openPopup, keypress: this._onKeyPress, remove: this.closePopup, move: this._movePopup }), this._popupHandlersAdded = !0), this }, unbindPopup: function () { return this._popup && (this.off({ click: this._openPopup, keypress: this._onKeyPress, remove: this.closePopup, move: this._movePopup }), this._popupHandlersAdded = !1, this._popup = null), this }, openPopup: function (t) { return this._popup && (this instanceof ci || (this._popup._source = this), this._popup._prepareOpen(t || this._latlng) && this._popup.openOn(this._map)), this }, closePopup: function () { return this._popup && this._popup.close(), this }, togglePopup: function () { return this._popup && this._popup.toggle(this), this }, isPopupOpen: function () { return !!this._popup && this._popup.isOpen() }, setPopupContent: function (t) { return this._popup && this._popup.setContent(t), this }, getPopup: function () { return this._popup }, _openPopup: function (t) { var e; this._popup && this._map && (Re(t), e = t.layer || t.target, this._popup._source !== e || e instanceof fi ? (this._popup._source = e, this.openPopup(t.latlng)) : this._map.hasLayer(this._popup) ? this.closePopup() : this.openPopup(t.latlng)) }, _movePopup: function (t) { this._popup.setLatLng(t.latlng) }, _onKeyPress: function (t) { 13 === t.originalEvent.keyCode && this._openPopup(t) } }), Ai.extend({ options: { pane: "tooltipPane", offset: [0, 0], direction: "auto", permanent: !1, sticky: !1, opacity: .9 }, onAdd: function (t) { Ai.prototype.onAdd.call(this, t), this.setOpacity(this.options.opacity), t.fire("tooltipopen", { tooltip: this }), this._source && (this.addEventParent(this._source), this._source.fire("tooltipopen", { tooltip: this }, !0)) }, onRemove: function (t) { Ai.prototype.onRemove.call(this, t), t.fire("tooltipclose", { tooltip: this }), this._source && (this.removeEventParent(this._source), this._source.fire("tooltipclose", { tooltip: this }, !0)) }, getEvents: function () { var t = Ai.prototype.getEvents.call(this); return this.options.permanent || (t.preclick = this.close), t }, _initLayout: function () { var t = "leaflet-tooltip " + (this.options.className || "") + " leaflet-zoom-" + (this._zoomAnimated ? "animated" : "hide"); this._contentNode = this._container = P("div", t), this._container.setAttribute("role", "tooltip"), this._container.setAttribute("id", "leaflet-tooltip-" + h(this)) }, _updateLayout: function () { }, _adjustPan: function () { }, _setPosition: function (t) { var e, i = this._map, n = this._container, o = i.latLngToContainerPoint(i.getCenter()), i = i.layerPointToContainerPoint(t), s = this.options.direction, r = n.offsetWidth, a = n.offsetHeight, h = m(this.options.offset), l = this._getAnchor(), i = "top" === s ? (e = r / 2, a) : "bottom" === s ? (e = r / 2, 0) : (e = "center" === s ? r / 2 : "right" === s ? 0 : "left" === s ? r : i.x < o.x ? (s = "right", 0) : (s = "left", r + 2 * (h.x + l.x)), a / 2); t = t.subtract(m(e, i, !0)).add(h).add(l), z(n, "leaflet-tooltip-right"), z(n, "leaflet-tooltip-left"), z(n, "leaflet-tooltip-top"), z(n, "leaflet-tooltip-bottom"), M(n, "leaflet-tooltip-" + s), Z(n, t) }, _updatePosition: function () { var t = this._map.latLngToLayerPoint(this._latlng); this._setPosition(t) }, setOpacity: function (t) { this.options.opacity = t, this._container && C(this._container, t) }, _animateZoom: function (t) { t = this._map._latLngToNewLayerPoint(this._latlng, t.zoom, t.center); this._setPosition(t) }, _getAnchor: function () { return m(this._source && this._source._getTooltipAnchor && !this.options.sticky ? this._source._getTooltipAnchor() : [0, 0]) } })), Ri = (A.include({ openTooltip: function (t, e, i) { return this._initOverlay(Ii, t, e, i).openOn(this), this }, closeTooltip: function (t) { return t.close(), this } }), o.include({ bindTooltip: function (t, e) { return this._tooltip && this.isTooltipOpen() && this.unbindTooltip(), this._tooltip = this._initOverlay(Ii, this._tooltip, t, e), this._initTooltipInteractions(), this._tooltip.options.permanent && this._map && this._map.hasLayer(this) && this.openTooltip(), this }, unbindTooltip: function () { return this._tooltip && (this._initTooltipInteractions(!0), this.closeTooltip(), this._tooltip = null), this }, _initTooltipInteractions: function (t) { var e, i; !t && this._tooltipHandlersAdded || (e = t ? "off" : "on", i = { remove: this.closeTooltip, move: this._moveTooltip }, this._tooltip.options.permanent ? i.add = this._openTooltip : (i.mouseover = this._openTooltip, i.mouseout = this.closeTooltip, i.click = this._openTooltip, this._map ? this._addFocusListeners() : i.add = this._addFocusListeners), this._tooltip.options.sticky && (i.mousemove = this._moveTooltip), this[e](i), this._tooltipHandlersAdded = !t) }, openTooltip: function (t) { return this._tooltip && (this instanceof ci || (this._tooltip._source = this), this._tooltip._prepareOpen(t) && (this._tooltip.openOn(this._map), this.getElement ? this._setAriaDescribedByOnLayer(this) : this.eachLayer && this.eachLayer(this._setAriaDescribedByOnLayer, this))), this }, closeTooltip: function () { if (this._tooltip) return this._tooltip.close() }, toggleTooltip: function () { return this._tooltip && this._tooltip.toggle(this), this }, isTooltipOpen: function () { return this._tooltip.isOpen() }, setTooltipContent: function (t) { return this._tooltip && this._tooltip.setContent(t), this }, getTooltip: function () { return this._tooltip }, _addFocusListeners: function () { this.getElement ? this._addFocusListenersOnLayer(this) : this.eachLayer && this.eachLayer(this._addFocusListenersOnLayer, this) }, _addFocusListenersOnLayer: function (t) { var e = "function" == typeof t.getElement && t.getElement(); e && (S(e, "focus", function () { this._tooltip._source = t, this.openTooltip() }, this), S(e, "blur", this.closeTooltip, this)) }, _setAriaDescribedByOnLayer: function (t) { t = "function" == typeof t.getElement && t.getElement(); t && t.setAttribute("aria-describedby", this._tooltip._container.id) }, _openTooltip: function (t) { var e; this._tooltip && this._map && (this._map.dragging && this._map.dragging.moving() && !this._openOnceFlag ? (this._openOnceFlag = !0, (e = this)._map.once("moveend", function () { e._openOnceFlag = !1, e._openTooltip(t) })) : (this._tooltip._source = t.layer || t.target, this.openTooltip(this._tooltip.options.sticky ? t.latlng : void 0))) }, _moveTooltip: function (t) { var e = t.latlng; this._tooltip.options.sticky && t.originalEvent && (t = this._map.mouseEventToContainerPoint(t.originalEvent), t = this._map.containerPointToLayerPoint(t), e = this._map.layerPointToLatLng(t)), this._tooltip.setLatLng(e) } }), di.extend({ options: { iconSize: [12, 12], html: !1, bgPos: null, className: "leaflet-div-icon" }, createIcon: function (t) { var t = t && "DIV" === t.tagName ? t : document.createElement("div"), e = this.options; return e.html instanceof Element ? (me(t), t.appendChild(e.html)) : t.innerHTML = !1 !== e.html ? e.html : "", e.bgPos && (e = m(e.bgPos), t.style.backgroundPosition = -e.x + "px " + -e.y + "px"), this._setIconStyles(t, "icon"), t }, createShadow: function () { return null } })); di.Default = _i; var Ni = o.extend({ options: { tileSize: 256, opacity: 1, updateWhenIdle: b.mobile, updateWhenZooming: !0, updateInterval: 200, zIndex: 1, bounds: null, minZoom: 0, maxZoom: void 0, maxNativeZoom: void 0, minNativeZoom: void 0, noWrap: !1, pane: "tilePane", className: "", keepBuffer: 2 }, initialize: function (t) { c(this, t) }, onAdd: function () { this._initContainer(), this._levels = {}, this._tiles = {}, this._resetView() }, beforeAdd: function (t) { t._addZoomLimit(this) }, onRemove: function (t) { this._removeAllTiles(), T(this._container), t._removeZoomLimit(this), this._container = null, this._tileZoom = void 0 }, bringToFront: function () { return this._map && (fe(this._container), this._setAutoZIndex(Math.max)), this }, bringToBack: function () { return this._map && (ge(this._container), this._setAutoZIndex(Math.min)), this }, getContainer: function () { return this._container }, setOpacity: function (t) { return this.options.opacity = t, this._updateOpacity(), this }, setZIndex: function (t) { return this.options.zIndex = t, this._updateZIndex(), this }, isLoading: function () { return this._loading }, redraw: function () { var t; return this._map && (this._removeAllTiles(), (t = this._clampZoom(this._map.getZoom())) !== this._tileZoom && (this._tileZoom = t, this._updateLevels()), this._update()), this }, getEvents: function () { var t = { viewprereset: this._invalidateAll, viewreset: this._resetView, zoom: this._resetView, moveend: this._onMoveEnd }; return this.options.updateWhenIdle || (this._onMove || (this._onMove = j(this._onMoveEnd, this.options.updateInterval, this)), t.move = this._onMove), this._zoomAnimated && (t.zoomanim = this._animateZoom), t }, createTile: function () { return document.createElement("div") }, getTileSize: function () { var t = this.options.tileSize; return t instanceof p ? t : new p(t, t) }, _updateZIndex: function () { this._container && void 0 !== this.options.zIndex && null !== this.options.zIndex && (this._container.style.zIndex = this.options.zIndex) }, _setAutoZIndex: function (t) { for (var e, i = this.getPane().children, n = -t(-1 / 0, 1 / 0), o = 0, s = i.length; o < s; o++)e = i[o].style.zIndex, i[o] !== this._container && e && (n = t(n, +e)); isFinite(n) && (this.options.zIndex = n + t(-1, 1), this._updateZIndex()) }, _updateOpacity: function () { if (this._map && !b.ielt9) { C(this._container, this.options.opacity); var t, e = +new Date, i = !1, n = !1; for (t in this._tiles) { var o, s = this._tiles[t]; s.current && s.loaded && (o = Math.min(1, (e - s.loaded) / 200), C(s.el, o), o < 1 ? i = !0 : (s.active ? n = !0 : this._onOpaqueTile(s), s.active = !0)) } n && !this._noPrune && this._pruneTiles(), i && (r(this._fadeFrame), this._fadeFrame = x(this._updateOpacity, this)) } }, _onOpaqueTile: u, _initContainer: function () { this._container || (this._container = P("div", "leaflet-layer " + (this.options.className || "")), this._updateZIndex(), this.options.opacity < 1 && this._updateOpacity(), this.getPane().appendChild(this._container)) }, _updateLevels: function () { var t = this._tileZoom, e = this.options.maxZoom; if (void 0 !== t) { for (var i in this._levels) i = Number(i), this._levels[i].el.children.length || i === t ? (this._levels[i].el.style.zIndex = e - Math.abs(t - i), this._onUpdateLevel(i)) : (T(this._levels[i].el), this._removeTilesAtZoom(i), this._onRemoveLevel(i), delete this._levels[i]); var n = this._levels[t], o = this._map; return n || ((n = this._levels[t] = {}).el = P("div", "leaflet-tile-container leaflet-zoom-animated", this._container), n.el.style.zIndex = e, n.origin = o.project(o.unproject(o.getPixelOrigin()), t).round(), n.zoom = t, this._setZoomTransform(n, o.getCenter(), o.getZoom()), u(n.el.offsetWidth), this._onCreateLevel(n)), this._level = n } }, _onUpdateLevel: u, _onRemoveLevel: u, _onCreateLevel: u, _pruneTiles: function () { if (this._map) { var t, e, i, n = this._map.getZoom(); if (n > this.options.maxZoom || n < this.options.minZoom) this._removeAllTiles(); else { for (t in this._tiles) (i = this._tiles[t]).retain = i.current; for (t in this._tiles) (i = this._tiles[t]).current && !i.active && (e = i.coords, this._retainParent(e.x, e.y, e.z, e.z - 5) || this._retainChildren(e.x, e.y, e.z, e.z + 2)); for (t in this._tiles) this._tiles[t].retain || this._removeTile(t) } } }, _removeTilesAtZoom: function (t) { for (var e in this._tiles) this._tiles[e].coords.z === t && this._removeTile(e) }, _removeAllTiles: function () { for (var t in this._tiles) this._removeTile(t) }, _invalidateAll: function () { for (var t in this._levels) T(this._levels[t].el), this._onRemoveLevel(Number(t)), delete this._levels[t]; this._removeAllTiles(), this._tileZoom = void 0 }, _retainParent: function (t, e, i, n) { var t = Math.floor(t / 2), e = Math.floor(e / 2), i = i - 1, o = new p(+t, +e), o = (o.z = i, this._tileCoordsToKey(o)), o = this._tiles[o]; return o && o.active ? o.retain = !0 : (o && o.loaded && (o.retain = !0), n < i && this._retainParent(t, e, i, n)) }, _retainChildren: function (t, e, i, n) { for (var o = 2 * t; o < 2 * t + 2; o++)for (var s = 2 * e; s < 2 * e + 2; s++) { var r = new p(o, s), r = (r.z = i + 1, this._tileCoordsToKey(r)), r = this._tiles[r]; r && r.active ? r.retain = !0 : (r && r.loaded && (r.retain = !0), i + 1 < n && this._retainChildren(o, s, i + 1, n)) } }, _resetView: function (t) { t = t && (t.pinch || t.flyTo); this._setView(this._map.getCenter(), this._map.getZoom(), t, t) }, _animateZoom: function (t) { this._setView(t.center, t.zoom, !0, t.noUpdate) }, _clampZoom: function (t) { var e = this.options; return void 0 !== e.minNativeZoom && t < e.minNativeZoom ? e.minNativeZoom : void 0 !== e.maxNativeZoom && e.maxNativeZoom < t ? e.maxNativeZoom : t }, _setView: function (t, e, i, n) { var o = Math.round(e), o = void 0 !== this.options.maxZoom && o > this.options.maxZoom || void 0 !== this.options.minZoom && o < this.options.minZoom ? void 0 : this._clampZoom(o), s = this.options.updateWhenZooming && o !== this._tileZoom; n && !s || (this._tileZoom = o, this._abortLoading && this._abortLoading(), this._updateLevels(), this._resetGrid(), void 0 !== o && this._update(t), i || this._pruneTiles(), this._noPrune = !!i), this._setZoomTransforms(t, e) }, _setZoomTransforms: function (t, e) { for (var i in this._levels) this._setZoomTransform(this._levels[i], t, e) }, _setZoomTransform: function (t, e, i) { var n = this._map.getZoomScale(i, t.zoom), e = t.origin.multiplyBy(n).subtract(this._map._getNewPixelOrigin(e, i)).round(); b.any3d ? be(t.el, e, n) : Z(t.el, e) }, _resetGrid: function () { var t = this._map, e = t.options.crs, i = this._tileSize = this.getTileSize(), n = this._tileZoom, o = this._map.getPixelWorldBounds(this._tileZoom); o && (this._globalTileRange = this._pxBoundsToTileRange(o)), this._wrapX = e.wrapLng && !this.options.noWrap && [Math.floor(t.project([0, e.wrapLng[0]], n).x / i.x), Math.ceil(t.project([0, e.wrapLng[1]], n).x / i.y)], this._wrapY = e.wrapLat && !this.options.noWrap && [Math.floor(t.project([e.wrapLat[0], 0], n).y / i.x), Math.ceil(t.project([e.wrapLat[1], 0], n).y / i.y)] }, _onMoveEnd: function () { this._map && !this._map._animatingZoom && this._update() }, _getTiledPixelBounds: function (t) { var e = this._map, i = e._animatingZoom ? Math.max(e._animateToZoom, e.getZoom()) : e.getZoom(), i = e.getZoomScale(i, this._tileZoom), t = e.project(t, this._tileZoom).floor(), e = e.getSize().divideBy(2 * i); return new f(t.subtract(e), t.add(e)) }, _update: function (t) { var e = this._map; if (e) { var i = this._clampZoom(e.getZoom()); if (void 0 === t && (t = e.getCenter()), void 0 !== this._tileZoom) { var n, e = this._getTiledPixelBounds(t), o = this._pxBoundsToTileRange(e), s = o.getCenter(), r = [], e = this.options.keepBuffer, a = new f(o.getBottomLeft().subtract([e, -e]), o.getTopRight().add([e, -e])); if (!(isFinite(o.min.x) && isFinite(o.min.y) && isFinite(o.max.x) && isFinite(o.max.y))) throw new Error("Attempted to load an infinite number of tiles"); for (n in this._tiles) { var h = this._tiles[n].coords; h.z === this._tileZoom && a.contains(new p(h.x, h.y)) || (this._tiles[n].current = !1) } if (1 < Math.abs(i - this._tileZoom)) this._setView(t, i); else { for (var l = o.min.y; l <= o.max.y; l++)for (var u = o.min.x; u <= o.max.x; u++) { var c, d = new p(u, l); d.z = this._tileZoom, this._isValidTile(d) && ((c = this._tiles[this._tileCoordsToKey(d)]) ? c.current = !0 : r.push(d)) } if (r.sort(function (t, e) { return t.distanceTo(s) - e.distanceTo(s) }), 0 !== r.length) { this._loading || (this._loading = !0, this.fire("loading")); for (var _ = document.createDocumentFragment(), u = 0; u < r.length; u++)this._addTile(r[u], _); this._level.el.appendChild(_) } } } } }, _isValidTile: function (t) { var e = this._map.options.crs; if (!e.infinite) { var i = this._globalTileRange; if (!e.wrapLng && (t.x < i.min.x || t.x > i.max.x) || !e.wrapLat && (t.y < i.min.y || t.y > i.max.y)) return !1 } return !this.options.bounds || (e = this._tileCoordsToBounds(t), g(this.options.bounds).overlaps(e)) }, _keyToBounds: function (t) { return this._tileCoordsToBounds(this._keyToTileCoords(t)) }, _tileCoordsToNwSe: function (t) { var e = this._map, i = this.getTileSize(), n = t.scaleBy(i), i = n.add(i); return [e.unproject(n, t.z), e.unproject(i, t.z)] }, _tileCoordsToBounds: function (t) { t = this._tileCoordsToNwSe(t), t = new s(t[0], t[1]); return t = this.options.noWrap ? t : this._map.wrapLatLngBounds(t) }, _tileCoordsToKey: function (t) { return t.x + ":" + t.y + ":" + t.z }, _keyToTileCoords: function (t) { var t = t.split(":"), e = new p(+t[0], +t[1]); return e.z = +t[2], e }, _removeTile: function (t) { var e = this._tiles[t]; e && (T(e.el), delete this._tiles[t], this.fire("tileunload", { tile: e.el, coords: this._keyToTileCoords(t) })) }, _initTile: function (t) { M(t, "leaflet-tile"); var e = this.getTileSize(); t.style.width = e.x + "px", t.style.height = e.y + "px", t.onselectstart = u, t.onmousemove = u, b.ielt9 && this.options.opacity < 1 && C(t, this.options.opacity) }, _addTile: function (t, e) { var i = this._getTilePos(t), n = this._tileCoordsToKey(t), o = this.createTile(this._wrapCoords(t), a(this._tileReady, this, t)); this._initTile(o), this.createTile.length < 2 && x(a(this._tileReady, this, t, null, o)), Z(o, i), this._tiles[n] = { el: o, coords: t, current: !0 }, e.appendChild(o), this.fire("tileloadstart", { tile: o, coords: t }) }, _tileReady: function (t, e, i) { e && this.fire("tileerror", { error: e, tile: i, coords: t }); var n = this._tileCoordsToKey(t); (i = this._tiles[n]) && (i.loaded = +new Date, this._map._fadeAnimated ? (C(i.el, 0), r(this._fadeFrame), this._fadeFrame = x(this._updateOpacity, this)) : (i.active = !0, this._pruneTiles()), e || (M(i.el, "leaflet-tile-loaded"), this.fire("tileload", { tile: i.el, coords: t })), this._noTilesToLoad() && (this._loading = !1, this.fire("load"), b.ielt9 || !this._map._fadeAnimated ? x(this._pruneTiles, this) : setTimeout(a(this._pruneTiles, this), 250))) }, _getTilePos: function (t) { return t.scaleBy(this.getTileSize()).subtract(this._level.origin) }, _wrapCoords: function (t) { var e = new p(this._wrapX ? H(t.x, this._wrapX) : t.x, this._wrapY ? H(t.y, this._wrapY) : t.y); return e.z = t.z, e }, _pxBoundsToTileRange: function (t) { var e = this.getTileSize(); return new f(t.min.unscaleBy(e).floor(), t.max.unscaleBy(e).ceil().subtract([1, 1])) }, _noTilesToLoad: function () { for (var t in this._tiles) if (!this._tiles[t].loaded) return !1; return !0 } }); var Di = Ni.extend({ options: { minZoom: 0, maxZoom: 18, subdomains: "abc", errorTileUrl: "", zoomOffset: 0, tms: !1, zoomReverse: !1, detectRetina: !1, crossOrigin: !1, referrerPolicy: !1 }, initialize: function (t, e) { this._url = t, (e = c(this, e)).detectRetina && b.retina && 0 < e.maxZoom ? (e.tileSize = Math.floor(e.tileSize / 2), e.zoomReverse ? (e.zoomOffset--, e.minZoom = Math.min(e.maxZoom, e.minZoom + 1)) : (e.zoomOffset++, e.maxZoom = Math.max(e.minZoom, e.maxZoom - 1)), e.minZoom = Math.max(0, e.minZoom)) : e.zoomReverse ? e.minZoom = Math.min(e.maxZoom, e.minZoom) : e.maxZoom = Math.max(e.minZoom, e.maxZoom), "string" == typeof e.subdomains && (e.subdomains = e.subdomains.split("")), this.on("tileunload", this._onTileRemove) }, setUrl: function (t, e) { return this._url === t && void 0 === e && (e = !0), this._url = t, e || this.redraw(), this }, createTile: function (t, e) { var i = document.createElement("img"); return S(i, "load", a(this._tileOnLoad, this, e, i)), S(i, "error", a(this._tileOnError, this, e, i)), !this.options.crossOrigin && "" !== this.options.crossOrigin || (i.crossOrigin = !0 === this.options.crossOrigin ? "" : this.options.crossOrigin), "string" == typeof this.options.referrerPolicy && (i.referrerPolicy = this.options.referrerPolicy), i.alt = "", i.src = this.getTileUrl(t), i }, getTileUrl: function (t) { var e = { r: b.retina ? "@2x" : "", s: this._getSubdomain(t), x: t.x, y: t.y, z: this._getZoomForUrl() }; return this._map && !this._map.options.crs.infinite && (t = this._globalTileRange.max.y - t.y, this.options.tms && (e.y = t), e["-y"] = t), q(this._url, l(e, this.options)) }, _tileOnLoad: function (t, e) { b.ielt9 ? setTimeout(a(t, this, null, e), 0) : t(null, e) }, _tileOnError: function (t, e, i) { var n = this.options.errorTileUrl; n && e.getAttribute("src") !== n && (e.src = n), t(i, e) }, _onTileRemove: function (t) { t.tile.onload = null }, _getZoomForUrl: function () { var t = this._tileZoom, e = this.options.maxZoom; return (t = this.options.zoomReverse ? e - t : t) + this.options.zoomOffset }, _getSubdomain: function (t) { t = Math.abs(t.x + t.y) % this.options.subdomains.length; return this.options.subdomains[t] }, _abortLoading: function () { var t, e, i; for (t in this._tiles) this._tiles[t].coords.z !== this._tileZoom && ((i = this._tiles[t].el).onload = u, i.onerror = u, i.complete || (i.src = K, e = this._tiles[t].coords, T(i), delete this._tiles[t], this.fire("tileabort", { tile: i, coords: e }))) }, _removeTile: function (t) { var e = this._tiles[t]; if (e) return e.el.setAttribute("src", K), Ni.prototype._removeTile.call(this, t) }, _tileReady: function (t, e, i) { if (this._map && (!i || i.getAttribute("src") !== K)) return Ni.prototype._tileReady.call(this, t, e, i) } }); function ji(t, e) { return new Di(t, e) } var Hi = Di.extend({ defaultWmsParams: { service: "WMS", request: "GetMap", layers: "", styles: "", format: "image/jpeg", transparent: !1, version: "1.1.1" }, options: { crs: null, uppercase: !1 }, initialize: function (t, e) { this._url = t; var i, n = l({}, this.defaultWmsParams); for (i in e) i in this.options || (n[i] = e[i]); var t = (e = c(this, e)).detectRetina && b.retina ? 2 : 1, o = this.getTileSize(); n.width = o.x * t, n.height = o.y * t, this.wmsParams = n }, onAdd: function (t) { this._crs = this.options.crs || t.options.crs, this._wmsVersion = parseFloat(this.wmsParams.version); var e = 1.3 <= this._wmsVersion ? "crs" : "srs"; this.wmsParams[e] = this._crs.code, Di.prototype.onAdd.call(this, t) }, getTileUrl: function (t) { var e = this._tileCoordsToNwSe(t), i = this._crs, i = _(i.project(e[0]), i.project(e[1])), e = i.min, i = i.max, e = (1.3 <= this._wmsVersion && this._crs === li ? [e.y, e.x, i.y, i.x] : [e.x, e.y, i.x, i.y]).join(","), i = Di.prototype.getTileUrl.call(this, t); return i + U(this.wmsParams, i, this.options.uppercase) + (this.options.uppercase ? "&BBOX=" : "&bbox=") + e }, setParams: function (t, e) { return l(this.wmsParams, t), e || this.redraw(), this } }); Di.WMS = Hi, ji.wms = function (t, e) { return new Hi(t, e) }; var Wi = o.extend({ options: { padding: .1 }, initialize: function (t) { c(this, t), h(this), this._layers = this._layers || {} }, onAdd: function () { this._container || (this._initContainer(), M(this._container, "leaflet-zoom-animated")), this.getPane().appendChild(this._container), this._update(), this.on("update", this._updatePaths, this) }, onRemove: function () { this.off("update", this._updatePaths, this), this._destroyContainer() }, getEvents: function () { var t = { viewreset: this._reset, zoom: this._onZoom, moveend: this._update, zoomend: this._onZoomEnd }; return this._zoomAnimated && (t.zoomanim = this._onAnimZoom), t }, _onAnimZoom: function (t) { this._updateTransform(t.center, t.zoom) }, _onZoom: function () { this._updateTransform(this._map.getCenter(), this._map.getZoom()) }, _updateTransform: function (t, e) { var i = this._map.getZoomScale(e, this._zoom), n = this._map.getSize().multiplyBy(.5 + this.options.padding), o = this._map.project(this._center, e), n = n.multiplyBy(-i).add(o).subtract(this._map._getNewPixelOrigin(t, e)); b.any3d ? be(this._container, n, i) : Z(this._container, n) }, _reset: function () { for (var t in this._update(), this._updateTransform(this._center, this._zoom), this._layers) this._layers[t]._reset() }, _onZoomEnd: function () { for (var t in this._layers) this._layers[t]._project() }, _updatePaths: function () { for (var t in this._layers) this._layers[t]._update() }, _update: function () { var t = this.options.padding, e = this._map.getSize(), i = this._map.containerPointToLayerPoint(e.multiplyBy(-t)).round(); this._bounds = new f(i, i.add(e.multiplyBy(1 + 2 * t)).round()), this._center = this._map.getCenter(), this._zoom = this._map.getZoom() } }), Fi = Wi.extend({ options: { tolerance: 0 }, getEvents: function () { var t = Wi.prototype.getEvents.call(this); return t.viewprereset = this._onViewPreReset, t }, _onViewPreReset: function () { this._postponeUpdatePaths = !0 }, onAdd: function () { Wi.prototype.onAdd.call(this), this._draw() }, _initContainer: function () { var t = this._container = document.createElement("canvas"); S(t, "mousemove", this._onMouseMove, this), S(t, "click dblclick mousedown mouseup contextmenu", this._onClick, this), S(t, "mouseout", this._handleMouseOut, this), t._leaflet_disable_events = !0, this._ctx = t.getContext("2d") }, _destroyContainer: function () { r(this._redrawRequest), delete this._ctx, T(this._container), k(this._container), delete this._container }, _updatePaths: function () { if (!this._postponeUpdatePaths) { for (var t in this._redrawBounds = null, this._layers) this._layers[t]._update(); this._redraw() } }, _update: function () { var t, e, i, n; this._map._animatingZoom && this._bounds || (Wi.prototype._update.call(this), t = this._bounds, e = this._container, i = t.getSize(), n = b.retina ? 2 : 1, Z(e, t.min), e.width = n * i.x, e.height = n * i.y, e.style.width = i.x + "px", e.style.height = i.y + "px", b.retina && this._ctx.scale(2, 2), this._ctx.translate(-t.min.x, -t.min.y), this.fire("update")) }, _reset: function () { Wi.prototype._reset.call(this), this._postponeUpdatePaths && (this._postponeUpdatePaths = !1, this._updatePaths()) }, _initPath: function (t) { this._updateDashArray(t); t = (this._layers[h(t)] = t)._order = { layer: t, prev: this._drawLast, next: null }; this._drawLast && (this._drawLast.next = t), this._drawLast = t, this._drawFirst = this._drawFirst || this._drawLast }, _addPath: function (t) { this._requestRedraw(t) }, _removePath: function (t) { var e = t._order, i = e.next, e = e.prev; i ? i.prev = e : this._drawLast = e, e ? e.next = i : this._drawFirst = i, delete t._order, delete this._layers[h(t)], this._requestRedraw(t) }, _updatePath: function (t) { this._extendRedrawBounds(t), t._project(), t._update(), this._requestRedraw(t) }, _updateStyle: function (t) { this._updateDashArray(t), this._requestRedraw(t) }, _updateDashArray: function (t) { if ("string" == typeof t.options.dashArray) { for (var e, i = t.options.dashArray.split(/[, ]+/), n = [], o = 0; o < i.length; o++) { if (e = Number(i[o]), isNaN(e)) return; n.push(e) } t.options._dashArray = n } else t.options._dashArray = t.options.dashArray }, _requestRedraw: function (t) { this._map && (this._extendRedrawBounds(t), this._redrawRequest = this._redrawRequest || x(this._redraw, this)) }, _extendRedrawBounds: function (t) { var e; t._pxBounds && (e = (t.options.weight || 0) + 1, this._redrawBounds = this._redrawBounds || new f, this._redrawBounds.extend(t._pxBounds.min.subtract([e, e])), this._redrawBounds.extend(t._pxBounds.max.add([e, e]))) }, _redraw: function () { this._redrawRequest = null, this._redrawBounds && (this._redrawBounds.min._floor(), this._redrawBounds.max._ceil()), this._clear(), this._draw(), this._redrawBounds = null }, _clear: function () { var t, e = this._redrawBounds; e ? (t = e.getSize(), this._ctx.clearRect(e.min.x, e.min.y, t.x, t.y)) : (this._ctx.save(), this._ctx.setTransform(1, 0, 0, 1, 0, 0), this._ctx.clearRect(0, 0, this._container.width, this._container.height), this._ctx.restore()) }, _draw: function () { var t, e, i = this._redrawBounds; this._ctx.save(), i && (e = i.getSize(), this._ctx.beginPath(), this._ctx.rect(i.min.x, i.min.y, e.x, e.y), this._ctx.clip()), this._drawing = !0; for (var n = this._drawFirst; n; n = n.next)t = n.layer, (!i || t._pxBounds && t._pxBounds.intersects(i)) && t._updatePath(); this._drawing = !1, this._ctx.restore() }, _updatePoly: function (t, e) { if (this._drawing) { var i, n, o, s, r = t._parts, a = r.length, h = this._ctx; if (a) { for (h.beginPath(), i = 0; i < a; i++) { for (n = 0, o = r[i].length; n < o; n++)s = r[i][n], h[n ? "lineTo" : "moveTo"](s.x, s.y); e && h.closePath() } this._fillStroke(h, t) } } }, _updateCircle: function (t) { var e, i, n, o; this._drawing && !t._empty() && (e = t._point, i = this._ctx, n = Math.max(Math.round(t._radius), 1), 1 != (o = (Math.max(Math.round(t._radiusY), 1) || n) / n) && (i.save(), i.scale(1, o)), i.beginPath(), i.arc(e.x, e.y / o, n, 0, 2 * Math.PI, !1), 1 != o && i.restore(), this._fillStroke(i, t)) }, _fillStroke: function (t, e) { var i = e.options; i.fill && (t.globalAlpha = i.fillOpacity, t.fillStyle = i.fillColor || i.color, t.fill(i.fillRule || "evenodd")), i.stroke && 0 !== i.weight && (t.setLineDash && t.setLineDash(e.options && e.options._dashArray || []), t.globalAlpha = i.opacity, t.lineWidth = i.weight, t.strokeStyle = i.color, t.lineCap = i.lineCap, t.lineJoin = i.lineJoin, t.stroke()) }, _onClick: function (t) { for (var e, i, n = this._map.mouseEventToLayerPoint(t), o = this._drawFirst; o; o = o.next)(e = o.layer).options.interactive && e._containsPoint(n) && (("click" === t.type || "preclick" === t.type) && this._map._draggableMoved(e) || (i = e)); this._fireEvent(!!i && [i], t) }, _onMouseMove: function (t) { var e; !this._map || this._map.dragging.moving() || this._map._animatingZoom || (e = this._map.mouseEventToLayerPoint(t), this._handleMouseHover(t, e)) }, _handleMouseOut: function (t) { var e = this._hoveredLayer; e && (z(this._container, "leaflet-interactive"), this._fireEvent([e], t, "mouseout"), this._hoveredLayer = null, this._mouseHoverThrottled = !1) }, _handleMouseHover: function (t, e) { if (!this._mouseHoverThrottled) { for (var i, n, o = this._drawFirst; o; o = o.next)(i = o.layer).options.interactive && i._containsPoint(e) && (n = i); n !== this._hoveredLayer && (this._handleMouseOut(t), n && (M(this._container, "leaflet-interactive"), this._fireEvent([n], t, "mouseover"), this._hoveredLayer = n)), this._fireEvent(!!this._hoveredLayer && [this._hoveredLayer], t), this._mouseHoverThrottled = !0, setTimeout(a(function () { this._mouseHoverThrottled = !1 }, this), 32) } }, _fireEvent: function (t, e, i) { this._map._fireDOMEvent(e, i || e.type, t) }, _bringToFront: function (t) { var e, i, n = t._order; n && (e = n.next, i = n.prev, e && ((e.prev = i) ? i.next = e : e && (this._drawFirst = e), n.prev = this._drawLast, (this._drawLast.next = n).next = null, this._drawLast = n, this._requestRedraw(t))) }, _bringToBack: function (t) { var e, i, n = t._order; n && (e = n.next, (i = n.prev) && ((i.next = e) ? e.prev = i : i && (this._drawLast = i), n.prev = null, n.next = this._drawFirst, this._drawFirst.prev = n, this._drawFirst = n, this._requestRedraw(t))) } }); function Ui(t) { return b.canvas ? new Fi(t) : null } var Vi = function () { try { return document.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"), function (t) { return document.createElement("<lvml:" + t + ' class="lvml">') } } catch (t) { } return function (t) { return document.createElement("<" + t + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">') } }(), zt = { _initContainer: function () { this._container = P("div", "leaflet-vml-container") }, _update: function () { this._map._animatingZoom || (Wi.prototype._update.call(this), this.fire("update")) }, _initPath: function (t) { var e = t._container = Vi("shape"); M(e, "leaflet-vml-shape " + (this.options.className || "")), e.coordsize = "1 1", t._path = Vi("path"), e.appendChild(t._path), this._updateStyle(t), this._layers[h(t)] = t }, _addPath: function (t) { var e = t._container; this._container.appendChild(e), t.options.interactive && t.addInteractiveTarget(e) }, _removePath: function (t) { var e = t._container; T(e), t.removeInteractiveTarget(e), delete this._layers[h(t)] }, _updateStyle: function (t) { var e = t._stroke, i = t._fill, n = t.options, o = t._container; o.stroked = !!n.stroke, o.filled = !!n.fill, n.stroke ? (e = e || (t._stroke = Vi("stroke")), o.appendChild(e), e.weight = n.weight + "px", e.color = n.color, e.opacity = n.opacity, n.dashArray ? e.dashStyle = d(n.dashArray) ? n.dashArray.join(" ") : n.dashArray.replace(/( *, *)/g, " ") : e.dashStyle = "", e.endcap = n.lineCap.replace("butt", "flat"), e.joinstyle = n.lineJoin) : e && (o.removeChild(e), t._stroke = null), n.fill ? (i = i || (t._fill = Vi("fill")), o.appendChild(i), i.color = n.fillColor || n.color, i.opacity = n.fillOpacity) : i && (o.removeChild(i), t._fill = null) }, _updateCircle: function (t) { var e = t._point.round(), i = Math.round(t._radius), n = Math.round(t._radiusY || i); this._setPath(t, t._empty() ? "M0 0" : "AL " + e.x + "," + e.y + " " + i + "," + n + " 0,23592600") }, _setPath: function (t, e) { t._path.v = e }, _bringToFront: function (t) { fe(t._container) }, _bringToBack: function (t) { ge(t._container) } }, qi = b.vml ? Vi : ct, Gi = Wi.extend({ _initContainer: function () { this._container = qi("svg"), this._container.setAttribute("pointer-events", "none"), this._rootGroup = qi("g"), this._container.appendChild(this._rootGroup) }, _destroyContainer: function () { T(this._container), k(this._container), delete this._container, delete this._rootGroup, delete this._svgSize }, _update: function () { var t, e, i; this._map._animatingZoom && this._bounds || (Wi.prototype._update.call(this), e = (t = this._bounds).getSize(), i = this._container, this._svgSize && this._svgSize.equals(e) || (this._svgSize = e, i.setAttribute("width", e.x), i.setAttribute("height", e.y)), Z(i, t.min), i.setAttribute("viewBox", [t.min.x, t.min.y, e.x, e.y].join(" ")), this.fire("update")) }, _initPath: function (t) { var e = t._path = qi("path"); t.options.className && M(e, t.options.className), t.options.interactive && M(e, "leaflet-interactive"), this._updateStyle(t), this._layers[h(t)] = t }, _addPath: function (t) { this._rootGroup || this._initContainer(), this._rootGroup.appendChild(t._path), t.addInteractiveTarget(t._path) }, _removePath: function (t) { T(t._path), t.removeInteractiveTarget(t._path), delete this._layers[h(t)] }, _updatePath: function (t) { t._project(), t._update() }, _updateStyle: function (t) { var e = t._path, t = t.options; e && (t.stroke ? (e.setAttribute("stroke", t.color), e.setAttribute("stroke-opacity", t.opacity), e.setAttribute("stroke-width", t.weight), e.setAttribute("stroke-linecap", t.lineCap), e.setAttribute("stroke-linejoin", t.lineJoin), t.dashArray ? e.setAttribute("stroke-dasharray", t.dashArray) : e.removeAttribute("stroke-dasharray"), t.dashOffset ? e.setAttribute("stroke-dashoffset", t.dashOffset) : e.removeAttribute("stroke-dashoffset")) : e.setAttribute("stroke", "none"), t.fill ? (e.setAttribute("fill", t.fillColor || t.color), e.setAttribute("fill-opacity", t.fillOpacity), e.setAttribute("fill-rule", t.fillRule || "evenodd")) : e.setAttribute("fill", "none")) }, _updatePoly: function (t, e) { this._setPath(t, dt(t._parts, e)) }, _updateCircle: function (t) { var e = t._point, i = Math.max(Math.round(t._radius), 1), n = "a" + i + "," + (Math.max(Math.round(t._radiusY), 1) || i) + " 0 1,0 ", e = t._empty() ? "M0 0" : "M" + (e.x - i) + "," + e.y + n + 2 * i + ",0 " + n + 2 * -i + ",0 "; this._setPath(t, e) }, _setPath: function (t, e) { t._path.setAttribute("d", e) }, _bringToFront: function (t) { fe(t._path) }, _bringToBack: function (t) { ge(t._path) } }); function Ki(t) { return b.svg || b.vml ? new Gi(t) : null } b.vml && Gi.include(zt), A.include({ getRenderer: function (t) { t = (t = t.options.renderer || this._getPaneRenderer(t.options.pane) || this.options.renderer || this._renderer) || (this._renderer = this._createRenderer()); return this.hasLayer(t) || this.addLayer(t), t }, _getPaneRenderer: function (t) { var e; return "overlayPane" !== t && void 0 !== t && (void 0 === (e = this._paneRenderers[t]) && (e = this._createRenderer({ pane: t }), this._paneRenderers[t] = e), e) }, _createRenderer: function (t) { return this.options.preferCanvas && Ui(t) || Ki(t) } }); var Yi = xi.extend({ initialize: function (t, e) { xi.prototype.initialize.call(this, this._boundsToLatLngs(t), e) }, setBounds: function (t) { return this.setLatLngs(this._boundsToLatLngs(t)) }, _boundsToLatLngs: function (t) { return [(t = g(t)).getSouthWest(), t.getNorthWest(), t.getNorthEast(), t.getSouthEast()] } }); Gi.create = qi, Gi.pointsToPath = dt, wi.geometryToLayer = bi, wi.coordsToLatLng = Li, wi.coordsToLatLngs = Ti, wi.latLngToCoords = Mi, wi.latLngsToCoords = zi, wi.getFeature = Ci, wi.asFeature = Zi, A.mergeOptions({ boxZoom: !0 }); var _t = n.extend({ initialize: function (t) { this._map = t, this._container = t._container, this._pane = t._panes.overlayPane, this._resetStateTimeout = 0, t.on("unload", this._destroy, this) }, addHooks: function () { S(this._container, "mousedown", this._onMouseDown, this) }, removeHooks: function () { k(this._container, "mousedown", this._onMouseDown, this) }, moved: function () { return this._moved }, _destroy: function () { T(this._pane), delete this._pane }, _resetState: function () { this._resetStateTimeout = 0, this._moved = !1 }, _clearDeferredResetState: function () { 0 !== this._resetStateTimeout && (clearTimeout(this._resetStateTimeout), this._resetStateTimeout = 0) }, _onMouseDown: function (t) { if (!t.shiftKey || 1 !== t.which && 1 !== t.button) return !1; this._clearDeferredResetState(), this._resetState(), re(), Le(), this._startPoint = this._map.mouseEventToContainerPoint(t), S(document, { contextmenu: Re, mousemove: this._onMouseMove, mouseup: this._onMouseUp, keydown: this._onKeyDown }, this) }, _onMouseMove: function (t) { this._moved || (this._moved = !0, this._box = P("div", "leaflet-zoom-box", this._container), M(this._container, "leaflet-crosshair"), this._map.fire("boxzoomstart")), this._point = this._map.mouseEventToContainerPoint(t); var t = new f(this._point, this._startPoint), e = t.getSize(); Z(this._box, t.min), this._box.style.width = e.x + "px", this._box.style.height = e.y + "px" }, _finish: function () { this._moved && (T(this._box), z(this._container, "leaflet-crosshair")), ae(), Te(), k(document, { contextmenu: Re, mousemove: this._onMouseMove, mouseup: this._onMouseUp, keydown: this._onKeyDown }, this) }, _onMouseUp: function (t) { 1 !== t.which && 1 !== t.button || (this._finish(), this._moved && (this._clearDeferredResetState(), this._resetStateTimeout = setTimeout(a(this._resetState, this), 0), t = new s(this._map.containerPointToLatLng(this._startPoint), this._map.containerPointToLatLng(this._point)), this._map.fitBounds(t).fire("boxzoomend", { boxZoomBounds: t }))) }, _onKeyDown: function (t) { 27 === t.keyCode && (this._finish(), this._clearDeferredResetState(), this._resetState()) } }), Ct = (A.addInitHook("addHandler", "boxZoom", _t), A.mergeOptions({ doubleClickZoom: !0 }), n.extend({ addHooks: function () { this._map.on("dblclick", this._onDoubleClick, this) }, removeHooks: function () { this._map.off("dblclick", this._onDoubleClick, this) }, _onDoubleClick: function (t) { var e = this._map, i = e.getZoom(), n = e.options.zoomDelta, i = t.originalEvent.shiftKey ? i - n : i + n; "center" === e.options.doubleClickZoom ? e.setZoom(i) : e.setZoomAround(t.containerPoint, i) } })), Zt = (A.addInitHook("addHandler", "doubleClickZoom", Ct), A.mergeOptions({ dragging: !0, inertia: !0, inertiaDeceleration: 3400, inertiaMaxSpeed: 1 / 0, easeLinearity: .2, worldCopyJump: !1, maxBoundsViscosity: 0 }), n.extend({ addHooks: function () { var t; this._draggable || (t = this._map, this._draggable = new Xe(t._mapPane, t._container), this._draggable.on({ dragstart: this._onDragStart, drag: this._onDrag, dragend: this._onDragEnd }, this), this._draggable.on("predrag", this._onPreDragLimit, this), t.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDragWrap, this), t.on("zoomend", this._onZoomEnd, this), t.whenReady(this._onZoomEnd, this))), M(this._map._container, "leaflet-grab leaflet-touch-drag"), this._draggable.enable(), this._positions = [], this._times = [] }, removeHooks: function () { z(this._map._container, "leaflet-grab"), z(this._map._container, "leaflet-touch-drag"), this._draggable.disable() }, moved: function () { return this._draggable && this._draggable._moved }, moving: function () { return this._draggable && this._draggable._moving }, _onDragStart: function () { var t, e = this._map; e._stop(), this._map.options.maxBounds && this._map.options.maxBoundsViscosity ? (t = g(this._map.options.maxBounds), this._offsetLimit = _(this._map.latLngToContainerPoint(t.getNorthWest()).multiplyBy(-1), this._map.latLngToContainerPoint(t.getSouthEast()).multiplyBy(-1).add(this._map.getSize())), this._viscosity = Math.min(1, Math.max(0, this._map.options.maxBoundsViscosity))) : this._offsetLimit = null, e.fire("movestart").fire("dragstart"), e.options.inertia && (this._positions = [], this._times = []) }, _onDrag: function (t) { var e, i; this._map.options.inertia && (e = this._lastTime = +new Date, i = this._lastPos = this._draggable._absPos || this._draggable._newPos, this._positions.push(i), this._times.push(e), this._prunePositions(e)), this._map.fire("move", t).fire("drag", t) }, _prunePositions: function (t) { for (; 1 < this._positions.length && 50 < t - this._times[0];)this._positions.shift(), this._times.shift() }, _onZoomEnd: function () { var t = this._map.getSize().divideBy(2), e = this._map.latLngToLayerPoint([0, 0]); this._initialWorldOffset = e.subtract(t).x, this._worldWidth = this._map.getPixelWorldBounds().getSize().x }, _viscousLimit: function (t, e) { return t - (t - e) * this._viscosity }, _onPreDragLimit: function () { var t, e; this._viscosity && this._offsetLimit && (t = this._draggable._newPos.subtract(this._draggable._startPos), e = this._offsetLimit, t.x < e.min.x && (t.x = this._viscousLimit(t.x, e.min.x)), t.y < e.min.y && (t.y = this._viscousLimit(t.y, e.min.y)), t.x > e.max.x && (t.x = this._viscousLimit(t.x, e.max.x)), t.y > e.max.y && (t.y = this._viscousLimit(t.y, e.max.y)), this._draggable._newPos = this._draggable._startPos.add(t)) }, _onPreDragWrap: function () { var t = this._worldWidth, e = Math.round(t / 2), i = this._initialWorldOffset, n = this._draggable._newPos.x, o = (n - e + i) % t + e - i, n = (n + e + i) % t - e - i, t = Math.abs(o + i) < Math.abs(n + i) ? o : n; this._draggable._absPos = this._draggable._newPos.clone(), this._draggable._newPos.x = t }, _onDragEnd: function (t) { var e, i, n, o, s = this._map, r = s.options, a = !r.inertia || t.noInertia || this._times.length < 2; s.fire("dragend", t), !a && (this._prunePositions(+new Date), t = this._lastPos.subtract(this._positions[0]), a = (this._lastTime - this._times[0]) / 1e3, e = r.easeLinearity, a = (t = t.multiplyBy(e / a)).distanceTo([0, 0]), i = Math.min(r.inertiaMaxSpeed, a), t = t.multiplyBy(i / a), n = i / (r.inertiaDeceleration * e), (o = t.multiplyBy(-n / 2).round()).x || o.y) ? (o = s._limitOffset(o, s.options.maxBounds), x(function () { s.panBy(o, { duration: n, easeLinearity: e, noMoveStart: !0, animate: !0 }) })) : s.fire("moveend") } })), St = (A.addInitHook("addHandler", "dragging", Zt), A.mergeOptions({ keyboard: !0, keyboardPanDelta: 80 }), n.extend({ keyCodes: { left: [37], right: [39], down: [40], up: [38], zoomIn: [187, 107, 61, 171], zoomOut: [189, 109, 54, 173] }, initialize: function (t) { this._map = t, this._setPanDelta(t.options.keyboardPanDelta), this._setZoomDelta(t.options.zoomDelta) }, addHooks: function () { var t = this._map._container; t.tabIndex <= 0 && (t.tabIndex = "0"), S(t, { focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown }, this), this._map.on({ focus: this._addHooks, blur: this._removeHooks }, this) }, removeHooks: function () { this._removeHooks(), k(this._map._container, { focus: this._onFocus, blur: this._onBlur, mousedown: this._onMouseDown }, this), this._map.off({ focus: this._addHooks, blur: this._removeHooks }, this) }, _onMouseDown: function () { var t, e, i; this._focused || (i = document.body, t = document.documentElement, e = i.scrollTop || t.scrollTop, i = i.scrollLeft || t.scrollLeft, this._map._container.focus(), window.scrollTo(i, e)) }, _onFocus: function () { this._focused = !0, this._map.fire("focus") }, _onBlur: function () { this._focused = !1, this._map.fire("blur") }, _setPanDelta: function (t) { for (var e = this._panKeys = {}, i = this.keyCodes, n = 0, o = i.left.length; n < o; n++)e[i.left[n]] = [-1 * t, 0]; for (n = 0, o = i.right.length; n < o; n++)e[i.right[n]] = [t, 0]; for (n = 0, o = i.down.length; n < o; n++)e[i.down[n]] = [0, t]; for (n = 0, o = i.up.length; n < o; n++)e[i.up[n]] = [0, -1 * t] }, _setZoomDelta: function (t) { for (var e = this._zoomKeys = {}, i = this.keyCodes, n = 0, o = i.zoomIn.length; n < o; n++)e[i.zoomIn[n]] = t; for (n = 0, o = i.zoomOut.length; n < o; n++)e[i.zoomOut[n]] = -t }, _addHooks: function () { S(document, "keydown", this._onKeyDown, this) }, _removeHooks: function () { k(document, "keydown", this._onKeyDown, this) }, _onKeyDown: function (t) { if (!(t.altKey || t.ctrlKey || t.metaKey)) { var e, i, n = t.keyCode, o = this._map; if (n in this._panKeys) o._panAnim && o._panAnim._inProgress || (i = this._panKeys[n], t.shiftKey && (i = m(i).multiplyBy(3)), o.options.maxBounds && (i = o._limitOffset(m(i), o.options.maxBounds)), o.options.worldCopyJump ? (e = o.wrapLatLng(o.unproject(o.project(o.getCenter()).add(i))), o.panTo(e)) : o.panBy(i)); else if (n in this._zoomKeys) o.setZoom(o.getZoom() + (t.shiftKey ? 3 : 1) * this._zoomKeys[n]); else { if (27 !== n || !o._popup || !o._popup.options.closeOnEscapeKey) return; o.closePopup() } Re(t) } } })), Et = (A.addInitHook("addHandler", "keyboard", St), A.mergeOptions({ scrollWheelZoom: !0, wheelDebounceTime: 40, wheelPxPerZoomLevel: 60 }), n.extend({ addHooks: function () { S(this._map._container, "wheel", this._onWheelScroll, this), this._delta = 0 }, removeHooks: function () { k(this._map._container, "wheel", this._onWheelScroll, this) }, _onWheelScroll: function (t) { var e = He(t), i = this._map.options.wheelDebounceTime, e = (this._delta += e, this._lastMousePos = this._map.mouseEventToContainerPoint(t), this._startTime || (this._startTime = +new Date), Math.max(i - (+new Date - this._startTime), 0)); clearTimeout(this._timer), this._timer = setTimeout(a(this._performZoom, this), e), Re(t) }, _performZoom: function () { var t = this._map, e = t.getZoom(), i = this._map.options.zoomSnap || 0, n = (t._stop(), this._delta / (4 * this._map.options.wheelPxPerZoomLevel)), n = 4 * Math.log(2 / (1 + Math.exp(-Math.abs(n)))) / Math.LN2, i = i ? Math.ceil(n / i) * i : n, n = t._limitZoom(e + (0 < this._delta ? i : -i)) - e; this._delta = 0, this._startTime = null, n && ("center" === t.options.scrollWheelZoom ? t.setZoom(e + n) : t.setZoomAround(this._lastMousePos, e + n)) } })), kt = (A.addInitHook("addHandler", "scrollWheelZoom", Et), A.mergeOptions({ tapHold: b.touchNative && b.safari && b.mobile, tapTolerance: 15 }), n.extend({ addHooks: function () { S(this._map._container, "touchstart", this._onDown, this) }, removeHooks: function () { k(this._map._container, "touchstart", this._onDown, this) }, _onDown: function (t) { var e; clearTimeout(this._holdTimeout), 1 === t.touches.length && (e = t.touches[0], this._startPos = this._newPos = new p(e.clientX, e.clientY), this._holdTimeout = setTimeout(a(function () { this._cancel(), this._isTapValid() && (S(document, "touchend", O), S(document, "touchend touchcancel", this._cancelClickPrevent), this._simulateEvent("contextmenu", e)) }, this), 600), S(document, "touchend touchcancel contextmenu", this._cancel, this), S(document, "touchmove", this._onMove, this)) }, _cancelClickPrevent: function t() { k(document, "touchend", O), k(document, "touchend touchcancel", t) }, _cancel: function () { clearTimeout(this._holdTimeout), k(document, "touchend touchcancel contextmenu", this._cancel, this), k(document, "touchmove", this._onMove, this) }, _onMove: function (t) { t = t.touches[0]; this._newPos = new p(t.clientX, t.clientY) }, _isTapValid: function () { return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance }, _simulateEvent: function (t, e) { t = new MouseEvent(t, { bubbles: !0, cancelable: !0, view: window, screenX: e.screenX, screenY: e.screenY, clientX: e.clientX, clientY: e.clientY }); t._simulated = !0, e.target.dispatchEvent(t) } })), Ot = (A.addInitHook("addHandler", "tapHold", kt), A.mergeOptions({ touchZoom: b.touch, bounceAtZoomLimits: !0 }), n.extend({ addHooks: function () { M(this._map._container, "leaflet-touch-zoom"), S(this._map._container, "touchstart", this._onTouchStart, this) }, removeHooks: function () { z(this._map._container, "leaflet-touch-zoom"), k(this._map._container, "touchstart", this._onTouchStart, this) }, _onTouchStart: function (t) { var e, i, n = this._map; !t.touches || 2 !== t.touches.length || n._animatingZoom || this._zooming || (e = n.mouseEventToContainerPoint(t.touches[0]), i = n.mouseEventToContainerPoint(t.touches[1]), this._centerPoint = n.getSize()._divideBy(2), this._startLatLng = n.containerPointToLatLng(this._centerPoint), "center" !== n.options.touchZoom && (this._pinchStartLatLng = n.containerPointToLatLng(e.add(i)._divideBy(2))), this._startDist = e.distanceTo(i), this._startZoom = n.getZoom(), this._moved = !1, this._zooming = !0, n._stop(), S(document, "touchmove", this._onTouchMove, this), S(document, "touchend touchcancel", this._onTouchEnd, this), O(t)) }, _onTouchMove: function (t) { if (t.touches && 2 === t.touches.length && this._zooming) { var e = this._map, i = e.mouseEventToContainerPoint(t.touches[0]), n = e.mouseEventToContainerPoint(t.touches[1]), o = i.distanceTo(n) / this._startDist; if (this._zoom = e.getScaleZoom(o, this._startZoom), !e.options.bounceAtZoomLimits && (this._zoom < e.getMinZoom() && o < 1 || this._zoom > e.getMaxZoom() && 1 < o) && (this._zoom = e._limitZoom(this._zoom)), "center" === e.options.touchZoom) { if (this._center = this._startLatLng, 1 == o) return } else { i = i._add(n)._divideBy(2)._subtract(this._centerPoint); if (1 == o && 0 === i.x && 0 === i.y) return; this._center = e.unproject(e.project(this._pinchStartLatLng, this._zoom).subtract(i), this._zoom) } this._moved || (e._moveStart(!0, !1), this._moved = !0), r(this._animRequest); n = a(e._move, e, this._center, this._zoom, { pinch: !0, round: !1 }, void 0); this._animRequest = x(n, this, !0), O(t) } }, _onTouchEnd: function () { this._moved && this._zooming ? (this._zooming = !1, r(this._animRequest), k(document, "touchmove", this._onTouchMove, this), k(document, "touchend touchcancel", this._onTouchEnd, this), this._map.options.zoomAnimation ? this._map._animateZoom(this._center, this._map._limitZoom(this._zoom), !0, this._map.options.zoomSnap) : this._map._resetView(this._center, this._map._limitZoom(this._zoom))) : this._zooming = !1 } })), Xi = (A.addInitHook("addHandler", "touchZoom", Ot), A.BoxZoom = _t, A.DoubleClickZoom = Ct, A.Drag = Zt, A.Keyboard = St, A.ScrollWheelZoom = Et, A.TapHold = kt, A.TouchZoom = Ot, t.Bounds = f, t.Browser = b, t.CRS = ot, t.Canvas = Fi, t.Circle = vi, t.CircleMarker = gi, t.Class = et, t.Control = B, t.DivIcon = Ri, t.DivOverlay = Ai, t.DomEvent = mt, t.DomUtil = pt, t.Draggable = Xe, t.Evented = it, t.FeatureGroup = ci, t.GeoJSON = wi, t.GridLayer = Ni, t.Handler = n, t.Icon = di, t.ImageOverlay = Ei, t.LatLng = v, t.LatLngBounds = s, t.Layer = o, t.LayerGroup = ui, t.LineUtil = vt, t.Map = A, t.Marker = mi, t.Mixin = ft, t.Path = fi, t.Point = p, t.PolyUtil = gt, t.Polygon = xi, t.Polyline = yi, t.Popup = Bi, t.PosAnimation = Fe, t.Projection = wt, t.Rectangle = Yi, t.Renderer = Wi, t.SVG = Gi, t.SVGOverlay = Oi, t.TileLayer = Di, t.Tooltip = Ii, t.Transformation = at, t.Util = tt, t.VideoOverlay = ki, t.bind = a, t.bounds = _, t.canvas = Ui, t.circle = function (t, e, i) { return new vi(t, e, i) }, t.circleMarker = function (t, e) { return new gi(t, e) }, t.control = Ue, t.divIcon = function (t) { return new Ri(t) }, t.extend = l, t.featureGroup = function (t, e) { return new ci(t, e) }, t.geoJSON = Si, t.geoJson = Mt, t.gridLayer = function (t) { return new Ni(t) }, t.icon = function (t) { return new di(t) }, t.imageOverlay = function (t, e, i) { return new Ei(t, e, i) }, t.latLng = w, t.latLngBounds = g, t.layerGroup = function (t, e) { return new ui(t, e) }, t.map = function (t, e) { return new A(t, e) }, t.marker = function (t, e) { return new mi(t, e) }, t.point = m, t.polygon = function (t, e) { return new xi(t, e) }, t.polyline = function (t, e) { return new yi(t, e) }, t.popup = function (t, e) { return new Bi(t, e) }, t.rectangle = function (t, e) { return new Yi(t, e) }, t.setOptions = c, t.stamp = h, t.svg = Ki, t.svgOverlay = function (t, e, i) { return new Oi(t, e, i) }, t.tileLayer = ji, t.tooltip = function (t, e) { return new Ii(t, e) }, t.transformation = ht, t.version = "1.9.4", t.videoOverlay = function (t, e, i) { return new ki(t, e, i) }, window.L); t.noConflict = function () { return window.L = Xi, this }, window.L = t });
//# sourceMappingURL=leaflet.js.map;// Leaflet.TileLayer.Fallback
// (c) 2015-2018 Boris Seang
// License Apache-2.0
!function (i, e) { "function" == typeof define && define.amd ? define(["leaflet"], e) : e("object" == typeof module && module.exports ? require("leaflet") : i.L) }(this, function (i) { i.TileLayer.Fallback = i.TileLayer.extend({ options: { minNativeZoom: 0 }, initialize: function (e, r) { i.TileLayer.prototype.initialize.call(this, e, r) }, createTile: function (e, r) { var t = i.TileLayer.prototype.createTile.call(this, e, r); return t._originalCoords = e, t._originalSrc = t.src, t }, _createCurrentCoords: function (i) { var e = this._wrapCoords(i); return e.fallback = !0, e }, _originalTileOnError: i.TileLayer.prototype._tileOnError, _tileOnError: function (i, e, r) { var t, l, o, a = this, n = e._originalCoords, c = e._currentCoords = e._currentCoords || a._createCurrentCoords(n), s = e._fallbackZoom = void 0 === e._fallbackZoom ? n.z - 1 : e._fallbackZoom - 1, f = e._fallbackScale = 2 * (e._fallbackScale || 1), p = a.getTileSize(), u = e.style; if (s < a.options.minNativeZoom) return this._originalTileOnError(i, e, r); c.z = s, c.x = Math.floor(c.x / 2), c.y = Math.floor(c.y / 2), t = a.getTileUrl(c), u.width = p.x * f + "px", u.height = p.y * f + "px", l = (n.y - c.y * f) * p.y, u.marginTop = -l + "px", o = (n.x - c.x * f) * p.x, u.marginLeft = -o + "px", u.clip = "rect(" + l + "px " + (o + p.x) + "px " + (l + p.y) + "px " + o + "px)", a.fire("tilefallback", { tile: e, url: e._originalSrc, urlMissing: e.src, urlFallback: t }), e.src = t }, getTileUrl: function (e) { var r = e.z = e.fallback ? e.z : this._getZoomForUrl(), t = { r: i.Browser.retina ? "@2x" : "", s: this._getSubdomain(e), x: e.x, y: e.y, z: r }; if (this._map && !this._map.options.crs.infinite) { var l = this._globalTileRange.max.y - e.y; this.options.tms && (t.y = l), t["-y"] = l } return i.Util.template(this._url, i.extend(t, this.options)) } }), i.tileLayer.fallback = function (e, r) { return new i.TileLayer.Fallback(e, r) } });; 'use strict';

(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(['leaflet'], factory);
  } else if (typeof exports === 'object') {
    module.exports = factory(require('leaflet'));
  } else {
    factory(window.L);
  }
}(this, function (L) {
  L.Canvas.include({
    _updateImg(layer) {
      const { img } = layer.options;
      const p = layer._point.round();
      p.x += img.offset.x; p.y += img.offset.y;
      if (img.rotate) {
        this._ctx.save();
        this._ctx.translate(p.x, p.y);
        this._ctx.rotate(img.rotate * Math.PI / 180);
        this._ctx.drawImage(img.el, -img.size[0] / 2, -img.size[1] / 2, img.size[0], img.size[1]);
        this._ctx.restore();
      } else {
        this._ctx.drawImage(img.el, p.x - img.size[0] / 2, p.y - img.size[1] / 2, img.size[0], img.size[1]);
      }
    },
  });

  const angleCrds = (map, prevLatlng, latlng) => {
    if (!latlng || !prevLatlng) return 0;
    const pxStart = map.project(prevLatlng);
    const pxEnd = map.project(latlng);
    return Math.atan2(pxStart.y - pxEnd.y, pxStart.x - pxEnd.x) / Math.PI * 180 - 90;
  };

  const defaultImgOptions = {
    rotate: 0,
    size: [40, 40],
    offset: { x: 0, y: 0 },
  };

  const CanvasMarker = L.CircleMarker.extend({
    _updatePath() {
      if (!this.options.img || !this.options.img.url) return;
      if (!this.options.img.el) {
        this.options.img = { ...defaultImgOptions, ...this.options.img };
        this.options.img.rotate += angleCrds(this._map, this.options.prevLatlng, this._latlng);
        const img = document.createElement('img');
        img.src = this.options.img.url;
        this.options.img.el = img;
        img.onload = () => {
          this.redraw();
        };
        img.onerror = () => {
          this.options.img = null;
        };
      } else {
        this._renderer._updateImg(this);
      }
    },
  });

  L.canvasMarker = function (...opt) {
    try {
      const i = opt.findIndex(o => typeof o === 'object' && o.img);
      if (i + 1) {
        if (!opt[i].radius && opt[i].img && opt[i].img.size) opt[i].radius = Math.ceil(Math.max(...opt[i].img.size) / 2);
        if (opt[i].pane) delete opt[i].pane;
      }
    } catch (e) { }
    return new CanvasMarker(...opt);
  };
}));; !function (t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define("leaflet-arc", [], e) : "object" == typeof exports ? exports["leaflet-arc"] = e() : t["leaflet-arc"] = e() }(this, function () { return function (t) { function e(o) { if (r[o]) return r[o].exports; var s = r[o] = { exports: {}, id: o, loaded: !1 }; return t[o].call(s.exports, s, s.exports, e), s.loaded = !0, s.exports } var r = {}; return e.m = t, e.c = r, e.p = "", e(0) }([function (t, e, r) { "use strict"; function o(t) { return t && t.__esModule ? t : { "default": t } } function s(t, e) { if (!t.geometries[0] || !t.geometries[0].coords[0]) return []; var r = function () { var r = e.lng - t.geometries[0].coords[0][0] - 360; return { v: t.geometries.map(function (t) { return r += 360, t.coords.map(function (t) { return L.latLng([t[1], t[0] + r]) }) }).reduce(function (t, e) { return t.concat(e) }) } }(); return "object" === ("undefined" == typeof r ? "undefined" : n(r)) ? r.v : void 0 } var i = Object.assign || function (t) { for (var e = 1; e < arguments.length; e++) { var r = arguments[e]; for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (t[o] = r[o]) } return t }, n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol ? "symbol" : typeof t }, a = r(2), h = o(a), p = function (t) { return { x: t.lng, y: t.lat } }; if (!L) throw new Error("Leaflet is not defined"); L.Polyline.Arc = function (t, e, r) { var o = L.latLng(t), n = L.latLng(e), a = i({ vertices: 10, offset: 10 }, r), u = new h["default"].GreatCircle(p(o), p(n)), c = u.Arc(a.vertices, { offset: a.offset }), f = s(c, o); return L.polyline(f, a) } }, function (t, e) { "use strict"; var r = Math.PI / 180, o = 180 / Math.PI, s = function (t, e) { this.lon = t, this.lat = e, this.x = r * t, this.y = r * e }; s.prototype.view = function () { return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4) }, s.prototype.antipode = function () { var t = -1 * this.lat, e = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1; return new s(e, t) }; var i = function () { this.coords = [], this.length = 0 }; i.prototype.move_to = function (t) { this.length++, this.coords.push(t) }; var n = function (t) { this.properties = t || {}, this.geometries = [] }; n.prototype.json = function () { if (this.geometries.length <= 0) return { geometry: { type: "LineString", coordinates: null }, type: "Feature", properties: this.properties }; if (1 == this.geometries.length) return { geometry: { type: "LineString", coordinates: this.geometries[0].coords }, type: "Feature", properties: this.properties }; for (var t = [], e = 0; e < this.geometries.length; e++)t.push(this.geometries[e].coords); return { geometry: { type: "MultiLineString", coordinates: t }, type: "Feature", properties: this.properties } }, n.prototype.wkt = function () { for (var t = "", e = "LINESTRING(", r = function (t) { e += t[0] + " " + t[1] + "," }, o = 0; o < this.geometries.length; o++) { if (0 === this.geometries[o].coords.length) return "LINESTRING(empty)"; var s = this.geometries[o].coords; s.forEach(r), t += e.substring(0, e.length - 1) + ")" } return t }; var a = function (t, e, r) { if (!t || void 0 === t.x || void 0 === t.y) throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties"); if (!e || void 0 === e.x || void 0 === e.y) throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties"); this.start = new s(t.x, t.y), this.end = new s(e.x, e.y), this.properties = r || {}; var o = this.start.x - this.end.x, i = this.start.y - this.end.y, n = Math.pow(Math.sin(i / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(o / 2), 2); if (this.g = 2 * Math.asin(Math.sqrt(n)), this.g == Math.PI) throw new Error("it appears " + t.view() + " and " + e.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite"); if (isNaN(this.g)) throw new Error("could not calculate great circle between " + t + " and " + e) }; if (a.prototype.interpolate = function (t) { var e = Math.sin((1 - t) * this.g) / Math.sin(this.g), r = Math.sin(t * this.g) / Math.sin(this.g), s = e * Math.cos(this.start.y) * Math.cos(this.start.x) + r * Math.cos(this.end.y) * Math.cos(this.end.x), i = e * Math.cos(this.start.y) * Math.sin(this.start.x) + r * Math.cos(this.end.y) * Math.sin(this.end.x), n = e * Math.sin(this.start.y) + r * Math.sin(this.end.y), a = o * Math.atan2(n, Math.sqrt(Math.pow(s, 2) + Math.pow(i, 2))), h = o * Math.atan2(i, s); return [h, a] }, a.prototype.Arc = function (t, e) { var r = []; if (!t || t <= 2) r.push([this.start.lon, this.start.lat]), r.push([this.end.lon, this.end.lat]); else for (var o = 1 / (t - 1), s = 0; s < t; ++s) { var a = o * s, h = this.interpolate(a); r.push(h) } for (var p = !1, u = 0, c = e && e.offset ? e.offset : 10, f = 180 - c, l = -180 + c, d = 360 - c, y = 1; y < r.length; ++y) { var g = r[y - 1][0], v = r[y][0], M = Math.abs(v - g); M > d && (v > f && g < l || g > f && v < l) ? p = !0 : M > u && (u = M) } var m = []; if (p && u < c) { var w = []; m.push(w); for (var x = 0; x < r.length; ++x) { var b = parseFloat(r[x][0]); if (x > 0 && Math.abs(b - r[x - 1][0]) > d) { var L = parseFloat(r[x - 1][0]), S = parseFloat(r[x - 1][1]), j = parseFloat(r[x][0]), E = parseFloat(r[x][1]); if (L > -180 && L < l && 180 == j && x + 1 < r.length && r[x - 1][0] > -180 && r[x - 1][0] < l) { w.push([-180, r[x][1]]), x++, w.push([r[x][0], r[x][1]]); continue } if (L > f && L < 180 && j == -180 && x + 1 < r.length && r[x - 1][0] > f && r[x - 1][0] < 180) { w.push([180, r[x][1]]), x++, w.push([r[x][0], r[x][1]]); continue } if (L < l && j > f) { var F = L; L = j, j = F; var C = S; S = E, E = C } if (L > f && j < l && (j += 360), L <= 180 && j >= 180 && L < j) { var G = (180 - L) / (j - L), I = G * E + (1 - G) * S; w.push([r[x - 1][0] > f ? 180 : -180, I]), w = [], w.push([r[x - 1][0] > f ? -180 : 180, I]), m.push(w) } else w = [], m.push(w); w.push([b, r[x][1]]) } else w.push([r[x][0], r[x][1]]) } } else { var N = []; m.push(N); for (var A = 0; A < r.length; ++A)N.push([r[A][0], r[A][1]]) } for (var P = new n(this.properties), _ = 0; _ < m.length; ++_) { var O = new i; P.geometries.push(O); for (var q = m[_], R = 0; R < q.length; ++R)O.move_to(q[R]) } return P }, "undefined" != typeof t && "undefined" != typeof t.exports) t.exports.Coord = s, t.exports.Arc = n, t.exports.GreatCircle = a; else { var h = {}; h.Coord = s, h.Arc = n, h.GreatCircle = a } }, function (t, e, r) { "use strict"; t.exports = r(1) }]) });;/*! Hammer.JS - v2.0.8 - 2016-04-23
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
!function (a, b, c, d) { "use strict"; function e(a, b, c) { return setTimeout(j(a, c), b) } function f(a, b, c) { return Array.isArray(a) ? (g(a, c[b], c), !0) : !1 } function g(a, b, c) { var e; if (a) if (a.forEach) a.forEach(b, c); else if (a.length !== d) for (e = 0; e < a.length;)b.call(c, a[e], e, a), e++; else for (e in a) a.hasOwnProperty(e) && b.call(c, a[e], e, a) } function h(b, c, d) { var e = "DEPRECATED METHOD: " + c + "\n" + d + " AT \n"; return function () { var c = new Error("get-stack-trace"), d = c && c.stack ? c.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace", f = a.console && (a.console.warn || a.console.log); return f && f.call(a.console, e, d), b.apply(this, arguments) } } function i(a, b, c) { var d, e = b.prototype; d = a.prototype = Object.create(e), d.constructor = a, d._super = e, c && la(d, c) } function j(a, b) { return function () { return a.apply(b, arguments) } } function k(a, b) { return typeof a == oa ? a.apply(b ? b[0] || d : d, b) : a } function l(a, b) { return a === d ? b : a } function m(a, b, c) { g(q(b), function (b) { a.addEventListener(b, c, !1) }) } function n(a, b, c) { g(q(b), function (b) { a.removeEventListener(b, c, !1) }) } function o(a, b) { for (; a;) { if (a == b) return !0; a = a.parentNode } return !1 } function p(a, b) { return a.indexOf(b) > -1 } function q(a) { return a.trim().split(/\s+/g) } function r(a, b, c) { if (a.indexOf && !c) return a.indexOf(b); for (var d = 0; d < a.length;) { if (c && a[d][c] == b || !c && a[d] === b) return d; d++ } return -1 } function s(a) { return Array.prototype.slice.call(a, 0) } function t(a, b, c) { for (var d = [], e = [], f = 0; f < a.length;) { var g = b ? a[f][b] : a[f]; r(e, g) < 0 && d.push(a[f]), e[f] = g, f++ } return c && (d = b ? d.sort(function (a, c) { return a[b] > c[b] }) : d.sort()), d } function u(a, b) { for (var c, e, f = b[0].toUpperCase() + b.slice(1), g = 0; g < ma.length;) { if (c = ma[g], e = c ? c + f : b, e in a) return e; g++ } return d } function v() { return ua++ } function w(b) { var c = b.ownerDocument || b; return c.defaultView || c.parentWindow || a } function x(a, b) { var c = this; this.manager = a, this.callback = b, this.element = a.element, this.target = a.options.inputTarget, this.domHandler = function (b) { k(a.options.enable, [a]) && c.handler(b) }, this.init() } function y(a) { var b, c = a.options.inputClass; return new (b = c ? c : xa ? M : ya ? P : wa ? R : L)(a, z) } function z(a, b, c) { var d = c.pointers.length, e = c.changedPointers.length, f = b & Ea && d - e === 0, g = b & (Ga | Ha) && d - e === 0; c.isFirst = !!f, c.isFinal = !!g, f && (a.session = {}), c.eventType = b, A(a, c), a.emit("hammer.input", c), a.recognize(c), a.session.prevInput = c } function A(a, b) { var c = a.session, d = b.pointers, e = d.length; c.firstInput || (c.firstInput = D(b)), e > 1 && !c.firstMultiple ? c.firstMultiple = D(b) : 1 === e && (c.firstMultiple = !1); var f = c.firstInput, g = c.firstMultiple, h = g ? g.center : f.center, i = b.center = E(d); b.timeStamp = ra(), b.deltaTime = b.timeStamp - f.timeStamp, b.angle = I(h, i), b.distance = H(h, i), B(c, b), b.offsetDirection = G(b.deltaX, b.deltaY); var j = F(b.deltaTime, b.deltaX, b.deltaY); b.overallVelocityX = j.x, b.overallVelocityY = j.y, b.overallVelocity = qa(j.x) > qa(j.y) ? j.x : j.y, b.scale = g ? K(g.pointers, d) : 1, b.rotation = g ? J(g.pointers, d) : 0, b.maxPointers = c.prevInput ? b.pointers.length > c.prevInput.maxPointers ? b.pointers.length : c.prevInput.maxPointers : b.pointers.length, C(c, b); var k = a.element; o(b.srcEvent.target, k) && (k = b.srcEvent.target), b.target = k } function B(a, b) { var c = b.center, d = a.offsetDelta || {}, e = a.prevDelta || {}, f = a.prevInput || {}; b.eventType !== Ea && f.eventType !== Ga || (e = a.prevDelta = { x: f.deltaX || 0, y: f.deltaY || 0 }, d = a.offsetDelta = { x: c.x, y: c.y }), b.deltaX = e.x + (c.x - d.x), b.deltaY = e.y + (c.y - d.y) } function C(a, b) { var c, e, f, g, h = a.lastInterval || b, i = b.timeStamp - h.timeStamp; if (b.eventType != Ha && (i > Da || h.velocity === d)) { var j = b.deltaX - h.deltaX, k = b.deltaY - h.deltaY, l = F(i, j, k); e = l.x, f = l.y, c = qa(l.x) > qa(l.y) ? l.x : l.y, g = G(j, k), a.lastInterval = b } else c = h.velocity, e = h.velocityX, f = h.velocityY, g = h.direction; b.velocity = c, b.velocityX = e, b.velocityY = f, b.direction = g } function D(a) { for (var b = [], c = 0; c < a.pointers.length;)b[c] = { clientX: pa(a.pointers[c].clientX), clientY: pa(a.pointers[c].clientY) }, c++; return { timeStamp: ra(), pointers: b, center: E(b), deltaX: a.deltaX, deltaY: a.deltaY } } function E(a) { var b = a.length; if (1 === b) return { x: pa(a[0].clientX), y: pa(a[0].clientY) }; for (var c = 0, d = 0, e = 0; b > e;)c += a[e].clientX, d += a[e].clientY, e++; return { x: pa(c / b), y: pa(d / b) } } function F(a, b, c) { return { x: b / a || 0, y: c / a || 0 } } function G(a, b) { return a === b ? Ia : qa(a) >= qa(b) ? 0 > a ? Ja : Ka : 0 > b ? La : Ma } function H(a, b, c) { c || (c = Qa); var d = b[c[0]] - a[c[0]], e = b[c[1]] - a[c[1]]; return Math.sqrt(d * d + e * e) } function I(a, b, c) { c || (c = Qa); var d = b[c[0]] - a[c[0]], e = b[c[1]] - a[c[1]]; return 180 * Math.atan2(e, d) / Math.PI } function J(a, b) { return I(b[1], b[0], Ra) + I(a[1], a[0], Ra) } function K(a, b) { return H(b[0], b[1], Ra) / H(a[0], a[1], Ra) } function L() { this.evEl = Ta, this.evWin = Ua, this.pressed = !1, x.apply(this, arguments) } function M() { this.evEl = Xa, this.evWin = Ya, x.apply(this, arguments), this.store = this.manager.session.pointerEvents = [] } function N() { this.evTarget = $a, this.evWin = _a, this.started = !1, x.apply(this, arguments) } function O(a, b) { var c = s(a.touches), d = s(a.changedTouches); return b & (Ga | Ha) && (c = t(c.concat(d), "identifier", !0)), [c, d] } function P() { this.evTarget = bb, this.targetIds = {}, x.apply(this, arguments) } function Q(a, b) { var c = s(a.touches), d = this.targetIds; if (b & (Ea | Fa) && 1 === c.length) return d[c[0].identifier] = !0, [c, c]; var e, f, g = s(a.changedTouches), h = [], i = this.target; if (f = c.filter(function (a) { return o(a.target, i) }), b === Ea) for (e = 0; e < f.length;)d[f[e].identifier] = !0, e++; for (e = 0; e < g.length;)d[g[e].identifier] && h.push(g[e]), b & (Ga | Ha) && delete d[g[e].identifier], e++; return h.length ? [t(f.concat(h), "identifier", !0), h] : void 0 } function R() { x.apply(this, arguments); var a = j(this.handler, this); this.touch = new P(this.manager, a), this.mouse = new L(this.manager, a), this.primaryTouch = null, this.lastTouches = [] } function S(a, b) { a & Ea ? (this.primaryTouch = b.changedPointers[0].identifier, T.call(this, b)) : a & (Ga | Ha) && T.call(this, b) } function T(a) { var b = a.changedPointers[0]; if (b.identifier === this.primaryTouch) { var c = { x: b.clientX, y: b.clientY }; this.lastTouches.push(c); var d = this.lastTouches, e = function () { var a = d.indexOf(c); a > -1 && d.splice(a, 1) }; setTimeout(e, cb) } } function U(a) { for (var b = a.srcEvent.clientX, c = a.srcEvent.clientY, d = 0; d < this.lastTouches.length; d++) { var e = this.lastTouches[d], f = Math.abs(b - e.x), g = Math.abs(c - e.y); if (db >= f && db >= g) return !0 } return !1 } function V(a, b) { this.manager = a, this.set(b) } function W(a) { if (p(a, jb)) return jb; var b = p(a, kb), c = p(a, lb); return b && c ? jb : b || c ? b ? kb : lb : p(a, ib) ? ib : hb } function X() { if (!fb) return !1; var b = {}, c = a.CSS && a.CSS.supports; return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function (d) { b[d] = c ? a.CSS.supports("touch-action", d) : !0 }), b } function Y(a) { this.options = la({}, this.defaults, a || {}), this.id = v(), this.manager = null, this.options.enable = l(this.options.enable, !0), this.state = nb, this.simultaneous = {}, this.requireFail = [] } function Z(a) { return a & sb ? "cancel" : a & qb ? "end" : a & pb ? "move" : a & ob ? "start" : "" } function $(a) { return a == Ma ? "down" : a == La ? "up" : a == Ja ? "left" : a == Ka ? "right" : "" } function _(a, b) { var c = b.manager; return c ? c.get(a) : a } function aa() { Y.apply(this, arguments) } function ba() { aa.apply(this, arguments), this.pX = null, this.pY = null } function ca() { aa.apply(this, arguments) } function da() { Y.apply(this, arguments), this._timer = null, this._input = null } function ea() { aa.apply(this, arguments) } function fa() { aa.apply(this, arguments) } function ga() { Y.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0 } function ha(a, b) { return b = b || {}, b.recognizers = l(b.recognizers, ha.defaults.preset), new ia(a, b) } function ia(a, b) { this.options = la({}, ha.defaults, b || {}), this.options.inputTarget = this.options.inputTarget || a, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = a, this.input = y(this), this.touchAction = new V(this, this.options.touchAction), ja(this, !0), g(this.options.recognizers, function (a) { var b = this.add(new a[0](a[1])); a[2] && b.recognizeWith(a[2]), a[3] && b.requireFailure(a[3]) }, this) } function ja(a, b) { var c = a.element; if (c.style) { var d; g(a.options.cssProps, function (e, f) { d = u(c.style, f), b ? (a.oldCssProps[d] = c.style[d], c.style[d] = e) : c.style[d] = a.oldCssProps[d] || "" }), b || (a.oldCssProps = {}) } } function ka(a, c) { var d = b.createEvent("Event"); d.initEvent(a, !0, !0), d.gesture = c, c.target.dispatchEvent(d) } var la, ma = ["", "webkit", "Moz", "MS", "ms", "o"], na = b.createElement("div"), oa = "function", pa = Math.round, qa = Math.abs, ra = Date.now; la = "function" != typeof Object.assign ? function (a) { if (a === d || null === a) throw new TypeError("Cannot convert undefined or null to object"); for (var b = Object(a), c = 1; c < arguments.length; c++) { var e = arguments[c]; if (e !== d && null !== e) for (var f in e) e.hasOwnProperty(f) && (b[f] = e[f]) } return b } : Object.assign; var sa = h(function (a, b, c) { for (var e = Object.keys(b), f = 0; f < e.length;)(!c || c && a[e[f]] === d) && (a[e[f]] = b[e[f]]), f++; return a }, "extend", "Use `assign`."), ta = h(function (a, b) { return sa(a, b, !0) }, "merge", "Use `assign`."), ua = 1, va = /mobile|tablet|ip(ad|hone|od)|android/i, wa = "ontouchstart" in a, xa = u(a, "PointerEvent") !== d, ya = wa && va.test(navigator.userAgent), za = "touch", Aa = "pen", Ba = "mouse", Ca = "kinect", Da = 25, Ea = 1, Fa = 2, Ga = 4, Ha = 8, Ia = 1, Ja = 2, Ka = 4, La = 8, Ma = 16, Na = Ja | Ka, Oa = La | Ma, Pa = Na | Oa, Qa = ["x", "y"], Ra = ["clientX", "clientY"]; x.prototype = { handler: function () { }, init: function () { this.evEl && m(this.element, this.evEl, this.domHandler), this.evTarget && m(this.target, this.evTarget, this.domHandler), this.evWin && m(w(this.element), this.evWin, this.domHandler) }, destroy: function () { this.evEl && n(this.element, this.evEl, this.domHandler), this.evTarget && n(this.target, this.evTarget, this.domHandler), this.evWin && n(w(this.element), this.evWin, this.domHandler) } }; var Sa = { mousedown: Ea, mousemove: Fa, mouseup: Ga }, Ta = "mousedown", Ua = "mousemove mouseup"; i(L, x, { handler: function (a) { var b = Sa[a.type]; b & Ea && 0 === a.button && (this.pressed = !0), b & Fa && 1 !== a.which && (b = Ga), this.pressed && (b & Ga && (this.pressed = !1), this.callback(this.manager, b, { pointers: [a], changedPointers: [a], pointerType: Ba, srcEvent: a })) } }); var Va = { pointerdown: Ea, pointermove: Fa, pointerup: Ga, pointercancel: Ha, pointerout: Ha }, Wa = { 2: za, 3: Aa, 4: Ba, 5: Ca }, Xa = "pointerdown", Ya = "pointermove pointerup pointercancel"; a.MSPointerEvent && !a.PointerEvent && (Xa = "MSPointerDown", Ya = "MSPointerMove MSPointerUp MSPointerCancel"), i(M, x, { handler: function (a) { var b = this.store, c = !1, d = a.type.toLowerCase().replace("ms", ""), e = Va[d], f = Wa[a.pointerType] || a.pointerType, g = f == za, h = r(b, a.pointerId, "pointerId"); e & Ea && (0 === a.button || g) ? 0 > h && (b.push(a), h = b.length - 1) : e & (Ga | Ha) && (c = !0), 0 > h || (b[h] = a, this.callback(this.manager, e, { pointers: b, changedPointers: [a], pointerType: f, srcEvent: a }), c && b.splice(h, 1)) } }); var Za = { touchstart: Ea, touchmove: Fa, touchend: Ga, touchcancel: Ha }, $a = "touchstart", _a = "touchstart touchmove touchend touchcancel"; i(N, x, { handler: function (a) { var b = Za[a.type]; if (b === Ea && (this.started = !0), this.started) { var c = O.call(this, a, b); b & (Ga | Ha) && c[0].length - c[1].length === 0 && (this.started = !1), this.callback(this.manager, b, { pointers: c[0], changedPointers: c[1], pointerType: za, srcEvent: a }) } } }); var ab = { touchstart: Ea, touchmove: Fa, touchend: Ga, touchcancel: Ha }, bb = "touchstart touchmove touchend touchcancel"; i(P, x, { handler: function (a) { var b = ab[a.type], c = Q.call(this, a, b); c && this.callback(this.manager, b, { pointers: c[0], changedPointers: c[1], pointerType: za, srcEvent: a }) } }); var cb = 2500, db = 25; i(R, x, { handler: function (a, b, c) { var d = c.pointerType == za, e = c.pointerType == Ba; if (!(e && c.sourceCapabilities && c.sourceCapabilities.firesTouchEvents)) { if (d) S.call(this, b, c); else if (e && U.call(this, c)) return; this.callback(a, b, c) } }, destroy: function () { this.touch.destroy(), this.mouse.destroy() } }); var eb = u(na.style, "touchAction"), fb = eb !== d, gb = "compute", hb = "auto", ib = "manipulation", jb = "none", kb = "pan-x", lb = "pan-y", mb = X(); V.prototype = { set: function (a) { a == gb && (a = this.compute()), fb && this.manager.element.style && mb[a] && (this.manager.element.style[eb] = a), this.actions = a.toLowerCase().trim() }, update: function () { this.set(this.manager.options.touchAction) }, compute: function () { var a = []; return g(this.manager.recognizers, function (b) { k(b.options.enable, [b]) && (a = a.concat(b.getTouchAction())) }), W(a.join(" ")) }, preventDefaults: function (a) { var b = a.srcEvent, c = a.offsetDirection; if (this.manager.session.prevented) return void b.preventDefault(); var d = this.actions, e = p(d, jb) && !mb[jb], f = p(d, lb) && !mb[lb], g = p(d, kb) && !mb[kb]; if (e) { var h = 1 === a.pointers.length, i = a.distance < 2, j = a.deltaTime < 250; if (h && i && j) return } return g && f ? void 0 : e || f && c & Na || g && c & Oa ? this.preventSrc(b) : void 0 }, preventSrc: function (a) { this.manager.session.prevented = !0, a.preventDefault() } }; var nb = 1, ob = 2, pb = 4, qb = 8, rb = qb, sb = 16, tb = 32; Y.prototype = { defaults: {}, set: function (a) { return la(this.options, a), this.manager && this.manager.touchAction.update(), this }, recognizeWith: function (a) { if (f(a, "recognizeWith", this)) return this; var b = this.simultaneous; return a = _(a, this), b[a.id] || (b[a.id] = a, a.recognizeWith(this)), this }, dropRecognizeWith: function (a) { return f(a, "dropRecognizeWith", this) ? this : (a = _(a, this), delete this.simultaneous[a.id], this) }, requireFailure: function (a) { if (f(a, "requireFailure", this)) return this; var b = this.requireFail; return a = _(a, this), -1 === r(b, a) && (b.push(a), a.requireFailure(this)), this }, dropRequireFailure: function (a) { if (f(a, "dropRequireFailure", this)) return this; a = _(a, this); var b = r(this.requireFail, a); return b > -1 && this.requireFail.splice(b, 1), this }, hasRequireFailures: function () { return this.requireFail.length > 0 }, canRecognizeWith: function (a) { return !!this.simultaneous[a.id] }, emit: function (a) { function b(b) { c.manager.emit(b, a) } var c = this, d = this.state; qb > d && b(c.options.event + Z(d)), b(c.options.event), a.additionalEvent && b(a.additionalEvent), d >= qb && b(c.options.event + Z(d)) }, tryEmit: function (a) { return this.canEmit() ? this.emit(a) : void (this.state = tb) }, canEmit: function () { for (var a = 0; a < this.requireFail.length;) { if (!(this.requireFail[a].state & (tb | nb))) return !1; a++ } return !0 }, recognize: function (a) { var b = la({}, a); return k(this.options.enable, [this, b]) ? (this.state & (rb | sb | tb) && (this.state = nb), this.state = this.process(b), void (this.state & (ob | pb | qb | sb) && this.tryEmit(b))) : (this.reset(), void (this.state = tb)) }, process: function (a) { }, getTouchAction: function () { }, reset: function () { } }, i(aa, Y, { defaults: { pointers: 1 }, attrTest: function (a) { var b = this.options.pointers; return 0 === b || a.pointers.length === b }, process: function (a) { var b = this.state, c = a.eventType, d = b & (ob | pb), e = this.attrTest(a); return d && (c & Ha || !e) ? b | sb : d || e ? c & Ga ? b | qb : b & ob ? b | pb : ob : tb } }), i(ba, aa, { defaults: { event: "pan", threshold: 10, pointers: 1, direction: Pa }, getTouchAction: function () { var a = this.options.direction, b = []; return a & Na && b.push(lb), a & Oa && b.push(kb), b }, directionTest: function (a) { var b = this.options, c = !0, d = a.distance, e = a.direction, f = a.deltaX, g = a.deltaY; return e & b.direction || (b.direction & Na ? (e = 0 === f ? Ia : 0 > f ? Ja : Ka, c = f != this.pX, d = Math.abs(a.deltaX)) : (e = 0 === g ? Ia : 0 > g ? La : Ma, c = g != this.pY, d = Math.abs(a.deltaY))), a.direction = e, c && d > b.threshold && e & b.direction }, attrTest: function (a) { return aa.prototype.attrTest.call(this, a) && (this.state & ob || !(this.state & ob) && this.directionTest(a)) }, emit: function (a) { this.pX = a.deltaX, this.pY = a.deltaY; var b = $(a.direction); b && (a.additionalEvent = this.options.event + b), this._super.emit.call(this, a) } }), i(ca, aa, { defaults: { event: "pinch", threshold: 0, pointers: 2 }, getTouchAction: function () { return [jb] }, attrTest: function (a) { return this._super.attrTest.call(this, a) && (Math.abs(a.scale - 1) > this.options.threshold || this.state & ob) }, emit: function (a) { if (1 !== a.scale) { var b = a.scale < 1 ? "in" : "out"; a.additionalEvent = this.options.event + b } this._super.emit.call(this, a) } }), i(da, Y, { defaults: { event: "press", pointers: 1, time: 251, threshold: 9 }, getTouchAction: function () { return [hb] }, process: function (a) { var b = this.options, c = a.pointers.length === b.pointers, d = a.distance < b.threshold, f = a.deltaTime > b.time; if (this._input = a, !d || !c || a.eventType & (Ga | Ha) && !f) this.reset(); else if (a.eventType & Ea) this.reset(), this._timer = e(function () { this.state = rb, this.tryEmit() }, b.time, this); else if (a.eventType & Ga) return rb; return tb }, reset: function () { clearTimeout(this._timer) }, emit: function (a) { this.state === rb && (a && a.eventType & Ga ? this.manager.emit(this.options.event + "up", a) : (this._input.timeStamp = ra(), this.manager.emit(this.options.event, this._input))) } }), i(ea, aa, { defaults: { event: "rotate", threshold: 0, pointers: 2 }, getTouchAction: function () { return [jb] }, attrTest: function (a) { return this._super.attrTest.call(this, a) && (Math.abs(a.rotation) > this.options.threshold || this.state & ob) } }), i(fa, aa, { defaults: { event: "swipe", threshold: 10, velocity: .3, direction: Na | Oa, pointers: 1 }, getTouchAction: function () { return ba.prototype.getTouchAction.call(this) }, attrTest: function (a) { var b, c = this.options.direction; return c & (Na | Oa) ? b = a.overallVelocity : c & Na ? b = a.overallVelocityX : c & Oa && (b = a.overallVelocityY), this._super.attrTest.call(this, a) && c & a.offsetDirection && a.distance > this.options.threshold && a.maxPointers == this.options.pointers && qa(b) > this.options.velocity && a.eventType & Ga }, emit: function (a) { var b = $(a.offsetDirection); b && this.manager.emit(this.options.event + b, a), this.manager.emit(this.options.event, a) } }), i(ga, Y, { defaults: { event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 9, posThreshold: 10 }, getTouchAction: function () { return [ib] }, process: function (a) { var b = this.options, c = a.pointers.length === b.pointers, d = a.distance < b.threshold, f = a.deltaTime < b.time; if (this.reset(), a.eventType & Ea && 0 === this.count) return this.failTimeout(); if (d && f && c) { if (a.eventType != Ga) return this.failTimeout(); var g = this.pTime ? a.timeStamp - this.pTime < b.interval : !0, h = !this.pCenter || H(this.pCenter, a.center) < b.posThreshold; this.pTime = a.timeStamp, this.pCenter = a.center, h && g ? this.count += 1 : this.count = 1, this._input = a; var i = this.count % b.taps; if (0 === i) return this.hasRequireFailures() ? (this._timer = e(function () { this.state = rb, this.tryEmit() }, b.interval, this), ob) : rb } return tb }, failTimeout: function () { return this._timer = e(function () { this.state = tb }, this.options.interval, this), tb }, reset: function () { clearTimeout(this._timer) }, emit: function () { this.state == rb && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input)) } }), ha.VERSION = "2.0.8", ha.defaults = { domEvents: !1, touchAction: gb, enable: !0, inputTarget: null, inputClass: null, preset: [[ea, { enable: !1 }], [ca, { enable: !1 }, ["rotate"]], [fa, { direction: Na }], [ba, { direction: Na }, ["swipe"]], [ga], [ga, { event: "doubletap", taps: 2 }, ["tap"]], [da]], cssProps: { userSelect: "none", touchSelect: "none", touchCallout: "none", contentZooming: "none", userDrag: "none", tapHighlightColor: "rgba(0,0,0,0)" } }; var ub = 1, vb = 2; ia.prototype = { set: function (a) { return la(this.options, a), a.touchAction && this.touchAction.update(), a.inputTarget && (this.input.destroy(), this.input.target = a.inputTarget, this.input.init()), this }, stop: function (a) { this.session.stopped = a ? vb : ub }, recognize: function (a) { var b = this.session; if (!b.stopped) { this.touchAction.preventDefaults(a); var c, d = this.recognizers, e = b.curRecognizer; (!e || e && e.state & rb) && (e = b.curRecognizer = null); for (var f = 0; f < d.length;)c = d[f], b.stopped === vb || e && c != e && !c.canRecognizeWith(e) ? c.reset() : c.recognize(a), !e && c.state & (ob | pb | qb) && (e = b.curRecognizer = c), f++ } }, get: function (a) { if (a instanceof Y) return a; for (var b = this.recognizers, c = 0; c < b.length; c++)if (b[c].options.event == a) return b[c]; return null }, add: function (a) { if (f(a, "add", this)) return this; var b = this.get(a.options.event); return b && this.remove(b), this.recognizers.push(a), a.manager = this, this.touchAction.update(), a }, remove: function (a) { if (f(a, "remove", this)) return this; if (a = this.get(a)) { var b = this.recognizers, c = r(b, a); -1 !== c && (b.splice(c, 1), this.touchAction.update()) } return this }, on: function (a, b) { if (a !== d && b !== d) { var c = this.handlers; return g(q(a), function (a) { c[a] = c[a] || [], c[a].push(b) }), this } }, off: function (a, b) { if (a !== d) { var c = this.handlers; return g(q(a), function (a) { b ? c[a] && c[a].splice(r(c[a], b), 1) : delete c[a] }), this } }, emit: function (a, b) { this.options.domEvents && ka(a, b); var c = this.handlers[a] && this.handlers[a].slice(); if (c && c.length) { b.type = a, b.preventDefault = function () { b.srcEvent.preventDefault() }; for (var d = 0; d < c.length;)c[d](b), d++ } }, destroy: function () { this.element && ja(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null } }, la(ha, { INPUT_START: Ea, INPUT_MOVE: Fa, INPUT_END: Ga, INPUT_CANCEL: Ha, STATE_POSSIBLE: nb, STATE_BEGAN: ob, STATE_CHANGED: pb, STATE_ENDED: qb, STATE_RECOGNIZED: rb, STATE_CANCELLED: sb, STATE_FAILED: tb, DIRECTION_NONE: Ia, DIRECTION_LEFT: Ja, DIRECTION_RIGHT: Ka, DIRECTION_UP: La, DIRECTION_DOWN: Ma, DIRECTION_HORIZONTAL: Na, DIRECTION_VERTICAL: Oa, DIRECTION_ALL: Pa, Manager: ia, Input: x, TouchAction: V, TouchInput: P, MouseInput: L, PointerEventInput: M, TouchMouseInput: R, SingleTouchInput: N, Recognizer: Y, AttrRecognizer: aa, Tap: ga, Pan: ba, Swipe: fa, Pinch: ca, Rotate: ea, Press: da, on: m, off: n, each: g, merge: ta, extend: sa, assign: la, inherit: i, bindFn: j, prefixed: u }); var wb = "undefined" != typeof a ? a : "undefined" != typeof self ? self : {}; wb.Hammer = ha, "function" == typeof define && define.amd ? define(function () { return ha }) : "undefined" != typeof module && module.exports ? module.exports = ha : a[c] = ha }(window, document, "Hammer");
//# sourceMappingURL=hammer.min.js.map;// TinyColor v1.4.1
// https://github.com/bgrins/TinyColor
// 2016-07-07, Brian Grinstead, MIT License
!function (a) { function b(a, d) { if (a = a ? a : "", d = d || {}, a instanceof b) return a; if (!(this instanceof b)) return new b(a, d); var e = c(a); this._originalInput = a, this._r = e.r, this._g = e.g, this._b = e.b, this._a = e.a, this._roundA = P(100 * this._a) / 100, this._format = d.format || e.format, this._gradientType = d.gradientType, this._r < 1 && (this._r = P(this._r)), this._g < 1 && (this._g = P(this._g)), this._b < 1 && (this._b = P(this._b)), this._ok = e.ok, this._tc_id = O++ } function c(a) { var b = { r: 0, g: 0, b: 0 }, c = 1, e = null, g = null, i = null, j = !1, k = !1; return "string" == typeof a && (a = K(a)), "object" == typeof a && (J(a.r) && J(a.g) && J(a.b) ? (b = d(a.r, a.g, a.b), j = !0, k = "%" === String(a.r).substr(-1) ? "prgb" : "rgb") : J(a.h) && J(a.s) && J(a.v) ? (e = G(a.s), g = G(a.v), b = h(a.h, e, g), j = !0, k = "hsv") : J(a.h) && J(a.s) && J(a.l) && (e = G(a.s), i = G(a.l), b = f(a.h, e, i), j = !0, k = "hsl"), a.hasOwnProperty("a") && (c = a.a)), c = z(c), { ok: j, format: a.format || k, r: Q(255, R(b.r, 0)), g: Q(255, R(b.g, 0)), b: Q(255, R(b.b, 0)), a: c } } function d(a, b, c) { return { r: 255 * A(a, 255), g: 255 * A(b, 255), b: 255 * A(c, 255) } } function e(a, b, c) { a = A(a, 255), b = A(b, 255), c = A(c, 255); var d, e, f = R(a, b, c), g = Q(a, b, c), h = (f + g) / 2; if (f == g) d = e = 0; else { var i = f - g; switch (e = h > .5 ? i / (2 - f - g) : i / (f + g), f) { case a: d = (b - c) / i + (c > b ? 6 : 0); break; case b: d = (c - a) / i + 2; break; case c: d = (a - b) / i + 4 }d /= 6 } return { h: d, s: e, l: h } } function f(a, b, c) { function d(a, b, c) { return 0 > c && (c += 1), c > 1 && (c -= 1), 1 / 6 > c ? a + 6 * (b - a) * c : .5 > c ? b : 2 / 3 > c ? a + 6 * (b - a) * (2 / 3 - c) : a } var e, f, g; if (a = A(a, 360), b = A(b, 100), c = A(c, 100), 0 === b) e = f = g = c; else { var h = .5 > c ? c * (1 + b) : c + b - c * b, i = 2 * c - h; e = d(i, h, a + 1 / 3), f = d(i, h, a), g = d(i, h, a - 1 / 3) } return { r: 255 * e, g: 255 * f, b: 255 * g } } function g(a, b, c) { a = A(a, 255), b = A(b, 255), c = A(c, 255); var d, e, f = R(a, b, c), g = Q(a, b, c), h = f, i = f - g; if (e = 0 === f ? 0 : i / f, f == g) d = 0; else { switch (f) { case a: d = (b - c) / i + (c > b ? 6 : 0); break; case b: d = (c - a) / i + 2; break; case c: d = (a - b) / i + 4 }d /= 6 } return { h: d, s: e, v: h } } function h(b, c, d) { b = 6 * A(b, 360), c = A(c, 100), d = A(d, 100); var e = a.floor(b), f = b - e, g = d * (1 - c), h = d * (1 - f * c), i = d * (1 - (1 - f) * c), j = e % 6, k = [d, h, g, g, i, d][j], l = [i, d, d, h, g, g][j], m = [g, g, i, d, d, h][j]; return { r: 255 * k, g: 255 * l, b: 255 * m } } function i(a, b, c, d) { var e = [F(P(a).toString(16)), F(P(b).toString(16)), F(P(c).toString(16))]; return d && e[0].charAt(0) == e[0].charAt(1) && e[1].charAt(0) == e[1].charAt(1) && e[2].charAt(0) == e[2].charAt(1) ? e[0].charAt(0) + e[1].charAt(0) + e[2].charAt(0) : e.join("") } function j(a, b, c, d, e) { var f = [F(P(a).toString(16)), F(P(b).toString(16)), F(P(c).toString(16)), F(H(d))]; return e && f[0].charAt(0) == f[0].charAt(1) && f[1].charAt(0) == f[1].charAt(1) && f[2].charAt(0) == f[2].charAt(1) && f[3].charAt(0) == f[3].charAt(1) ? f[0].charAt(0) + f[1].charAt(0) + f[2].charAt(0) + f[3].charAt(0) : f.join("") } function k(a, b, c, d) { var e = [F(H(d)), F(P(a).toString(16)), F(P(b).toString(16)), F(P(c).toString(16))]; return e.join("") } function l(a, c) { c = 0 === c ? 0 : c || 10; var d = b(a).toHsl(); return d.s -= c / 100, d.s = B(d.s), b(d) } function m(a, c) { c = 0 === c ? 0 : c || 10; var d = b(a).toHsl(); return d.s += c / 100, d.s = B(d.s), b(d) } function n(a) { return b(a).desaturate(100) } function o(a, c) { c = 0 === c ? 0 : c || 10; var d = b(a).toHsl(); return d.l += c / 100, d.l = B(d.l), b(d) } function p(a, c) { c = 0 === c ? 0 : c || 10; var d = b(a).toRgb(); return d.r = R(0, Q(255, d.r - P(255 * -(c / 100)))), d.g = R(0, Q(255, d.g - P(255 * -(c / 100)))), d.b = R(0, Q(255, d.b - P(255 * -(c / 100)))), b(d) } function q(a, c) { c = 0 === c ? 0 : c || 10; var d = b(a).toHsl(); return d.l -= c / 100, d.l = B(d.l), b(d) } function r(a, c) { var d = b(a).toHsl(), e = (d.h + c) % 360; return d.h = 0 > e ? 360 + e : e, b(d) } function s(a) { var c = b(a).toHsl(); return c.h = (c.h + 180) % 360, b(c) } function t(a) { var c = b(a).toHsl(), d = c.h; return [b(a), b({ h: (d + 120) % 360, s: c.s, l: c.l }), b({ h: (d + 240) % 360, s: c.s, l: c.l })] } function u(a) { var c = b(a).toHsl(), d = c.h; return [b(a), b({ h: (d + 90) % 360, s: c.s, l: c.l }), b({ h: (d + 180) % 360, s: c.s, l: c.l }), b({ h: (d + 270) % 360, s: c.s, l: c.l })] } function v(a) { var c = b(a).toHsl(), d = c.h; return [b(a), b({ h: (d + 72) % 360, s: c.s, l: c.l }), b({ h: (d + 216) % 360, s: c.s, l: c.l })] } function w(a, c, d) { c = c || 6, d = d || 30; var e = b(a).toHsl(), f = 360 / d, g = [b(a)]; for (e.h = (e.h - (f * c >> 1) + 720) % 360; --c;)e.h = (e.h + f) % 360, g.push(b(e)); return g } function x(a, c) { c = c || 6; for (var d = b(a).toHsv(), e = d.h, f = d.s, g = d.v, h = [], i = 1 / c; c--;)h.push(b({ h: e, s: f, v: g })), g = (g + i) % 1; return h } function y(a) { var b = {}; for (var c in a) a.hasOwnProperty(c) && (b[a[c]] = c); return b } function z(a) { return a = parseFloat(a), (isNaN(a) || 0 > a || a > 1) && (a = 1), a } function A(b, c) { D(b) && (b = "100%"); var d = E(b); return b = Q(c, R(0, parseFloat(b))), d && (b = parseInt(b * c, 10) / 100), a.abs(b - c) < 1e-6 ? 1 : b % c / parseFloat(c) } function B(a) { return Q(1, R(0, a)) } function C(a) { return parseInt(a, 16) } function D(a) { return "string" == typeof a && -1 != a.indexOf(".") && 1 === parseFloat(a) } function E(a) { return "string" == typeof a && -1 != a.indexOf("%") } function F(a) { return 1 == a.length ? "0" + a : "" + a } function G(a) { return 1 >= a && (a = 100 * a + "%"), a } function H(b) { return a.round(255 * parseFloat(b)).toString(16) } function I(a) { return C(a) / 255 } function J(a) { return !!V.CSS_UNIT.exec(a) } function K(a) { a = a.replace(M, "").replace(N, "").toLowerCase(); var b = !1; if (T[a]) a = T[a], b = !0; else if ("transparent" == a) return { r: 0, g: 0, b: 0, a: 0, format: "name" }; var c; return (c = V.rgb.exec(a)) ? { r: c[1], g: c[2], b: c[3] } : (c = V.rgba.exec(a)) ? { r: c[1], g: c[2], b: c[3], a: c[4] } : (c = V.hsl.exec(a)) ? { h: c[1], s: c[2], l: c[3] } : (c = V.hsla.exec(a)) ? { h: c[1], s: c[2], l: c[3], a: c[4] } : (c = V.hsv.exec(a)) ? { h: c[1], s: c[2], v: c[3] } : (c = V.hsva.exec(a)) ? { h: c[1], s: c[2], v: c[3], a: c[4] } : (c = V.hex8.exec(a)) ? { r: C(c[1]), g: C(c[2]), b: C(c[3]), a: I(c[4]), format: b ? "name" : "hex8" } : (c = V.hex6.exec(a)) ? { r: C(c[1]), g: C(c[2]), b: C(c[3]), format: b ? "name" : "hex" } : (c = V.hex4.exec(a)) ? { r: C(c[1] + "" + c[1]), g: C(c[2] + "" + c[2]), b: C(c[3] + "" + c[3]), a: I(c[4] + "" + c[4]), format: b ? "name" : "hex8" } : (c = V.hex3.exec(a)) ? { r: C(c[1] + "" + c[1]), g: C(c[2] + "" + c[2]), b: C(c[3] + "" + c[3]), format: b ? "name" : "hex" } : !1 } function L(a) { var b, c; return a = a || { level: "AA", size: "small" }, b = (a.level || "AA").toUpperCase(), c = (a.size || "small").toLowerCase(), "AA" !== b && "AAA" !== b && (b = "AA"), "small" !== c && "large" !== c && (c = "small"), { level: b, size: c } } var M = /^\s+/, N = /\s+$/, O = 0, P = a.round, Q = a.min, R = a.max, S = a.random; b.prototype = { isDark: function () { return this.getBrightness() < 128 }, isLight: function () { return !this.isDark() }, isValid: function () { return this._ok }, getOriginalInput: function () { return this._originalInput }, getFormat: function () { return this._format }, getAlpha: function () { return this._a }, getBrightness: function () { var a = this.toRgb(); return (299 * a.r + 587 * a.g + 114 * a.b) / 1e3 }, getLuminance: function () { var b, c, d, e, f, g, h = this.toRgb(); return b = h.r / 255, c = h.g / 255, d = h.b / 255, e = .03928 >= b ? b / 12.92 : a.pow((b + .055) / 1.055, 2.4), f = .03928 >= c ? c / 12.92 : a.pow((c + .055) / 1.055, 2.4), g = .03928 >= d ? d / 12.92 : a.pow((d + .055) / 1.055, 2.4), .2126 * e + .7152 * f + .0722 * g }, setAlpha: function (a) { return this._a = z(a), this._roundA = P(100 * this._a) / 100, this }, toHsv: function () { var a = g(this._r, this._g, this._b); return { h: 360 * a.h, s: a.s, v: a.v, a: this._a } }, toHsvString: function () { var a = g(this._r, this._g, this._b), b = P(360 * a.h), c = P(100 * a.s), d = P(100 * a.v); return 1 == this._a ? "hsv(" + b + ", " + c + "%, " + d + "%)" : "hsva(" + b + ", " + c + "%, " + d + "%, " + this._roundA + ")" }, toHsl: function () { var a = e(this._r, this._g, this._b); return { h: 360 * a.h, s: a.s, l: a.l, a: this._a } }, toHslString: function () { var a = e(this._r, this._g, this._b), b = P(360 * a.h), c = P(100 * a.s), d = P(100 * a.l); return 1 == this._a ? "hsl(" + b + ", " + c + "%, " + d + "%)" : "hsla(" + b + ", " + c + "%, " + d + "%, " + this._roundA + ")" }, toHex: function (a) { return i(this._r, this._g, this._b, a) }, toHexString: function (a) { return "#" + this.toHex(a) }, toHex8: function (a) { return j(this._r, this._g, this._b, this._a, a) }, toHex8String: function (a) { return "#" + this.toHex8(a) }, toRgb: function () { return { r: P(this._r), g: P(this._g), b: P(this._b), a: this._a } }, toRgbString: function () { return 1 == this._a ? "rgb(" + P(this._r) + ", " + P(this._g) + ", " + P(this._b) + ")" : "rgba(" + P(this._r) + ", " + P(this._g) + ", " + P(this._b) + ", " + this._roundA + ")" }, toPercentageRgb: function () { return { r: P(100 * A(this._r, 255)) + "%", g: P(100 * A(this._g, 255)) + "%", b: P(100 * A(this._b, 255)) + "%", a: this._a } }, toPercentageRgbString: function () { return 1 == this._a ? "rgb(" + P(100 * A(this._r, 255)) + "%, " + P(100 * A(this._g, 255)) + "%, " + P(100 * A(this._b, 255)) + "%)" : "rgba(" + P(100 * A(this._r, 255)) + "%, " + P(100 * A(this._g, 255)) + "%, " + P(100 * A(this._b, 255)) + "%, " + this._roundA + ")" }, toName: function () { return 0 === this._a ? "transparent" : this._a < 1 ? !1 : U[i(this._r, this._g, this._b, !0)] || !1 }, toFilter: function (a) { var c = "#" + k(this._r, this._g, this._b, this._a), d = c, e = this._gradientType ? "GradientType = 1, " : ""; if (a) { var f = b(a); d = "#" + k(f._r, f._g, f._b, f._a) } return "progid:DXImageTransform.Microsoft.gradient(" + e + "startColorstr=" + c + ",endColorstr=" + d + ")" }, toString: function (a) { var b = !!a; a = a || this._format; var c = !1, d = this._a < 1 && this._a >= 0, e = !b && d && ("hex" === a || "hex6" === a || "hex3" === a || "hex4" === a || "hex8" === a || "name" === a); return e ? "name" === a && 0 === this._a ? this.toName() : this.toRgbString() : ("rgb" === a && (c = this.toRgbString()), "prgb" === a && (c = this.toPercentageRgbString()), ("hex" === a || "hex6" === a) && (c = this.toHexString()), "hex3" === a && (c = this.toHexString(!0)), "hex4" === a && (c = this.toHex8String(!0)), "hex8" === a && (c = this.toHex8String()), "name" === a && (c = this.toName()), "hsl" === a && (c = this.toHslString()), "hsv" === a && (c = this.toHsvString()), c || this.toHexString()) }, clone: function () { return b(this.toString()) }, _applyModification: function (a, b) { var c = a.apply(null, [this].concat([].slice.call(b))); return this._r = c._r, this._g = c._g, this._b = c._b, this.setAlpha(c._a), this }, lighten: function () { return this._applyModification(o, arguments) }, brighten: function () { return this._applyModification(p, arguments) }, darken: function () { return this._applyModification(q, arguments) }, desaturate: function () { return this._applyModification(l, arguments) }, saturate: function () { return this._applyModification(m, arguments) }, greyscale: function () { return this._applyModification(n, arguments) }, spin: function () { return this._applyModification(r, arguments) }, _applyCombination: function (a, b) { return a.apply(null, [this].concat([].slice.call(b))) }, analogous: function () { return this._applyCombination(w, arguments) }, complement: function () { return this._applyCombination(s, arguments) }, monochromatic: function () { return this._applyCombination(x, arguments) }, splitcomplement: function () { return this._applyCombination(v, arguments) }, triad: function () { return this._applyCombination(t, arguments) }, tetrad: function () { return this._applyCombination(u, arguments) } }, b.fromRatio = function (a, c) { if ("object" == typeof a) { var d = {}; for (var e in a) a.hasOwnProperty(e) && (d[e] = "a" === e ? a[e] : G(a[e])); a = d } return b(a, c) }, b.equals = function (a, c) { return a && c ? b(a).toRgbString() == b(c).toRgbString() : !1 }, b.random = function () { return b.fromRatio({ r: S(), g: S(), b: S() }) }, b.mix = function (a, c, d) { d = 0 === d ? 0 : d || 50; var e = b(a).toRgb(), f = b(c).toRgb(), g = d / 100, h = { r: (f.r - e.r) * g + e.r, g: (f.g - e.g) * g + e.g, b: (f.b - e.b) * g + e.b, a: (f.a - e.a) * g + e.a }; return b(h) }, b.readability = function (c, d) { var e = b(c), f = b(d); return (a.max(e.getLuminance(), f.getLuminance()) + .05) / (a.min(e.getLuminance(), f.getLuminance()) + .05) }, b.isReadable = function (a, c, d) { var e, f, g = b.readability(a, c); switch (f = !1, e = L(d), e.level + e.size) { case "AAsmall": case "AAAlarge": f = g >= 4.5; break; case "AAlarge": f = g >= 3; break; case "AAAsmall": f = g >= 7 }return f }, b.mostReadable = function (a, c, d) { var e, f, g, h, i = null, j = 0; d = d || {}, f = d.includeFallbackColors, g = d.level, h = d.size; for (var k = 0; k < c.length; k++)e = b.readability(a, c[k]), e > j && (j = e, i = b(c[k])); return b.isReadable(a, i, { level: g, size: h }) || !f ? i : (d.includeFallbackColors = !1, b.mostReadable(a, ["#fff", "#000"], d)) }; var T = b.names = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "0ff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "00f", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", burntsienna: "ea7e5d", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "0ff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "f0f", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "663399", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" }, U = b.hexNames = y(T), V = function () { var a = "[-\\+]?\\d+%?", b = "[-\\+]?\\d*\\.\\d+%?", c = "(?:" + b + ")|(?:" + a + ")", d = "[\\s|\\(]+(" + c + ")[,|\\s]+(" + c + ")[,|\\s]+(" + c + ")\\s*\\)?", e = "[\\s|\\(]+(" + c + ")[,|\\s]+(" + c + ")[,|\\s]+(" + c + ")[,|\\s]+(" + c + ")\\s*\\)?"; return { CSS_UNIT: new RegExp(c), rgb: new RegExp("rgb" + d), rgba: new RegExp("rgba" + e), hsl: new RegExp("hsl" + d), hsla: new RegExp("hsla" + e), hsv: new RegExp("hsv" + d), hsva: new RegExp("hsva" + e), hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/ } }(); "undefined" != typeof module && module.exports ? module.exports = b : "function" == typeof define && define.amd ? define(function () { return b }) : window.tinycolor = b }(Math);;// https://github.com/otto-dev/coordinate-parser
// Copyright (C) 2016 WEPROG GmbH

// Was based on Require so I just concatenated the whole thing

// Validator Class
var Validator;

Validator = class Validator {
  isValid(coordinates) {
    var isValid, validationError;
    isValid = true;
    try {
      this.validate(coordinates);
      return isValid;
    } catch (error) {
      validationError = error;
      isValid = false;
      return isValid;
    }
  }

  validate(coordinates) {
    this.checkContainsNoLetters(coordinates);
    this.checkValidOrientation(coordinates);
    return this.checkNumbers(coordinates);
  }

  checkContainsNoLetters(coordinates) {
    var containsLetters;
    containsLetters = /(?![neswd])[a-z]/i.test(coordinates);
    if (containsLetters) {
      throw new Error('Coordinate contains invalid alphanumeric characters.');
    }
  }

  checkValidOrientation(coordinates) {
    var validOrientation;
    validOrientation = /^[^nsew]*[ns]?[^nsew]*[ew]?[^nsew]*$/i.test(coordinates);
    if (!validOrientation) {
      throw new Error('Invalid cardinal direction.');
    }
  }

  checkNumbers(coordinates) {
    var coordinateNumbers;
    coordinateNumbers = coordinates.match(/-?\d+(\.\d+)?/g);
    this.checkAnyCoordinateNumbers(coordinateNumbers);
    this.checkEvenCoordinateNumbers(coordinateNumbers);
    return this.checkMaximumCoordinateNumbers(coordinateNumbers);
  }

  checkAnyCoordinateNumbers(coordinateNumbers) {
    if (coordinateNumbers.length === 0) {
      throw new Error('Could not find any coordinate number');
    }
  }

  checkEvenCoordinateNumbers(coordinateNumbers) {
    var isUnevenNumbers;
    isUnevenNumbers = coordinateNumbers.length % 2;
    if (isUnevenNumbers) {
      throw new Error('Uneven count of latitude/longitude numbers');
    }
  }

  checkMaximumCoordinateNumbers(coordinateNumbers) {
    if (coordinateNumbers.length > 6) {
      throw new Error('Too many coordinate numbers');
    }
  }

};

// CoordinateNumber class

var CoordinateNumber = class CoordinateNumber {
  constructor(coordinateNumbers) {
    coordinateNumbers = this.normalizeCoordinateNumbers(coordinateNumbers);
    this.sign = this.normalizedSignOf(coordinateNumbers[0]);
    [this.degrees, this.minutes, this.seconds, this.milliseconds] = coordinateNumbers.map(Math.abs);
  }

  normalizeCoordinateNumbers(coordinateNumbers) {
    var currentNumber, i, j, len, normalizedNumbers;
    normalizedNumbers = [0, 0, 0, 0];
    for (i = j = 0, len = coordinateNumbers.length; j < len; i = ++j) {
      currentNumber = coordinateNumbers[i];
      normalizedNumbers[i] = parseFloat(currentNumber);
    }
    return normalizedNumbers;
  }

  normalizedSignOf(number) {
    if (number >= 0) {
      return 1;
    } else {
      return -1;
    }
  }

  detectSpecialFormats() {
    if (this.degreesCanBeSpecial()) {
      if (this.degreesCanBeMilliseconds()) {
        return this.degreesAsMilliseconds();
      } else if (this.degreesCanBeDegreesMinutesAndSeconds()) {
        return this.degreesAsDegreesMinutesAndSeconds();
      } else if (this.degreesCanBeDegreesAndMinutes()) {
        return this.degreesAsDegreesAndMinutes();
      }
    }
  }

  degreesCanBeSpecial() {
    var canBe;
    canBe = false;
    if (!this.minutes && !this.seconds) {
      canBe = true;
    }
    return canBe;
  }

  degreesCanBeMilliseconds() {
    var canBe;
    if (this.degrees > 909090) {
      canBe = true;
    } else {
      canBe = false;
    }
    return canBe;
  }

  degreesAsMilliseconds() {
    this.milliseconds = this.degrees;
    return this.degrees = 0;
  }

  degreesCanBeDegreesMinutesAndSeconds() {
    var canBe;
    if (this.degrees > 9090) {
      canBe = true;
    } else {
      canBe = false;
    }
    return canBe;
  }

  degreesAsDegreesMinutesAndSeconds() {
    var newDegrees;
    newDegrees = Math.floor(this.degrees / 10000);
    this.minutes = Math.floor((this.degrees - newDegrees * 10000) / 100);
    this.seconds = Math.floor(this.degrees - newDegrees * 10000 - this.minutes * 100);
    return this.degrees = newDegrees;
  }

  degreesCanBeDegreesAndMinutes() {
    var canBe;
    if (this.degrees > 360) {
      canBe = true;
    } else {
      canBe = false;
    }
    return canBe;
  }

  degreesAsDegreesAndMinutes() {
    var newDegrees;
    newDegrees = Math.floor(this.degrees / 100);
    this.minutes = this.degrees - newDegrees * 100;
    return this.degrees = newDegrees;
  }

  toDecimal() {
    var decimalCoordinate;
    decimalCoordinate = this.sign * (this.degrees + this.minutes / 60 + this.seconds / 3600 + this.milliseconds / 3600000);
    return decimalCoordinate;
  }

};

// Coordinates Class

var Coordinates = class Coordinates {
  constructor(coordinateString) {
    this.coordinates = coordinateString;
    this.latitudeNumbers = null;
    this.longitudeNumbers = null;
    this.validate();
    this.parse();
  }

  validate() {
    var validator;
    validator = new Validator();
    return validator.validate(this.coordinates);
  }

  parse() {
    this.groupCoordinateNumbers();
    this.latitude = this.extractLatitude();
    return this.longitude = this.extractLongitude();
  }

  groupCoordinateNumbers() {
    var coordinateNumbers, numberCountEachCoordinate;
    coordinateNumbers = this.extractCoordinateNumbers(this.coordinates);
    numberCountEachCoordinate = coordinateNumbers.length / 2;
    this.latitudeNumbers = coordinateNumbers.slice(0, numberCountEachCoordinate);
    return this.longitudeNumbers = coordinateNumbers.slice((0 - numberCountEachCoordinate));
  }

  extractCoordinateNumbers(coordinates) {
    return coordinates.match(/-?\d+(\.\d+)?/g);
  }

  extractLatitude() {
    var latitude;
    latitude = this.coordinateNumbersToDecimal(this.latitudeNumbers);
    if (this.latitudeIsNegative()) {
      latitude = latitude * -1;
    }
    return latitude;
  }

  extractLongitude() {
    var longitude;
    longitude = this.coordinateNumbersToDecimal(this.longitudeNumbers);
    if (this.longitudeIsNegative()) {
      longitude = longitude * -1;
    }
    return longitude;
  }

  coordinateNumbersToDecimal(coordinateNumbers) {
    var coordinate, decimalCoordinate;
    coordinate = new CoordinateNumber(coordinateNumbers);
    coordinate.detectSpecialFormats();
    decimalCoordinate = coordinate.toDecimal();
    return decimalCoordinate;
  }

  latitudeIsNegative() {
    var isNegative;
    isNegative = this.coordinates.match(/s/i);
    return isNegative;
  }

  longitudeIsNegative() {
    var isNegative;
    isNegative = this.coordinates.match(/w/i);
    return isNegative;
  }

  getLatitude() {
    return this.latitude;
  }

  getLongitude() {
    return this.longitude;
  }

};; window.geofsShaders = window.geofsShaders || {}; geofsShaders["atmosphereCommon.glsl"] = "precision highp float;\nuniform float planetRadius;\nuniform float realPlanetRadius;\nuniform float atmoRadiusSquared;\n#ifdef VOLUMETRIC_CLOUDS\nconst float windSpeedRatio = 0.0002;\nuniform float cloudCover;\nuniform float cloudBase;\nuniform float cloudTop;\nuniform vec3 windVector;\nuniform float cloudThickness;\nuniform float layerPosition;\nuniform float baseThickness;\nuniform float layer;\nuniform float cloudBaseRadius;\nuniform float cloudTopRadius;\n#ifdef REALTIME_CLOUDS\nuniform sampler2D coverageTexture;\n#endif\n#endif\n/*\nfloat cloudThickness = cloudTop - cloudBase;\nfloat layerPosition = 0.1; // set the layer base to 10% of the cloud height\nfloat baseThickness = cloudThickness * layerPosition;\nfloat layer = cloudBase + baseThickness;\nfloat cloudBase_radius = realPlanetRadius + cloudBase;\nfloat cloudTop_radius = cloudBase_radius + cloudThickness;\n*/\nconst float PI = 3.14159265359;\nconst float TWO_PI = 6.28318530718;\nconst float FOUR_PI = 12.5663706144;\n#ifdef QUALITY_7\n#define PRIMARY_STEPS 16\n#define LIGHT_STEPS 4\n#define CLOUDS_MAX_LOD 1\n#define CLOUDS_MARCH_STEP 500.0\n#define CLOUDS_DENS_MARCH_STEP 100.0\n#define MAXIMUM_CLOUDS_STEPS 300\n#define DISTANCE_QUALITY_RATIO 0.00003\n#define CLOUD_SHADOWS\n#elif defined QUALITY_6\n#define PRIMARY_STEPS 12\n#define LIGHT_STEPS 4\n#define CLOUDS_MAX_LOD 1\n#define CLOUDS_MARCH_STEP 500.0\n#define CLOUDS_DENS_MARCH_STEP 100.0\n#define MAXIMUM_CLOUDS_STEPS 200\n#define DISTANCE_QUALITY_RATIO 0.00004\n#define CLOUD_SHADOWS\n#elif defined QUALITY_5\n#define PRIMARY_STEPS 9\n#define LIGHT_STEPS 3\n#define CLOUDS_MAX_LOD 1\n#define CLOUDS_MARCH_STEP 750.0\n#define CLOUDS_DENS_MARCH_STEP 150.0\n#define MAXIMUM_CLOUDS_STEPS 150\n#define DISTANCE_QUALITY_RATIO 0.00005\n#define CLOUD_SHADOWS\n#elif defined QUALITY_4\n#define PRIMARY_STEPS 9\n#define LIGHT_STEPS 3\n#define CLOUDS_MAX_LOD 1\n#define CLOUDS_MARCH_STEP 750.0\n#define CLOUDS_DENS_MARCH_STEP 150.0\n#define MAXIMUM_CLOUDS_STEPS 100\n#define DISTANCE_QUALITY_RATIO 0.00007\n#define CLOUD_SHADOWS\n#elif defined QUALITY_3\n#define PRIMARY_STEPS 6\n#define LIGHT_STEPS 2\n#define CLOUDS_MAX_LOD 0\n#define CLOUDS_MARCH_STEP 750.0\n#define CLOUDS_DENS_MARCH_STEP 150.0\n#define MAXIMUM_CLOUDS_STEPS 75\n#define DISTANCE_QUALITY_RATIO 0.0001\n#define CLOUD_SHADOWS\n#elif defined QUALITY_2\n#define PRIMARY_STEPS 6\n#define LIGHT_STEPS 1\n#define CLOUDS_MAX_LOD 0\n#define CLOUDS_MARCH_STEP 1000.0\n#define CLOUDS_DENS_MARCH_STEP 200.0\n#define MAXIMUM_CLOUDS_STEPS 50\n#define DISTANCE_QUALITY_RATIO 0.0002\n#define CLOUD_SHADOWS\n#elif defined QUALITY_1\n#define PRIMARY_STEPS 3\n#define LIGHT_STEPS 1\n#define CLOUDS_MAX_LOD 0\n#define CLOUDS_MARCH_STEP 1000.0\n#define CLOUDS_DENS_MARCH_STEP 200.0\n#define MAXIMUM_CLOUDS_STEPS 20\n#define DISTANCE_QUALITY_RATIO 0.0004\n#elif defined QUALITY_0\n#define PRIMARY_STEPS 3\n#define LIGHT_STEPS 1\n#define CLOUDS_MAX_LOD 0\n#define CLOUDS_MARCH_STEP 1000.0\n#define CLOUDS_DENS_MARCH_STEP 200.0\n#define MAXIMUM_CLOUDS_STEPS 10\n#define DISTANCE_QUALITY_RATIO 0.0004\n#else //DEFAULT\n#define PRIMARY_STEPS 9\n#define LIGHT_STEPS 2\n#define CLOUDS_MAX_LOD 1\n#define CLOUDS_MARCH_STEP 750.0\n#define CLOUDS_DENS_MARCH_STEP 150.0\n#define MAXIMUM_CLOUDS_STEPS 40\n#define DISTANCE_QUALITY_RATIO 0.0002\n#define CLOUD_SHADOWS\n#endif\n#define CLOUDS_MAX_VIEWING_DISTANCE 250000.0\nvec2 raySphereIntersect(vec3 r0, vec3 rd, float sr) {\nfloat a = dot(rd, rd);\nfloat b = 2.0 * dot(rd, r0);\nfloat c = dot(r0, r0) - (sr * sr);\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) return vec2(-1.0, -1.0);\nfloat squaredD = sqrt(d);\nreturn vec2(\n(-b - squaredD) / (2.0 * a),\n(-b + squaredD) / (2.0 * a)\n);\n}\nfloat reMap (float value, float old_low, float old_high, float new_low, float new_high ) {\nreturn new_low + (value - old_low) * (new_high - new_low) / (old_high - old_low);\n}\nfloat saturate (float value) {\nreturn clamp(value, 0.0, 1.0);\n}\nfloat isotropic() {\nreturn 0.07957747154594767; //1.0 / (4.0 * PI);\n}\nfloat rayleigh(float costh) {\nreturn (3.0 / (16.0 * PI)) * (1.0 + pow(costh, 2.0));\n}\nfloat HenyeyGreenstein(float g, float costh)\n{\nreturn (1.0 - g * g) / (FOUR_PI * pow(1.0 + g * g - 2.0 * g * costh, 3.0 / 2.0));\n}\nfloat Schlick(float k, float costh) {\nreturn (1.0 - k * k) / (FOUR_PI * pow(1.0 - k * costh, 2.0));\n}\nvec3 light_intensity = vec3(100.0);//vec3(100.0); // how bright the light is, affects the brightness of the atmosphere\nvec3 beta_ray = vec3(5.5e-6, 13.0e-6, 22.4e-6);//vec3(5.5e-6, 13.0e-6, 22.4e-6); // the amount rayleigh scattering scatters the colors (for earth: causes the blue atmosphere)\nvec3 beta_mie = vec3(21e-6); // vec3(21e-6);// the amount mie scattering scatters colors\nvec3 beta_ambient = vec3(0.0); // the amount of scattering that always occurs, can help make the back side of the atmosphere a bit brighter\nfloat g = 0.9; // the direction mie scatters the light in (like a cone). closer to -1 means more towards a single direction\nfloat height_ray = 10e3; // how high do you have to go before there is no rayleigh scattering?\nfloat height_mie = 3.2e3; // the same, but for mie\nfloat density_multiplier = 4.0; // 1.0 - how much extra the atmosphere blocks light\n#ifdef ADVANCED_ATMOSPHERE\nvec4 calculate_scattering(\nvec3 start, 			// the start of the ray (the camera position)\nvec3 dir, 				// the direction of the ray (the camera vector)\nfloat maxDistance, 		// the maximum distance the ray can travel (because something is in the way, like an object)\nvec3 light_dir\n) {\nfloat a = dot(dir, dir);\nfloat b = 2.0 * dot(dir, start);\nfloat c = dot(start, start) - atmoRadiusSquared;\nfloat d = (b * b) - 4.0 * a * c;\nif (d < 0.0) return vec4(0.0);\nfloat squaredD = sqrt(d);\nvec2 ray_length = vec2(\nmax((-b - squaredD) / (2.0 * a), 0.0),\nmin((-b + squaredD) / (2.0 * a), maxDistance)\n);\nif (ray_length.x > ray_length.y) return vec4(0.0);\nbool allow_mie = maxDistance > ray_length.y;\nfloat step_size_i = (ray_length.y - ray_length.x) / float(PRIMARY_STEPS);\nfloat ray_pos_i = ray_length.x;\nvec3 total_ray = vec3(0.0); // for rayleigh\nvec3 total_mie = vec3(0.0); // for mie\nvec2 opt_i = vec2(0.0);\nvec2 scale_height = vec2(height_ray, height_mie);\nfloat mu = dot(dir, light_dir);\nfloat mumu = mu * mu;\nfloat gg = g * g;\nfloat phase_ray = 3.0 / (50.2654824574 ) * (1.0 + mumu);\nfloat phase_mie = (allow_mie ? 3.0 : 0.5 ) / (25.1327412287 ) * ((1.0 - gg) * (mumu + 1.0)) / (pow(1.0 + gg - 2.0 * mu * g, 1.5) * (2.0 + gg));\nfor (int i = 0; i < PRIMARY_STEPS; ++i) {\nvec3 pos_i = start + dir * (ray_pos_i + step_size_i);\nfloat height_i = length(pos_i) - planetRadius;\nvec2 density = exp(-height_i / scale_height) * step_size_i;\nopt_i += density;\na = dot(light_dir, light_dir);\nb = 2.0 * dot(light_dir, pos_i);\nc = dot(pos_i, pos_i) - atmoRadiusSquared;\nd = (b * b) - 4.0 * a * c;\nif (d <= 0.0) d = 1.0; // not supposed to be required but this avoids the black singularity line at dusk and dawn\nfloat step_size_l = (-b + sqrt(d)) / (2.0 * a * float(LIGHT_STEPS));\nfloat ray_pos_l = 0.0;\nvec2 opt_l = vec2(0.0);\nfor (int l = 0; l < LIGHT_STEPS; ++l) {\nvec3 pos_l = pos_i + light_dir * (ray_pos_l + step_size_l * 0.5);\nfloat height_l = length(pos_l) - planetRadius;\nopt_l += exp(-height_l / scale_height) * step_size_l;\nray_pos_l += step_size_l;\n}\nvec3 attn = exp(-((beta_mie * (opt_i.y + opt_l.y)) + (beta_ray * (opt_i.x + opt_l.x))));\ntotal_ray += density.x * attn;\ntotal_mie += density.y * attn;\nray_pos_i += step_size_i;\n}\nfloat opacity = length(exp(-((beta_mie * opt_i.y) + (beta_ray * opt_i.x)) * density_multiplier));\nreturn vec4((\nphase_ray * beta_ray * total_ray // rayleigh color\n+ phase_mie * beta_mie * total_mie // mie\n+ opt_i.x * beta_ambient // and ambient\n) * light_intensity, 1.0 - opacity);\n}\n#endif\n#ifdef VOLUMETRIC_CLOUDS\nfloat hash(float p)\n{\np = fract(p * .1031);\np *= p + 33.33;\np *= p + p;\nreturn fract(p);\n}\nfloat noise(in vec3 x) {\nvec3 p = floor(x);\nvec3 f = fract(x);\nf = f*f*(3.0 - 2.0*f);\nfloat n = p.x + p.y*157.0 + 113.0*p.z;\nreturn mix(mix(mix( hash(n+ 0.0), hash(n+ 1.0),f.x),\nmix( hash(n+157.0), hash(n+158.0),f.x),f.y),\nmix(mix( hash(n+113.0), hash(n+114.0),f.x),\nmix(hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n}\nint lastFlooredPosition;\nfloat lastLiveCoverageValue = 0.0;\nfloat cloudDensity(vec3 p, vec3 wind, int lod, inout float heightRatio) {\nfloat finalCoverage = cloudCover;\n#ifdef REALTIME_CLOUDS\nvec3 sphericalNormal = normalize(p);\nvec2 positionSurfaceC = czm_ellipsoidWgs84TextureCoordinates(sphericalNormal);\nfloat sampledValue = texture(coverageTexture, positionSurfaceC).r;\nlastLiveCoverageValue = clamp((sampledValue - 0.3) * 10.0, 0.0, 1.0);\nfinalCoverage *= lastLiveCoverageValue;\n#endif\nif (finalCoverage <= 0.1) return 0.0;\nfloat height = length(p) - realPlanetRadius;\nheightRatio = (height - cloudBase) / cloudThickness;\nfloat positionResolution = 0.002;\np = p * positionResolution + wind;\nfloat shape = noise(p * 0.3);\nfloat shapeHeight = noise(p * 0.05);\nfloat bn = 0.50000 * noise(p); p = p * 2.0;\nif( lod>=1 ) bn += 0.20000 * noise(p); p = p * 2.11;\nfloat cumuloNimbus = saturate((shapeHeight - 0.5) * 2.0);\ncumuloNimbus *= saturate(1.0 - pow(heightRatio - 0.5, 2.0) * 4.0);\nfloat cumulus = saturate(1.0 - pow(heightRatio - 0.25, 2.0) * 25.0) * shapeHeight;\nfloat stratoCumulus = saturate(1.0 - pow(heightRatio - 0.12, 2.0) * 60.0) * (1.0 - shapeHeight);\nfloat dens = saturate(stratoCumulus + cumulus + cumuloNimbus) * 2.0 * finalCoverage;\ndens -= 1.0 - shape;\ndens -= bn;\nreturn clamp(dens, 0.0, 1.0);\n}\n#endif\n";; window.geofsShaders = window.geofsShaders || {}; geofsShaders["atmosphereOnlyFS.glsl"] = "precision highp float;\nuniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\n#ifdef VOLUMETRIC_CLOUDS\nuniform sampler2D volumetricCloudsTexture;\n#endif\nuniform float backgroundFogDensity;\nuniform vec4 backgroundFogColor;\nuniform float volumetricFogDensity;\nuniform float volumetricFogBottom;\nuniform float volumetricFogTop;\nin vec2 v_textureCoordinates;\nvoid main() {\nvec4 color = texture(colorTexture, v_textureCoordinates);\nvec4 rawDepthColor = texture(depthTexture, v_textureCoordinates);\nfloat depth = rawDepthColor.r;// depth packing algo appears to be buggy on mobile so only use the most significant element for now\nvec4 positionEC = czm_windowToEyeCoordinates(gl_FragCoord.xy, depth);\nvec4 worldCoordinate = czm_inverseView * positionEC;\nvec3 vWorldPosition = worldCoordinate.xyz / worldCoordinate.w;\nvec3 posToEye = vWorldPosition - czm_viewerPositionWC;\nvec3 direction = normalize(posToEye);\nvec3 lightDirection = normalize(czm_sunPositionWC);\nfloat distance = length(posToEye);\nfloat elevation;\n#ifdef RETRO\nif (depth >= 0.9) {\ngl_FragColor = color;\nreturn;\n}\n#endif\nif (depth >= 1.0) {\nelevation = length(czm_viewerPositionWC) - (realPlanetRadius);\ndistance = max(distance, 10000000.0); // max out the distance when looking at the sky to avoid clamp/arc artefact\n}\nelse {\nelevation = length(vWorldPosition) - (realPlanetRadius);\n}\nfloat fragFogDensity;\nfragFogDensity = clamp((volumetricFogTop - elevation) / (volumetricFogTop - volumetricFogBottom), 0.0, 1.0) * volumetricFogDensity * depth; // volumetric\ncolor = mix(color, vec4(czm_lightColor, 1.0), clamp(fragFogDensity, 0.0, 1.0));\n#if defined(VOLUMETRIC_CLOUDS)\nfloat depthMaskDistance = 0.5;\nif (length(czm_viewerPositionWC) < cloudBaseRadius) {\ndepthMaskDistance = 0.9; // try to include distant trees and object in the mask\n}\n#if defined(CLOUD_SHADOWS)\nfloat baseDistance = cloudBaseRadius + baseThickness;\nif (depth < 1.0 && czm_lightColor.z > 0.15 && length(vWorldPosition) < baseDistance) {\nvec3 wind = windVector * czm_frameNumber * windSpeedRatio;\nfloat mask = 1.0;\nvec2 toClouds = raySphereIntersect(vWorldPosition, -lightDirection, baseDistance);\nvec3 position = vWorldPosition + (-lightDirection * toClouds.x);\nfloat hr;\nfloat dens = cloudDensity(position, wind, 0, hr);\nmask = clamp(1.0 - dens * 2.0, 0.2, 1.0);\ncolor *= mask;\n}\n#endif\n#endif\n#ifdef ADVANCED_ATMOSPHERE\nvec4 atmosphereColor = calculate_scattering(\nczm_viewerPositionWC,\ndirection,\ndistance,\nlightDirection\n);\ncolor = atmosphereColor + color * (1.0 - atmosphereColor.a);\n#ifdef VOLUMETRIC_CLOUDS\nvec4 clouds = texture(volumetricCloudsTexture, v_textureCoordinates);\nclouds.rgb *= 3.0;\ncolor = mix(color, clouds, clouds.a * clouds.a * clamp((depth - depthMaskDistance) * 100.0, 0.0, 1.0));\n#endif\nfloat exposure = 1.2;\ncolor = vec4(1.0 - exp(-exposure * color));\n#endif\nfloat backFogDensity;\nbackFogDensity += backgroundFogDensity * depth;\ncolor = mix(color, vec4(backgroundFogColor.rgb, 1.0), clamp(backFogDensity, 0.0, 1.0));\ngl_FragColor = color;\n}\n";; window.geofsShaders = window.geofsShaders || {}; geofsShaders["volumetricCloudsFS.glsl"] = "precision highp float;\nuniform sampler2D noiseTexture;\nin vec2 v_textureCoordinates;\nvec3 skyAmbientColor = vec3(0.705, 0.850, 0.952); //0.219, 0.380, 0.541\nvec3 groundAmbientColor = vec3(0.5, 0.55, 0.5); //vec3(0.741, 0.898, 0.823); //0.639, 0.858, 0.721\nfloat distanceQualityR = 0.00005; // LOD/quality ratio\nfloat minDistance = 10.0; // avoid cloud in cockpit\n#undef PRIMARY_STEPS\n#undef LIGHT_STEPS\n#define PRIMARY_STEPS 1\n#define LIGHT_STEPS 0\nvec4 calculate_clouds(\nvec3 start,\nvec3 dir,\nfloat maxDistance,\nvec3 light_dir,\nvec3 wind\n) {\nvec4 cloud = vec4(0.0, 0.0, 0.0, 1.0);\nvec2 toTop = raySphereIntersect(start, dir, cloudTopRadius);\nvec2 toCloudBase = raySphereIntersect(start, dir, cloudBaseRadius);\nfloat startHeight = length(start) - realPlanetRadius;\nfloat absoluteMaxDistance = CLOUDS_MAX_VIEWING_DISTANCE;\nfloat tmin = minDistance;\nfloat tmax = maxDistance;\nif (startHeight > cloudTop) {\nif (toTop.x < 0.0) return vec4(0.0); // no intersection with cloud layer\ntmin = toTop.x;\nif (toCloudBase.x > 0.0) {\ntmax = min(toCloudBase.x, maxDistance);\n}\nelse {\ntmax = min(toTop.y, maxDistance);\n}\n}\nelse if (startHeight < cloudBase) {\ntmin = toCloudBase.y;\ntmax = min(toTop.y, maxDistance);\n}\nelse {\nif (toCloudBase.x > 0.0) {\ntmax = min(toCloudBase.x, maxDistance);\n}\nelse {\ntmax = min(toTop.y, maxDistance);\n}\n}\ntmin = max(tmin, minDistance);\ntmax = min(tmax, absoluteMaxDistance);\nif (tmax < tmin) return vec4(0.0); // object obstruction\nfloat rayLength = tmax - tmin;\nfloat longMarchStep = rayLength / float(MAXIMUM_CLOUDS_STEPS);\nlongMarchStep = max(longMarchStep, CLOUDS_MARCH_STEP);\nfloat shortMarchStep = CLOUDS_DENS_MARCH_STEP;\nfloat numberApproachSteps = (CLOUDS_MARCH_STEP / CLOUDS_DENS_MARCH_STEP) * 2.0;\nfloat ditherAmount = texture(noiseTexture, mod(gl_FragCoord.xy / 512.0, 1.0)).r * 2.0 - 1.0;\nfloat ditherDistance = ditherAmount * shortMarchStep;\nfloat distance = tmin + ditherDistance;\nfloat dens = 0.0;\nfloat marchStep;\nfloat distanceToFirstCloud = 0.0;\nfloat lastDensity;\nfloat gInScattering = 0.9;\nfloat gOutScattering = 0.0;\nfloat kInScattering = 0.99;\nfloat dotLightRay = dot(dir, light_dir);\nfloat inScattering = Schlick(kInScattering, dotLightRay); //HenyeyGreenstein(gInScattering, dotLightRay);\nfloat outScattering = isotropic(); //HenyeyGreenstein(gOutScattering, dotLightRay);\nfloat sunScatteringPhase = mix(outScattering, inScattering, dotLightRay);\nfloat ambientScatteringPhase = isotropic();\nbool inCloud = false;\nbool rayComplete = false;\nfloat stepsBeforeExitingCloud = 0.0;\nfor (int i = 0; i < MAXIMUM_CLOUDS_STEPS; i++) {\nvec3 position = start + dir * distance;\nfloat depth = distance / CLOUDS_MAX_VIEWING_DISTANCE;\nint qualityRatio = int(distance * distanceQualityR);\nint lod = CLOUDS_MAX_LOD - qualityRatio;\nfloat heightRatio;\nif (inCloud == true) {\nmarchStep = shortMarchStep;\n}\nelse {\nmarchStep = longMarchStep;\nlod = 0;\n}\ndens = cloudDensity(position, wind, lod, heightRatio);\nif(dens > 0.01) {\nif (inCloud != true) {\ninCloud = true;\nstepsBeforeExitingCloud = numberApproachSteps;\ndistance = clamp(distance - CLOUDS_MARCH_STEP, tmin, tmax); // take one step back\ncontinue;\n}\nfloat deltaDens = clamp((dens - lastDensity) * 10.0, -1.0, 1.0);\nfloat lighting = (abs(deltaDens - dotLightRay) / 2.0) * clamp((heightRatio - 0.02) * 20.0, 0.5, 1.0);\nlastDensity = dens;\nfloat scatteringCoeff = 0.25 * dens;\nfloat extinctionCoeff = 0.01 * dens;\ncloud.a *= exp(-extinctionCoeff * marchStep);\nfloat sunIntensityAtSurface = clamp(0.2 - dens, 0.0, 1.0);\nvec3 sunLight = lighting * czm_lightColor * sunIntensityAtSurface * czm_lightColor.z;\nvec3 ambientSun = czm_lightColor * sunIntensityAtSurface * czm_lightColor.z * isotropic();\nvec3 skyAmbientLight = (skyAmbientColor * czm_lightColor.z + ambientSun);\nvec3 groundAmbientLight = (groundAmbientColor * czm_lightColor.z * 0.5 + ambientSun);\nvec3 ambientLight = mix(groundAmbientLight, skyAmbientLight, heightRatio);\nvec3 stepScattering = scatteringCoeff * marchStep * (sunScatteringPhase * sunLight + ambientScatteringPhase * ambientLight);\ncloud.rgb += cloud.a * stepScattering;\nif (cloud.a < 0.01) {\ncloud.a = 0.0;\nbreak;\n}\nif (distanceToFirstCloud == 0.0) {\ndistanceToFirstCloud = distance;\n}\n}\nelse {\nif (stepsBeforeExitingCloud > 0.0) {\nstepsBeforeExitingCloud--;\n}\nelse {\ninCloud = false;\n}\n}\ndistance += marchStep;\nif (distance > tmax) {\nif (rayComplete == true) {\nbreak;\n}\nelse {\nrayComplete = true;\ndistance = tmax;\n}\n}\n}\nvec4 atmosphereAtDistance = calculate_scattering(\nczm_viewerPositionWC,\ndir,\ndistanceToFirstCloud,\nlight_dir\n) * 0.2; // account for tone mapping\ncloud.rgb = cloud.rgb * (1.0 - atmosphereAtDistance.a) + atmosphereAtDistance.rgb;\ncloud.a = (1.0 - cloud.a);\nreturn cloud;\n}\nvoid main() {\nvec4 color = vec4(0.0);\nif (cloudCover < 0.1) {\ngl_FragColor = color;\nreturn;\n}\nvec4 rawDepthColor = texture(czm_globeDepthTexture, v_textureCoordinates);\n#if !defined(GL_EXT_frag_depth)\nfloat depth = rawDepthColor.r; // depth packing algo appears to be buggy on mobile so only use the most significant element for now\n#else\nfloat depth = czm_unpackDepth(rawDepthColor);\n#endif\nif (depth == 0.0) {\ndepth = 1.0;\n}\n#ifdef VOLUMETRIC_CLOUDS\nvec4 positionEC = czm_windowToEyeCoordinates(gl_FragCoord.xy, depth);\nvec4 worldCoordinate = czm_inverseView * positionEC;\nvec3 vWorldPosition = worldCoordinate.xyz / worldCoordinate.w;\nvec3 posToEye = vWorldPosition - czm_viewerPositionWC;\nvec3 direction = normalize(posToEye);\nvec3 lightDirection = normalize(czm_sunPositionWC);\nfloat distance = length(posToEye);\nif (depth == 1.0) {\ndistance = CLOUDS_MAX_VIEWING_DISTANCE;\n}\nvec3 wind = windVector * czm_frameNumber * windSpeedRatio;\ncolor = calculate_clouds(\nczm_viewerPositionWC, // the position of the camera\ndirection, // the camera vector (ray direction of this pixel)\ndistance, // max dist, essentially the scene depth\nlightDirection, // light direction\nwind\n);\n#endif\ngl_FragColor = color;\n}\n";; window.geofsShaders = window.geofsShaders || {}; geofsShaders["oceanFS.glsl"] = "precision highp float;\nconst float specularShininess = 200.0;\nconst float specularPower = 2.0;\nconst float animationSpeed = 0.00005;\nfloat waveAmplitude;\nvec3 positionMC;\nczm_material czm_getMaterial(czm_materialInput materialInput) {\nczm_material material;\nvec4 layerColor = materialInput.layerColor;\nif (layerColor.r > 0.46 && layerColor.r < 0.54 && czm_lightColor.z < 0.13) {\npositionMC = (czm_inverseModelView * vec4(-materialInput.positionToEyeEC, 1.0)).xyz;\nvec3 sphericalNormal = normalize(positionMC);\nvec2 positionSurfaceC = czm_ellipsoidWgs84TextureCoordinates(sphericalNormal) * 3000.0;\nmaterial.diffuse = texture(lightsTexture, fract(positionSurfaceC)).rgb * 1.5;\nmaterial.alpha = material.diffuse.r * layerColor.r;\n}\nif (layerColor.b > 0.0) {\nvec4 czm_lightColorV4 = vec4(czm_lightColor, 1.0);\npositionMC = (czm_inverseModelView * vec4(-materialInput.positionToEyeEC, 1.0)).xyz;\nfloat seaRatio = 1.0 - clamp(materialInput.height / 10.0, 0.0, 0.8);\nwaveAmplitude = layerColor.b * seaRatio;\nfloat shoreRatio = 0.0;\nif (layerColor.b < 0.95) {\nshoreRatio = 0.01;\n}\nfloat windFactor = windSpeed * 0.05;\nwaveAmplitude *= windFactor + 0.88;\nvec3 normalTangentSpace = vec3(1.0, 1.0, 1.0 / waveAmplitude);\n#if !defined(GL_EXT_frag_depth)\nvec2 positionSurfaceC = materialInput.st * 128.0;\n#else\nvec3 sphericalNormal = czm_geodeticSurfaceNormal(positionMC, vec3(0.0), vec3(1.0));\nvec2 positionSurfaceC = czm_ellipsoidWgs84TextureCoordinates(sphericalNormal);\n#endif\nfloat time = geofsTime * animationSpeed * (windFactor + 0.9);\nvec4 noise = czm_getWaterNoise(normalMap, positionSurfaceC * 500000.0, time, 0.0);\nnormalTangentSpace = noise.xyz * normalTangentSpace;\nnormalTangentSpace = normalize(normalTangentSpace);\nvec3 normalEC = normalize(materialInput.tangentToEyeMatrix * normalTangentSpace);\nvec3 up = normalize(materialInput.tangentToEyeMatrix * vec3(0.0, 0.0, 1.0));\nvec3 surfaceToLight = normalize(mat3(czm_view) * (czm_sunPositionWC - positionMC));\nvec3 surfaceToCamera = normalize(mat3(czm_view) * (czm_viewerPositionWC - positionMC));\nvec3 reflectedSun = normalize(-reflect(surfaceToLight, normalEC));\nfloat specularCoefficient = pow(max(dot(reflectedSun, surfaceToCamera), 0.0), specularShininess * waveAmplitude) * specularPower;\nfloat waveHeight = clamp((0.99 + shoreRatio - dot(normalEC, up)) * 500.0, 0.0, 1.0);\nvec2 positionSurfaceC2 = vec2(fract(positionSurfaceC * 50000.0));\nvec4 foam = texture(foamTexture, positionSurfaceC2) * waveHeight * czm_lightColorV4; // uv from geo coords (noisy)\nfloat reflectionCoefficient = dot(surfaceToCamera, normalEC);\nvec4 reflectionColor = mix(horizonColor, azimutColor, reflectionCoefficient);\nreflectionColor = reflectionColor + czm_lightColorV4 * specularCoefficient;//mix(waterColor, czm_lightColorV4, specularCoefficient);\nfloat Eta = 0.15;\nfloat fresnel = Eta + (1.0 - Eta) * pow(max(0.0, 1.0 - dot(surfaceToCamera, normalEC)), 5.0);\nmaterial.diffuse = reflectionColor.rgb + foam.rgb;\nmaterial.alpha = layerColor.b * (fresnel * 0.5 + specularCoefficient + foam.r);\n}\nreturn material;\n}\n";; window.geofsShaders = window.geofsShaders || {}; geofsShaders["wireFS.glsl"] = "precision highp float;\nczm_material czm_getMaterial(czm_materialInput materialInput) {\nczm_material material;\nvec3 positionMC = (czm_inverseModelView * vec4(-materialInput.positionToEyeEC, 1.0)).xyz;\nvec3 sphericalNormal = normalize(positionMC);\nvec2 positionSurfaceC = abs(fract(czm_ellipsoidWgs84TextureCoordinates(sphericalNormal) * 500000.0) - vec2(0.5, 0.5)) * 2.0;\nfloat value = 1.0 - min(positionSurfaceC.x, positionSurfaceC.y);\nif (value > 0.95) {\nmaterial.diffuse = mix(backgroundColor.rgb, wireframeColor.rgb, (value - 0.95) * 4.0);\nif (value > 0.99) {\nmaterial.diffuse = wireframeColor.rgb;\n}\n}\nelse {\nmaterial.diffuse = backgroundColor.rgb;\n}\nmaterial.alpha = 1.0;\nreturn material;\n}\n";; window.geofsShaders = window.geofsShaders || {}; geofsShaders["buildingsFS.glsl"] = "void fragmentMain(\nFragmentInput fsInput,\ninout czm_modelMaterial material) {\nmaterial.alpha = 1.0;\nvec3 emission = vec3(0.0);\nvec4 baseColor = texture(u_buildingTexture, fsInput.attributes.texCoord_0);\nvec4 buildingColor = fsInput.attributes.color_0;//min((fsInput.attributes.color_0 + vec4(0.2)) * 0.8, vec4(1.0)); // desaturated vertex color\n#ifdef BUILDINGS_REFLECTION\nvec4 reflection;\nvec4 specularColor = texture(u_specularTexture, fsInput.attributes.texCoord_0);\nfloat specularTexLevel = specularColor.r;\nvec3 surfaceToLight = normalize((mat3(czm_view) * czm_sunPositionWC) - fsInput.attributes.positionEC);\nvec3 surfaceToCamera = normalize(-fsInput.attributes.positionEC); // we are in Eye Coordinates, so EyePos is (0,0,0)\nvec3 reflected = normalize(-reflect(surfaceToLight, fsInput.attributes.normalEC));\n#endif\nif (u_retro) {\nfloat gamma = 2.08;\nvec3 retroColor = baseColor.xyz;//vec3(0.051, 0.145, 0.231);\nretroColor = pow(retroColor, vec3(gamma));\nbaseColor.rgb = retroColor;\n/*\nfloat ambientCoefficient = 0.8;\nfloat diffuseCoefficient = max(0.0, dot(fsInput.attributes.normalEC, czm_sunDirectionEC) * 1.0);\nbaseColor.xyz *= min(diffuseCoefficient + ambientCoefficient, 1.0);\n*/\nmaterial.diffuse = baseColor.xyz;\n}\nelse if (czm_lightColor.z < 0.20) {\nemission = baseColor.xyz;\nfloat gamma = 0.4;\n#ifdef BUILDINGS_REFLECTION\nfloat reflectionLevel = 0.6 * specularTexLevel;\nvec3 coord = normalize(vec3(czm_inverseViewRotation * reflect(surfaceToCamera, fsInput.attributes.normalEC)));\nreflection = texture(u_environmentTexture, vec2(coord.x, (coord.z - coord.y) / 3.0));\nreflection *= reflectionLevel;\nmaterial.diffuse = pow(emission.rgb + reflection.rgb, vec3(1.0/gamma));\n#else\nmaterial.diffuse = pow(emission.rgb, vec3(1.0/gamma));\n#endif\n}\nelse {\nif (!u_isSnowy) {\nbaseColor *= buildingColor;\n}\nfloat ambientCoefficient = 0.1;\nfloat diffuseCoefficient = max(0.0, dot(fsInput.attributes.normalEC, czm_sunDirectionEC) * 1.0);\nbaseColor.xyz *= min(diffuseCoefficient + ambientCoefficient, 1.0);\n#ifdef BUILDINGS_REFLECTION\nfloat specularLevel = 200.0 * specularTexLevel;\nfloat specularCoefficient = pow(max(dot(reflected, surfaceToCamera), 0.0), 50.0);\nvec3 specular = czm_lightColor * specularCoefficient * specularLevel;\nfloat reflectionLevel = 0.2 * specularTexLevel;\nvec3 coord = normalize(vec3(czm_inverseViewRotation * reflect(surfaceToCamera, fsInput.attributes.normalEC)));\nreflection = texture(u_environmentTexture, vec2(coord.x, (coord.z - coord.y) / 3.0));\nreflection *= reflectionLevel;\nmaterial.diffuse = (baseColor.xyz + reflection.xyz + specular) * czm_lightColor;\n#else\nmaterial.diffuse = baseColor.xyz * czm_lightColor;\n#endif\n}\n}\n";; window.geofsShaders = window.geofsShaders || {}; geofsShaders["treesFS.glsl"] = "void fragmentMain(\nFragmentInput fsInput,\ninout czm_modelMaterial material) {\nvec4 baseColor = texture(u_treeTexture, fsInput.attributes.texCoord_0);\nmaterial.alpha = baseColor.a;\nif (material.alpha < 0.5) {\ndiscard;\n}\nfloat expo = 2.2;\nbaseColor.rgb = pow(baseColor.rgb, vec3(expo));\nif (czm_lightColor.z < 0.20) {\nmaterial.diffuse = baseColor.rgb * czm_lightColor * 0.1;\n}\nelse {\nmaterial.diffuse = baseColor.xyz * czm_lightColor;\n}\n}\n";;
var $jscomp = $jscomp || {}; $jscomp.scope = {}; $jscomp.arrayIteratorImpl = function (a) { var b = 0; return function () { return b < a.length ? { done: !1, value: a[b++] } : { done: !0 } } }; $jscomp.arrayIterator = function (a) { return { next: $jscomp.arrayIteratorImpl(a) } }; $jscomp.makeIterator = function (a) { var b = typeof Symbol != "undefined" && Symbol.iterator && a[Symbol.iterator]; if (b) return b.call(a); if (typeof a.length == "number") return $jscomp.arrayIterator(a); throw Error(String(a) + " is not an iterable or ArrayLike"); }; $jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1; $jscomp.ASSUME_NO_NATIVE_SET = !1; $jscomp.SIMPLE_FROUND_POLYFILL = !1; $jscomp.ISOLATE_POLYFILLS = !1; $jscomp.FORCE_POLYFILL_PROMISE = !1; $jscomp.FORCE_POLYFILL_PROMISE_WHEN_NO_UNHANDLED_REJECTION = !1; $jscomp.INSTRUMENT_ASYNC_CONTEXT = !0; $jscomp.defineProperty = $jscomp.ASSUME_ES5 || typeof Object.defineProperties == "function" ? Object.defineProperty : function (a, b, c) { if (a == Array.prototype || a == Object.prototype) return a; a[b] = c.value; return a };
$jscomp.getGlobal = function (a) { a = ["object" == typeof globalThis && globalThis, a, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global]; for (var b = 0; b < a.length; ++b) { var c = a[b]; if (c && c.Math == Math) return c } throw Error("Cannot find global object"); }; $jscomp.global = $jscomp.getGlobal(this); $jscomp.IS_SYMBOL_NATIVE = typeof Symbol === "function" && typeof Symbol("x") === "symbol"; $jscomp.TRUST_ES6_POLYFILLS = !$jscomp.ISOLATE_POLYFILLS || $jscomp.IS_SYMBOL_NATIVE; $jscomp.polyfills = {};
$jscomp.propertyToPolyfillSymbol = {}; $jscomp.POLYFILL_PREFIX = "$jscp$"; var $jscomp$lookupPolyfilledValue = function (a, b, c) { if (!c || a != null) { c = $jscomp.propertyToPolyfillSymbol[b]; if (c == null) return a[b]; c = a[c]; return c !== void 0 ? c : a[b] } }; $jscomp.polyfill = function (a, b, c, d) { b && ($jscomp.ISOLATE_POLYFILLS ? $jscomp.polyfillIsolated(a, b, c, d) : $jscomp.polyfillUnisolated(a, b, c, d)) };
$jscomp.polyfillUnisolated = function (a, b, c, d) { c = $jscomp.global; a = a.split("."); for (d = 0; d < a.length - 1; d++) { var e = a[d]; if (!(e in c)) return; c = c[e] } a = a[a.length - 1]; d = c[a]; b = b(d); b != d && b != null && $jscomp.defineProperty(c, a, { configurable: !0, writable: !0, value: b }) };
$jscomp.polyfillIsolated = function (a, b, c, d) {
  var e = a.split("."); a = e.length === 1; d = e[0]; d = !a && d in $jscomp.polyfills ? $jscomp.polyfills : $jscomp.global; for (var f = 0; f < e.length - 1; f++) { var g = e[f]; if (!(g in d)) return; d = d[g] } e = e[e.length - 1]; c = $jscomp.IS_SYMBOL_NATIVE && c === "es6" ? d[e] : null; b = b(c); b != null && (a ? $jscomp.defineProperty($jscomp.polyfills, e, { configurable: !0, writable: !0, value: b }) : b !== c && ($jscomp.propertyToPolyfillSymbol[e] === void 0 && (c = Math.random() * 1E9 >>> 0, $jscomp.propertyToPolyfillSymbol[e] = $jscomp.IS_SYMBOL_NATIVE ?
    $jscomp.global.Symbol(e) : $jscomp.POLYFILL_PREFIX + c + "$" + e), $jscomp.defineProperty(d, $jscomp.propertyToPolyfillSymbol[e], { configurable: !0, writable: !0, value: b })))
}; $jscomp.underscoreProtoCanBeSet = function () { var a = { a: !0 }, b = {}; try { return b.__proto__ = a, b.a } catch (c) { } return !1 };
$jscomp.setPrototypeOf = $jscomp.TRUST_ES6_POLYFILLS && typeof Object.setPrototypeOf == "function" ? Object.setPrototypeOf : $jscomp.underscoreProtoCanBeSet() ? function (a, b) { a.__proto__ = b; if (a.__proto__ !== b) throw new TypeError(a + " is not extensible"); return a } : null; $jscomp.generator = {}; $jscomp.generator.ensureIteratorResultIsObject_ = function (a) { if (!(a instanceof Object)) throw new TypeError("Iterator result " + a + " is not an object"); };
$jscomp.generator.Context = function () { this.isRunning_ = !1; this.yieldAllIterator_ = null; this.yieldResult = void 0; this.nextAddress = 1; this.finallyAddress_ = this.catchAddress_ = 0; this.finallyContexts_ = this.abruptCompletion_ = null }; $jscomp.generator.Context.prototype.start_ = function () { if (this.isRunning_) throw new TypeError("Generator is already running"); this.isRunning_ = !0 }; $jscomp.generator.Context.prototype.stop_ = function () { this.isRunning_ = !1 };
$jscomp.generator.Context.prototype.jumpToErrorHandler_ = function () { this.nextAddress = this.catchAddress_ || this.finallyAddress_ }; $jscomp.generator.Context.prototype.next_ = function (a) { this.yieldResult = a }; $jscomp.generator.Context.prototype.throw_ = function (a) { this.abruptCompletion_ = { exception: a, isException: !0 }; this.jumpToErrorHandler_() }; $jscomp.generator.Context.prototype.return = function (a) { this.abruptCompletion_ = { return: a }; this.nextAddress = this.finallyAddress_ };
$jscomp.generator.Context.prototype.jumpThroughFinallyBlocks = function (a) { this.abruptCompletion_ = { jumpTo: a }; this.nextAddress = this.finallyAddress_ }; $jscomp.generator.Context.prototype.yield = function (a, b) { this.nextAddress = b; return { value: a } }; $jscomp.generator.Context.prototype.yieldAll = function (a, b) { a = $jscomp.makeIterator(a); var c = a.next(); $jscomp.generator.ensureIteratorResultIsObject_(c); if (c.done) this.yieldResult = c.value, this.nextAddress = b; else return this.yieldAllIterator_ = a, this.yield(c.value, b) };
$jscomp.generator.Context.prototype.jumpTo = function (a) { this.nextAddress = a }; $jscomp.generator.Context.prototype.jumpToEnd = function () { this.nextAddress = 0 }; $jscomp.generator.Context.prototype.setCatchFinallyBlocks = function (a, b) { this.catchAddress_ = a; b != void 0 && (this.finallyAddress_ = b) }; $jscomp.generator.Context.prototype.setFinallyBlock = function (a) { this.catchAddress_ = 0; this.finallyAddress_ = a || 0 }; $jscomp.generator.Context.prototype.leaveTryBlock = function (a, b) { this.nextAddress = a; this.catchAddress_ = b || 0 };
$jscomp.generator.Context.prototype.enterCatchBlock = function (a) { this.catchAddress_ = a || 0; a = this.abruptCompletion_.exception; this.abruptCompletion_ = null; return a }; $jscomp.generator.Context.prototype.enterFinallyBlock = function (a, b, c) { c ? this.finallyContexts_[c] = this.abruptCompletion_ : this.finallyContexts_ = [this.abruptCompletion_]; this.catchAddress_ = a || 0; this.finallyAddress_ = b || 0 };
$jscomp.generator.Context.prototype.leaveFinallyBlock = function (a, b) { b = this.finallyContexts_.splice(b || 0)[0]; if (b = this.abruptCompletion_ = this.abruptCompletion_ || b) { if (b.isException) return this.jumpToErrorHandler_(); b.jumpTo != void 0 && this.finallyAddress_ < b.jumpTo ? (this.nextAddress = b.jumpTo, this.abruptCompletion_ = null) : this.nextAddress = this.finallyAddress_ } else this.nextAddress = a }; $jscomp.generator.Context.prototype.forIn = function (a) { return new $jscomp.generator.Context.PropertyIterator(a) };
$jscomp.generator.Context.PropertyIterator = function (a) { this.object_ = a; this.properties_ = []; for (var b in a) this.properties_.push(b); this.properties_.reverse() }; $jscomp.generator.Context.PropertyIterator.prototype.getNext = function () { for (; this.properties_.length > 0;) { var a = this.properties_.pop(); if (a in this.object_) return a } return null }; $jscomp.generator.Engine_ = function (a) { this.context_ = new $jscomp.generator.Context; this.program_ = a };
$jscomp.generator.Engine_.prototype.next_ = function (a) { this.context_.start_(); if (this.context_.yieldAllIterator_) return this.yieldAllStep_(this.context_.yieldAllIterator_.next, a, this.context_.next_); this.context_.next_(a); return this.nextStep_() };
$jscomp.generator.Engine_.prototype.return_ = function (a) { this.context_.start_(); var b = this.context_.yieldAllIterator_; if (b) return this.yieldAllStep_("return" in b ? b["return"] : function (c) { return { value: c, done: !0 } }, a, this.context_.return); this.context_.return(a); return this.nextStep_() };
$jscomp.generator.Engine_.prototype.throw_ = function (a) { this.context_.start_(); if (this.context_.yieldAllIterator_) return this.yieldAllStep_(this.context_.yieldAllIterator_["throw"], a, this.context_.next_); this.context_.throw_(a); return this.nextStep_() };
$jscomp.generator.Engine_.prototype.yieldAllStep_ = function (a, b, c) { try { var d = a.call(this.context_.yieldAllIterator_, b); $jscomp.generator.ensureIteratorResultIsObject_(d); if (!d.done) return this.context_.stop_(), d; var e = d.value } catch (f) { return this.context_.yieldAllIterator_ = null, this.context_.throw_(f), this.nextStep_() } this.context_.yieldAllIterator_ = null; c.call(this.context_, e); return this.nextStep_() };
$jscomp.generator.Engine_.prototype.nextStep_ = function () { for (; this.context_.nextAddress;)try { var a = this.program_(this.context_); if (a) return this.context_.stop_(), { value: a.value, done: !1 } } catch (b) { this.context_.yieldResult = void 0, this.context_.throw_(b) } this.context_.stop_(); if (this.context_.abruptCompletion_) { a = this.context_.abruptCompletion_; this.context_.abruptCompletion_ = null; if (a.isException) throw a.exception; return { value: a.return, done: !0 } } return { value: void 0, done: !0 } };
$jscomp.generator.Generator_ = function (a) { this.next = function (b) { return a.next_(b) }; this.throw = function (b) { return a.throw_(b) }; this.return = function (b) { return a.return_(b) }; this[Symbol.iterator] = function () { return this } }; $jscomp.generator.createGenerator = function (a, b) { b = new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(b)); $jscomp.setPrototypeOf && a.prototype && $jscomp.setPrototypeOf(b, a.prototype); return b };
$jscomp.asyncExecutePromiseGenerator = function (a) { function b(d) { return a.next(d) } function c(d) { return a.throw(d) } return new Promise(function (d, e) { function f(g) { g.done ? d(g.value) : Promise.resolve(g.value).then(b, c).then(f, e) } f(a.next()) }) }; $jscomp.asyncExecutePromiseGeneratorFunction = function (a) { return $jscomp.asyncExecutePromiseGenerator(a()) }; $jscomp.asyncExecutePromiseGeneratorProgram = function (a) { return $jscomp.asyncExecutePromiseGenerator(new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(a))) };
L.Polyline.plotter = L.Polyline.extend({
  _lineMarkers: [], _editIcon: L.divIcon({ className: "leaflet-div-icon leaflet-editing-icon" }), _halfwayPointMarkers: [], _existingLatLngs: [], options: { weight: 2, color: "#000", readOnly: !1 }, initialize: function (a, b) { this._lineMarkers = []; this._halfwayPointMarkers = []; this._setExistingLatLngs(a); L.Polyline.prototype.initialize.call(this, [], b) }, onAdd: function (a) { L.Polyline.prototype.onAdd.call(this, a); this._map = a; this._plotExisting(); this.options.readOnly || this._bindMapClick() },
  onRemove: function (a) { this._halfwayPointMarkers.forEach(function (b) { b.remove() }); this._lineMarkers.forEach(function (b) { b.remove() }); this._halfwayPointMarkers = this._lineMarkers = []; this._unbindMapClick(); L.Polyline.prototype.onRemove.call(this, a) }, setLatLngs: function (a) { L.Polyline.prototype.setLatLngs.call(this, a) }, setReadOnly: function (a) {
    if (a && !this.options.readOnly) { var b = "_unbindMarkerEvents", c = "_unbindHalfwayMarker"; this._unbindMapClick() } else !a && this.options.readOnly && (c = b = "_bindMarkerEvents", this._bindMapClick());
    if (typeof b !== "undefined") { this.options.readOnly = a; for (index in this._halfwayPointMarkers) this[c](this._halfwayPointMarkers[index]); for (index in this._lineMarkers) this[b](this._lineMarkers[index]) }
  }, _bindMapClick: function () { this._map.on("click", this._onMapClick, this) }, _unbindMapClick: function () { this._map.off("click", this._onMapClick, this) }, _setExistingLatLngs: function (a) { this._existingLatLngs = a }, _replot: function () { this._redraw(); this._redrawHalfwayPoints() }, _getNewMarker: function (a, b) {
    return new L.marker(a,
      b)
  }, _unbindMarkerEvents: function (a) { a.off("click", this._removePoint, this); a.off("drag", this._replot, this); a.dragging.disable() }, _bindMarkerEvents: function (a) { var b = this; a.on("mousedown", function () { b._screwedUpLeafletEventsBubblingCancellation = !0 }, this); a.on("click", this._removePoint, this); a.on("drag", this._replot, this); a.dragging.enable() }, _bindHalfwayMarker: function (a) { a.on("click", this._addHalfwayPoint, this) }, _unbindHalfwayMarker: function (a) { a.off("click", this._addHalfwayPoint, this) }, _addToMapAndBindMarker: function (a) {
    a.addTo(this._map);
    this.options.readOnly || this._bindMarkerEvents(a)
  }, _removePoint: function (a) { this._map.removeLayer(this._lineMarkers[this._lineMarkers.indexOf(a.target)]); this._lineMarkers.splice(this._lineMarkers.indexOf(a.target), 1); this._replot() }, _onMapClick: function (a) { this._screwedUpLeafletEventsBubblingCancellation ? this._screwedUpLeafletEventsBubblingCancellation = !1 : (this._addNewMarker(a), this._replot()) }, _addNewMarker: function (a) {
    a = this._getNewMarker(a.latlng, { icon: this._editIcon }); this._addToMapAndBindMarker(a);
    this._lineMarkers.push(a)
  }, _redrawHalfwayPoints: function () {
    for (index in this._halfwayPointMarkers) this._map.removeLayer(this._halfwayPointMarkers[index]); this._halfwayPointMarkers = []; for (index in this._lineMarkers) {
      index = parseInt(index); if (typeof this._lineMarkers[index + 1] === "undefined") break; var a = (new L.Marker([(this._lineMarkers[index].getLatLng().lat + this._lineMarkers[index + 1].getLatLng().lat) / 2, (this._lineMarkers[index].getLatLng().lng + this._lineMarkers[index + 1].getLatLng().lng) / 2], {
        icon: this._editIcon,
        opacity: .5
      })).addTo(this._map); a.index = index; this.options.readOnly || this._bindHalfwayMarker(a); this._halfwayPointMarkers.push(a)
    }
  }, _addHalfwayPoint: function (a) { var b = this._getNewMarker(a.latlng, { icon: this._editIcon }); this._addToMapAndBindMarker(b); this._lineMarkers.splice(a.target.index + 1, 0, b); this._replot() }, _plotExisting: function () { for (index in this._existingLatLngs) this._addNewMarker({ latlng: new L.LatLng(this._existingLatLngs[index][0], this._existingLatLngs[index][1]) }); this._replot() }, _redraw: function () {
    this.setLatLngs([]);
    this.redraw(); for (index in this._lineMarkers) this.addLatLng(this._lineMarkers[index].getLatLng()); this.redraw()
  }
}); L.Polyline.Plotter = function (a, b) { return new L.Polyline.plotter(a, b) };
geofs.configuration = {
  google: { physics: { degradedCollisions: [!0, !0, !0, !0, !0, !0, !0, !0] } }, defaults: {
    screenSpacePresets: { maximumScreenSpaceError: [10, 6, 4, 2, 2, 2, 2, 1], fogScreenSpaceErrorFactor: [2, 2, 2, 2, 1.8, 1.7, 1.5, 1], fogDensity: [5E-4, 3.2E-4, 3E-4, 2.5E-4, 2E-4, 1.5E-4, 1E-4, 5E-5], google: { dynamicScreenSpaceErrorDensity: [1, 1, 1, .1, .01, .001, 1E-4, 1E-5], dynamicScreenSpaceErrorFactor: [32, 32, 24, 24, 24, 24, 24, 24], maximumScreenSpaceError: [256, 128, 64, 48, 32, 24, 20, 12] } }, physics: {
      deltaMs: [20, 20, 20, 10, 10, 10, 10, 10], degradedCollisions: [!0,
      !0, !0, !0, !1, !1, !1, !1]
    }, renderingQualityLevels: {
      0: { resolutionScale: .7, tileCacheSize: 0, fxaa: !1, msaaSamples: 1, globeLighting: !1, dropShadow: !1, cloudCoverToCloudNumber: 15, scatteringQuality: 0, shadowMapSize: 1024, shadowDistance: 1E3, viewingDistance: 0, degradedCollisions: !1, lowResRunways: !1 }, 1: { resolutionScale: .8, tileCacheSize: 100, fxaa: !1, msaaSamples: 1, globeLighting: !0, dropShadow: !1, cloudCoverToCloudNumber: 1, scatteringQuality: 0, shadowMapSize: 1024, shadowDistance: 1E3, viewingDistance: 1, degradedCollisions: !0, lowResRunways: !0 },
      2: { resolutionScale: .9, tileCacheSize: 150, fxaa: !0, msaaSamples: 1, globeLighting: !0, dropShadow: !1, cloudCoverToCloudNumber: 5, scatteringQuality: 1, shadowMapSize: 1024, shadowDistance: 1E3, viewingDistance: 2, degradedCollisions: !0, lowResRunways: !0 }, 3: { resolutionScale: 1, tileCacheSize: 250, fxaa: !0, msaaSamples: 1, globeLighting: !0, dropShadow: !0, cloudCoverToCloudNumber: 10, scatteringQuality: 2, shadowMapSize: 1024, shadowDistance: 1E3, viewingDistance: 3, degradedCollisions: !0, lowResRunways: !0 }, 4: {
        resolutionScale: 1, tileCacheSize: 500,
        fxaa: !0, msaaSamples: 1, globeLighting: !0, dropShadow: !0, cloudCoverToCloudNumber: 12, scatteringQuality: 3, shadowMapSize: 2048, shadowDistance: 2E3, viewingDistance: 4, degradedCollisions: !1, lowResRunways: !1
      }, 5: { resolutionScale: 1, tileCacheSize: 1E3, fxaa: !0, msaaSamples: 1, globeLighting: !0, dropShadow: !0, cloudCoverToCloudNumber: 14, scatteringQuality: 4, shadowMapSize: 2048, shadowDistance: 2E3, viewingDistance: 5, degradedCollisions: !1, lowResRunways: !1 }, 6: {
        resolutionScale: 1, tileCacheSize: 2E3, fxaa: !0, msaaSamples: 1, globeLighting: !0,
        dropShadow: !0, cloudCoverToCloudNumber: 15, scatteringQuality: 5, shadowMapSize: 4096, shadowDistance: 3E3, viewingDistance: 6, degradedCollisions: !1, lowResRunways: !1
      }
    }, qualityToBuildingTexture: { 1: "low", 2: "low", 3: "low", 4: "med", 5: "med", 6: "high", 7: "high" }
  }, applyConfiguration: function (a) { geofs.configuration.current = $.extend(!0, {}, geofs.configuration.defaults, a || {}) }
}; geofs.configuration.applyConfiguration(); "use strict"; window.geofs = window.geofs || {};
var GRAVITY = 9.81, DEGREES_TO_RAD = Math.PI / 180, RAD_TO_DEGREES = 180 / Math.PI, KMH_TO_MS = 1 / 3.6, METERS_TO_FEET = 3.2808399, METERS_TO_NM = 5.39957E-4, FEET_TO_METERS = .3048, LONGITUDE_TO_HOURS = .0666, EPSILON = 1E-7, ONE_MINUS_EPSILON = 1 - EPSILON, MERIDIONAL_RADIUS = 6378137, EARTH_CIRCUMFERENCE = MERIDIONAL_RADIUS * 2 * Math.PI, METERS_TO_LOCAL_LAT = 1 / (EARTH_CIRCUMFERENCE / 360), STANDARD_GLIDE_ANGLE = 3, GLIDE_SLOPE = .052359, PI = Math.PI, HALF_PI = PI / 2, TWO_PI = PI * 2, ONE_OVER_TWO_PI = 1 / TWO_PI, ONE_OVER_PI = 1 / PI, MS_TO_FEETMINUTE = 196.85, MS_TO_KNOTS =
  1.94384449, KNOTS_TO_MS = .514444444, KMH_TO_KNOTS = .539956803, AXIS_TO_INDEX = { X: 0, Y: 1, Z: 2 }, AXIS_TO_VECTOR = { X: [1, 0, 0], Y: [0, 1, 0], Z: [0, 0, 1] }, KELVIN_OFFSET = 273.15, TEMPERATURE_LAPSE_RATE = .0065, ZUPAxis = { X: "X", Y: "Y", Z: "Z" }, YUPAxis = { X: "X", Y: "Z", Z: "Y" }, AIR_DENSITY_SL = 1.22, AIR_PRESSURE_SL = 101325, AIR_TEMP_SL = 15, DRAG_CONSTANT = .07, MIN_DRAG_COEF = .02, PLANFORM_EFFICIENCY_FACTOR = .7, TOTAL_DRAG_CONSTANT = DRAG_CONSTANT + MIN_DRAG_COEF, IDEAL_GAS_CONSTANT = 8.31447, MOLAR_MASS_DRY_AIR = .0289644, GAS_CONSTANT = IDEAL_GAS_CONSTANT / MOLAR_MASS_DRY_AIR,
  GM_RL = GRAVITY * MOLAR_MASS_DRY_AIR / (IDEAL_GAS_CONSTANT * TEMPERATURE_LAPSE_RATE), DEFAULT_AIRFOIL_ASPECT_RATIO = 7, WATER_DENSITY = 997, FOV = 60, VIEWPORT_REFERENCE_WIDTH = 1800, VIEWPORT_REFERENCE_HEIGHT = 800, SMOOTH_BUFFER = {}, SMOOTHING_FACTOR = .2, SIX_STEP_WARNING = "#18a400 #2b9100 #487300 #835b00 #933700 #a71500".split(" "), SHADOWS_NONE = 0, SHADOWS_ALL = 1, SHADOWS_CAST = 2, SHADOWS_RECEIVE = 3; geofs.constants = { init: function () { } };
V2 = { add: function (a, b) { return [a[0] + b[0], a[1] + b[1]] }, sub: function (a, b) { return [a[0] - b[0], a[1] - b[1]] }, length: function (a) { return Math.sqrt(a[0] * a[0] + a[1] * a[1]) }, fastLengthApprox: function (a) { var b = a[0]; a = a[1]; return Math.max(b, a) + Math.min(b, a) / 2 }, scale: function (a, b) { return [a[0] * b, a[1] * b] }, parseInt: function (a) { return [parseInt(a[0]), parseInt(a[1])] }, round: function (a) { return [Math.round(a[0]), Math.round(a[1])] }, div: function (a, b) { return [a[0] / b[0], a[1] / b[1]] } };
V3 = {
  isValid: function (a) { if (!a) return !1; for (var b = 0; b <= 2; b++)if (a[b] === null || isNaN(a[b])) return !1; return !0 }, dup: function (a) { return [a[0], a[1], a[2]] }, toString: function (a) { return "[" + a[0] + ", " + a[1] + ", " + a[2] + "]" }, nearlyEqual: function (a, b, c) { c || (c = 1E-6); return Math.abs(a[0] - b[0]) <= c && Math.abs(a[1] - b[1]) <= c && Math.abs(a[2] - b[2]) <= c }, abs: function (a) { return [Math.abs(a[0]), Math.abs(a[1]), Math.abs(a[2])] }, cross: function (a, b) { var c = a[0], d = a[1]; a = a[2]; var e = b[0], f = b[1]; b = b[2]; return [d * b - a * f, a * e - c * b, c * f - d * e] }, dot: function (a,
    b) { return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] }, add: function (a, b) { return [a[0] + b[0], a[1] + b[1], a[2] + b[2]] }, addAngles: function (a, b) { return [fixAngle(a[0] + b[0]), fixAngle(a[1] + b[1]), fixAngle(a[2] + b[2])] }, sub: function (a, b) { return [a[0] - b[0], a[1] - b[1], a[2] - b[2]] }, mult: function (a, b) { return [a[0] * b[0], a[1] * b[1], a[2] * b[2]] }, scale: function (a, b) { return [a[0] * b, a[1] * b, a[2] * b] }, length: function (a) { return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]) }, normalize: function (a) {
      var b = V3.length(a); return b <= 0 ? [NaN, NaN, NaN] : V3.scale(a,
        1 / b)
    }, bisect: function (a, b) { return [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2, (a[2] + b[2]) / 2] }, rotate: function (a, b, c) { var d = V3.dot(a, b); a = V3.sub(a, V3.scale(b, d)); var e = V3.cross(b, a); return V3.add(V3.scale(b, d), V3.add(V3.scale(a, Math.cos(c)), V3.scale(e, Math.sin(c)))) }, toRadians: function (a) { return [a[0] * DEGREES_TO_RAD, a[1] * DEGREES_TO_RAD, a[2] * DEGREES_TO_RAD] }, toDegrees: function (a) { return [a[0] * RAD_TO_DEGREES, a[1] * RAD_TO_DEGREES, a[2] * RAD_TO_DEGREES] }, clamp: function (a, b, c) {
      return [clamp(a[0], b, c), clamp(a[1], b, c), clamp(a[2],
        b, c)]
    }, span: function (a, b, c) { return [span(a[0], b, c), span(a[1], b, c), span(a[2], b, c)] }, exponentialSmoothing: function (a, b, c, d) { return [exponentialSmoothing(a + "0", b[0], c, d), exponentialSmoothing(a + "1", b[1], c, d), exponentialSmoothing(a + "2", b[2], c, d)] }, sqrt: function (a) { return [Math.sqrt(Math.abs(a[0])) * Math.sign(a[0]), Math.sqrt(Math.abs(a[1])) * Math.sign(a[1]), Math.sqrt(Math.abs(a[2])) * Math.sign(a[2])] }
};
M33 = {
  toString: function (a) { return "[" + V3.toString(a[0]) + ", " + V3.toString(a[1]) + ", " + V3.toString(a[2]) + "]" }, toM4: function (a) { return [a[0][0], a[0][1], a[0][2], 0, a[1][0], a[1][1], a[1][2], 0, a[2][0], a[2][1], a[2][2], 0, 0, 0, 0, 0] }, toArray: function (a) { return [a[0][0], a[0][1], a[0][2], a[1][0], a[1][1], a[1][2], a[2][0], a[2][1], a[2][2]] }, toRowMajorArray: function (a) { return [a[0][0], a[1][0], a[2][0], a[0][1], a[1][1], a[2][1], a[0][2], a[1][2], a[2][2]] }, fromColumnMajorArray: function (a) {
    return [[a[0], a[3], a[6]], [a[1], a[4], a[7]],
    [a[2], a[5], a[8]]]
  }, fromRowMajorArray: function (a) { return [[a[0], a[1], a[2]], [a[3], a[4], a[5]], [a[6], a[7], a[8]]] }, identity: function () { return [[1, 0, 0], [0, 1, 0], [0, 0, 1]] }, dup: function (a) { return [V3.dup(a[0]), V3.dup(a[1]), V3.dup(a[2])] }, nearlyEqual: function (a, b) { return V3.nearlyEqual(a[0], b[0]) && V3.nearlyEqual(a[1], b[1]) && V3.nearlyEqual(a[2], b[2]) }, transpose: function (a) { return [[a[0][0], a[1][0], a[2][0]], [a[0][1], a[1][1], a[2][1]], [a[0][2], a[1][2], a[2][2]]] }, add: function (a, b) {
    return [V3.add(a[0], b[0]), V3.add(a[1],
      b[1]), V3.add(a[2], b[2])]
  }, multiplyV: function (a, b) { var c = b[0], d = b[1]; b = b[2]; var e = a[0], f = a[1]; a = a[2]; return [e[0] * c + e[1] * d + e[2] * b, f[0] * c + f[1] * d + f[2] * b, a[0] * c + a[1] * d + a[2] * b] }, multiply: function (a, b) {
    var c = a[0][0], d = a[0][1], e = a[0][2], f = a[1][0], g = a[1][1], k = a[1][2], m = a[2][0], n = a[2][1]; a = a[2][2]; var q = b[0][0], u = b[0][1], z = b[0][2], B = b[1][0], p = b[1][1], r = b[1][2], C = b[2][0], A = b[2][1]; b = b[2][2]; return [[c * q + f * u + m * z, d * q + g * u + n * z, e * q + k * u + a * z], [c * B + f * p + m * r, d * B + g * p + n * r, e * B + k * p + a * r], [c * C + f * A + m * b, d * C + g * A + n * b, e * C + k * A + a *
      b]]
  }, scaled: function (a, b) { return [[a[0][0] * b[0], a[0][1] * b[1], a[0][2] * b[2]], [a[1][0] * b[0], a[1][1] * b[1], a[1][2] * b[2]], [a[2][0] * b[0], a[2][1] * b[1], a[2][2] * b[2]]] }, transform: function (a, b) { var c = a[0], d = a[1]; a = a[2]; var e = b[0], f = b[1]; b = b[2]; return [c[0] * e + d[0] * f + a[0] * b, c[1] * e + d[1] * f + a[1] * b, c[2] * e + d[2] * f + a[2] * b] }, rotationXYZ: function (a, b) { b = M33.setFromEuler(b); return b = M33.multiply(a, b) }, rotationX: function (a, b) { var c = Math.cos(b); b = Math.sin(b); return M33.multiply(a, [[1, 0, 0], [0, c, -b], [0, b, c]]) }, rotationY: function (a,
    b) { var c = Math.cos(b); b = Math.sin(b); return M33.multiply(a, [[c, 0, b], [0, 1, 0], [-b, 0, c]]) }, rotationZ: function (a, b) { var c = Math.cos(b); b = Math.sin(b); return M33.multiply(a, [[c, -b, 0], [b, c, 0], [0, 0, 1]]) }, rotationParentFrameX: function (a, b) { var c = Math.cos(b); b = Math.sin(b); return M33.multiply([[1, 0, 0], [0, c, -b], [0, b, c]], a) }, rotationParentFrameY: function (a, b) { var c = Math.cos(b); b = Math.sin(b); return M33.multiply([[c, 0, b], [0, 1, 0], [-b, 0, c]], a) }, rotationParentFrameZ: function (a, b) {
      var c = Math.cos(b); b = Math.sin(b); return M33.multiply([[c,
        -b, 0], [b, c, 0], [0, 0, 1]], a)
    }, rotate: function (a, b, c) { var d = b[0], e = b[1]; b = b[2]; var f = Math.cos(c), g = 1 - f; c = Math.sin(c); return M33.multiply(a, [[d * d * g + f, e * d * g + b * c, b * d * g - e * c], [d * e * g - b * c, e * e * g + f, e * b * g + d * c], [d * b * g + e * c, e * b * g - d * c, b * b * g + f]]) }, transformByTranspose: function (a, b) { return [a[0][0] * b[0] + a[0][1] * b[1] + a[0][2] * b[2], a[1][0] * b[0] + a[1][1] * b[1] + a[1][2] * b[2], a[2][0] * b[0] + a[2][1] * b[1] + a[2][2] * b[2]] }, makeOrthonormalFrame: function (a, b) {
      a = V3.normalize(a); b = V3.normalize(V3.cross(b, a)); var c = V3.cross(b, a); return [b,
        a, c]
    }, setFromEuler: function (a) { var b = Math.cos(a[0]), c = Math.sin(a[0]), d = Math.cos(a[1]), e = Math.sin(a[1]), f = Math.cos(a[2]); a = Math.sin(a[2]); return [[f * d + a * c * e, -a * d + f * c * e, b * e], [a * b, f * b, -c], [f * -e + a * c * d, -a * -e + f * c * d, b * d]] }, getOrientation: function (a) {
      if (a[1][2] > .998) { var b = Math.atan2(-a[2][0], -a[2][1]); var c = -HALF_PI; a = 0 } else a[1][2] < -.998 ? (b = Math.atan2(a[2][0], a[2][1]), c = HALF_PI, a = 0) : (b = Math.atan2(a[1][0], a[1][1]), c = Math.asin(-a[1][2]), a = Math.atan2(a[0][2], a[2][2])); return [b * RAD_TO_DEGREES, c * RAD_TO_DEGREES,
      a * RAD_TO_DEGREES]
    }, toMatrix: function (a) { return a }, toYup: function (a) { var b = a[1], c = a[2]; a[2] = [b[0], b[1], b[2]]; a[1] = [c[0], c[1], c[2]]; b = [a[0][1], a[1][1], a[2][1]]; c = [a[0][2], a[1][2], a[2][2]]; a[0][1] = c[0]; a[1][1] = c[1]; a[2][1] = c[2]; a[0][2] = b[0]; a[1][2] = b[1]; a[2][2] = b[2]; return a }
}; M33.toEuler = M33.getOrientation;
M3 = {
  identity: function () { return [0, 0, 0, 0, 0, 0, 0, 0, 0] }, sub: function (a, b) { for (var c = [], d = 0; d < 9; d++)c[d] = a[d] - b[d]; return c }, add: function (a, b) { for (var c = [], d = 0; d < 9; d++)c[d] = a[d] + b[d]; return c }, dup: function (a) { return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]] }, scale: function (a, b) { for (var c = [], d = 0; d < 9; d++)c[d] = a[d] * b; return c }, toM33: function (a) { return [[a[0], a[1], a[2]], [a[3], a[4], a[5]], [a[6], a[7], a[8]]] }, snapToUnit: function (a) {
    for (var b = 0; b < 9; b++)a[b] < EPSILON && (a[b] = 0), a[b] > ONE_MINUS_EPSILON && (a[b] = 1);
    return a
  }
}; M4 = { fromRowMajorArray: function (a) { return [[a[0], a[1], a[2], a[4]], [a[5], a[6], a[7], a[8]], [a[9], a[10], a[11], a[12]], [a[13], a[14], a[15], a[16]]] }, fromColumnMajorArray: function (a) { return [[a[0], a[4], a[8], a[12]], [a[1], a[5], a[9], a[13]], [a[2], a[6], a[10], a[14]], [a[3], a[7], a[11], a[15]]] } }; var SMALL_NUM = 1E-8;
function intersect_RayTriangle(a, b) { var c = b.u; var d = b.v; var e = b.n; var f = V3.sub(a[1], a[0]); var g = V3.sub(a[0], b[0]); g = -V3.dot(e, g); e = V3.dot(e, f); if (Math.abs(e) < SMALL_NUM) return null; e = g / e; if (e < 0 || e > 1) return null; f = V3.scale(f, e); a = V3.add(a[0], f); f = V3.dot(c, c); e = V3.dot(c, d); g = V3.dot(d, d); b = V3.sub(a, b[0]); c = V3.dot(b, c); d = V3.dot(b, d); b = e * e - f * g; g = (e * d - g * c) / b; if (g < 0 || g > 1) return null; d = (e * c - f * d) / b; return d < 0 || g + d > 1 ? null : { point: a } }
S2 = { identity: function () { return { x: 1, y: 1 } }, mult: function (a, b) { return { x: a.x * b.x, y: a.y * b.y } }, add: function (a, b) { return { x: a.x + b.x, y: a.y + b.y } }, scale: function (a, b) { return { x: a.x * b, y: a.y * b } } }; Math.sign = function (a) { return a < 0 ? -1 : 1 }; Math.maxAbsValue = function (a, b) { return Math.abs(a) > Math.abs(b) ? a : b }; Math.arrayToPrecision = function (a, b) { for (var c = a.length; c >= 0; c--)a[c] && a[c].toFixed && (a[c] = parseFloat(a[c].toFixed(b))); return a }; Math.parity = function (a) { return a % 2 == 0 ? !0 : !1 }; "use strict";
var Object3D = function (a) {
  a = a || {}; this._name = a.name; this._nodeName = a.node; this._children = []; a["3dmodel"] && this.setModel(a["3dmodel"]); this.setLight(a); this._points = a.points || {}; this._collisionPoints = a.collisionPoints || []; var b = this._points, c; for (c in b) b[c].worldPosition = [0, 0, 0]; b = this._collisionPoints; for (c in b) b[c].worldPosition = [0, 0, 0]; this.setInitialRotation(a.rotation); a.modelOnlyRotation && this.setModelOnlyRotation(a.modelOnlyRotation); this.setInitialPosition(a.position); this.setInitialScale(a.scale);
  this.setScale(a.scale); this.visible = !0; this._options = Object.assign({}, a)
};
Object3D.prototype = {
  reset: function () { this.setInitialPosition(this._options.position); this.worldRotation = this._rotation; this.worldPosition = this._position; this.worldScale = this._scale }, setInitialRotation: function (a) { this._initialRotation = M33.identity(); this._initialRotation = M33.rotationXYZ(this._initialRotation, a || [0, 0, 0]); this._rotation = M33.dup(this._initialRotation) }, setModelOnlyRotation: function (a) {
    this._modeOnlyRotation = M33.identity(); this._modeOnlyRotation = M33.rotationXYZ(this._modeOnlyRotation,
      a || [0, 0, 0])
  }, rotateInitialRotation: function (a) { this._initialRotation = M33.rotationXYZ(this._initialRotation, a || [0, 0, 0]); this._rotation = M33.dup(this._initialRotation) }, rotate: function (a) { this._rotation = M33.rotationXYZ(this._rotation, a) }, rotateX: function (a) { this._rotation = M33.rotationX(this._rotation, a) }, rotateY: function (a) { this._rotation = M33.rotationY(this._rotation, a) }, rotateZ: function (a) { this._rotation = M33.rotationZ(this._rotation, a) }, setRotationX: function (a) {
    this._rotation = M33.rotationX(this._initialRotation,
      a)
  }, setRotationY: function (a) { this._rotation = M33.rotationY(this._initialRotation, a) }, setRotationZ: function (a) { this._rotation = M33.rotationZ(this._initialRotation, a) }, rotateParentFrameX: function (a) { this._rotation = M33.rotationParentFrameX(this._rotation, a) }, rotateParentFrameY: function (a) { this._rotation = M33.rotationParentFrameY(this._rotation, a) }, rotateParentFrameZ: function (a) { this._rotation = M33.rotationParentFrameZ(this._rotation, a) }, getRotation: function () { return this._rotation }, setInitialPosition: function (a) {
    this._nodeName &&
      (this._nodeOrigin = a, a = [0, 0, 0]); a = a || [0, 0, 0]; this._initialPosition = V3.dup(a); this._position = V3.dup(this._initialPosition)
  }, setInitialScale: function (a) { a = a || 1; a.length || (a = [a, a, a]); this._initialScale = a }, scale: function (a, b) { a = a || 1; a.length || (a = [a, a, a]); this._scale = V3.mult(this._initialScale, a); b && this.propagateToTree("scale", [a, b]) }, setPosition: function (a) { this._position = a }, translate: function (a) { this._position = V3.add(this._position, a) }, setTranslation: function (a) {
    this._position = V3.add(this._initialPosition,
      a)
  }, setScale: function (a, b) { a = a || 1; a.length || (a = [a, a, a]); this._scale = a; b && this.propagateToTree("setScale", [a, b]) }, getScale: function () { return this._scale }, setOpacity: function (a) { this.model.setOpacity(a || 1) }, setScaleOffset: function (a, b) { this._scaleOffset = a; b && this.propagateToTree("setScaleOffset", [a, b]) }, getPosition: function () { return this._position }, getLocalPosition: function () { var a = this._position; this._parent && (a = V3.add(a, this._parent.getLocalPosition())); return a }, resetAnimatedTransform: function () {
    this._rotation =
      M33.dup(this._initialRotation); this._position = V3.dup(this._initialPosition)
  }, resetRotationMatrix: function () { if (this.htr) { var a = V3.toRadians(this.htr); this.setInitialRotation([a[1], a[2], a[0]]) } }, setPoint: function (a, b) { this._points[a] = b; this.setVectorWorldPosition(this._points[a]) }, setVectorWorldPosition: function (a) { a.worldPosition = M33.transform(this.worldRotation, a); a.worldPosition = V3.add(this.worldPosition, a.worldPosition); a.worldPosition = V3.mult(a.worldPosition, this.worldScale); return a.worldPosition },
  compute: function (a) {
    if (geofs.debugOn && $(".debugBreakOnPartName")[0].checked && $(".debugPartName").val() == this._name) debugger; if (this._parent) {
      this.worldRotation = M33.multiply(this._parent.worldRotation, this._rotation); var b = this._position; this._nodeName && (this._nodeOrigin = this.getNodePosition()) && (b = V3.add(this._position, this._nodeOrigin)); this.worldPosition = M33.transform(this._parent.worldRotation, b); this.worldPosition = V3.add(this.worldPosition, this._parent.worldPosition); this.worldScale = V3.mult(this._scale,
        this._parent.worldScale)
    } else this.worldRotation = this._initialRotation, this.worldPosition = M33.transform(this._initialRotation, this._position), this.worldScale = this._initialScale; b = this._points; for (var c in b) this.setVectorWorldPosition(b[c]); b = this._collisionPoints; c = 0; for (var d = b.length; c < d; c++)this.setVectorWorldPosition(b[c]); !this._nodeName && (c = this._scaleOffset ? V3.scale(this.worldPosition, this._scaleOffset) : this.worldPosition, this.model || this._name == "root") && (b = this.worldRotation, this._modeOnlyRotation &&
      (b = M33.multiply(b, this._modeOnlyRotation)), this.htr = M33.toEuler(b), this.lla = V3.add(a, xyz2lla(c, a))); this.propagateToTree("compute", [a])
  }, render: function (a) {
    var b = this._scaleOffset ? V3.scale(this.worldPosition, this._scaleOffset) : this.worldPosition; if (this.visible) {
      if (this.model) if (this._nodeName) { var c = this.getNode(); c && geofs.api.setNodeRotationTranslationScale(c, this.getRotation(), this.getPosition(), this.getScale(), this.model.forceZup) } else this.model.setPositionOrientationAndScale(this.lla, this.htr,
        this._scale, this); this._light && (this.lla = V3.add(a, xyz2lla(b, a)), this._light && this._light.setLocation(this.lla))
    } this.propagateToTree("render", [a])
  }, setModel: function (a) { this.model = a }, getModel: function (a) { return this.model }, getNode: function () { this._node || (this._node = this.model.getNode(this._nodeName)); return this._node }, getNodePosition: function () { var a = this.getNode(); return this._nodeOrigin ? this._nodeOrigin : a ? this._nodeOrigin = geofs.api.getNodePosition(a, this.model.forceZup) : null }, getNodeRotation: function () {
    var a =
      this.getNode(); return a ? geofs.api.getNodeRotation(a) : M33.identity()
  }, setLight: function (a) { a.lightBillboard && (this._light = a.lightBillboard) }, getWorldFrame: function () { return this.worldRotation }, getWorldPosition: function () { return this.worldPosition }, getLlaLocation: function () { return this.lla }, addChild: function (a) { a._parent = this; this._children.push(a) }, setVisibility: function (a, b) {
    var c = !0; if (a && !b) for (b = this._parent; b && b._options.type != "root";)c = c && b.visible, b = b._parent; b = !0; c && (this.model && (b = this._nodeName ?
      this.model.setNodeVisibilityByName(this._nodeName, a) : this.model.setVisibility(a)), this._light && (b = this._light.setVisibility(a)), this.propagateToTree("setVisibility", [a, !0])); b && (this.visible = a)
  }, findModelInAncestry: function () { for (var a = this; a;) { var b = a.getModel(); if (b) return b; a = a.getParent() } }, getParent: function () { return this._parent }, propagateToTree: function (a, b) { for (var c = this._children, d = 0, e = c.length; d < e; d++) { var f = c[d]; f[a].apply(f, b) } }, destroy: function () {
    this._node = null; this.model && !this.model.detroyed &&
      (this.model.destroy(), this.model = null)
  }
}; Object3D.utilities = { getPointLla: function (a, b) { return a.lla ? a.lla : a.worldPosition ? V3.add(b, xyz2lla(a.worldPosition, b)) : a } }; "use strict"; window.geofs = window.geofs || {};
geofs.trees = {
  qualityLevels: {
    1: { 10: { range: 1, altitude: 1E3 } }, 2: { 10: { range: 1, altitude: 2E3 }, 11: { range: 1, altitude: 1E3 } }, 3: { 10: { range: 1, altitude: 3E3 }, 11: { range: 1, altitude: 2E3 }, 12: { range: 1, altitude: 1E3 } }, 4: { 10: { range: 1, altitude: 4E3 }, 11: { range: 1, altitude: 3E3 }, 12: { range: 2, altitude: 2E3 } }, 5: { 10: { range: 1, altitude: 5E3 }, 11: { range: 1, altitude: 4E3 }, 12: { range: 2, altitude: 3E3 } }, 6: { 10: { range: 2, altitude: 6E3 }, 11: { range: 2, altitude: 5E3 }, 12: { range: 2, altitude: 4E3 } }, 7: {
      10: { range: 2, altitude: 7E3 }, 11: { range: 2, altitude: 6E3 }, 12: {
        range: 3,
        altitude: 5E3
      }
    }
  }, init: function () {
    if (!this.simple3DTileProvider) {
      geofs.trees.shader = new Cesium.CustomShader({
        uniforms: { u_treeTexture: { value: new Cesium.TextureUniform({ url: this.makeTextureURL(), minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR }), type: Cesium.UniformType.SAMPLER_2D } }, varyings: {}, mode: Cesium.CustomShaderMode.REPLACE_MATERIAL, lightingModel: Cesium.LightingModel.UNLIT, translucencyMode: Cesium.CustomShaderTranslucencyMode.OPAQUE, vertexShaderText: "void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput) {}",
        fragmentShaderText: geofsShaders["treesFS.glsl"]
      }); var a = { tilingScheme: new Cesium.WebMercatorTilingScheme({ numberOfLevelZeroTilesX: 1, numberOfLevelZeroTilesY: 1 }), qualityLevels: geofs.trees.qualityLevels, url: geofs.treeServer, extension: geofs.treeServerExtension || ".glb", location: null, rotation: geofs.version >= 4 ? [0, 0, 0] : [90, 0, 0], customShader: geofs.trees.shader, experimental: !0, shadows: SHADOWS_ALL }; this.simple3DTileProvider = new geofs.simple3DTileProvider(a); geofs.trees.seasonChangeHandlerSet = $("body").on("seasonChange",
        function () { geofs.trees.updateSeasonTextures(geofs.season) }); geofs.trees.updateSeasonTextures(geofs.season)
    }
  }, makeTextureURL: function () { var a = geofs.season || "summer"; a != "winter" || weather.isSnowable || (a = "autumn"); return "shaders/trees/" + a + ".png" }, updateSeasonTextures: function () { geofs.trees.shader.setUniform("u_treeTexture", new Cesium.TextureUniform({ url: this.makeTextureURL(), minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR })) }, update: function (a) { this.simple3DTileProvider && this.simple3DTileProvider.update(a) },
  destroy: function () { this.simple3DTileProvider && (this.simple3DTileProvider.destroy(), this.simple3DTileProvider = null, geofs.trees.seasonChangeHandlerSet && (geofs.trees.seasonChangeHandlerSet.off(), geofs.trees.seasonChangeHandlerSet = null)) }
};
geofs.buildings = {
  GLSLReflection: !0, qualityLevels: {
    1: { 10: { range: 1, altitude: 1E4 } }, 2: { 10: { range: 2, altitude: 1E4 }, 11: { range: 2, altitude: 8E3 } }, 3: { 10: { range: 3, altitude: 1E4 }, 11: { range: 3, altitude: 8E3 }, 12: { range: 3, altitude: 6E3 } }, 4: { 10: { range: 4, altitude: 1E4 }, 11: { range: 4, altitude: 9E3 }, 12: { range: 4, altitude: 8E3 }, 13: { range: 4, altitude: 7E3 } }, 5: { 10: { range: 5, altitude: 12E3 }, 11: { range: 5, altitude: 1E4 }, 12: { range: 5, altitude: 9E3 }, 13: { range: 5, altitude: 8E3 } }, 6: {
      10: { range: 6, altitude: 15E3 }, 11: { range: 6, altitude: 12E3 }, 12: {
        range: 6,
        altitude: 1E4
      }, 13: { range: 6, altitude: 8E3 }
    }, 7: { 10: { range: 6, altitude: 15E3 }, 11: { range: 6, altitude: 12E3 }, 12: { range: 6, altitude: 1E4 }, 13: { range: 6, altitude: 8E3 } }
  }, init: function () {
    var a = {
      u_retro: { value: !1, type: Cesium.UniformType.BOOL }, u_buildingTexture: { value: new Cesium.TextureUniform({ url: this.makeTextureURL(), minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR }), type: Cesium.UniformType.SAMPLER_2D }, u_isSnowy: { value: geofs.isSnowy, type: Cesium.UniformType.BOOL }, u_isNight: {
        value: geofs.isNight,
        type: Cesium.UniformType.BOOL
      }
    }; geofs.buildings.GLSLReflection && (a.u_specularTexture = { value: new Cesium.TextureUniform({ url: "shaders/buildings/specular-" + geofs.configuration.current.qualityToBuildingTexture[geofs.preferences.graphics.quality || geofs.preferences.graphics.advanced.viewingDistance || 0] + ".jpg", minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR }), type: Cesium.UniformType.SAMPLER_2D }, a.u_environmentTexture = {
      value: new Cesium.TextureUniform({
        url: "shaders/reflection_city.jpg",
        minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR
      }), type: Cesium.UniformType.SAMPLER_2D
    }); geofs.buildings.buildingsShader = new Cesium.CustomShader({ uniforms: a, varyings: {}, mode: Cesium.CustomShaderMode.REPLACE_MATERIAL, lightingModel: Cesium.LightingModel.UNLIT, vertexShaderText: "void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput) {}", fragmentShaderText: (geofs.buildings.GLSLReflection ? "#define BUILDINGS_REFLECTION\n" : "") + geofsShaders["buildingsFS.glsl"] }); a =
      { tilingScheme: new Cesium.GeographicTilingScheme, qualityLevels: geofs.buildings.qualityLevels, extension: geofs.buildingServerExtension || ".glb", url: geofs.buildingServer, location: null, rotation: geofs.version >= 4 ? [0, 0, 0] : [90, 0, 0], customShader: geofs.buildings.buildingsShader, experimental: !0, shadows: SHADOWS_ALL }; this.simple3DTileProvider = new geofs.simple3DTileProvider(a); geofs.buildings.seasonChangeHandler = $("body").on("seasonChange", function () {
        geofs.buildings.buildingsShader.setUniform("u_isSnowy", geofs.isSnowy);
        geofs.buildings.buildingsShader.setUniform("u_isNight", geofs.isNight); geofs.utils.executeOnceWithinTime(geofs.buildings.updateTextures, 1E3)
      }); geofs.buildings.nightChangeHandler = $("body").on("nightChange", function () { geofs.buildings.buildingsShader.setUniform("u_isNight", geofs.isNight); geofs.utils.executeOnceWithinTime(geofs.buildings.updateTextures, 1E3) }); geofs.buildings.qualityChangeHandler = $("body").on("qualityChange", function () { geofs.utils.executeOnceWithinTime(geofs.buildings.updateTextures, 1E3) })
  },
  update: function (a) { this.simple3DTileProvider && this.simple3DTileProvider.update(a) }, makeTextureURL: function () { return "shaders/buildings/texture" + (geofs.isNight ? "-night" : "") + (geofs.isSnowy ? "-snow" : "") + "-" + geofs.configuration.current.qualityToBuildingTexture[geofs.preferences.graphics.quality || geofs.preferences.graphics.advanced.viewingDistance || 0] + ".jpg" }, updateTextures: function () {
    geofs.buildings.buildingsShader.setUniform("u_buildingTexture", new Cesium.TextureUniform({
      url: geofs.buildings.makeTextureURL(),
      minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR
    })); geofs.buildings.GLSLReflection && (geofs.buildings.buildingsShader.setUniform("u_specularTexture", new Cesium.TextureUniform({ url: "shaders/buildings/specular-" + geofs.configuration.current.qualityToBuildingTexture[geofs.preferences.graphics.quality || geofs.preferences.graphics.advanced.viewingDistance || 0] + ".jpg", minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR })), geofs.buildings.buildingsShader.setUniform("u_environmentTexture",
      new Cesium.TextureUniform({ url: "shaders/reflection_city" + (geofs.isNight ? "-night" : "") + ".jpg", minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR })))
  }, destroy: function () {
    this.simple3DTileProvider && (this.simple3DTileProvider.destroy(), this.simple3DTileProvider = null, geofs.buildings.nightChangeHandler && (geofs.buildings.nightChangeHandler.off(), geofs.buildings.nightChangeHandler = null), geofs.buildings.qualityChangeHandler && (geofs.buildings.qualityChangeHandler.off(), geofs.buildings.qualityChangeHandler =
      null), geofs.buildings.seasonChangeHandler && (geofs.buildings.seasonChangeHandler.off(), geofs.buildings.seasonChangeHandler = null))
  }
}; geofs.simple3DTileProvider = function (a) { this.tilingScheme = a.tilingScheme; this.options = a; this.tiles = {} };
geofs.simple3DTileProvider.prototype = {
  update: function (a) {
    var b = {}, c = this.options.qualityLevels[geofs.preferences.graphics.quality || geofs.preferences.graphics.advanced.viewingDistance], d; for (d in c) { var e = c[d]; if (!(a[2] > e.altitude)) { var f = this.coords2tile(a[0], a[1], parseInt(d)); geofs.tile2Grid(e.range, f).forEach(function (k) { var m = d + "_" + k.x + "_" + k.y; k.id = m; k.z = d; b[m] = k }) } } for (var g in this.tiles) b[g] || this.unloadTile(g); if (!geofs.cautiousWithTerrain) for (g in b) this.tiles[g] || (this.loadTile(b[g]), this.tiles[g] =
      b[g])
  }, loadTile: function (a) { var b = this.tile2coords(a.x, a.y, a.z); b[2] = 0; a.model = new geofs.api.Model(null, { url: this.options.url + a.id + (this.options.extension || ".glb"), location: b, rotation: this.options.rotation, customShader: this.options.customShader, experimental: this.options.experimental, shadows: this.options.shadows, environmentMapOptions: { enabled: !1 }, releaseGltfJson: !0 }) }, unloadTile: function (a) { this.tiles[a].model && this.tiles[a].model.destroy(); delete this.tiles[a] }, destroy: function () { for (var a in this.tiles) this.unloadTile(a) },
  coords2tile: function (a, b, c) { a = new Cesium.Cartographic(b * DEGREES_TO_RAD, a * DEGREES_TO_RAD, 0); return this.tilingScheme.positionToTileXY(a, c) }, tile2coords: function (a, b, c) { a = this.tilingScheme.tileXYToRectangle(a, b, c, new Cesium.Rectangle); return [a.south * RAD_TO_DEGREES, a.west * RAD_TO_DEGREES] }
}; "use strict"; window.geofs = window.geofs || {}; geofs.api = {}; geofs.api.march2019theTwentyFirst = 2458563; geofs.api.halfADayInSeconds = 43200; geofs.api.overlayBaseZIndex = 60; geofs.api.ALTITUDE_RELATIVE = "ALTITUDE_RELATIVE";
geofs.api.CLAMP_TO_GROUND = "CLAMP_TO_GROUND"; geofs.api.nativeMouseHandling = !1; geofs.api.maximumUpsamplingResolution = 20;
geofs.api.initWorld = function (a, b) {
  b = b || {}; Cesium.Ion.defaultAccessToken = geofs.ionkey; var c = {
    animation: !1, geocoder: !1, homeButton: !1, infoBox: !1, selectionIndicator: !1, sceneModePicker: !1, baseLayerPicker: !1, timeline: !1, navigationHelpButton: !1, navigationInstructionsInitiallyVisible: !1, fullscreenButton: !1, scene3DOnly: !0, clock: new Cesium.Clock({ currentTime: new Cesium.JulianDate(geofs.api.march2019theTwentyFirst, 43200) }), showRenderLoopErrors: geofs.debugOn, requestRenderMode: !0, maximumUpsamplingResolution: geofs.api.maximumUpsamplingResolution,
    useBrowserRecommendedResolution: !1, contextOptions: { requestWebgl2: !0, webgl: {} }, msaaSamples: 1, orderIndependentTranslucency: !1, useDefaultRenderLoop: !0
  }; geofs.version >= 4 ? c.baseLayer = new Cesium.ImageryLayer(new Cesium.UrlTemplateImageryProvider({ url: Cesium.buildModuleUrl("Assets/Textures/NaturalEarthII/{z}/{x}/{reverseY}.jpg"), tilingScheme: new Cesium.GeographicTilingScheme({ numberOfLevelZeroTilesX: 2, numberOfLevelZeroTilesY: 1 }), maximumLevel: 2 })) : c.imageryProvider = new Cesium.UrlTemplateImageryProvider({
    url: Cesium.buildModuleUrl("Assets/Textures/NaturalEarthII/{z}/{x}/{reverseY}.jpg"),
    tilingScheme: new Cesium.GeographicTilingScheme({ numberOfLevelZeroTilesX: 2, numberOfLevelZeroTilesY: 1 }), maximumLevel: 2
  }); geofs.PRODUCTION || (c.contextOptions.webgl.preserveDrawingBuffer = !0); geofs.androidViewerOptions = geofs.androidViewerOptions || {}; geofs.iosViewerOptions = geofs.iosViewerOptions || {}; Object.assign(c, geofs.androidViewerOptions, geofs.iosViewerOptions, b); try {
    geofs.api.viewer = new Cesium.Viewer(a, c), c.useDefaultRenderLoop || (geofs.renderLoop = function () { geofs.pause || geofs.api.viewer.render(); requestAnimationFrame(geofs.renderLoop) },
      geofs.renderLoop())
  } catch (d) { geofs.debug.error(d, "geofs.api.initWorld"); geofs.api.notify('An error occured while creating the WebGL environment. Please visit the <a href="/pages/instructions.php">instructions page</a> or contact support@geo-fs.com for more details'); return } geofs.version >= 4 ? function () {
    var d, e, f; return (0, $jscomp.asyncExecutePromiseGeneratorProgram)(function (g) {
      if (g.nextAddress == 1) return d = geofs.api, e = d.setTerrainProvider, f = geofs.api.FlatRunwayTerrainProvider, g.yield(Cesium.CesiumTerrainProvider.fromUrl(geofs.srtmServer,
        { requestWaterMask: !1, requestVertexNormals: !0, requestMetadata: !1 }), 2); e.call(d, new f({ baseProvider: g.yieldResult, bypass: !1, maximumLevel: 12 }), "geofs"); g.jumpToEnd()
    })
  }() : geofs.api.setTerrainProvider(new geofs.api.FlatRunwayTerrainProvider({ baseProvider: new Cesium.CesiumTerrainProvider({ url: geofs.srtmServer, requestWaterMask: !1, requestVertexNormals: !0 }), bypass: !1, maximumLevel: 12 }), "geofs"); geofs.api.viewer.scene.skyBox = new Cesium.SkyBox({
    sources: {
      positiveX: "images/skybox/tycho2t3_80_px.png", negativeX: "images/skybox/tycho2t3_80_mx.png",
      positiveY: "images/skybox/tycho2t3_80_py.png", negativeY: "images/skybox/tycho2t3_80_my.png", positiveZ: "images/skybox/tycho2t3_80_pz.png", negativeZ: "images/skybox/tycho2t3_80_mz.png"
    }
  }); geofs.api.viewer.scene.moon.textureUrl = "images/moonSmall.jpg"; geofs.api.viewer.scene.globe.enableLighting = !1; geofs.api.viewer.scene.globe.lambertDiffuseMultiplier = 10; geofs.api.viewer.scene.sun.show = !0; geofs.api.viewer.scene.globe.maximumUpsamplingLevel = 22; geofs.api.viewer.scene.globe.depthTestAgainstTerrain = !0; geofs.api.viewer.scene.globe.showWaterEffect =
    !1; geofs.api.viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString("#4b5e27"); geofs.api.labels = geofs.api.viewer.scene.primitives.add(new Cesium.LabelCollection); geofs.api.billboards = {
      "default": geofs.api.viewer.scene.primitives.add(new Cesium.BillboardCollection({ scene: geofs.api.viewer.scene, blendOption: Cesium.BlendOption.OPAQUE_AND_TRANSLUCENT })), opaque: geofs.api.viewer.scene.primitives.add(new Cesium.BillboardCollection({ scene: geofs.api.viewer.scene, blendOption: Cesium.BlendOption.OPAQUE })),
      translucent: geofs.api.viewer.scene.primitives.add(new Cesium.BillboardCollection({ scene: geofs.api.viewer.scene, blendOption: Cesium.BlendOption.TRANSLUCENT }))
    }; geofs.api.models = geofs.api.viewer.scene.primitives.add(new Cesium.PrimitiveCollection({ destroyPrimitives: !1 })); geofs.api.viewer.scene.preRender.addEventListener(geofs.api.frameCallbackWrapper); $(".geofs-ui-3dview").trigger("rendererInitDone"); geofs.api.viewer.scene.renderError.addEventListener(function (d) {
      geofs.debug.error(d, "geofs.api.viewer.scene.renderError");
      geofs.api.notify("GeoFS encountered an error. If this persists, try to reset preferences to default and refresh the page.")
    })
}; geofs.api.destroyWorld = function () { geofs.api.viewer.scene.preRender.removeEventListener(geofs.api.frameCallbackWrapper) }; geofs.api.triggerExplicitRendering = function () { geofs.api.viewer.scene.requestRender() }; geofs.frameCallbackStack = {};
geofs.api.addFrameCallback = function (a, b, c) { b = b || "global"; geofs.frameCallbackStack[b] || (geofs.frameCallbackStack[b] = { callbacks: {}, lastId: 0, maxExecutionTime: c, lastIndex: 1 }); geofs.frameCallbackStack[b].lastId++; geofs.frameCallbackStack[b].callbacks[geofs.frameCallbackStack[b].lastId] = a; return geofs.frameCallbackStack[b].lastId }; geofs.api.removeFrameCallback = function (a, b) { b = b || "global"; geofs.frameCallbackStack[b] && delete geofs.frameCallbackStack[b].callbacks[a] };
geofs.api.frameCallbackWrapper = function (a, b) {
  geofs.api.precisionTime = geofs.utils.now(); for (var c in geofs.frameCallbackStack) if (a = geofs.frameCallbackStack[c], a.maxExecutionTime > 0) { var d = a.lastIndex; do { try { a.callbacks[d](geofs.api.precisionTime) } catch (e) { geofs.debug.error(e, "geofs.api.frameCallbackWrapper maxExecutionTime"), geofs.debug.throw(e) } d++; d > a.lastId && (d = 1) } while (geofs.api.precisionTime + a.maxExecutionTime > geofs.utils.now()); a.lastIndex = d } else for (d in a.callbacks) try { a.callbacks[d](geofs.api.precisionTime) } catch (e) {
    geofs.debug.error(e,
      "geofs.api.frameCallbackWrapper general"), geofs.debug.throw(e)
  }
}; geofs.api.setOutsideShadowDistance = function (a) { geofs.camera.currentDefinition.insideView || (geofs.api.viewer.shadowMap.maximumDistance = a) }; geofs.api.configureOutsideView = function () { geofs.api.viewer.shadowMap.maximumDistance = geofs.api.renderingSettings.shadowDistance || 1E3; geofs.api.viewer.shadowMap.darkness = .5; geofs.api.camera.frustum.near = 1 };
geofs.api.configureInsideView = function () { geofs.api.viewer.shadowMap.maximumDistance = geofs.aircraft.instance.definition.cockpitShadowMapMaxDistance || 100; geofs.api.viewer.shadowMap.darkness = .5; geofs.api.camera.frustum.near = .1 }; geofs.api.setGlobeLighting = function (a) { geofs.api.viewer.scene.globe.enableLighting = a; a ? geofs.api.renderingSettings.dropShadow && (geofs.api.viewer.scene.globe.shadows = Cesium.ShadowMode.RECEIVE_ONLY) : geofs.api.viewer.scene.globe.shadows = Cesium.ShadowMode.DISABLED };
geofs.api.setSceneLight = function (a, b) { geofs.api.viewer.scene.light.color = a || geofs.api.viewer.scene.light.color; geofs.api.viewer.scene.light.intensity = (b || geofs.api.viewer.scene.light.intensity) * 2; geofs.api.googleTileset && geofs.api.googleTileset.customShader.setUniform("u_lightIntensity", b || 1) }; geofs.api.setWaterEffect = function (a) { a ? (geofs.fx.water.create(), geofs.api.waterDetection.create(), geofs.fx.wake.create()) : (geofs.fx.water.destroy(), geofs.api.waterDetection.destroy(), geofs.fx.wake.destroy()) };
geofs.api.setVegetation = function (a) { a ? geofs.trees.init() : geofs.trees.destroy() }; geofs.api.setBuildings = function (a) { a ? geofs.buildings.init() : geofs.buildings.destroy() }; geofs.api.setHD = function (a) { geofs.api.hdOn !== a && (geofs.api.hdOn = a, geofs.api.setDataProvider(a ? "hd" : "sr")) }; geofs.api.setDataProvider = function (a) { geofs.api.dataProvider != a && (a = { method: "doGeoIp", dataprovider: a }, $(".geofs-apiResponse").htmlView("load", "/backend/accounts/hd.php", a)) };
geofs.api.setTerrainProvider = function (a, b) { b && geofs.api.terrainProviderName == b || (geofs.api.viewer.terrainProvider = a, geofs.api.terrainProviderName = b) };
geofs.api.setImageryProvider = function (a, b, c, d, e, f) {
  if (!f || geofs.api.imageryProviderName != f) {
    var g = geofs.api.viewer.imageryLayers; g.remove(g.get(0), !0); a = g.addImageryProvider(a, 0); geofs.runways.setRunwayModelVisibility(b || geofs.preferences.graphics.runways && geofs.api.dataProvider == "sr"); geofs.api.setImageryColorModifier("multiplier", { brightness: c || 1, contrast: d || 1, saturation: e || 1 }); geofs.preferences && geofs.preferences.graphics && geofs.api.enhanceColors(geofs.preferences.graphics.enhanceColors); geofs.api.imageryProviderName =
      f; return a
  }
};
geofs.api.setGoogleTiles = function (a) {
  var b; return (0, $jscomp.asyncExecutePromiseGeneratorProgram)(function (c) {
    if (c.nextAddress == 1) {
      if (a === !1 && geofs.api.googleTileset) return geofs.api.googleTileset.tileLoadListener(), geofs.api.viewer.scene.primitives.remove(geofs.api.googleTileset), geofs.api.googleTileset = null, geofs.api.setVegetation(geofs.preferences.graphics.vegetation), geofs.api.setBuildings(geofs.preferences.graphics.buildings), geofs.objects.init(), geofs.api.viewer.scene.globe.show = !0, c.return();
      if (!a || geofs.api.googleTileset) return c.jumpTo(0); Cesium.GoogleMaps.defaultApiKey = geofs.googleAPIKey; geofs.api.setVegetation(!1); geofs.api.setBuildings(!1); geofs.api.viewer.scene.globe.show = !1; geofs.api.viewer.terrainProvider = null; geofs.api.hdOn = null; geofs.api.terrainProviderName = "google"; geofs.api.imageryProviderName = "google"; geofs.configuration.applyConfiguration(geofs.configuration.google); geofs.api.renderingQuality(); geofs.objects.destroy(); c.setCatchFinallyBlocks(3); b = geofs.api; return c.yield(Cesium.createGooglePhotorealistic3DTileset(),
        5)
    } if (c.nextAddress != 3) return b.googleTileset = c.yieldResult, geofs.api.viewer.scene.primitives.add(geofs.api.googleTileset), geofs.api.googleTileset.tileLoadListener = geofs.api.googleTileset.tileVisible.addEventListener(function (d) { geofs.fx.globeLoaded = !0; $("body").trigger("globeLoaded"); geofs.api.googleTileset.tileLoadListener() }), geofs.api.googleTileset.enableCollision = !1, geofs.api.googleTileset.foveatedScreenSpaceError = !1, geofs.api.googleTileset.cullRequestsWhileMoving = !1, geofs.api.googleTileset.cacheBytes =
      536870912, geofs.api.googleTileset.maximumCacheOverflowBytes = 536870912, geofs.api.googleTileset.dynamicScreenSpaceError = !0, geofs.api.googleTileset.dynamicScreenSpaceErrorDensity = 1, geofs.api.googleTileset.dynamicScreenSpaceErrorFactor = 24, geofs.api.googleTileset.shadows = Cesium.ShadowMode.RECEIVE_ONLY, geofs.api.renderingSettings.adaptativeRenderingQuality = !1, geofs.api.googleTileset.customShader = new Cesium.CustomShader({
        varyings: {}, uniforms: {
          u_normalMap: {
            value: new Cesium.TextureUniform({ url: "/shaders/oceannormal2.jpg" }),
            type: Cesium.UniformType.SAMPLER_2D
          }, u_foamTexture: { value: new Cesium.TextureUniform({ url: "/shaders/seafoam.jpg" }), type: Cesium.UniformType.SAMPLER_2D }, u_horizonColor: { value: Cesium.Color.fromCssColorString("#f1f9fbff"), type: Cesium.UniformType.VEC4 }, u_azimutColor: { value: Cesium.Color.fromCssColorString("#38618aff"), type: Cesium.UniformType.VEC4 }, u_geofsTime: { value: 0, type: Cesium.UniformType.FLOAT }, u_windSpeed: { value: weather.currentWindSpeedMs || 0, type: Cesium.UniformType.FLOAT }, u_earthRadius: {
            value: 6378137,
            type: Cesium.UniformType.FLOAT
          }, u_lightIntensity: { value: 1, type: Cesium.UniformType.FLOAT }
        }, mode: Cesium.CustomShaderMode.MODIFY_MATERIAL, lightingModel: Cesium.LightingModel.UNLIT, translucencyMode: Cesium.CustomShaderTranslucencyMode.OPAQUE, vertexShaderText: geofsShaders["googleVS.glsl"], fragmentShaderText: geofsShaders["googleFS.glsl"]
      }), c.leaveTryBlock(0); c.enterCatchBlock(); console.log("Failed to load tileset"); c.jumpToEnd()
  })
};
geofs.api.updateGoogleTiles = function (a) { geofs.api.googleTileset && (a = geofs.api.viewer.scene.globe.ellipsoid.cartographicToCartesian(new Cesium.Cartographic(a[1] * DEGREES_TO_RAD, a[0] * DEGREES_TO_RAD, 0)), a = Cesium.Cartesian3.magnitude(a), geofs.api.googleTileset.customShader.setUniform("u_earthRadius", a)) };
geofs.api.setDebugImageryProvider = function () { geofs.api.viewer.imageryLayers.addImageryProvider(new Cesium.TileCoordinatesImageryProvider({ tilingScheme: new Cesium.WebMercatorTilingScheme({ numberOfLevelZeroTilesX: 1, numberOfLevelZeroTilesY: 1 }) })) }; geofs.api.setTimeAndDate = function (a, b) { geofs.api.viewer.clock.shouldAnimate = !0; geofs.api.viewer.clock.currentTime = new Cesium.JulianDate(geofs.api.march2019theTwentyFirst + (b || 0), a - geofs.api.halfADayInSeconds) };
geofs.api.setClock = function (a) { geofs.api.viewer.clock.multiplier = 1; geofs.api.viewer.clock.currentTime = Cesium.JulianDate.fromDate(a); geofs.api.viewer.clock.shouldAnimate = !0 }; geofs.api.isWebXRAvailable = function () { return !!navigator.xr };
geofs.api.toggleVr = function () {
  function a(d, e) { d = e.session; d.requestAnimationFrame(a); if (e = e.getViewerPose(b)) !geofs.XRFov && e.views && e.views[0] && (geofs.XRFov = 2 * Math.atan(1 / e.views[0].projectionMatrix[5]) * 180 / PI, geofs.api.setFOV(geofs.camera.cam, geofs.XRFov)), d = d.renderState.baseLayer, c.bindFramebuffer(c.FRAMEBUFFER, d.framebuffer), c.clear(c.COLOR_BUFFER_BIT | c.DEPTH_BUFFER_BIT), geofs.api.viewer.scene._defaultView.passState.XRViews = e.views, geofs.api.viewer.scene._defaultView.passState.XRglLayer = d, geofs.api.viewer.scene.render() }
  if (navigator.xr) if (geofs.vrOn) geofs.vrOn = !1, geofs.api.viewer.scene.useWebVR = !1, geofs.api.XRSession && geofs.api.XRSession.end(); else {
    geofs.vrOn = !0; geofs.api.viewer.scene.useWebVR = !0; geofs.camera.set(null, "cockpit"); var b, c; navigator.xr.requestSession("immersive-vr").then(function (d) {
      c = geofs.api.viewer.scene._context._gl; geofs.api.XRSession = d; d.addEventListener("end", function () { geofs.XRFov = null }); d.updateRenderState({ baseLayer: new XRWebGLLayer(d, c) }); d.requestReferenceSpace("local").then(function (e) {
        b =
          e; d.requestAnimationFrame(a)
      })
    })
  }
}; geofs.api.enhanceColors = function (a) { a = a || 0; geofs.api.setImageryColorModifier("enhancement", { contrast: 1 + .5 * a, saturation: 1 + .5 * a }) }; geofs.api.defaultImageryColorModifier = { brightness: 1, contrast: 1, saturation: 1, gamma: 1, hue: 0 }; geofs.api.imageryColorModifiers = {}; geofs.api.setImageryColorModifier = function (a, b) { b = Object.assign({}, geofs.api.defaultImageryColorModifier, b); geofs.api.imageryColorModifiers[a || "base"] = b; geofs.api.applyImageryColorModifiers() };
geofs.api.removeImageryColorModifier = function (a) { delete geofs.api.imageryColorModifiers[a]; geofs.api.applyImageryColorModifiers() };
geofs.api.applyImageryColorModifiers = function () {
  geofs.api.imageryColors = Object.assign({}, geofs.api.defaultImageryColorModifier); for (var a in geofs.api.imageryColorModifiers) geofs.api.imageryColors.brightness *= geofs.api.imageryColorModifiers[a].brightness, geofs.api.imageryColors.contrast *= geofs.api.imageryColorModifiers[a].contrast, geofs.api.imageryColors.saturation *= geofs.api.imageryColorModifiers[a].saturation, geofs.api.imageryColors.gamma *= geofs.api.imageryColorModifiers[a].gamma, geofs.api.imageryColors.hue +=
    geofs.api.imageryColorModifiers[a].hue; geofs.api.setImageryBrightness(geofs.api.imageryColors.brightness); geofs.api.setImageryContrast(geofs.api.imageryColors.contrast); geofs.api.setImagerySaturation(geofs.api.imageryColors.saturation); geofs.api.setImageryGamma(geofs.api.imageryColors.gamma); geofs.api.setImageryHue(geofs.api.imageryColors.hue)
}; geofs.api.setImageryBrightness = function (a) { var b = geofs.api.viewer.imageryLayers.get(0); a && (b.brightness = a); return b.brightness };
geofs.api.setImageryContrast = function (a) { var b = geofs.api.viewer.imageryLayers.get(0); a && (b.contrast = a); return b.contrast }; geofs.api.setImagerySaturation = function (a) { var b = geofs.api.viewer.imageryLayers.get(0); a && (b.saturation = a); return b.saturation }; geofs.api.setImageryHue = function (a) { var b = geofs.api.viewer.imageryLayers.get(0); b.hue = a || 0; return b.hue }; geofs.api.setImageryGamma = function (a) { var b = geofs.api.viewer.imageryLayers.get(0); a && (b.gamma = a); return b.gamma };
geofs.api.defaultAtmosphereColorModifier = { brightnessShift: 0, saturationShift: 0, hueShift: 0, groundBrightnessShift: 0, groundSaturationShift: 0, groundHueShift: 0, fogBrightness: 1, cloudsBrightness: 1 }; geofs.api.atmosphereColorModifiers = {}; geofs.api.setAtmosphereColorModifier = function (a, b) { a = a || "base"; b = Object.assign({}, geofs.api.defaultAtmosphereColorModifier, geofs.api.atmosphereColorModifiers[a] || {}, b); geofs.api.atmosphereColorModifiers[a] = b; geofs.api.applyAtmosphereColorModifiers() };
geofs.api.removeAtmosphereColorModifier = function (a) { delete geofs.api.atmosphereColorModifiers[a]; geofs.api.applyAtmosphereColorModifiers() };
geofs.api.applyAtmosphereColorModifiers = function () {
  geofs.api.atmosphereColors = Object.assign({}, geofs.api.defaultAtmosphereColorModifier); for (var a in geofs.api.atmosphereColorModifiers) geofs.api.atmosphereColors.brightnessShift += geofs.api.atmosphereColorModifiers[a].brightnessShift, geofs.api.atmosphereColors.saturationShift += geofs.api.atmosphereColorModifiers[a].saturationShift, geofs.api.atmosphereColors.hueShift += geofs.api.atmosphereColorModifiers[a].hueShift, geofs.api.atmosphereColors.groundBrightnessShift +=
    geofs.api.atmosphereColorModifiers[a].groundBrightnessShift, geofs.api.atmosphereColors.groundHueShift += geofs.api.atmosphereColorModifiers[a].groundHueShift, geofs.api.atmosphereColors.groundSaturationShift += geofs.api.atmosphereColorModifiers[a].groundSaturationShift, geofs.api.atmosphereColors.fogBrightness *= geofs.api.atmosphereColorModifiers[a].fogBrightness, geofs.api.atmosphereColors.cloudsBrightness *= geofs.api.atmosphereColorModifiers[a].cloudsBrightness; geofs.api.viewer.scene.skyAtmosphere.brightnessShift =
      geofs.api.atmosphereColors.brightnessShift; geofs.api.viewer.scene.skyAtmosphere.saturationShift = geofs.api.atmosphereColors.saturationShift; geofs.api.viewer.scene.skyAtmosphere.hueShift = geofs.api.atmosphereColors.hueShift; geofs.api.viewer.scene.globe.atmosphereBrightnessShift = clamp(geofs.api.atmosphereColors.groundBrightnessShift, -1, 1); geofs.api.viewer.scene.globe.atmosphereHueShift = clamp(geofs.api.atmosphereColors.groundHueShift, -1, 1); geofs.api.viewer.scene.globe.atmosphereSaturationShift = clamp(geofs.api.atmosphereColors.groundSaturationShift,
        -1, 1); geofs.api.viewer.scene.fog.minimumBrightness = geofs.api.atmosphereColors.fogBrightness; geofs.fx.cloudManager.setCloudsBrightness(geofs.api.atmosphereColors.cloudsBrightness)
}; geofs.api.showSun = function () { }; geofs.api.hideSun = function () { }; geofs.api.advancedRenderingQuality = function () { geofs.api.renderingQuality(null, !0) }; geofs.api.renderingSettings = Object.assign({}, geofs.configuration.current.renderingQualityLevels[0]);
geofs.api.renderingQuality = function (a, b) {
  if (geofs.api.viewer) {
    var c = geofs.api.viewer.scene.highDynamicRange = !1; a = a || geofs.preferences.graphics.quality; if (b || a != geofs.preferences.graphics.quality) c = !0; geofs.preferences.graphics.quality = a; a == 0 && (b = !0); geofs.configuration.current.renderingQualityLevels[a] || (geofs.api.notify("An error occurred while applying preferences. Settings are reset to default."), geofs.resetPreferences()); geofs.api.renderingSettings.viewingDistance = geofs.configuration.current.renderingQualityLevels[a].viewingDistance;
    geofs.api.renderingSettings.resolutionScale = geofs.configuration.current.renderingQualityLevels[a].resolutionScale; geofs.api.renderingSettings.tileCacheSize = geofs.configuration.current.renderingQualityLevels[a].tileCacheSize; geofs.api.renderingSettings.fxaa = geofs.configuration.current.renderingQualityLevels[a].fxaa; geofs.api.renderingSettings.msaaSamples = geofs.configuration.current.renderingQualityLevels[a].msaaSamples; geofs.api.renderingSettings.globeLighting = geofs.configuration.current.renderingQualityLevels[a].globeLighting;
    geofs.api.renderingSettings.dropShadow = geofs.configuration.current.renderingQualityLevels[a].dropShadow; geofs.api.renderingSettings.cloudCoverToCloudNumber = geofs.configuration.current.renderingQualityLevels[a].cloudCoverToCloudNumber; geofs.api.renderingSettings.shadowMapSize = geofs.configuration.current.renderingQualityLevels[a].shadowMapSize; geofs.api.renderingSettings.shadowDistance = geofs.configuration.current.renderingQualityLevels[a].shadowDistance; geofs.api.renderingSettings.advancedAtmosphere =
      geofs.preferences.graphics.advancedAtmosphere; geofs.api.renderingSettings.scatteringQuality = geofs.configuration.current.renderingQualityLevels[a].scatteringQuality; geofs.api.renderingSettings.volumetricClouds = geofs.preferences.graphics.volumetricClouds && geofs.api.renderingSettings.advancedAtmosphere; geofs.api.renderingSettings.lowResRunways = geofs.configuration.current.renderingQualityLevels[a].lowResRunways; if (b) {
        $('[data-gespref="geofs.preferences.graphics.quality"]').addClass("geofs-disabled");
        $(".geofs-advancedGraphics .slider").removeClass("geofs-disabled"); $(".geofs-advancedGraphics.geofs-advanced").addClass("geofs-expanded"); geofs.preferences.graphics.quality = 0; geofs.api.renderingSettings.resolutionScale = geofs.preferences.graphics.advanced.resolutionScale; geofs.api.renderingSettings.viewingDistance = geofs.preferences.graphics.advanced.viewingDistance; if (geofs.api.renderingSettings.viewingDistance < 1 || geofs.api.renderingSettings.viewingDistance > 7) geofs.api.renderingSettings.viewingDistance =
          3; geofs.api.renderingSettings.lowResRunways = geofs.api.renderingSettings.viewingDistance <= 3; geofs.api.renderingSettings.fxaa = geofs.preferences.graphics.advanced.fxaa; geofs.api.renderingSettings.msaaSamples = geofs.preferences.graphics.advanced.msaaSamples; geofs.preferences.graphics.advanced.msaaSamples == 1 ? $('[data-gespref="geofs.preferences.graphics.advanced.msaaSamples"] .slider-input').val("OFF") : null; geofs.api.renderingSettings.tileCacheSize = geofs.preferences.graphics.advanced.tileCacheSize; geofs.api.renderingSettings.globeLighting =
            geofs.preferences.graphics.advanced.globeLighting; geofs.api.renderingSettings.dropShadow = geofs.preferences.graphics.advanced.dropShadow; geofs.api.renderingSettings.softShadows = geofs.preferences.graphics.advanced.softShadows; geofs.api.renderingSettings.scatteringQuality = geofs.preferences.graphics.advanced.scatteringQuality; geofs.api.renderingSettings.cloudCoverToCloudNumber = geofs.configuration.current.renderingQualityLevels[0].cloudCoverToCloudNumber * geofs.preferences.graphics.advanced.cloudDensity;
        geofs.api.renderingSettings.shadowMapSize = geofs.configuration.current.renderingQualityLevels[0].shadowMapSize * geofs.preferences.graphics.advanced.shadowQuality; geofs.api.renderingSettings.shadowDistance = geofs.configuration.current.renderingQualityLevels[0].shadowDistance * geofs.preferences.graphics.advanced.shadowQuality
      } else $('[data-gespref="geofs.preferences.graphics.quality"]').removeClass("geofs-disabled"), $(".geofs-advancedGraphics .slider").addClass("geofs-disabled"), geofs.preferences.graphics.advanced.resolutionScale =
        geofs.api.renderingSettings.resolutionScale, geofs.preferences.graphics.advanced.viewingDistance = geofs.configuration.current.renderingQualityLevels[a].viewingDistance, geofs.preferences.graphics.advanced.tileCacheSize = geofs.api.renderingSettings.tileCacheSize, geofs.preferences.graphics.advanced.fxaa = geofs.api.renderingSettings.fxaa, geofs.preferences.graphics.advanced.msaaSamples = geofs.api.renderingSettings.msaaSamples, geofs.preferences.graphics.advanced.globeLighting = geofs.api.renderingSettings.globeLighting,
        geofs.preferences.graphics.advanced.dropShadow = geofs.api.renderingSettings.dropShadow, geofs.preferences.graphics.advanced.softShadows = !1, geofs.api.renderingSettings.softShadows = !1, geofs.preferences.graphics.advanced.shadowQuality = geofs.api.renderingSettings.shadowMapSize / geofs.configuration.current.renderingQualityLevels[0].shadowMapSize, geofs.preferences.graphics.advanced.scatteringQuality = geofs.api.renderingSettings.scatteringQuality, geofs.preferences.graphics.advanced.cloudDensity = geofs.api.renderingSettings.cloudCoverToCloudNumber /
        geofs.configuration.current.renderingQualityLevels[0].cloudCoverToCloudNumber, geofs.setPreferenceValues($(".geofs-advancedGraphics"), !0); geofs.preferences.graphics.advancedAtmosphere ? $('[for="volumetricClouds"]').show() : $('[for="volumetricClouds"]').hide(); geofs.api.renderingSettings.volumetricClouds ? $('[data-gespref="geofs.preferences.graphics.advanced.cloudDensity"]').hide() : $('[data-gespref="geofs.preferences.graphics.advanced.cloudDensity"]').show(); geofs.fx.atmosphere.create(geofs.api.renderingSettings.advancedAtmosphere,
          geofs.api.renderingSettings.scatteringQuality, geofs.api.renderingSettings.volumetricClouds, !geofs.preferences.weather.manual); geofs.api.viewer.scene.fog.enabled = !0; geofs.api.renderingSettings.physicsDeltaMs = geofs.configuration.current.physics.deltaMs[geofs.api.renderingSettings.viewingDistance]; geofs.api.renderingSettings.degradedCollisions = geofs.configuration.current.physics.degradedCollisions[geofs.api.renderingSettings.viewingDistance]; geofs.api.renderingSettings.fogDensity = geofs.configuration.current.screenSpacePresets.fogDensity[geofs.api.renderingSettings.viewingDistance];
    geofs.api.renderingSettings.maximumScreenSpaceError = geofs.configuration.current.screenSpacePresets.maximumScreenSpaceError[geofs.api.renderingSettings.viewingDistance]; geofs.api.renderingSettings.fogScreenSpaceErrorFactor = geofs.configuration.current.screenSpacePresets.fogScreenSpaceErrorFactor[geofs.api.renderingSettings.viewingDistance]; geofs.api.renderingSettings.buildingCollision && (geofs.api.renderingSettings.degradedCollisions = !0); geofs.api.viewer.scene.fog.density = geofs.api.renderingSettings.fogDensity;
    geofs.api.viewer.scene.globe.maximumScreenSpaceError = geofs.api.renderingSettings.maximumScreenSpaceError; geofs.api.viewer.scene.fog.screenSpaceErrorFactor = geofs.api.renderingSettings.fogScreenSpaceErrorFactor; a = 0; geofs.preferences.mobile && (a = clamp(window.devicePixelRatio, 0, 4) / 10); geofs.api.viewer.resolutionScale = geofs.api.renderingSettings.resolutionScale - a; geofs.api.viewer.scene.globe.tileCacheSize = geofs.api.renderingSettings.tileCacheSize; geofs.api.viewer.scene.postProcessStages.fxaa.enabled = geofs.api.renderingSettings.fxaa;
    geofs.api.setGlobeLighting(geofs.api.renderingSettings.globeLighting); geofs.api.viewer.shadowMap.size = geofs.api.renderingSettings.shadowMapSize; geofs.api.renderingSettings.adaptativeRenderingQuality = geofs.api.renderingSettings.viewingDistance <= 6; geofs.fx.cloudManager.setCloudCoverToCloudNumber(geofs.api.renderingSettings.cloudCoverToCloudNumber); geofs.useSimpleShadow(!geofs.api.renderingSettings.dropShadow); geofs.api.viewer.shadowMap.softShadows = geofs.api.renderingSettings.softShadows; geofs.api.setOutsideShadowDistance(geofs.api.renderingSettings.shadowDistance);
    geofs.api.viewer.scene.msaaSamples = geofs.api.renderingSettings.msaaSamples; geofs.api.googleTileset && (geofs.api.googleTileset.dynamicScreenSpaceErrorDensity = geofs.configuration.current.screenSpacePresets.google.dynamicScreenSpaceErrorDensity[geofs.api.renderingSettings.viewingDistance], geofs.api.googleTileset.dynamicScreenSpaceErrorFactor = geofs.configuration.current.screenSpacePresets.google.dynamicScreenSpaceErrorFactor[geofs.api.renderingSettings.viewingDistance], geofs.api.googleTileset.maximumScreenSpaceError =
      geofs.configuration.current.screenSpacePresets.google.maximumScreenSpaceError[geofs.api.renderingSettings.viewingDistance], geofs.api.renderingSettings.degradedCollisions = !0, geofs.api.renderingSettings.adaptativeRenderingQuality = !1); geofs.runways.redraw(); geofs.api.viewer.resize(); c && $("body").trigger("qualityChange")
  }
}; geofs.api.adaptativeMaxMaximumScreenSpaceError = 6; geofs.api.adaptativeTopSpeed = 100; geofs.api.adaptativeTopAltitude = 500; geofs.api.adaptativeTurnrateRatio = 5E-4;
geofs.api.adaptativeRenderingQuality = function () {
  var a = geofs.api.renderingSettings.maximumScreenSpaceError, b = geofs.animation.values.kias / geofs.api.adaptativeTopSpeed, c = clamp((geofs.api.adaptativeTopAltitude - (geofs.relativeAltitude || 0)) / geofs.api.adaptativeTopAltitude, 0, 1); a += b * c + 0 * geofs.api.adaptativeTurnrateRatio; geofs.api.viewer.scene.globe.maximumScreenSpaceError = exponentialSmoothing("adaptativeRenderingQuality", clamp(a, geofs.api.renderingSettings.maximumScreenSpaceError, geofs.api.adaptativeMaxMaximumScreenSpaceError),
    null, geofs.api.renderingSettings.maximumScreenSpaceError)
}; geofs.api.useNativeShadows = function (a) { geofs.api.viewer.shadows = a }; geofs.api.useNativeAtmosphere = function (a) { geofs.api.viewer.scene.globe.showGroundAtmosphere = a; geofs.api.viewer.scene.skyAtmosphere.show = a; geofs.api.viewer.scene.fog.renderable = a };
geofs.api.addLabel = function (a, b, c) { b = b || [0, 0, 0]; c = c || {}; if (V3.isValid(b)) return a = { position: new Cesium.Cartesian3.fromDegrees(b[1], b[0], b[2]), text: geofs.api.makeLabelTextSafe(a) }, c = Object.assign(c, a), geofs.api.labels.add(c); geofs.debug.debugger() }; geofs.api.updateLabelText = function (a, b) { a.text = geofs.api.makeLabelTextSafe(b) }; geofs.api.makeLabelTextSafe = function (a) { return a.replace(/[^\x20-\x7E]+/g, "") }; geofs.api.removeLabel = function (a) { a && geofs.api.labels.remove(a) };
geofs.api.setLabelPosition = function (a, b) { a && (V3.isValid(b) ? a.position = new Cesium.Cartesian3.fromDegrees(b[1], b[0], b[2]) : geofs.debug.debugger()) };
geofs.api.getGuarantiedGroundAltitude = function (a) { var b = geofs.objects.getAltitudeAtLocation(a, !0); if (b) return new Promise(function (c, d) { c([{ height: b.location[2] }]) }); a = [Cesium.Cartographic.fromDegrees(a[1], a[0])]; return geofs.api.googleTileset ? geofs.api.viewer.scene.sampleHeightMostDetailed(a, null, 1) : geofs.api.viewer.terrainProvider ? Cesium.sampleTerrain(geofs.api.viewer.terrainProvider, geofs.api.viewer.terrainProvider.maximumLevel, a) : new Promise(function (c, d) { c([{ height: 0 }]) }) };
geofs.api.getFastTerrainElevation = function (a) { a = new Cesium.Cartographic.fromDegrees(a[1], a[0], a[2]); return geofs.api.googleTileset ? geofs.api.googleTileset.getHeight(a, geofs.api.viewer.scene) || 0 : geofs.api.viewer.scene.globe.getHeight(a) || 0 }; geofs.api.contactAltitudeErrorThreshold = .2; geofs.api.generalAltitudeErrorThreshold = 10; geofs.api.wrongAltitudeAllowedTries = 5;
geofs.api.getGroundAltitude = function (a, b) {
  if (geofs.debugOn && !V3.isValid(a)) debugger; var c = geofs.groundElevation || 0; geofs.api.googleTileset ? (a = new Cesium.Cartographic.fromDegrees(a[1], a[0], c), a = geofs.api.googleTileset.getHeight(a, geofs.api.viewer.scene)) : geofs.api.renderingSettings.buildingCollision ? (a = new Cesium.Cartographic.fromDegrees(a[1] + 1E-4, a[0] + 1E-4, 0), a = geofs.api.viewer.scene.sampleHeight(a, geofs.aircraft.instance.models), geofs.debug.watch("groundAltitude", a)) : (a = new Cesium.Cartographic.fromDegrees(a[1],
    a[0], c), a = geofs.api.viewer.scene.globe.getHeight(a)); a < -1E3 && (a = void 0); if (a == void 0) b && b.lastGroundAltitude ? (a = c || b.lastGroundAltitude, b.wrongValue = "undefined") : a = c; else if (b) {
      b.lastGroundAltitude = c || b.lastGroundAltitude; c = Math.abs(b.lastGroundAltitude - a); if (b.groundContact) { if (c > geofs.api.contactAltitudeErrorThreshold && (b.wrongAltitudeTries = b.wrongAltitudeTries || 0, b.wrongAltitudeTries <= geofs.api.wrongAltitudeAllowedTries)) return b.wrongAltitudeTries++, b.wrongValue = a, b.lastGroundAltitude || 0 } else if (c >
        geofs.api.generalAltitudeErrorThreshold && (b.wrongAltitudeTries = b.wrongAltitudeTries || 0, b.wrongAltitudeTries <= geofs.api.wrongAltitudeAllowedTries)) return b.wrongAltitudeTries++, b.wrongValue = a, b.lastGroundAltitude || 0; b.wrongAltitudeTries = 0; b.lastGroundAltitude = a
    } return a
}; geofs.api.oldNormal = [0, 0, 1]; geofs.api.normalDotThreshold = .95; geofs.api.wrongNormalTries = 3;
geofs.api.getGroundNormal = function (a, b) {
  b = b || {}; b.oldNormal = b.oldNormal || [0, 0, 1]; a = V3.dup(a); var c = xyz2lla([1, 1, a[2]], a), d = V3.add(a, [c[0], 0, a[2]]); c = V3.add(a, [0, c[1], a[2]]); a[2] = geofs.api.getGroundAltitude(a); d[2] = geofs.api.getGroundAltitude(d); c[2] = geofs.api.getGroundAltitude(c); d = V3.sub(d, a); c = V3.sub(c, a); d = lla2xyz(d, a); c = lla2xyz(c, a); a = V3.normalize(V3.cross(c, d)); if (V3.dot(a, b.oldNormal) < geofs.api.normalDotThreshold && b.wrongNormal < geofs.api.wrongNormalTries) return b.wrongNormal += 1, b.oldNormal;
  b.wrongNormal = 0; b.oldNormal = a; return geofs.api.oldNormal = a
};
geofs.api.Model = function (a, b) {
  var c = this; b = b || {}; b.url = b.url || a; b.scene = b.scene || geofs.api.viewer.scene; this.loadedPromise = new Promise(function (d) {
    return (0, $jscomp.asyncExecutePromiseGeneratorProgram)(function (e) {
      c.readyPromise = new Promise(function (f) {
        return (0, $jscomp.asyncExecutePromiseGeneratorProgram)(function (g) {
          if (g.nextAddress == 1) return g.yield(geofs.api.loadModel(b), 2); c._model = g.yieldResult; if (!c._model) return g.return(); d(); c.forceZup = b.forceZup; if (c.detroyed || c._model.isDestroyed()) return c.destroy(),
            g.return(); b.modelMatrix || c.setPositionOrientationAndScale(b.location, b.rotation, null); b.justLoad || c.addToWorld(); c._model.ready ? (c.ready = !0, f()) : c._model.readyPromise ? c._model.readyPromise.then(function () { c.ready = !0; f() }) : c._model.readyEvent && c._model.readyEvent.addEventListener(function () { c.ready = !0; f() }); g.jumpToEnd()
        })
      }); e.jumpToEnd()
    })
  })
}; geofs.api.Model.prototype.addToWorld = function () { var a = this; this.loadedPromise.then(function () { geofs.api.addModelToWorld(a._model) }) };
geofs.api.Model.prototype.removeFromWorld = function () { geofs.api.removeModelFromWorld(this._model) }; geofs.api.Model.prototype.getReadyPromise = function () { return this._model && this._model.readyPromise ? this._model.readyPromise : this.readyPromise }; geofs.api.Model.prototype.isReady = function () { return this._model ? this._model.ready : !1 }; geofs.api.Model.prototype.getNode = function (a) { return geofs.api.getModelNode(this._model, a) };
geofs.api.Model.prototype.setOpacity = function (a) { this.ready && (this._opacity = this._model.color.alpha = a) }; geofs.api.Model.prototype.setRotation = function (a, b) { var c = [0, 0, 0]; c[b || 0] = a; this.setPositionOrientationAndScale(null, c, null) }; geofs.api.Model.prototype.setScale = function (a) { this.setPositionOrientationAndScale(null, null, a) }; geofs.api.Model.prototype.setPositionOrientationAndScale = function (a, b, c) { return geofs.api.setModelPositionOrientationAndScale(this._model, a, b, c) };
geofs.api.Model.prototype.setLocation = function (a) { this.setPositionOrientationAndScale(a) }; geofs.api.Model.prototype.translate = function (a) { this.setPositionOrientationAndScale(V3.add(this._model._apiLla, a)) }; geofs.api.Model.prototype.rotate = function (a) { this.setPositionOrientationAndScale(null, V3.add(this._model._apiHtr, a)) }; geofs.api.Model.prototype.scale = function (a) { Array.isArray(a) || (a = [a, a, a]); this.setPositionOrientationAndScale(null, null, V3.add(this._model._apiScale, a)) };
geofs.api.Model.prototype.setColor = function (a) { this._model && (this._model.color = Cesium.Color.clone(a), this._model.color.alpha = this._opacity || a.alpha) }; geofs.api.Model.prototype.setShadows = function (a) { this._model.shadows = a }; geofs.api.Model.prototype.setCssColor = function (a) { this._model.color = Cesium.Color.fromCssColorString(a) }; geofs.api.Model.prototype.addShader = function (a, b) { return geofs.api.addShaderToModel(this._model, a, b) };
geofs.api.Model.prototype.setTextureFromCanvas = function (a, b) { return geofs.api.setModelTextureFromCanvas(this._model, a, b) }; geofs.api.Model.prototype.changeTexture = function (a, b) { return geofs.api.changeModelTexture(this._model, a, b) }; geofs.api.Model.prototype.setVisibility = function (a) { return geofs.api.setModelVisibility(this._model, a) }; geofs.api.Model.prototype.hide = function () { geofs.api.setModelVisibility(this._model, !1) };
geofs.api.Model.prototype.show = function () { geofs.api.setModelVisibility(this._model, !0) }; geofs.api.Model.prototype.setNodeVisibilityByName = function (a, b) { var c = this; if (this.ready) { var d = this._model.getNode(a); return geofs.api.setNodeVisibility(d, b) } this.readyPromise.then(function () { if (c._model && c._model.ready) { var e = c._model.getNode(a); return geofs.api.setNodeVisibility(e, b) } }); return !0 }; geofs.api.Model.prototype.destroy = function () { geofs.api.destroyModel(this._model); this.detroyed = !0 };
geofs.api.Model.prototype.remove = function () { geofs.api.removeFromWorld(this._model) };
geofs.api.generateShader = function (a, b) {
  return new Cesium.CustomShader({
    uniforms: geofs.api.generateUniforms(a, b || ""), varyings: {}, mode: Cesium.CustomShaderMode.REPLACE_MATERIAL, lightingModel: Cesium.LightingModel.UNLIT, translucencyMode: a.translucent ? Cesium.CustomShaderTranslucencyMode.TRANSLUCENT : Cesium.CustomShaderTranslucencyMode.OPAQUE, vertexShaderText: geofsShaders[a.name + "VS.glsl"] || "void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput) {}", fragmentShaderText: geofsShaders[a.name +
      "FS.glsl"]
  })
}; geofs.api.getShaderTextureList = function (a, b) { a.textures = a.textures || {}; switch (a.name) { case "mappedReflective": a.textures.diffuse = a.textures.diffuse || b + "/texture_0.jpg"; a.textures.reflective = a.textures.reflective || "/shaders/reflection.jpg"; a.textures.normal = a.textures.normal || b + "/normal.jpg"; a.textures.specular = a.textures.specular || b + "/specular.jpg"; break; case "glass": a.textures.reflective = a.textures.reflective || "/shaders/reflection.jpg" }return a.textures };
geofs.api.generateUniforms = function (a, b) { b = geofs.api.getShaderTextureList(a, b); var c = {}, d; for (d in b) c["u_" + d] = { value: new Cesium.TextureUniform({ url: b[d], minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR }), type: Cesium.UniformType.SAMPLER_2D }; for (d in a.uniforms) c["u_" + d] = { value: a.uniforms[d], type: Cesium.UniformType.FLOAT }; return c };
geofs.api.loadModel = function (a) {
  var b, c, d, e; return (0, $jscomp.asyncExecutePromiseGeneratorProgram)(function (f) {
    switch (f.nextAddress) {
      case 1: b = { shadows: SHADOWS_NONE }; typeof a == "string" && (a = { url: a }); a = Object.assign({}, b, a); a.scene = geofs.api.viewer.scene; a.altitudeMode == geofs.api.ALTITUDE_RELATIVE && (a.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND); a.altitudeMode == geofs.api.CLAMP_TO_GROUND && (a.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND); if (a.asCesiumInstance) {
        c = {
          collectionId: a.collectionId,
          instance: !0, url: a.url
        }; f.jumpTo(2); break
      } if (a.asCesiumEntity) { c = new Cesium.ModelGraphics(a); c.entity = new Cesium.Entity({ model: c }); f.jumpTo(2); break } if (!(geofs.version >= 4)) { a.experimental ? (a.retryCallback = function (g, k) { return !1 }, a.url = new Cesium.Resource(a), c = Cesium.ModelExperimental.fromGltf(a)) : c = Cesium.Model.fromGltf(a); f.jumpTo(2); break } a.upAxis = Cesium.Axis.Y; a.forwardAxis = Cesium.Axis.X; f.setCatchFinallyBlocks(5); return f.yield(Cesium.Model.fromGltfAsync(a), 7); case 7: c = f.yieldResult; d = c.environmentMapManager;
        d.saturation = .35; d.brightness = 1.4; d.gamma = .8; d.atmosphereScatteringIntensity = 5; d.groundColor = Cesium.Color.fromCssColorString("#001850"); f.leaveTryBlock(2); break; case 5: return e = f.enterCatchBlock(), geofs.debug.log("geofs.api.loadModel fromGltfAsync exception"), geofs.debug.log(e), f.return(null); case 2: return f.return(c)
    }
  })
};
geofs.api.addModelToWorld = function (a) { a && (a.isDestroyed && a.isDestroyed() || (a.instance ? geofs.api.addModelInstance(a.collectionId, { modelMatrix: a.modelMatrix }, a.url) : a.entity ? geofs.api.viewer.entities.add(a.entity) : geofs.api.models.add(a))) }; geofs.api.instanceCollections = {}; geofs.api.modelInstances = {}; geofs.api.addModelInstance = function (a, b, c) { geofs.api.modelInstances[a] || (geofs.api.modelInstances[a] = [], geofs.api.modelInstances[a].url = c); geofs.api.modelInstances[a].push(b) };
geofs.api.commitInstanceCollection = function (a) { geofs.api.modelInstances[a] && (geofs.api.instanceCollections[a] = geofs.api.viewer.scene.primitives.add(new Cesium.ModelInstanceCollection({ url: geofs.api.modelInstances[a].url, instances: geofs.api.modelInstances[a], incrementallyLoadTextures: !1, dynamic: !1, allowPicking: !1, shadows: 0 }))) }; geofs.api.destroyInstanceCollection = function (a) { geofs.api.instanceCollections[a] && geofs.api.instanceCollections[a].destroy(); delete geofs.api.instanceCollections[a]; delete geofs.api.modelInstances[a] };
geofs.api.setModelTextureFromCanvas = function (a, b, c) {
  if (a) if (a.customShader) a.geofsTexUniform ? (c = a.customShader._textureManager._textures.u_diffuse) && c._initialized && c._width > 1 ? (c.copyFrom({ source: b.canvas }), c.generateMipmap()) : a.customShader.setUniform("u_diffuse", a.geofsTexUniform) : (a.geofsTexUniform = new Cesium.TextureUniform({ typedArray: b.context.getImageData(0, 0, b.width, b.height).data, width: b.width, height: b.height, repeat: !1, minificationFilter: Cesium.TextureMinificationFilter.LINEAR, magnificationFilter: Cesium.TextureMinificationFilter.LINEAR }),
    a.customShader.setUniform("u_diffuse", a.geofsTexUniform)); else if (a = a._rendererResources.textures[c || 0]) a.copyFrom({ source: b.canvas }), a.generateMipmap()
};
geofs.api.changeModelTexture = function (a, b, c) { if (a) if (a.customShader) a.customShader.setUniform("u_diffuse", new Cesium.TextureUniform({ url: b, minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR })); else { var d = geofs.version >= 4 ? a._nodesByName[c.node || ""]._runtimeNode.runtimePrimitives[0].primitive.material.metallicRoughness.baseColorTexture.texture : a._rendererResources.textures[c.index || 0]; Cesium.Resource.fetchImage({ url: b }).then(function (e) { d.copyFrom({ source: e }); d.generateMipmap() }) } };
geofs.api.toggleModelShadow = function (a, b) { !geofs.api.viewer.shadows || !a || a.isDestroyed && a.isDestroyed() || (a.shadows = b ? Cesium.ShadowMode.CAST_ONLY : Cesium.ShadowMode.DISABLED) }; geofs.api.removeModelFromWorld = function (a) { a && (a.isDestroyed && a.isDestroyed() || (a.entity ? geofs.api.viewer.entities.remove(a.entity) : geofs.api.models.remove(a))) }; geofs.api.setModelVisibility = function (a, b) { if (!a || a.isDestroyed && a.isDestroyed()) return !1; a.entity ? a.entity.show = b : a.show = b; return !0 };
geofs.api.setModelColor = function (a, b, c, d, e) { if (!a || a.isDestroyed && a.isDestroyed()) return !1; a.color.red = b; a.color.green = c; a.color.blue = d; a.color.alpha = e }; geofs.api.setModelOpacity = function (a, b) { if (!a || a.isDestroyed && a.isDestroyed()) return !1; a.color.alpha = b; return !0 }; geofs.api.destroyModel = function (a) { a && (geofs.api.removeModelFromWorld(a), a.destroy && !a.isDestroyed() && a.destroy()) };
geofs.fromHeadingPitchRoll = function (a, b, c) { b = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_X, -b); c = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_Y, -c); c = Cesium.Quaternion.multiply(b, c, c); a = Cesium.Quaternion.fromAxisAngle(Cesium.Cartesian3.UNIT_Z, -a); return Cesium.Quaternion.multiply(a, c, c) };
geofs.headingPitchRollScaleToFixedFrame = function (a, b, c, d, e) { e = new Cesium.Cartesian3(e[0], e[1], e[2]); b = geofs.fromHeadingPitchRoll(b, c, d); c = new Cesium.Matrix4; e = Cesium.Matrix4.fromTranslationQuaternionRotationScale(Cesium.Cartesian3.ZERO, b, e, c); a = Cesium.Transforms.eastNorthUpToFixedFrame(a); return Cesium.Matrix4.multiply(a, e, a) }; geofs.api.setModelElevation = function (a, b) { geofs.api.setModelPositionOrientationAndScale(a, [a._apiLla[0], a._apiLla[1], b]) };
geofs.api.setModelPositionOrientationAndScale = function (a, b, c, d) {
  if (a && (!a.isDestroyed || !a.isDestroyed())) if (d = d || a._apiScale || [1, 1, 1], Array.isArray(d) || (d = [d, d, d]), c = c ? c.slice() : a._apiHtr || [0, 0, 0], b = b ? b.slice() : a._apiLla || [0, 0, 0], V3.isValid(c)) if (V3.isValid(d)) if (V3.isValid(b)) {
    var e = Cesium.Cartesian3.fromDegrees(b[1], b[0], b[2]); if (a.entity) {
      a.entity.position = e; var f = new Cesium.HeadingPitchRoll(c[0] * DEGREES_TO_RAD, c[1] * DEGREES_TO_RAD, c[2] * DEGREES_TO_RAD); a.entity.orientation = Cesium.Transforms.headingPitchRollQuaternion(e,
        f)
    } else a.modelMatrix = geofs.headingPitchRollScaleToFixedFrame(e, c[0] * DEGREES_TO_RAD, c[1] * DEGREES_TO_RAD, c[2] * DEGREES_TO_RAD, d), a.referenceMatrix = Cesium.Matrix4.inverse(a.modelMatrix, new Cesium.Matrix4); a._apiScale = d; a._apiHtr = c; a._apiLla = b
  } else geofs.debug.debugger(); else geofs.debug.debugger(); else geofs.debug.debugger()
}; geofs.api.getModelNode = function (a, b) { if (a) { a._geofsNodes = a._geofsNodes || {}; if (!a._geofsNodes[b]) { if (!a || !a.ready) return !1; a._geofsNodes[b] = a.getNode(b) } return a._geofsNodes[b] } };
geofs.api.setModelRotationPosition = function (a, b, c) { a.originalTransform || (a.originalTransform = a.modelMatrix.clone(a.originalTransform)); if (b) var d = Cesium.Matrix3.fromColumnMajorArray(M33.toArray(b)); if (c) var e = Cesium.Cartesian3.fromDegrees(c[1], c[0], c[2]); a.modelMatrix = Cesium.Matrix4.fromRotationTranslation(d, e); b = Cesium.Transforms.eastNorthUpToFixedFrame(e); a.modelMatrix = Cesium.Matrix4.multiply(b, a.modelMatrix, b) };
geofs.api.setNodeRotationTranslationScale = function (a, b, c, d, e) {
  if (b) { var f = Cesium.Matrix3.fromColumnMajorArray(M33.toArray(b)); e && (f = Cesium.Matrix3.multiply(f, Cesium.Matrix4.getRotation(Cesium.Axis.Y_UP_TO_Z_UP, new Cesium.Matrix3), f)) } if (c) var g = new Cesium.Cartesian3(c[0], c[1], c[2]); b = Cesium.Matrix4.fromRotationTranslation(f, g); if (d && d[0] != 1 || d[1] != 1 || d[2] != 1) d = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(d[0], d[1], d[2])), b = Cesium.Matrix4.multiply(b, d, b); e && (b = Cesium.Matrix4.multiply(Cesium.Axis.Z_UP_TO_Y_UP,
    b, b)); a.matrix = Cesium.Matrix4.multiply(a.originalMatrix, b, a.matrix)
}; geofs.api.setNodeScale = function (a, b) { b = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(b[0], b[1], b[2])); a.matrix = Cesium.Matrix4.multiply(a.matrix, b, a.matrix) }; geofs.api.setNodeVisibility = function (a, b) { if (!a) return !1; a.show = b; return !0 }; geofs.api.getNodePosition = function (a, b) { a = geofs.api.getNodeOriginalMatrix(a, b); a = Cesium.Matrix4.getTranslation(a, new Cesium.Cartesian3); return [a.x, a.y, a.z] };
geofs.api.getNodeOriginalMatrix = function (a, b) { a.geofsOriginalMatrix || (a.geofsOriginalMatrix = a.originalMatrix, b && (a.geofsOriginalMatrix = Cesium.Matrix4.multiply(Cesium.Axis.Y_UP_TO_Z_UP, a.geofsOriginalMatrix, new Cesium.Matrix4))); return a.geofsOriginalMatrix }; geofs.api.getNodeRotation = function (a) { return M33.identity() }; geofs.api.initAndGetCamera = function () { geofs.api.camera = geofs.api.viewer.camera; return geofs.api.camera }; geofs.api.getFOV = function (a) { return a.frustum.fov };
geofs.api.setFOV = function (a, b) { a.frustum.fov = b }; geofs.api.setCameraPositionAndOrientation = function (a, b, c) { V3.isValid(b) ? V3.isValid(c) ? (a.position = Cesium.Cartesian3.fromDegrees(b[1], b[0], b[2]), a.setView({ orientation: { heading: Cesium.Math.toRadians(c[0]), pitch: Cesium.Math.toRadians(c[1]), roll: Cesium.Math.toRadians(c[2]) } })) : geofs.debug.debugger() : geofs.debug.debugger() }; geofs.api.getCameraLla = function (a) { a = a.positionCartographic; return [a.latitude * RAD_TO_DEGREES, a.longitude * RAD_TO_DEGREES, a.height] };
geofs.api.setCameraLookAt = function (a, b) { a.lookAt(Cesium.Cartesian3.fromDegrees(b[1], b[0], b[2])) }; geofs.api.getHeading = function (a) { return a.heading * RAD_TO_DEGREES }; geofs.api.getTilt = function (a) { return a.pitch * RAD_TO_DEGREES }; geofs.api.debug = function (a) { geofs.api.viewer && (geofs.api.viewer.scene.debugShowFramesPerSecond = a ? !0 : !1) }; geofs.api.getPositionFromScreenCoords = function (a, b) { return geofs.api.viewer.scene.pickPosition(new Cesium.Cartesian2(a, b), new Cesium.Cartesian3) };
geofs.api.getDistanceFromScreenCoords = function (a, b, c) { if (a = geofs.api.viewer.scene.pickPosition(new Cesium.Cartesian2(a, b), new Cesium.Cartesian3)) return Cesium.Cartesian3.distance(c, a) }; geofs.api.getModelFromScreenCoords = function (a, b) { return geofs.api.viewer.scene.pick(new Cesium.Cartesian2(a, b)) }; geofs.api.getNodeNameFromScreenCoords = function (a, b) { return (a = geofs.api.getModelFromScreenCoords(a, b)) && a.node ? a.node.name : null };
geofs.api.getLlaFromScreencoordDepth = function (a, b, c) { a = geofs.camera.cam.getPickRay(new Cesium.Cartesian2(a, b)); c = Cesium.Ray.getPoint(a, c); if (!isNaN(c.x)) return c = Cesium.Cartographic.fromCartesian(c, null, new Cesium.Cartographic), [c.latitude * RAD_TO_DEGREES, c.longitude * RAD_TO_DEGREES, c.height] }; geofs.api.getScreenCoordFromLla = function (a) { return Cesium.SceneTransforms.wgs84ToWindowCoordinates(geofs.api.viewer.scene, Cesium.Cartesian3.fromDegrees(a[1], a[0], a[2])) };
geofs.api.xyz2lla = function (a, b) { var c = new Cesium.Matrix4, d = geofs.api.viewer.scene.globe.ellipsoid, e = Cesium.Cartesian3.fromDegrees(b[1], b[0], b[2]); Cesium.Transforms.eastNorthUpToFixedFrame(e, d, c); a = new Cesium.Cartesian3(a[0], a[1], a[2]); c = Cesium.Matrix4.multiplyByPoint(c, a, new Cesium.Cartesian3); return (d = Cesium.Cartographic.fromCartesian(c, d, new Cesium.Cartographic)) ? [d.latitude * RAD_TO_DEGREES - b[0], d.longitude * RAD_TO_DEGREES - b[1], d.height - b[2]] : [0, 0, 0] };
geofs.api.takeCanvasScreenShot = function (a) { var b = geofs.api.viewer.canvas.toDataURL("image/jpg"); a.href = b }; geofs.api.preferredCompositor = "css"; geofs.api.compositors = {}; geofs.api.compositors.css = function (a, b) { }; geofs.api.compositors.css.prototype = { name: "css", createLayer: function (a, b) { return new geofs.api.cssCompositorLayer(a, b) }, render: function () { }, destroy: function () { } };
geofs.api.cssCompositorLayer = function (a, b) { this.container = a || ".geofs-overlay-container"; this._$element = $('<div class="' + (b ? "geofs-inline-overlay" : "geofs-overlay") + '"></div>').appendTo(this.container); this.inline = b; this.positionY = this.positionX = this.rotation = 0; this.frame = { x: 0, y: 0 }; this.size = { x: 0, y: 0 }; this.offset = { x: 0, y: 0 } };
geofs.api.cssCompositorLayer.prototype = {
  setDrawOrder: function (a) { (this._$mask || this._$element).css("z-index", a + geofs.api.overlayBaseZIndex) }, setUrl: function (a) { var b = this; a && (this.image = new Image, this.image.src = a, this.image.onload = function () { b.loaded() }, this._$element.css("background-image", 'url("' + a + '")')) }, setMask: function (a) { a && (this._$mask = $('<div class="geofs-overlay geofs-overlay-mask"></div>').appendTo(this.container), this._$mask.css("mask-image", 'url("' + a + '")'), this._$element.appendTo(this._$mask)) },
  setText: function (a) { this._$element.html(a); this._$element.addClass("geofs-textOverlay") }, setTitle: function (a) { this._$element.attr("title", a) }, setClass: function (a) { this._$element.addClass(a) }, setStyle: function (a) { this._$element.attr("style", a) }, loaded: function () { this.naturalSize = { x: this.image.width, y: this.image.height }; $(this).trigger("load") }, setFrameSize: function (a) {
    this._$mask && (this._$mask.css("mask-size", a.x + "px " + a.y + "px"), this._$mask.css("width", a.x + "px"), this._$mask.css("height", a.y + "px"));
    this._$element.css("width", a.x + "px"); this._$element.css("height", a.y + "px"); this.frame = a
  }, setVisibility: function (a) { a ? (this._$mask || this._$element).addClass("geofs-visible").removeClass("geofs-hidden") : (this._$mask || this._$element).addClass("geofs-hidden").removeClass("geofs-visible") }, setAnchor: function (a) { var b = this._$mask || this._$element; b.css("margin-left", -a.x + "px "); b.css("margin-bottom", -a.y + "px ") }, setRotationCenter: function (a) { this._$element.css("transform-origin", a.x + "px " + a.y + "px") }, setSize: function (a) {
    this._$element.css("background-size",
      a.x + "px " + a.y + "px"); this.size = a
  }, setPosition: function (a) { if (!this.inline) { var b = this._$mask || this._$element; b.css("left", a.x + "px"); b.css("bottom", a.y + "px") } }, setPositionX: function (a) { this.inline || ((this._$mask || this._$element).css("left", a + "px"), this.positionX = a) }, setPositionY: function (a) { this.inline || ((this._$mask || this._$element).css("bottom", a + "px"), this.positionY = a) }, setOffset: function (a) { this.offset = a }, setTranslation: function (a) {
    this._$element.css("background-position", this.offset.x + a.x + "px " +
      (this.offset.y + a.y) + "px")
  }, setOpacity: function (a) { (this._$mask || this._$element).css("opacity", a) }, setRotation: function (a) { var b = "rotate(" + fixAngle360(-a) + "deg)"; this._$element.css("transform", b); this.rotation = a }, getElement: function () { return this._$element[0] }, destroy: function () { this.image && (this.image = this.image.onload = null); this._$mask && (this._$mask.remove(), this._$mask = null); this._$element.remove(); this._$element = null }
};
geofs.api.compositors.canvas = function (a, b) { b = { width: b.size.x, height: b.size.y }; this.container = a || ".geofs-overlay-container"; this._$element = $('<div class="geofs-canvas-overlay"></div>').appendTo(this.container); this.canvasAPI = new geofs.api.Canvas(b); $(this.canvasAPI.canvas).appendTo(this._$element); this.layers = [] };
geofs.api.compositors.canvas.prototype = {
  name: "canvas", createLayer: function (a, b) { a = new geofs.api.canvasCompositorLayer(this, b); this.layers.push(a); return a }, render: function () {
    var a = this, b = this.canvasAPI.context; this.canvasAPI.clear("#00000000"); this.layers.forEach(function (c) {
      c.visibility && (b.globalAlpha = c.opacity, c.clip && (b.save(), b.beginPath(), b.arc(c.clip[0], c.clip[1], c.clip[2], 0, TWO_PI, !0), b.clip()), c.image && c.image.complete && a.canvasAPI.drawRotatedSprite({
        sprite: c.sprite, image: c.image, origin: c.origin,
        size: c.size, center: c.anchor, destination: c.position, rotation: c.rotation, translation: c.translation
      }), c.clip && b.restore(), b.globalAlpha = 1)
    })
  }, destroy: function () { this.canvasAPI.destroy(); this._$element && (this._$element.remove(), this._$element = null) }
}; geofs.api.canvasCompositorLayer = function (a, b) { this.compositor = a; this.rotation = 0; this.opacity = 1; this.anchor = { x: 0, y: 0 }; this.origin = [0, 0]; this.position = [0, 0]; this.size = [0, 0]; this.frameSize = [0, 0]; this.anchor = [0, 0]; this.rotationCenter = [0, 0]; this.offset = [0, 0] };
geofs.api.canvasCompositorLayer.prototype = {
  setDrawOrder: function (a) { this.drawOrder = a }, setUrl: function (a) { var b = this; a && (this.image = this.compositor.canvasAPI.loadImage(a), this.image.onload = function () { b.loaded() }) }, setMask: function (a, b) { var c = this; a && (b ? this.clip = b : (this.mask = this.compositor.canvasAPI.loadImage(a), this.mask.onload = function () { c.maskNaturalSize = [c.mask.width, c.mask.height]; c.maskCenter = [c.mask.width / 2, c.mask.height / 2] })) }, setText: function (a) { this.text = a }, setTitle: function (a) {
    this.title =
      a
  }, setClass: function (a) { }, setStyle: function (a) { }, loaded: function () { this.naturalSize = { x: this.image.width, y: this.image.height }; this.sprite = [this.image.width, this.image.height]; $(this).trigger("load") }, setFrameSize: function (a) { this.frameSize = [a.x, a.y] }, setVisibility: function (a) { a !== void 0 && (this.visibility = a) }, setAnchor: function (a) { this.anchor = [a.x, this.frameSize[1] - a.y]; this.anchor = V2.sub(this.anchor, this.offset) }, setRotationCenter: function (a) { this.rotationCenter = [a.x, a.y] }, setSize: function (a) {
    this.size =
      [a.x, a.y]
  }, setPosition: function (a) { this.position = [a.x, a.y] }, setPositionX: function (a) { this.position[0] = a }, setPositionY: function (a) { this.position[1] = a }, setOffset: function (a) { this.offset = [a.x, a.y]; this.anchor = V2.sub(this.anchor, this.offset) }, setTranslation: function (a) { this.translation = [-a.x, -a.y] }, setOpacity: function (a) { this.opacity = a }, setRotation: function (a) { this.rotation = -a * DEGREES_TO_RAD }, getElement: function () { return this.compositor._$element }, destroy: function () {
    this.image && (this.image = this.image.onload =
      null); this._$mask && (this._$mask.remove(), this._$mask = null); this._$element && (this._$element.remove(), this._$element = null)
  }
};
geofs.api.billboard = function (a, b, c) {
  c = Object.assign({ collection: "default" }, c); a = a || [0, 0, 0]; c.image = c.image || b; c.image += geofs.killCache; c.position = Cesium.Cartesian3.fromDegrees(a[1], a[0], a[2]); geofs.api.billboards[c.collection] || (geofs.api.billboards[c.collection] = geofs.api.viewer.scene.primitives.add(new Cesium.BillboardCollection({ scene: geofs.api.viewer.scene, blendOption: Cesium.BlendOption.TRANSLUCENT }))); this._billboard = geofs.api.billboards[c.collection].add(c); this._lla = a; c.altitudeMode == geofs.api.ALTITUDE_RELATIVE &&
    (this._billboard.heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND); c.altitudeMode == geofs.api.CLAMP_TO_GROUND && (this._billboard.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND); c.opacity && this.setOpacity(c.opacity); c.scale && this.setScale(c.scale); c.rotation && this.setRotation(c.rotation); c.geofsFixCameraRotation && this.fixCameraRotation(); this._options = c
};
geofs.api.billboard.prototype = {
  setUrl: function (a) { }, setVisibility: function (a) { this._billboard && (this._billboard.show = a) }, setColor: function (a) { this._billboard && (a.alpha = this.opacity || 1, this._billboard.color = a) }, setCssColor: function (a) { this._billboard && (this._billboard.color = Cesium.Color.fromCssColorString(a)) }, setOpacity: function (a) { if (this._billboard) { var b = this._billboard.color || new Cesium.Color(1, 1, 1, 1); b.alpha = a; this._billboard.color = b; this.opacity = a } }, setRotation: function (a) {
    this._billboard &&
      (this._billboard.rotation = a)
  }, setScale: function (a) { this._billboard && (this._billboard.scale = a) }, setLocation: function (a) { this._billboard && (V3.isValid(a) ? (this._lla = a, this._billboard.position = Cesium.Cartesian3.fromDegrees(a[1], a[0], a[2])) : geofs.debug.debugger()) }, getLla: function (a) { return this._lla }, fixCameraRotation: function () { var a = this; this.rotationFixCallback = geofs.api.addFrameCallback(function () { a._billboard.rotation = geofs.camera.radianRoll }, "billboardsRotationFix") }, destroy: function () {
    this._billboard &&
      (geofs.api.removeFrameCallback(this.rotationFixCallback, "billboardsRotationFix"), geofs.api.billboards[this._options.collection].remove(this._billboard), this._billboard = null)
  }
};
geofs.api.groundTexture = function (a, b, c) {
  c = Object.assign({ width: .001 }, c); a = a || [0, 0, 0]; c.image = c.image || b; c.image += geofs.killCache; c.position = Cesium.Cartesian3.fromDegrees(a[1], a[0], a[2]); this._entity = geofs.api.viewer.entities.add({
    polygon: {
      hierarchy: {
        positions: [new Cesium.Cartesian3.fromDegrees(a[1] - c.width, a[0] - c.width, 0), new Cesium.Cartesian3.fromDegrees(a[1] + c.width, a[0] - c.width, 0), new Cesium.Cartesian3.fromDegrees(a[1] + c.width, a[0] + c.width, 0), new Cesium.Cartesian3.fromDegrees(a[1] - c.width, a[0] +
          c.width, 0)]
      }, material: new Cesium.ImageMaterialProperty({ image: c.image }), classificationType: Cesium.ClassificationType.TERRAIN, stRotation: 0, shadows: Cesium.ShadowMode.ENABLED
    }, interleave: !1, allowPicking: !1
  }); this.lla = a; this._options = c; c.opacity && this.setOpacity(c.opacity); c.scale && this.setScale(c.scale); c.rotation && this.setRotation(c.rotation)
};
geofs.api.groundTexture.prototype = {
  setUrl: function (a) { this._entity && (this._entity.polygon.material.image = a) }, setVisibility: function (a) { this._entity && (this._entity.show = a) }, setColor: function (a) { this._entity && (a.alpha = this.opacity || 1, this._entity.polygon.material.color = a) }, setOpacity: function (a) { if (this._entity) { var b = this._entity.polygon.material.color || new Cesium.Color(1, 1, 1, 1); b.alpha = a; this._entity.polygon.material.color = b; this.opacity = a } }, setRotation: function (a) {
    this._entity && (this._entity.stRotation =
      a)
  }, setScale: function (a) { this._entity && (this.scale = a, this.setLocation(this.lla)) }, setLocation: function (a) { if (this._entity) if (V3.isValid(a)) { this.lla = a; var b = this._options.width * this.scale; this._entity.hierarchy = [new Cesium.Cartesian3.fromDegrees(a[1] - b, a[0] - b, 0), new Cesium.Cartesian3.fromDegrees(a[1] + b, a[0] - b, 0), new Cesium.Cartesian3.fromDegrees(a[1] + b, a[0] + b, 0), new Cesium.Cartesian3.fromDegrees(a[1] - b, a[0] + b, 0)] } else geofs.debug.debugger() }, getLla: function (a) { return this.lla }, destroy: function () {
    this._entity &&
      (geofs.api.viewer.entities.remove(this._entity), this._entity = null)
  }
}; geofs.api.notify = function (a, b, c) { $.haring.create(a, b || "OK", c) }; geofs.api.analytics = { init: function () { }, event: function (a, b, c, d) { window.gtag && window.gtag("event", b, { event_category: a, event_label: c, value: d }) } }; geofs.api.postMessage = function (a) { window.top.postMessage(a, "*") };
geofs.api.Canvas = function (a) { this.canvas = document.createElement("canvas"); this.width = this.canvas.width = a.width; this.height = this.canvas.height = a.height; var b = {}; a.willReadFrequently && (b.willReadFrequently = !0); this.context = this.canvas.getContext("2d", b); a.color = a.color || "#000000"; this._options = a; this.patchSize = a.patchSize || a.width; this.context.fillStyle = a.color; this.context.fillRect(0, 0, this.canvas.width, this.canvas.height); this.images = {}; this.imageIndex = 0 };
geofs.api.Canvas.prototype = {
  loadTiles: function (a) {
    var b = this; Array.isArray(a) || (a = [a]); this.patchSize = this.canvas.width / Math.sqrt(a.length); this.imagesToLoad = a.length; this.imagesLoaded = 0; this.context.fillStyle = this._options.color; this.context.fillRect(0, 0, this.canvas.width, this.canvas.height); this._options.blur && (this.context.filter = "blur(" + this._options.blur + "px)"); return new Promise(function (c) {
      a.forEach(function (d, e) {
        d = b.loadImage(d, e); d.onload = function (f) { ++b.imagesLoaded == b.imagesToLoad && b.paintAndResolve(c) };
        d.onerror = function (f) { ++b.imagesLoaded == b.imagesToLoad && b.paintAndResolve(c) }
      })
    })
  }, paintAndResolve: function (a) { var b = this.canvas.width / this.patchSize, c; for (c in this.images) try { this.context.drawImage(this.images[c], c % b * this.patchSize, this.patchSize * Math.floor(c / b), this.patchSize, this.patchSize) } catch (d) { } a(this.canvas) }, clear: function (a) { this.context.clearRect(0, 0, this.canvas.width, this.canvas.height); a && (this.context.fillStyle = a, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)) }, loadImage: function (a,
    b) { b == void 0 && (b = this.imageIndex++); this.images[b] = this.images[b] || new Image; this.images[b].crossOrigin = "anonymous"; this.images[b].src = a; return this.images[b] }, drawRotatedSprite: function (a) {
      var b = a.image; if (b.complete) {
        var c = this.context; a.sprite = a.sprite || a.size; c.save(); c.translate(a.destination[0], a.destination[1]); c.rotate(a.rotation); a.translation = a.translation || [0, 0]; var d = V2.parseInt(V2.add(a.center, a.translation)); c.drawImage(b, a.origin[0], a.origin[1], a.sprite[0], a.sprite[1], -d[0], -d[1], a.size[0],
          a.size[1]); c.restore()
      }
    }, drawSprite: function (a) { var b = a.image; if (b.complete) { var c = this.context; a.sprite = a.sprite || a.size; a.center = a.center || [0, 0]; a.translation = a.translation || [0, 0]; a.destination = V2.add(V2.sub(a.destination, a.center), a.translation); c.drawImage(b, a.origin[0], a.origin[1], a.sprite[0], a.sprite[1], a.destination[0], a.destination[1], a.size[0], a.size[1]) } }, getImageAsURLData: function () { if (this.canvas.toBlob) this.canvas.toBlob(function (a) { return URL.createObjectURL(a) }); else return this.canvas.toDataURL() },
  destroy: function () { for (var a in this.images) this.images[a] = null; this.images = null; $(this.canvas).remove() }
};
geofs.api.FlatRunwayTerrainProvider = function (a) { var b = this; this.baseProvider = a.baseProvider; this.regions = {}; this.tiles = {}; this.minFlatteningLevel = this.defaultMinFlatteningLevel = 6; this.maximumLevel = 12; this.maximumLevel = a.maximumLevel || this.maximumLevel; this.flatten = !a.bypass; this.setMaximumLevel(this.maximumLevel); a = function () { b.regions = {}; for (var c in geofs.runways.nearRunways) b.addRunway(geofs.runways.nearRunways[c]) }; $(document).on("runwayUpdate", a); a() };
geofs.api.FlatRunwayTerrainProvider.prototype = {
  aName: "FlatRunwayTerrainProvider", get availability() { return this.baseProvider.availability }, get credit() { return this.baseProvider.credit }, get _tileCredits() { return this.baseProvider._tileCredits }, get errorEvent() { return this.baseProvider.errorEvent }, get hasMetadata() { return this.baseProvider.hasMetadata }, get _layers() { return this.baseProvider._layers }, get hasVertexNormals() { return this.baseProvider.hasVertexNormals }, get requestMetadata() { return this.baseProvider.requestMetadata },
  get requestVertexNormals() { return this.baseProvider.requestVertexNormals }, get hasWaterMask() { return this.baseProvider.hasWaterMask }, get _ready() { return this.baseProvider._ready }, get ready() { return this.baseProvider.ready }, get readyPromise() { return this.baseProvider.readyPromise }, get tilingScheme() { return this.baseProvider.tilingScheme }, getLevelMaximumGeometricError: function (a) { return this.baseProvider.getLevelMaximumGeometricError(a) }, getTileDataAvailable: function (a, b, c) {
    return c > this.maximumLevel ?
      !1 : this.baseProvider.getTileDataAvailable(a, b, c)
  }, setMaximumLevel: function (a) { this.minFlatteningLevel = a < this.defaultMinFlatteningLevel ? a : this.defaultMinFlatteningLevel; this.maximumLevel = a }, addRunway: function (a) {
    var b = xy2ll([a.padding, a.padding], a.threshold1); a.rec = Cesium.Rectangle.fromDegrees(Math.min(a.threshold1[1], a.threshold2[1]) - b[1], Math.min(a.threshold1[0], a.threshold2[0]) - b[0], Math.max(a.threshold1[1], a.threshold2[1]) + b[1], Math.max(a.threshold1[0], a.threshold2[0]) + b[0]); a.threshold1Cartesian =
      Cesium.Cartesian3.fromDegrees(a.threshold1[1], a.threshold1[0]); a.threshold2Cartesian = Cesium.Cartesian3.fromDegrees(a.threshold2[1], a.threshold2[0]); a.direction = Cesium.Cartesian3.subtract(a.threshold1Cartesian, a.threshold2Cartesian, new Cesium.Cartesian3); a = { name: a.id, rec: a.rec, runways: [a], coord: geofs.mainAirportList[a.icao], vertices: {} }; for (var c in this.regions) b = this.regions[c], Cesium.Rectangle.intersection(b.rec, a.rec) !== void 0 && (a.rec = Cesium.Rectangle.union(a.rec, b.rec), a.name += b.name, a.runways =
        a.runways.concat(b.runways), delete this.regions[c]); this.regions[a.name] = a
  }, requestTileGeometry: function (a, b, c, d) { if (c >= this.minFlatteningLevel && this.flatten) { var e = this.baseProvider.tilingScheme.tileXYToRectangle(a, b, c), f; for (f in this.regions) if (Cesium.Rectangle.intersection(this.regions[f].rec, e) !== void 0) return a = this.baseProvider.requestTileGeometry(a, b, c, d), a === void 0 ? void 0 : this.getPromise(a, e, this.regions[f]) } return this.baseProvider.requestTileGeometry(a, b, c, d) }, getPromise: function (a, b, c) {
    var d =
      this; if (a !== void 0) {
        var e = new Promise(function (f, g) { c.referenceElevation ? f(c.referenceElevation) : (c.coord || (c.coord = [c.runways[0].threshold1[0], c.runways[0].threshold1[1]]), Cesium.sampleTerrain(d.baseProvider, d.maximumLevel, [Cesium.Cartographic.fromDegrees(c.coord[1], c.coord[0])]).then(function (k) { k[0] && k[0].height ? (c.referenceElevation = k[0].height, c.runways.forEach(function (m) { m.setElevation(c.referenceElevation) }), f(c.referenceElevation)) : g("no value") })) }); return Promise.all([e, a]).then(function (f) {
          try {
            var g =
              f[0], k = f[1]; for (f = 0; f < c.runways.length; f++) {
                var m = c.runways[f], n = !1; k._oldMinimumHeight = k._minimumHeight; k._oldMaximumHeight = k._maximumHeight; var q = 32767 / (k._oldMaximumHeight - k._oldMinimumHeight); g > k._maximumHeight && (k._maximumHeight = g, n = !0); g < k._minimumHeight && (k._minimumHeight = g, n = !0); for (var u = k._oldMinimumHeight - k._minimumHeight, z = 32767 / (k._maximumHeight - k._minimumHeight), B = (g - k._minimumHeight) * z, p = 0; p < k._heightValues.length; p++) {
                  var r = b.south + k._quantizedVertices[k._heightValues.length + p] / 32767 *
                    b.height, C = b.west + k._quantizedVertices[p] / 32767 * b.width; if (Cesium.Rectangle.contains(c.rec, new Cesium.Cartographic(C, r, 0))) {
                      var A = Cesium.Cartesian3.fromRadians(C, r); Cesium.Cartesian3.subtract(m.threshold1Cartesian, A, A); var I = Cesium.Cartesian3.magnitude(A), aa = Cesium.Cartesian3.multiplyByScalar(m.direction, Cesium.Cartesian3.dot(A, m.direction) / Cesium.Cartesian3.dot(m.direction, m.direction), new Cesium.Cartesian3), X = Cesium.Cartesian3.subtract(A, aa, new Cesium.Cartesian3); if (Math.sqrt(Cesium.Cartesian3.dot(X,
                        X)) < m.padding && I < m.lengthMeters + m.padding) { k._heightValues[p] = B; continue }
                    } n && (k._heightValues[p] = (k._heightValues[p] / q + u) * z)
                }
              } return k
          } catch (ea) { geofs.debug.log("FlatRunwayTerrainProvider promise: " + ea) }
        })
      }
  }
};
geofs.api.waterDetection = {
  initialized: !1, canvasAPI: null, blur: 0, backgroundColour: "#000000", depthSlope: .03, depthOffset: 1.5, tileSize: 256, zoomLevel: 11, lastTileURL: null, lastDepth: 0, create: function () { this.canvasAPI = new geofs.api.Canvas({ width: this.tileSize, height: this.tileSize, color: this.backgroundColour, willReadFrequently: !0 }); this.initialized = !0 }, reset: function () { this.lastDepth = 0 }, getWaterDepth: function (a, b) {
    if (!this.initialized) return null; var c = geofs.coord2tile(a, b, this.zoomLevel), d = geofs.landuseServer +
      this.zoomLevel + "/" + c.x + "/" + c.y + ".png"; if (this.lastTileURL != d) return this.canvasAPI.context.filter = "blur(" + this.blur + "px)", this.canvasAPI.loadTiles(d), this.lastTileURL = d, this.tileOrigin = geofs.tile2coord(c.x, c.y, this.zoomLevel), a = geofs.tile2coord(c.x + 1, c.y + 1, this.zoomLevel), this.pixelGeographicSize = { lat: (a.lat - this.tileOrigin.lat) / this.tileSize, lon: (a.lon - this.tileOrigin.lon) / this.tileSize }, this.lastDepth; a = this.canvasAPI.context.getImageData(Math.round((b - this.tileOrigin.lon) / this.pixelGeographicSize.lon),
        Math.round((a - this.tileOrigin.lat) / this.pixelGeographicSize.lat), 1, 1).data; a = this.depthSlope * a[2] - this.depthOffset; geofs.cautiousWithTerrain && (a = 0); return this.lastDepth = a
  }, destroy: function () { this.canvasAPI && (this.canvasAPI.destroy(), this.canvasAPI = null); this.initialized = !1 }
}; geofs.api.tileLayerConstructor = L.tileLayer.fallback; geofs.api.mapMaxZoom = 13; geofs.api.mapOption = { minZoom: 3, maxZoom: geofs.api.mapMaxZoom, markerZoomAnimation: !1, worldCopyJump: !0, preferCanvas: !0, attributionControl: !1 };
geofs.api.mapTooltipOptions = { permanent: !1 }; geofs.api.toolTipPositioning = [{ direction: "top", offset: L.point(0, -15) }, { direction: "right", offset: L.point(15, 0) }, { direction: "bottom", offset: L.point(0, 15) }, { direction: "left", offset: L.point(-15, 0) }];
geofs.api.map = {
  defaultMarker: { coords: [0, 0], radius: 5, color: "#ffffff", weight: 2, fillColor: "#000000", fillOpacity: 1, pane: "markerPane", popupMinWidth: 200, popupMaxWidth: 400 }, markerByMinZoom: [[], [], [], [], [], [], [], [], [], [], [], [], [], []], markerLayers: { navaid: { minZoom: 6, maxZoom: 15, tileSize: 5, tiles: {} }, major: { minZoom: 6, maxZoom: 15, tileSize: 5, tiles: {} }, minor: { minZoom: 8, maxZoom: 15, tileSize: 5, tiles: {} } }, defaultLayer: { minZoom: 0, maxZoom: 15, tileSize: 10, tiles: {} }, init: function (a, b, c) {
    var d = this; a.zoom = a.zoom || 10; this._holder =
      a.holder || $(".geofs-map-viewport")[0]; this._holder = a.holder || $(".geofs-map-viewport")[0]; this._map = L.map(this._holder, geofs.api.mapOption); geofs.api.tileLayerConstructor(geofs.osmTileProvider, { attribution: "\u00a9 OpenStreetMap contributors - Made with Natural Earth." }).addTo(this._map); this._map.zoomControl.setPosition("bottomleft"); this.icons = {}; this._map.on("load resize moveend", function () { d.updateMarkerLayers() }); this._map.on("zoomend", function () {
        d._map.getZoom(); d.updateMarkerVisibility(); for (var e in ui.playerMarkers) {
          var f =
            ui.playerMarkers[e]._marker; f._icon && (f._icon.style.transform += " rotate(" + f._geofsRotation + "deg)")
        } d.updateMarkerLayers()
      }); this._map.getPane("tooltipPane").style.opacity = .9; this._map.getPane("overlayPane").style.opacity = .7; this._genericPopup = L.popup({ closeButton: !1 }); this._map.setView(L.latLng(b, c), a.zoom); this._map.on("mouseup", controls.mouseUpHandler); $(document).on("click ", ".geofs-createPath", function () { geofs.api.map.flightPathOn ? geofs.api.map.stopCreatePath(d) : geofs.api.map.createPath() }).on("click",
        ".geofs-clearPath", function () { geofs.api.map.clearPath(d) })
  }, updateMap: function (a, b, c) { a = L.latLng(a, b); c && (a = this._map.project(a), a = new L.point(a.x + c[0], a.y + c[1]), a = this._map.unproject(a)); this._map.panTo(a) }, getCenterLla: function (a, b) { a = this._map.getCenter(); return [a.lat, a.lng] }, getPixelSize: function () { return this._map.getSize() }, llaToPixel: function (a) { return this._map.latLngToContainerPoint(L.latLng(a[0], a[1])) }, getIcon: function (a, b) {
    this.icons[a] || (this.icons[a] = b.url ? L.icon({
      iconUrl: b.url, iconSize: b.size ||
        [0, 0], iconAnchor: b.anchor || [0, 0], popupAnchor: [0, 0], opacity: b.opacity, className: b.className
    }) : L.divIcon({ className: b.className })); return this.icons[a]
  }, addLayer: function (a) { return this._map.createPane(a) }, addLayeredMarker: function (a, b) {
    var c = geofs.getLatLonMatrixcoord(b.coords[0], b.coords[1], geofs.api.map.markerLayers[a].tileSize); geofs.api.map.markerLayers[a] || (geofs.api.map.markerLayers[a] = Object.assign({}, geofs.api.map.defaultLayer)); geofs.api.map.markerLayers[a].visibileTiles = {}; geofs.api.map.markerLayers[a].tiles[c] ||
      (geofs.api.map.markerLayers[a].tiles[c] = []); geofs.api.map.markerLayers[a].tiles[c].push(b)
  }, getVisibleTiles: function (a, b) { var c = a.getNorthEast().wrap(), d = a.getSouthWest().wrap(); a = Math.floor(d.lng / b); var e = Math.floor(d.lat / b), f = (parseInt((c.lng - d.lng) / b) || 1) + 2; b = (parseInt((c.lat - d.lat) / b) || 1) + 2; c = {}; for (d = a; d < a + f; d++)for (var g = e; g < e + b; g++)c[g + "/" + d] = !0; return c }, showTile: function (a, b) {
    a.tiles[b] && (a.tiles[b].forEach(function (c) {
      c.marker || (c.marker = new geofs.api.map.marker(c)); c.marker.addToMap();
      c.marker._marker.options.keepToFront && c.marker._marker.bringToFront()
    }), a.visibileTiles[b] = a.tiles[b])
  }, hideTile: function (a, b) { a.visibileTiles && a.visibileTiles[b] && a.tiles[b] && (a.tiles[b].forEach(function (c) { c.marker && (c.marker.destroy(), c.marker = null) }), delete a.visibileTiles[b]) }, updateMarkerLayers: function () {
    var a = this._map.getZoom(), b; for (b in geofs.api.map.markerLayers) {
      var c = geofs.api.map.markerLayers[b]; if (a > c.minZoom && a < c.maxZoom) {
        var d = this.getVisibleTiles(this._map.getBounds(), c.tileSize),
          e; for (e in c.visibileTiles) d[e] || this.hideTile(c, e); for (e in d) this.showTile(c, e)
      } else for (e in c.visibileTiles) this.hideTile(c, e)
    }
  }, updateMarkerVisibility: function () {
    for (var a = this._map.getZoom(), b = 0; b < this.markerByMinZoom.length; b++)this.markerByMinZoom[b].hidden ? b <= a && (this.markerByMinZoom[b].forEach(function (c) { c.addToMap(); c._marker.options.keepToFront && c._marker.bringToFront() }), this.markerByMinZoom[b].hidden = !1) : b > a && (this.markerByMinZoom[b].forEach(function (c) { c.removeFromMap() }), this.markerByMinZoom[b].hidden =
      !0)
  }, getCoordsFromMouseEvent: function (a) { return [a.latlng.lat, a.latlng.lng] }, isGenericPopupOpen: function () { return !!this._genericPopup._map }, closeGenericPopup: function () { this._genericPopup.closePopup() }, openGenericPopup: function (a, b) { this._genericPopup.closePopup(); this._genericPopup.setContent(a).setLatLng(L.latLng(b[0], b[1])).openOn(this._map) }, closeAllPopups: function () { this._map.closePopup() }, setTooltipVisibility: function (a) { geofs.api.mapTooltipOptions.permanent = a }, addImageLayer: function (a, b, c) {
    return L.imageOverlay(a,
      c || [[90, -180], [-90, 180]], { opacity: b }).addTo(this._map)
  }, removeImageLayer: function (a) { a.remove() }
};
geofs.api.map.marker = function (a) {
  a = Object.assign({}, geofs.api.map.defaultMarker, a); a.zIndexOffset = a.zIndex; a.img ? (a.img.offset && (a.img.rotate && (a.img.offset = V3.rotate([a.img.offset[0], a.img.offset[1], 0], [0, 0, 1], a.img.rotate * DEGREES_TO_RAD)), a.img.offset = { x: a.img.offset[0], y: a.img.offset[1] }), this._marker = L.canvasMarker(a.coords, a)) : a.icon ? (a.opacity = a.opacity || a.icon.options.opacity, this._marker = L.marker(a.coords, a)) : this._marker = L.circleMarker(a.coords, a); a.popup && this._marker.bindPopup(a.popup,
    { minWidth: a.popupMinWidth, maxWidth: a.popupMaxWidth, closeButton: !1 }); a.label && (this.label = a.label, a = Object.assign({}, geofs.api.mapTooltipOptions, geofs.api.toolTipPositioning[Math.floor(Math.random() * 4)]), this._marker.bindTooltip(this.label, a)); a.minZoom && a.minZoom <= geofs.api.mapMaxZoom && geofs.api.map.markerByMinZoom[a.minZoom].push(this)
};
geofs.api.map.marker.prototype = {
  addToMap: function (a, b) { this._marker.addTo(a || geofs.api.map._map) }, removeFromMap: function () { this._marker.remove() }, update: function (a, b, c, d) { a && b && this._marker.setLatLng(L.latLng(a, b)); d && (this.label = d, this._marker.setTooltipContent(d)); c && this._marker._icon && (this._marker._geofsRotation = c, this._marker._icon.style.transform += " rotate(" + this._marker._geofsRotation + "deg)") }, destroy: function () { this._marker.unbindTooltip(); this._marker.unbindPopup(); this._marker.remove() },
  resetTooltip: function () { if (this._marker) { this._marker.unbindTooltip(); var a = Object.assign({}, geofs.api.mapTooltipOptions, geofs.api.toolTipPositioning[Math.floor(Math.random() * 4)]); this._marker.bindTooltip(this.label, a) } }
}; geofs.api.map.path = []; geofs.api.map.createPath = function (a, b, c) { a = a || geofs.api.map.path; b = L.polyline(b, c).addTo(geofs.api.map._map); a.push(b); return b };
geofs.api.map.createGreatCirclePath = function (a, b, c, d) { a = a || geofs.api.map.path; b = L.Polyline.Arc(b, c, d).addTo(geofs.api.map._map); a.push(b); return b }; geofs.api.map.clearPath = function (a) { a = a || geofs.api.map.path; a.forEach(function (b) { b.remove() }); a = [] }; geofs.api.reverserGeocode = function (a, b) { jQuery.getJSON("/backend/geocode/geocode.php?query=" + a, function (c) { try { c.lat && c.lon && b(c.lat, c.lon) } catch (d) { } }) }; geofs.api.pixelDensityMobileThreshold = 1.5;
geofs.api.testIfMobileDevice = function () { var a = geofs.api.hasTouch() && geofs.api.hasOrientation() && window.devicePixelRatio >= geofs.api.pixelDensityMobileThreshold; return geofs.isApp || geofs.forceMobileMode || a ? !0 : !1 }; geofs.api.hasTouch = function () { return !!navigator.maxTouchPoints }; geofs.api.hasOrientation = function () { return !!window.DeviceOrientationEvent }; geofs.api.getPlatform = function () { return geofs.platform ? geofs.platform : null };
geofs.api.doRetro = function () {
  geofs.retroOn || (geofs.aircraftList[2E3] = { name: "Retro 172", dir: "|models|aircraft|retro|c172|", multiplayerFiles: "multiplayer.gltf,multiplayer-low.gltf", path: "/models/aircraft/retro/c172/" }, geofs.retroOn = !0, clearInterval(weather.interval), weather.refresh = function () { }, weather.update = function () { }, geofs.aircraft.instance.change(2E3).then(function () {
    audio.impl.html5.playFile("/sounds/retro/chiptune.mp3", 1E3); geofs.useSimpleShadow(!0); var a = Cesium.Color.fromCssColorString("#2caecf"),
      b = Cesium.Color.fromCssColorString("#0b2740"); geofs.fx.water.material = new Cesium.Material({ fabric: { type: "retrowire", source: geofsShaders["wireFS.glsl"], uniforms: { windSpeed: 0, geofsTime: 0, wireframeColor: a, backgroundColor: b } } }); geofs.api.viewer.scene.globe.material = geofs.fx.water.material; var c = geofs.api.viewer.entities.add({
        position: Cesium.Cartesian3.fromDegrees(0, 0, 1E6), billboard: {
          image: "images/retro/sun.png", show: !0, pixelOffset: new Cesium.Cartesian2(0, 0), eyeOffset: new Cesium.Cartesian3(0, 0, 0), horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
          verticalOrigin: Cesium.VerticalOrigin.BOTTOM, width: 256, height: 256
        }
      }); geofs.api.addFrameCallback(function () { c.position = new Cesium.Cartesian3.fromDegrees(geofs.aircraft.instance.llaLocation[1] - 10, geofs.aircraft.instance.llaLocation[0], 1E4) }); geofs.fx.atmosphere.create(!1, 0, !1, !1, !0); geofs.api.viewer.scene.skyAtmosphere.hueShift = .3; geofs.api.viewer.scene.skyAtmosphere.brightnessShift = -.2; geofs.api.viewer.scene.skyAtmosphere.saturationShift = .2; geofs.api.viewer.scene.skyBox.show = !1; geofs.api.viewer.scene.sun.show =
        !1; geofs.api.viewer.scene.fog.density = 8E-5; geofs.runways.modelVisibility = !0; geofs.runways.redraw(); geofs.buildings.buildingsShader && (geofs.buildings.buildingsShader && geofs.buildings.buildingsShader.setUniform("u_retro", !0), geofs.buildings.buildingsShader.setUniform("u_buildingTexture", new Cesium.TextureUniform({ url: "shaders/buildings/retro.jpg", minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR })), geofs.buildings.buildingsShader.setUniform("u_specularTexture", new Cesium.TextureUniform({ url: "shaders/black.jpg" })));
    geofs.trees.shader && geofs.trees.shader.setUniform("u_treeTexture", new Cesium.TextureUniform({ url: "shaders/trees/retro.png", minificationFilter: Cesium.TextureMinificationFilter.LINEAR_MIPMAP_LINEAR }))
  }))
};
geofs.api.color = {
  pixelToHex: function (a) { return Cesium.Color.fromBytes(a[0], a[1], a[2], a[3] || 255).toCssHexString() }, bytesToHex: function (a, b, c, d) { return Cesium.Color.fromBytes(a, b, c, d || 255).toCssHexString() }, compareRGBBytes: function (a, b) { a.forEach(function (c, d) { if (c != b[d]) return !1 }); return !0 }, mix: function (a, b, c) { return Cesium.Color.lerp(a, b, c, new Cesium.Color) }, mixArray: function (a, b) {
    var c = a.length - 1; b *= c; var d = parseInt(b); c = clamp(parseInt(b + 1), 0, c); return Cesium.Color.lerp(a[d], a[c], b - Math.floor(b),
      new Cesium.Color)
  }
};
geofs.runways = {
  nearRunways: [], tempRunways: [], lastRunwayTestLocation: [0, 0], runwayNumberLimit: 6, refreshRate: 1E4, refreshDistanceThreshold: .1, modelVisibility: !1, defaultPadding: 1E3, defaultWidth: 200, defaultLength: 1E4, tileLength: 582, modelRunwayWidth: 60, thresholdToAimingPoint: 350, thresholdLength: 582, modelVerticalOffset: .1, imageryLayers: [], imageryOpacity: .6, redraw: function () { geofs.runways.modelVisibility && (geofs.runways.setRunwayModelVisibility(!1), geofs.runways.setRunwayModelVisibility(!0)) }, refresh: function () {
    var a =
      geofs.aircraft.instance.llaLocation; clearInterval(geofs.runwaysCheckTimeout); geofs.runwaysCheckTimeout = setInterval(geofs.runways.refresh, geofs.runways.refreshRate); if (!(V2.length(V2.sub(a, geofs.runways.lastRunwayTestLocation)) < geofs.runways.refreshDistanceThreshold)) {
        geofs.runways.lastRunwayTestLocation = a; var b = geofs.runways.getNearRunways(a, geofs.runways.runwayNumberLimit), c = {}; for (a = 0; a < b.length; a++) {
          var d = geofs.runways.generateRunwayId(b[a]); c[d] || (c[d] = geofs.runways.newRunwayFromGridRecord(b[a],
            d))
        } for (a in geofs.runways.nearRunways) c[a] || geofs.runways.nearRunways[a].destroy(); geofs.runways.nearRunways = Object.assign({}, c); for (a in geofs.runways.nearRunways) b = geofs.runways.nearRunways[a], geofs.runways.modelVisibility && b.generateRunwayModel(), b.addPAPIs(), b.setElevation(); $("body").trigger("runwayUpdate")
      }
  }, reset: function () { Object.keys(geofs.runways.nearRunways).forEach(function (a) { return geofs.runways.nearRunways[a].destroy() }); geofs.runways.nearRunways = {}; geofs.runways.refresh() }, getNearestRunway: function (a) {
    var b =
      1; do var c = geofs.runways.getNearRunways(a, 1, b++); while (!c.length && b < 10); return c[0] ? (a = c[0], b = geofs.runways.generateRunwayId(a), geofs.runways.nearRunways[b] || (geofs.runways.nearRunways[b] = geofs.runways.newRunwayFromGridRecord(a, b)), geofs.runways.nearRunways[b]) : null
  }, getNearRunways: function (a, b, c) {
    c = c || 1; b = b || geofs.runways.runwayNumberLimit; for (var d = parseInt(a[0]), e = parseInt(a[1]), f = [], g, k = -c; k <= c; k++) { g = geofs.majorRunwayGrid[e + k] || {}; for (var m = -c; m <= c; m++)g[d + m] && (f = f.concat(g[d + m])) } geofs.runways.setRunwayDistance(a,
      f); f.sort(function (n, q) { return n.distance - q.distance }); return f.slice(0, b)
  }, setRunwayDistance: function (a, b) { for (var c = 0, d = b.length; c < d; c++) { var e = b[c]; e.distance = geofs.utils.llaDistanceInMeters(a, [e[4], e[5]]) } }, setRunwayModelVisibility: function (a) { Object.keys(geofs.runways.nearRunways).forEach(function (b) { geofs.runways.nearRunways[b].destroyRunwayModel(); a && geofs.runways.nearRunways[b].generateRunwayModel() }); geofs.runways.modelVisibility = a }, toggleRunwayCircuit: function (a) {
    this.tempRunways[a] = this.tempRunways[a] ||
      geofs.runways.newRunwayFromNavaidId(a); this.tempRunways[a].circuitModelA ? (this.tempRunways[a].hideCircuit(), this.tempRunways[a].destroy()) : this.tempRunways[a].showCircuit()
  }, setCircuitVisibility: function (a) { Object.keys(geofs.runways.nearRunways).forEach(function (b) { geofs.runways.nearRunways[b].hideCircuit(); a && geofs.runways.nearRunways[b].showCircuit() }); geofs.preferences.circuits = a }, env: {}, getRotationCanvas: function (a) {
    geofs.runways.env[a] || (geofs.runways.env[a] = {}, geofs.runways.env[a].promise = new Promise(function (b) {
      var c =
        document.createElement("img"); c.onload = function (d) { d = d.currentTarget; var e = document.createElement("canvas"); e.width = d.width; e.height = d.width; geofs.runways.env[a].image = d; geofs.runways.env[a].canvas = e; geofs.runways.env[a].context = e.getContext("2d"); geofs.runways.env[a].context.translate(d.width / 2, d.width / 2); b(geofs.runways.env[a]) }; c.src = a
    }), geofs.runways.env[a].promise.then(function (b) { return b })); return geofs.runways.env[a].promise
  }, setAsyncPrimitiveMaterial: function (a, b, c) {
    var d; return (0, $jscomp.asyncExecutePromiseGeneratorProgram)(function (e) {
      if (e.nextAddress ==
        1) return e.yield(geofs.runways.getRotationCanvas(a), 2); d = e.yieldResult; d.context.clearRect(-d.image.width, -d.image.width, d.image.width * 2, d.image.width * 2); d.context.save(); d.context.rotate(b); d.context.globalAlpha = geofs.runways.imageryOpacity; d.context.drawImage(d.image, -d.image.width / 2, -(d.image.height / 2)); d.canvas.toBlob ? d.canvas.toBlob(function (f) { c.appearance = new Cesium.EllipsoidSurfaceAppearance({ material: new Cesium.Material({ fabric: { type: "Image", uniforms: { image: URL.createObjectURL(f) } } }), aboveGround: !0 }) }) :
          c.appearance = new Cesium.EllipsoidSurfaceAppearance({ material: new Cesium.Material({ fabric: { type: "Image", uniforms: { image: d.canvas.toDataURL() } } }), aboveGround: !0 }); d.context.restore(); e.jumpToEnd()
    })
  }, asyncSetImageLayerRotationPosition: function (a, b, c, d) {
    var e, f, g; return (0, $jscomp.asyncExecutePromiseGeneratorProgram)(function (k) {
      if (k.nextAddress == 1) return k.yield(geofs.runways.getRotationCanvas(a), 2); e = k.yieldResult; e.context.clearRect(-e.image.width, -e.image.width, e.image.width * 2, e.image.width * 2); e.context.save();
      e.context.rotate(b); e.context.drawImage(e.image, -e.image.width / 2, -(e.image.height / 2)); f = { rectangle: c, alpha: geofs.runways.imageryOpacity, minimumTerrainLevel: 12 }; e.canvas.toBlob ? e.canvas.toBlob(function (m) { m = new Cesium.ImageryLayer(new Cesium.SingleTileImageryProvider({ url: URL.createObjectURL(m), rectangle: c }), f); geofs.api.viewer.imageryLayers.add(m); d.imageryLayers.push(m) }) : (g = new Cesium.ImageryLayer(new Cesium.SingleTileImageryProvider({ url: e.canvas.toDataURL(), rectangle: c }), f), geofs.api.viewer.imageryLayers.add(g),
        d.imageryLayers.push(g)); e.context.restore(); k.jumpToEnd()
    })
  }
}; geofs.runways.generateRunwayId = function (a) { return a[0] + a[1] + a[2] + a[3] }; geofs.runways.newRunwayFromNavaidId = function (a) { var b = geofs.nav.getNavaid(a); return geofs.runways.newRunwayFromNavaidObject(b, a) }; geofs.runways.newRunwayFromNavaidObject = function (a, b) { return new geofs.runways.runway([a.icao, null, null, a.heading, a.lat, a.lon, null], b, !0) }; geofs.runways.newRunwayFromGridRecord = function (a, b) { return new geofs.runways.runway(a, b) };
geofs.runways.runway = function (a, b, c) {
  this.id = b || geofs.runways.generateRunwayId(a); this.icao = a[0]; this.location = [a[4], a[5], 0]; this.heading = fixAngle(a[3]); this.lengthFeet = a[1]; this.widthFeet = a[2]; this.padding = a[6] || geofs.runways.defaultPadding; this.headingRad = this.heading * DEGREES_TO_RAD; this.lengthMeters = (this.lengthFeet || geofs.runways.defaultLength) * FEET_TO_METERS; this.widthMeters = (this.widthFeet || geofs.runways.defaultWidth) * FEET_TO_METERS; this.threshold1 = this.location; this.meterLengthLocal = [Math.sin(this.headingRad),
  Math.cos(this.headingRad), 0]; this.meterlla = xyz2lla(this.meterLengthLocal, this.threshold1); this.lengthInLla = V3.scale(this.meterlla, this.lengthMeters); this.meterWidthLocal = [-Math.cos(this.headingRad), Math.sin(this.headingRad), 0]; this.meterWidthLla = xyz2lla(this.meterWidthLocal, this.threshold1); this.widthInLla = V3.scale(this.meterWidthLla, this.widthMeters); this.meterAcrossInLla = V3.scale(this.widthInLla, 1 / this.widthMeters); this.threshold2 = V3.add(this.threshold1, this.lengthInLla); this.aimingPointLla1 = V3.add(this.threshold1,
    V3.scale(this.meterlla, geofs.runways.thresholdToAimingPoint)); this.aimingPointLla2 = V3.add(this.threshold2, V3.scale(this.meterlla, -geofs.runways.thresholdToAimingPoint)); this.lightsOn = !1; this.lights = []; this.PAPIs = []; this.localStepXm = this.widthMeters / 33; this.localStepYm = 50; this.stepX = V3.scale(this.widthInLla, 1 / 33); this.stepY = V3.scale(this.meterlla, 50)
};
geofs.runways.runway.prototype = {
  setElevation: function (a) { var b = this; this.elevationSet || (a == void 0 ? geofs.api.getGuarantiedGroundAltitude(geofs.mainAirportList[this.icao] ? geofs.mainAirportList[this.icao] : this.threshold1).then(function (c) { b.setElevation(c[0].height) }) : (this.location[2] = a, this.threshold1[2] = a, this.threshold2[2] = a, this.PAPIs.forEach(function (c) { c.location[2] = a }), this.elevationSet = !0)) }, showCircuit: function () {
    this.circuitModelA || this.icao == "FAKE" || (this.circuitModelA = new geofs.api.Model(null,
      { url: "/models/objects/misc/circuitA.glb", location: [this.threshold1[0], this.threshold1[1], 0], rotation: [this.heading, 0, 0], altitudeMode: geofs.api.ALTITUDE_RELATIVE, scale: 1 }), this.circuitModelB = new geofs.api.Model(null, { url: "/models/objects/misc/circuitB.glb", location: [this.threshold2[0], this.threshold2[1], 0], rotation: [this.heading, 0, 0], altitudeMode: geofs.api.ALTITUDE_RELATIVE, scale: 1 }))
  }, destroyCircuit: function () {
    this.circuitModelA && (this.circuitModelA.destroy(), this.circuitModelA = null, this.circuitModelB.destroy(),
      this.circuitModelB = null)
  }, hideCircuit: function () { this.destroyCircuit() }, turnLightsOn: function () {
    if (this.icao != "FAKE" && !this.lightsOn) {
      var a = geofs.runwaysLights.templateCenter[1] - 1, b = geofs.runwaysLights.thresholdLightTemplate[a], c = b[1]; b = -c; for (var d = a, e = geofs.runwaysLights.thresholdLightTemplate.length; d < e; d++) { var f = geofs.runwaysLights.thresholdLightTemplate[d]; a = f[0]; var g = b; for (f = b + f[1]; g < f; g++)this.addLightRow(this.threshold1, a, -g), b++ } d = V2.add(this.threshold1, V2.scale(this.stepY, c)); c = (this.lengthMeters -
        this.localStepYm * c) / this.localStepYm; a = geofs.runwaysLights.thresholdLightTemplate[0][0]; for (b = 0; b < c; b++)this.addLightRow(d, a, b); a = geofs.runwaysLights.templateCenter[1] - 1; b = geofs.runwaysLights.thresholdLightTemplate[a]; c = b[1]; b = -c; d = a; for (e = geofs.runwaysLights.thresholdLightTemplate.length; d < e; d++)for (f = geofs.runwaysLights.thresholdLightTemplate[d], a = f[0], g = b, f = b + f[1]; g < f; g++)this.addLightRow(this.threshold2, a, g), b++; this.lightsOn = !0
    }
  }, addLightRow: function (a, b, c) {
    a = V2.add(a, V2.scale(this.stepY, c));
    c = 0; for (var d = b.length; c < d; c++) { var e = b[c]; if (e) { var f = V2.add(a, V3.scale(this.stepX, c - geofs.runwaysLights.templateCenter[0])); f[2] = geofs.runwaysLights.lightElevation; this.lights.push(new geofs.fx.light(f, e, geofs.runwaysLights.lightBillboardOptions)) } }
  }, turnLightsOff: function () { if (this.lightsOn) { for (var a = 0; a < this.lights.length; a++)this.lights[a].destroy(), this.lights[a] = null; this.lights = []; this.lightsOn = !1 } }, addPAPIs: function () {
    if (!this.PAPIs.length) {
      var a = xyz2lla(V3.scale(this.meterWidthLocal, 9),
        this.threshold1), b = V3.add(this.aimingPointLla1, xyz2lla(V3.scale(this.meterWidthLocal, this.widthMeters / 2 + 15), this.aimingPointLla1)); b = V3.add(b, V3.scale(this.stepY, 5)); this.PAPIs.push(new geofs.runwaysLights.PAPI(b, a)); a = xyz2lla(V3.scale(this.meterWidthLocal, -9), this.threshold2); b = V3.add(this.aimingPointLla2, xyz2lla(V3.scale(this.meterWidthLocal, -this.widthMeters / 2 - 15), this.aimingPointLla2)); b = V3.add(b, V3.scale(this.stepY, -5)); this.PAPIs.push(new geofs.runwaysLights.PAPI(b, a))
    }
  }, generateRunwayModel: function () {
    if (!this.modelExists &&
      this.icao != "FAKE") {
      var a = new Cesium.Color(.5, .5, .5, geofs.runways.imageryOpacity); if (geofs.retroOn) a = new Cesium.GeometryInstance({
        geometry: new Cesium.GroundPolylineGeometry({
          positions: Cesium.Cartesian3.fromDegreesArray([this.threshold1[1] - this.widthInLla[1], this.threshold1[0] - this.widthInLla[0], this.threshold1[1] + this.widthInLla[1], this.threshold1[0] + this.widthInLla[0], this.threshold2[1] + this.widthInLla[1], this.threshold2[0] + this.widthInLla[0], this.threshold2[1] - this.widthInLla[1], this.threshold2[0] -
            this.widthInLla[0]]), width: 10, loop: !0
        }), attributes: { color: Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString("#2caecf")) }
      }), geofs.api.viewer.scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({ geometryInstances: a, appearance: new Cesium.PolylineColorAppearance })); else if (Cesium.Entity.supportsMaterialsforEntitiesOnTerrain(geofs.api.viewer.scene) && !geofs.isApp) {
        this.entities = []; var b = V3.scale(this.widthInLla, .5); a = geofs.api.viewer.entities.add({
          polygon: {
            hierarchy: {
              positions: [new Cesium.Cartesian3.fromDegrees(this.threshold1[1] -
                b[1], this.threshold1[0] - b[0], 0), new Cesium.Cartesian3.fromDegrees(this.threshold1[1] + this.lengthInLla[1] - b[1], this.threshold1[0] + this.lengthInLla[0] - b[0], 0), new Cesium.Cartesian3.fromDegrees(this.threshold1[1] + this.lengthInLla[1] + b[1], this.threshold1[0] + this.lengthInLla[0] + b[0], 0), new Cesium.Cartesian3.fromDegrees(this.threshold1[1] + b[1], this.threshold1[0] + b[0], 0)]
            }, material: new Cesium.ImageMaterialProperty({ image: "models/objects/runway/full.jpg", color: a }), classificationType: Cesium.ClassificationType.TERRAIN,
            stRotation: this.headingRad - HALF_PI, shadows: Cesium.ShadowMode.ENABLED
          }, interleave: !1, allowPicking: !1
        }); this.modelExists = !0; this.entities.push(a)
      } else b = this.lengthMeters * .5, a = V2.scale(this.meterlla, b), b = xy2ll([b, b], this.threshold1), a = [this.threshold1[0] + a[0], this.threshold1[1] + a[1]], a = Cesium.Rectangle.fromDegrees(a[1] - b[1], a[0] - b[0], a[1] + b[1], a[0] + b[0]), geofs.runways.asyncSetImageLayerRotationPosition("models/objects/runway/full.jpg", this.headingRad - HALF_PI, a, this)
    }
  }, destroyRunwayModel: function () {
    this.entities &&
      this.entities.forEach(function (a) { geofs.api.viewer.entities.remove(a) }); this.primitives && this.primitives.forEach(function (a) { geofs.api.viewer.scene.groundPrimitives.remove(a) }); this.entities = null; this.imageryLayers && (this.imageryLayers.forEach(function (a) { geofs.api.viewer.imageryLayers.remove(a, !0) }), this.imageryLayers = []); this.creationTime = null; this.modelExists = !1
  }, destroyLights: function () { if (this.lights) { for (var a = 0; a < this.lights.length; a++)this.lights[a].destroy(); this.lights = [] } }, destroyPAPIs: function () {
    if (this.PAPIs) {
      for (var a =
        0; a < this.PAPIs.length; a++)this.PAPIs[a].destroy(); this.PAPIs = []
    }
  }, destroy: function () { this.destroyRunwayModel(); this.destroyCircuit(); this.destroyLights(); this.destroyPAPIs() }
}; $("body").on("runwayUpdate", function () { geofs.runwaysLights.updateAll() }); $("body").on("nightChange", function () { geofs.runwaysLights.updateAll() });
geofs.runwaysLights = {
  lightBillboardOptions: { altitudeMode: geofs.api.ALTITUDE_RELATIVE, sizeInMeters: !1, scaleByDistance: new Cesium.NearFarScalar(1, 1, 4E3, .15) }, papiBillboardOptions: { altitudeMode: geofs.api.ALTITUDE_RELATIVE, sizeInMeters: !1, scaleByDistance: new Cesium.NearFarScalar(1, .15, 4E3, .05) }, lightElevation: .5, thresholdLightTemplate: [[[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], "length"], [[1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1], 12], [[3, 0, 3, 0, 3, 0, 3,
    0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3, 0, 3], 1], [[0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], 5], [[0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], 1], [[0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0], 5], [[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], 1], [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 5]], templateCenter: [17, 2]
}; geofs.runwaysLights.turnAllOff = function () { for (var a in geofs.runways.nearRunways) geofs.runways.nearRunways[a].turnLightsOff() };
geofs.runwaysLights.turnAllOn = function () { for (var a in geofs.runways.nearRunways) geofs.runways.nearRunways[a].turnLightsOn() }; geofs.runwaysLights.updateAll = function () { geofs.isNight ? geofs.runwaysLights.turnAllOn() : geofs.runwaysLights.turnAllOff() };
geofs.runwaysLights.PAPI = function (a, b) { this.lights = []; this.heightAboveGround = 1; for (var c = [a[0], a[1]], d = 0; d < 4; d++)this.lights[d] = { white: new geofs.fx.light([c[0], c[1], this.heightAboveGround], "whitepapi", geofs.runwaysLights.papiBillboardOptions), red: new geofs.fx.light([c[0], c[1], this.heightAboveGround], "redpapi", geofs.runwaysLights.papiBillboardOptions) }, c = V2.add(c, b); this.location = a; this.refresh() };
geofs.runwaysLights.PAPI.prototype = {
  refresh: function () {
    var a = this; clearInterval(this.papiInterval); this.papiInterval = setInterval(function () {
      var b = geofs.utils.llaDistanceInMeters([geofs.aircraft.instance.llaLocation[0], geofs.aircraft.instance.llaLocation[1], a.location[2]], a.location, a.location), c = Math.atan2(geofs.aircraft.instance.llaLocation[2] - a.location[2], b) * RAD_TO_DEGREES; b = c < 2; var d = c < 2.5, e = c < 3.5; c = c < 4; a.lights[3].white.setVisibility(!b); a.lights[3].red.setVisibility(b); a.lights[2].white.setVisibility(!d);
      a.lights[2].red.setVisibility(d); a.lights[1].white.setVisibility(!e); a.lights[1].red.setVisibility(e); a.lights[0].white.setVisibility(!c); a.lights[0].red.setVisibility(c)
    }, 1E3)
  }, destroy: function () { clearInterval(this.papiInterval); for (var a = 0; a < 4; a++)this.lights[a].red.destroy(), this.lights[a].white.destroy(); this.lights = this.location = null }
}; "use strict"; geofs.animation = {}; geofs.animation.init = function () { };
geofs.animation.getRampRatio = function (a, b) { if (b < 0 || b > 1) return 0; var c = a.length - 1, d = 1 / c, e = Math.ceil(b / d), f = clamp(e - 1, 0, c - 1); e = clamp(e, 1, c); c = a[f]; a = a[e]; return a > c ? c + (b - f * d) / d * (a - c) : a + (d - (b - f * d)) / d * (c - a) }; geofs.animation.getRampValue = function (a, b) { var c = 0; b > a[0] && b < a[3] && (c = b < a[1] ? 1 / (a[1] - a[0]) * (b - a[0]) : b > a[2] ? 1 - 1 / (a[3] - a[2]) * (b - a[2]) : 1); return c }; geofs.animation.values = {}; geofs.animation.resetValues = function (a) { geofs.animation.values = Object.assign({}, geofs.animation.values, a) };
geofs.animation.getValue = function (a) { return geofs.animation.values[a] || 0 }; geofs.animation.setValue = function (a, b) { return geofs.animation.values[a] = b };
geofs.animation.filter = function (a, b) {
  if (a.value == "random") b = Math.random(); else if (a["function"]) { if (b = 0, !geofs.aircraft.instance.aircraftRecord.isCommunity) try { b = Function(a["function"])() } catch (f) { b = 0 } } else a.text ? b = a.text : a.value && a.value.forEach ? a.value.forEach(function (f) { b = Math.maxAbsValue(b, geofs.animation.values[f]) }) : b = b || geofs.animation.values[a.value] || (a.type == "text" ? "" : 0); if (a.value == "strobe") b = 0, geofs.utils.fastNow() % 1500 > 1400 && (b = 1); else if (a.value == "strobe2") b = 0, geofs.utils.fastNow() %
    1800 > 1700 && (b = 1); else if (a.value == "strobe3") { b = 0; var c = geofs.utils.fastNow() % 1800; if (c > 100 && c < 200 || c > 1700) b = 1 } a.eq && (b = b == a.eq ? 1 : 0); a.notEq && (b = b != a.notEq ? 1 : 0); a.ramp ? b = geofs.animation.getRampValue(a.ramp, b) : a.valueRamp ? b = geofs.animation.getRampRatio(a.valueRamp, b) : a.ratioRamp && (c = geofs.animation.getRampRatio(a.ratioRamp, b), b *= c); a.floor && (b = Math.floor(b)); a.abs && (b = Math.abs(b)); a.between && (b = b > a.between[0] && b < a.between[1] ? 1 : 0); a.delay && (b -= a.delay, b = clamp(b, 0, 1), a.delay < 0 && (b += a.delay)); a.threshold &&
      (b = b < a.threshold ? 0 : b - a.threshold); a.negthreshold && (b = b > a.negthreshold ? 0 : b - a.negthreshold); a.gt && (b = b > a.gt ? 1 : 0); a.lt && (b = b < a.lt ? 1 : 0); a.min && b < a.min && (b = a.min); a.max && b > a.max && (b = a.max); c = !1; if (a.when) { for (var d = 0, e = a.when.length; d < e; d++)if (a.when[d] == b) { c = !0; break } b = c } else if (a.whenNot) { c = !0; d = 0; for (e = a.whenNot.length; d < e; d++)if (a.whenNot[d] == b) { c = !1; break } b = c } a.preoffset && (b += a.preoffset); a.log && (b = Math.log(b)); a.ratio && (b *= a.ratio); a.power && (b = Math.pow(b, a.power)); a.offset && (b += a.offset); a.set &&
        (b = b ? a.set : a.unset || 0); a.fmin && b < a.fmin && (b = a.fmin); a.fmax && b > a.fmax && (b = a.fmax); a.concat && (Array.isArray(a.concat) || (a.concat = [a.concat]), a.concat.forEach(function (f) { b += geofs.animation.values[f] !== void 0 ? geofs.animation.values[f] : f })); return b
}; "use strict"; window.geofs = window.geofs || {}; geofs.utils = { timeProvider: window.performance || window.Date }; geofs.utils.lastNow = geofs.utils.timeProvider.now(); geofs.utils.fastNow = function () { return geofs.utils.lastNow };
geofs.utils.now = function () { geofs.utils.lastNow = geofs.utils.timeProvider.now(); return geofs.utils.lastNow }; geofs.utils.updateTime = function (a, b) { return geofs.utils.lastNow - (a.lastNow || 0) > b ? (a.lastNow = geofs.utils.lastNow, !0) : !1 }; geofs.utils.hourStamp = function () { return Math.round(Date.now() / 36E5) }; geofs.utils.llaDistanceInMeters = function (a, b, c) { return V2.length(ll2xy(V3.sub(a, b), c || a)) }; geofs.utils.llaDistanceInMeters3D = function (a, b, c) { return V3.length(lla2xyz(V3.sub(a, b), c || a)) };
geofs.utils.functionsMap = {}; geofs.utils.executeOnceWithinTime = function (a, b) { var c = a.toString().substring(0, 50); clearTimeout(geofs.utils.functionsMap[c]); geofs.utils.functionsMap[c] = setTimeout(function () { delete geofs.utils.functionsMap[c]; a() }, b) }; geofs.utils.throttleWithDefault = function (a, b, c, d) { return geofs.utils.lastNow - (d.time || 0) > c ? (d.time = geofs.utils.lastNow, a()) : b }; geofs.utils.pivotArray = function (a) { var b = {}; try { for (i = 0, l = a.length; i < l; i++)b[a[i]] = 1 } catch (c) { } return b };
geofs.utils.htrFromHeadingNormal = function (a, b) { a *= DEGREES_TO_RAD; a = V3.normalize(V3.cross([Math.sin(a), Math.cos(a), 0], b)); var c = V3.cross(b, a); return M33.getOrientation([a, c, b]) }; geofs.utils.hash = function (a) { for (var b = 0, c = 0; b < a.length; b++)c = Math.imul(31, c) + a.charCodeAt(b) | 0; return c }; geofs.utils.hashCode = function (a) { return geofs.utils.hash(a) + "" }; geofs.utils.displayAltitude = function (a) { return a = a > 18E3 ? "FL" + Math.round(a / 500) * 5 : a + "ft." };
geofs.utils.parseAltitude = function (a) { if (a != void 0) return a += "", a.toUpperCase().substr(0, 2) == "FL" && (a = parseInt(a.substr(2) * 100)), a = parseInt(a), isNaN(a) ? null : a }; geofs.utils.stickyRounding = function (a, b) { var c = Math.trunc(a); a = Math.abs(a - c); var d = 0; a > 1 - b * 2 && (d = a - (1 - b * 2)); a < 0 && (d = -(b - a)); return c + .5 / b * d }; geofs.utils.knotsToMach = function (a) { return geofs.utils.msToMach(a * KNOTS_TO_MS) }; geofs.utils.machToKnots = function (a) { return geofs.utils.machToMs(a) * MS_TO_KNOTS };
geofs.utils.msToMach = function (a) { return a / (331.3 + .606 * weather.atmosphere.airTempAtAltitude) }; geofs.utils.machToMs = function (a) { return a * (331.3 + .606 * weather.atmosphere.airTempAtAltitude) }; geofs.utils.sortLocationByDistance = function (a, b) { for (var c = 0, d = b.length; c < d; c++) { var e = b[c]; e.distance = geofs.utils.distanceBetweenLocations(a, e.coords || [e.lat, e.lon]) } b.sort(function (f, g) { return f.distance - g.distance }); return b };
geofs.utils.distanceBetweenLocations = function (a, b) { var c = a[0] * DEGREES_TO_RAD, d = b[0] * DEGREES_TO_RAD; a = (b[1] * DEGREES_TO_RAD - a[1] * DEGREES_TO_RAD) * Math.cos((c + d) / 2); c = d - c; return Math.sqrt(a * a + c * c) * MERIDIONAL_RADIUS }; geofs.utils.bearingBetweenLocations = function (a, b) { var c = a[0] * DEGREES_TO_RAD, d = b[0] * DEGREES_TO_RAD; a = a[1] * DEGREES_TO_RAD; b = b[1] * DEGREES_TO_RAD; return (Math.atan2(Math.sin(b - a) * Math.cos(d), Math.cos(c) * Math.sin(d) - Math.sin(c) * Math.cos(d) * Math.cos(b - a)) * RAD_TO_DEGREES + 360) % 360 };
geofs.utils.lookAt = function (a, b, c) { a = lla2xyz(V3.sub(a, b), b); c = M33.makeOrthonormalFrame(a, c); return M33.getOrientation(c) }; geofs.utils.limitRate = function (a, b, c, d) { var e = b - a; return Math.abs(e * d) > c ? a + e * c * d : b };
geofs.utils.morseMap = { A: ".-", B: "-...", C: "-.-.", D: "-..", E: ".", F: "..-.", G: "--.", H: "....", I: "..", J: ".---", K: "-.-", L: ".-..", M: "--", N: "-.", O: "---", P: ".--.", Q: "--.-", R: ".-.", S: "...", T: "-", U: "..-", W: ".--", X: "-..-", Y: "-.--", Z: "--..", 1: ".----", 2: "..---", 3: "...--", 4: "....-", 5: ".....", 6: "-....", 7: "--...", 8: "---..", 9: "----.", 0: "-----" }; geofs.utils.textToMorse = function (a) { return a.toUpperCase().split("").map(function (b) { return geofs.utils.morseMap[b] }).join(" ") };
geofs.utils.easingFunctions = {
  linear: function (a) { return a }, easeInQuad: function (a) { return a * a }, easeOutQuad: function (a) { return a * (2 - a) }, easeInOutQuad: function (a) { return a < .5 ? 2 * a * a : -1 + (4 - 2 * a) * a }, easeInCubic: function (a) { return a * a * a }, easeOutCubic: function (a) { return --a * a * a + 1 }, easeInOutCubic: function (a) { return a < .5 ? 4 * a * a * a : (a - 1) * (2 * a - 2) * (2 * a - 2) + 1 }, easeInQuart: function (a) { return a * a * a * a }, easeOutQuart: function (a) { return 1 - --a * a * a * a }, easeInOutQuart: function (a) { return a < .5 ? 8 * a * a * a * a : 1 - 8 * --a * a * a * a }, easeInQuint: function (a) {
    return a *
      a * a * a * a
  }, easeOutQuint: function (a) { return 1 + --a * a * a * a * a }, easeInOutQuint: function (a) { return a < .5 ? 16 * a * a * a * a * a : 1 + 16 * --a * a * a * a * a }
}; geofs.utils.isWebglSupported = function () { try { var a = document.createElement("canvas"); return !!window.WebGLRenderingContext && a.getContext("webgl") } catch (b) { return !1 } }; geofs.utils.getFunctionFromString = function (a) { var b = window; a = a.split("."); for (i = 0; i < a.length - 1; i++)if (b = b[a[i]], b == void 0) return; return b[a[a.length - 1]] }; geofs.utils.booleanToBinary = function (a) { return a ? 1 : 0 };
geofs.utils.toFixedFloat = function (a, b) { return Number(a.toFixed(b)) }; geofs.utils.arrayToFixed = function (a, b) { for (var c = 0; c < a.length; c++)a[c] = Number(a[c].toFixed(b)); return a }; function absMin(a, b) { asbA = Math.abs(a); asbB = Math.abs(b); return asbA < asbB ? a : b } function span(a, b, c) { return b == void 0 || c == void 0 ? a : a > b && a < c ? a - b > c - a ? b : c : a } function boundHours24(a) { a %= 24; a < 0 && (a = 24 + a); return a } function fixAngle(a) { return fixAngle360(a + 180) - 180 } function fixAngle360(a) { a %= 360; return a >= 0 ? a : a + 360 }
function fixAngles360(a) { for (var b = a.length - 1; b >= 0; b--)a[b] = fixAngle(a[b]); return a } function fixAngles(a) { for (var b = a.length - 1; b >= 0; b--)a[b] = fixAngle(a[b]); return a }
function exponentialSmoothing(a, b, c, d, e) { SMOOTH_BUFFER[a] || (SMOOTH_BUFFER[a] = { Stm1: d || 0, Xtm1: d || 0 }, c ? (SMOOTH_BUFFER[a].smoothingFactor = c, SMOOTH_BUFFER[a].invSmoothingFactor = 1 - c) : (SMOOTH_BUFFER[a].smoothingFactor = SMOOTHING_FACTOR, SMOOTH_BUFFER[a].invSmoothingFactor = 1 - SMOOTHING_FACTOR)); a = SMOOTH_BUFFER[a]; e != void 0 && c && (a.smoothingFactor = c * e, a.invSmoothingFactor = 1 - a.smoothingFactor); c = a.Xtm1 * a.smoothingFactor + a.invSmoothingFactor * a.Stm1; a.Stm1 = c; a.Xtm1 = b; return c }
function getBuildingCollision(a) { return null } function xyz2lla(a, b) { return geofs.api.xyz2lla(a, b) } function xy2ll(a, b) { var c = []; c[0] = a[1] * METERS_TO_LOCAL_LAT; c[1] = a[0] / (Math.cos((b[0] + c[0]) * DEGREES_TO_RAD) * MERIDIONAL_RADIUS * DEGREES_TO_RAD); return c } function lla2xyz(a, b) { b = ll2xy(a, b); b[2] = a[2]; return b } function ll2xy(a, b) { var c = []; c[1] = a[0] / METERS_TO_LOCAL_LAT; c[0] = a[1] / (1 / (Math.cos((b[0] + a[0]) * DEGREES_TO_RAD) * MERIDIONAL_RADIUS * DEGREES_TO_RAD)); return c } function clamp(a, b, c) { return a > c ? c : a < b ? b : a }
function snapToUnit(a) { return a < EPSILON ? 0 : a > ONE_MINUS_EPSILON ? 1 : a } function geoDecodeLocation(a, b) { if (a) { a += ""; if (a.toUpperCase() == a && a.length <= 4 && a.length >= 2) { var c = geofs.mainAirportList[a.toUpperCase()]; if (c) return b(c[0], c[1]) } try { var d = new Coordinates(a); return b(d.getLatitude(), d.getLongitude()) } catch (e) { geofs.api.reverserGeocode(a, b) } } } geofs.ajax = {};
geofs.ajax.post = function (a, b, c, d) { b = JSON.stringify(b); return $.ajax({ type: "POST", url: a, crossDomain: !0, data: b, dataType: "json", success: c, error: function (e, f, g) { try { d(e, f, g) } catch (k) { } geofs.debug.error(g, "geofs.ajax.post. POST failed" + f + " - " + g) } }) }; function lookAt(a, b, c) { return geofs.utils.lookAt(a, b, c) }
function getURLParameters() { var a = {}; if (window.location.search) { var b = window.location.search.substring(1, window.location.search.length); b = b.split("&"); for (var c = 0; c < b.length; c++) { var d = b[c].split("="); a[d[0]] = d[1] } } return a } function clone(a) { if (typeof a == "object") if (geofs.isArray(a)) { var b = []; for (var c = 0; c < a.length; c++)b[c] = clone(a[c]) } else for (c in b = {}, a) b[c] = clone(a[c]); else b = a; return b }
geofs.selectDropdown = function (a, b) { for (var c = 0; c < a.options.length; c++)if (a.options[c].value == b) { a.selectedIndex = c; break } };
geofs.getLink = function () { var a = geofs.aircraft.instance.llaLocation[2]; geofs.aircraft.instance.groundContact && (a = 0); new URL(window.location.href); var b = geofs.url + "/fly?"; b += "a=" + geofs.aircraft.instance.id; b += "&la=" + geofs.aircraft.instance.llaLocation[0].toFixed(5); b += "&lo=" + geofs.aircraft.instance.llaLocation[1].toFixed(5); b += "&al=" + a.toFixed(); b += "&h=" + geofs.aircraft.instance.htr[0].toFixed(); a = "Use this link to start the simulator at the current location:<textarea>" + b + "</textarea>"; $(".geofs-linkOutput").html(a) };
geofs.isArray = function (a) { return a.constructor === Array }; geofs.loadModel = function (a, b) { b = b || {}; b.url = a + geofs.killCache; return geofs.api.loadModel(b) }; geofs.getGroundAltitude = function (a, b) { var c = geofs.objects.getAltitudeAtLocation(a); if (c) return c; b = geofs.api.getGroundAltitude(a, b); return { location: [a[0], a[1], b] } };
geofs.getCollisionResult = function (a, b, c, d) { b && c && (geofs.isApp || geofs.api.renderingSettings.degradedCollisions || geofs.cautiousWithTerrain) ? (b = c.normal[2] < .45 ? c.location[2] : geofs.getAltitudeAtPointFromCollisionResult(c, [b[0], b[1], 0]), a = { location: [a[0], a[1], b], normal: V3.dup(c.normal), object: c.object }) : a = geofs.getGroundAltitude(a, d); return a }; geofs.getAltitudeAtPointFromCollisionResult = function (a, b) { return a.location[2] + -a.normal[0] / a.normal[2] * b[0] + -a.normal[1] / a.normal[2] * b[1] };
geofs.getNormalFromCollision = function (a, b) { var c = 10; geofs.api.renderingSettings.degradedCollisions && (c = 100); return geofs.api.googleTileset ? [0, 0, 1] : a.normal ? a.normal : geofs.utils.throttleWithDefault(function () { return geofs.api.getGroundNormal(a.location, b) }, b.oldNormal || [0, 0, 1], c, b) }; var PID = function (a, b, c) { this._kp = a; this._ki = b; this._kd = c; this.reset() }; PID.prototype.reset = function () { this._maxOutput = this._minOutput = this._setPoint = this._integral = this._previousError = this._previousInput = 0 };
PID.prototype.initialize = function (a, b) { this._integral = a || 0; this._previousInput = b || 0 }; PID.prototype.set = function (a, b, c) { this._minOutput = b; this._maxOutput = c; this._setPoint = a }; PID.prototype.compute = function (a, b) { var c = this._setPoint - a; this._integral += c * b * this._ki; this._integral = clamp(this._integral, this._minOutput, this._maxOutput); b = -(a - this._previousInput); this._previousInput = a; return clamp(this._kp * c + this._integral + this._kd * b, this._minOutput, this._maxOutput) };
geofs.useSimpleShadow = function (a) { a == 0 && geofs.simpleShadowOn !== !1 ? (geofs.aircraft.instance && geofs.aircraft.instance.removeShadow && geofs.aircraft.instance.removeShadow(), geofs.api.useNativeShadows(!0), geofs.simpleShadowOn = !1) : a == 1 && !geofs.simpleShadowOn && geofs.aircraft.instance && geofs.aircraft.instance.addShadow() && (geofs.api.useNativeShadows(!1), geofs.simpleShadowOn = !0) }; geofs.disableShadows = function () { geofs.shadowsDisabled || (geofs.useSimpleShadow(!0), geofs.shadowsDisabled = !0) };
geofs.enableShadows = function () { geofs.shadowsDisabled !== !1 && (geofs.useSimpleShadow(geofs.preferences.graphics.forceSimpleShadow || geofs.preferences.graphics.simpleShadow), geofs.shadowsDisabled = !1) }; geofs.shadow = function (a, b) { this.createShadow(a + geofs.killCache, b); this.context = {}; this.shadowOffset = .1 };
geofs.shadow.prototype = {
  createShadow: function (a, b) { this.scale = V3.scale(b, 2); this.scale[2] = 1; this.shadow = new geofs.api.Model(a) }, setLocationRotation: function (a, b) {
    b = geofs.getCollisionResult(a, [0, 0, 0], geofs.aircraft.instance.collResult, this.context); var c = geofs.getNormalFromCollision(b, this), d = geofs.aircraft.instance.object3d.getWorldFrame()[1]; d = V3.normalize(V3.cross(d, c)); var e = V3.cross(c, d); c = M33.getOrientation([d, e, c]); this.shadow.setPositionOrientationAndScale([a[0], a[1], b.location[2] + this.shadowOffset],
      c, this.scale)
  }, destroy: function () { this.shadow.destroy(); this.context = this.shadowBox = null }
}; geofs.WGS84TileSize = 256; geofs.WGS84Coord2tile = function (a, b, c) { c = Math.pow(2, c); b = fixAngle360(b + 180) * c; return { x: Math.floor(b / geofs.WGS84TileSize), y: Math.floor((90 - a) * c / geofs.WGS84TileSize) } }; geofs.WGS84Coord2tileQuad = function (a, b, c) { a = geofs.WGS84Coord2tile(a, b, c); return [{ x: a.x - 1, y: a.y - 1 }, { x: a.x, y: a.y - 1 }, { x: a.x - 1, y: a.y }, { x: a.x, y: a.y }] };
geofs.WGS84Tile2coord = function (a, b, c) { c = Math.pow(2, c); return { lon: a * geofs.WGS84TileSize / c - 180, lat: 90 - b * geofs.WGS84TileSize / c } }; geofs.coord2tile = function (a, b, c) { c = Math.pow(2, c); a *= DEGREES_TO_RAD; return { x: Math.floor((b + 180) / 360 * c), y: Math.floor((1 - Math.log(Math.tan(a) + 1 / Math.cos(a)) / Math.PI) / 2 * c) } }; geofs.coord2CenterTile = function (a, b, c) { c = Math.pow(2, c); a *= DEGREES_TO_RAD; return { x: Math.round((b + 180) / 360 * c), y: Math.round((1 - Math.log(Math.tan(a) + 1 / Math.cos(a)) / Math.PI) / 2 * c) } };
geofs.coord2tileQuad = function (a, b, c) { a = geofs.coord2CenterTile(a, b, c); return [{ x: a.x - 1, y: a.y - 1 }, { x: a.x, y: a.y - 1 }, { x: a.x - 1, y: a.y }, { x: a.x, y: a.y }] }; geofs.coord2tileGrid = function (a, b, c, d, e) { e = e || geofs.coord2CenterTile(a, b, c); a = Math.floor(d / 2); b = []; for (c = -a; c < a; c++) { d = c < 0 ? Math.abs(c) : c + 1; for (var f = -a; f < a; f++)b.push({ x: e.x + f, y: e.y + c, r: Math.max(f < 0 ? Math.abs(f) : f + 1, d) }) } return b };
geofs.tile2Grid = function (a, b) { a = Math.floor(a / 2); for (var c = [], d = -a; d <= a; d++)for (var e = d < 0 ? Math.abs(d) : d + 1, f = -a; f <= a; f++)c.push({ x: b.x + f, y: b.y + d, r: Math.max(f < 0 ? Math.abs(f) : f + 1, e) }); return c }; geofs.tile2coord = function (a, b, c) { c = Math.pow(2, c); b = Math.PI - 2 * Math.PI * b / c; return { lat: RAD_TO_DEGREES * Math.atan(.5 * (Math.exp(b) - Math.exp(-b))), lon: a / c * 360 - 180 } }; geofs.getLatLonMatrixcoord = function (a, b, c) { return parseInt(a / c) + "/" + parseInt(b / c) };
geofs.perlin = {
  size: 100, gradient: [], normalizationRatio: 1 / Math.sqrt(.5), lerp: function (a, b, c) { return (1 - c) * a + c * b }, dotGridGradient: function (a, b, c, d) { return (c - a) * geofs.perlin.gradient[b][a][0] + (d - b) * geofs.perlin.gradient[b][a][1] }, get: function (a, b, c) {
    a = Math.abs(a * c) % geofs.perlin.size; b = Math.abs(b * c) % geofs.perlin.size; var d = parseInt(a), e = d + 1, f = parseInt(b), g = f + 1, k = a - d; c = b - f; var m = geofs.perlin.dotGridGradient(d, f, a, b); var n = geofs.perlin.dotGridGradient(e, f, a, b); f = geofs.perlin.lerp(m, n, k); m = geofs.perlin.dotGridGradient(d,
      g, a, b); n = geofs.perlin.dotGridGradient(e, g, a, b); a = geofs.perlin.lerp(m, n, k); a = geofs.perlin.lerp(f, a, c); return geofs.perlin.normalizationRatio * a
  }
}; for (var w = 0; w <= geofs.perlin.size; w++) { geofs.perlin.gradient[w] = []; for (var h = 0; h <= geofs.perlin.size; h++) { var theta = Math.random() * TWO_PI; geofs.perlin.gradient[w][h] = [Math.cos(theta), Math.sin(theta)] } }
geofs.tileManager = function (a) {
  this.sizeInPixels = a.sizeInPixels || 512; this.zoomLevel = a.zoomLevel || 12; this.server = a.server; this.tileSize = 256; this.maxZoomLevel = 20; this.minZoomLevel = 11; this.backgroundColor = "#000000"; this.useDataView = a.useDataView; a.sizeInTiles ? (this.sizeInTiles = a.sizeInTiles, this.sizeInPixels = this.tileSize * this.sizeInTiles) : this.sizeInTiles = Math.round(this.sizeInPixels / this.tileSize); this.canvasAPI = new geofs.api.Canvas({ width: this.sizeInPixels, height: this.sizeInPixels, color: this.backgroundColor });
  this.tileSizeAtZoom = []; this.tileSizeAtZoom[this.zoomLevel] = this.tileSize; for (a = this.zoomLevel + 1; a <= this.maxZoomLevel; a++)this.tileSizeAtZoom[a] = Math.floor(this.tileSize / Math.pow(2, a - this.zoomLevel)); this.initialized = !0
};
geofs.tileManager.prototype = {
  update: function (a, b) {
    var c = this; if (this.initialized) {
      this.tileCoordinates = geofs.coord2tileGrid(a, b, this.zoomLevel, this.sizeInTiles); this.originAtZoom = []; this.originAtZoom[this.zoomLevel] = this.tileCoordinates[0]; for (a = this.zoomLevel + 1; a <= this.maxZoomLevel; a++)b = Math.pow(2, a - this.zoomLevel), this.originAtZoom[a] = { x: this.tileCoordinates[0].x * b, y: this.tileCoordinates[0].y * b }; a = this.tileCoordinates[0].x + "-" + this.tileCoordinates[0].y; if (a != this.originTileId) {
        this.ready = !1; this.dataView =
          null; this.originTileId = a; var d = []; this.tileCoordinates.forEach(function (e) { d.push(c.server + c.zoomLevel + "/" + e.x + "/" + e.y + ".png") }); this.origin = geofs.tile2coord(this.tileCoordinates[0].x, this.tileCoordinates[0].y, this.zoomLevel); this.end = geofs.tile2coord(this.tileCoordinates[0].x + this.sizeInTiles, this.tileCoordinates[0].y + this.sizeInTiles, this.zoomLevel); this.pixelGeographicSize = { lat: (this.end.lat - this.origin.lat) / this.sizeInPixels, lon: (this.end.lon - this.origin.lon) / this.sizeInPixels }; this.canvasAPI.loadTiles(d).then(function (e) {
            c.useDataView &&
              c.prepareDataView(e); c.ready = !0
          })
      }
    }
  }, prepareDataView: function () { var a = this.canvasAPI.context.getImageData(0, 0, this.canvasAPI.canvas.width, this.canvasAPI.canvas.height); this.dataView = new DataView(a.data.buffer) }, coordsToPixels: function (a, b) { if (this.ready) return a = { x: (b - this.origin.lon) / this.pixelGeographicSize.lon, y: (a - this.origin.lat) / this.pixelGeographicSize.lat }, geofs.debugOn && $(".redpixel").css({ top: a.y + "px", left: a.x + "px" }), a }, getSubTilePixel: function (a, b, c, d, e) {
    if (this.ready) if (a = Math.round((a -
      this.originAtZoom[c].x) * this.tileSizeAtZoom[c] + d), b = Math.round((b - this.originAtZoom[c].y) * this.tileSizeAtZoom[c] + e), this.useDataView) try { return this.dataView.getUint32(4 * (a + b * this.canvasAPI.canvas.width)) } catch (f) { return null } else return this.canvasAPI.context.getImageData(a, b, 1, 1).data
  }, getTilePixel: function (a, b, c, d, e) {
    if (this.ready) return this.canvasAPI.context.getImageData((a - this.originAtZoom[c].x) * this.tileSizeAtZoom[c] + d / this.tileSizeAtZoom[c], (b - this.originAtZoom[c].y) * this.tileSizeAtZoom[c] +
      e / this.tileSizeAtZoom[c], 1, 1)
  }, getTileImageData: function (a, b, c, d, e, f, g) { if (this.ready) return this.canvasAPI.context.getImageData((a - this.originAtZoom[c].x) * this.tileSizeAtZoom[c] + d / this.tileSizeAtZoom[c], (b - this.originAtZoom[c].y) * this.tileSizeAtZoom[c] + e / this.tileSizeAtZoom[c], sizePx.w / this.tileSizeAtZoom[c], sizePx.h / this.tileSizeAtZoom[c]) }, getImageDataFromCoords: function (a, b) {
    if (this.ready) return a = this.coordsToPixels(a.lat, a.lon), b = this.coordsToPixels(b.lat, b.lon), this.canvasAPI.context.getImageData(a.x,
      a.y, b.x - a.x, b.y - a.y)
  }, pixelsToCoords: function (a, b) { }
}; "use strict"; window.geofs = window.geofs || {}; var PAGE_PATH = document.location.href.replace(/\/[^\/]+$/, "/"); geofs.includes = {};
geofs.initialRunways = [[-22.81244, -43.26368, 0, 126], [43.674166, 10.3843691, 0, 36.54], [40.45589, -3.54654, 0, -39], [37.62616, -122.39275, 0, 118], [51.15143, -.16629, 0, -102], [48.99873, 2.60975, 0, -95], [33.93726741762918, -118.38364975124578, 0, -96.50347129433592], [42.36021520436057, -70.98767662157663, 0, -103.54], [25.800717256450998, -80.30116643603567, 0, 87.65], [43.66555302435758, 7.228367855065596, 0, -135.67487141768297]]; geofs.lastFlightDefault = {}; geofs.groundElevation = 0; geofs.waveHeight = 0; geofs.waveVerticalSpeed = 0;
geofs.groundIsWater = !1; geofs.waterIsSea = !1; geofs.frameNumber = 0;
geofs.init = function () {
  geofs.constants.init(); geofs.PRODUCTION = geofs.PRODUCTION || !1; geofs.PRODUCTION || (geofs.killCache = "?kc=" + Date.now(), geofs.debug.init()); geofs.api.analytics.init(); geofs.doPause(1); geofs.viewport = $(".geofs-ui-3dview")[0]; geofs.canvas = $(".geofs-ui-3dview"); geofs.resizeHandlers = {}; geofs.resizeHandlersIndex = 0; geofs.addResizeHandler(geofs.getViewportDimentions, geofs); $(window).resize(geofs.handleResize); geofs.getViewportDimentions(); geofs.lastTime = geofs.utils.now(); $(window).on("unload",
    geofs.unload); geofs.initPreferences(); geofs.mobile.init(); geofs.autoStart ? geofs.start() : window.localStorage.getItem("startModalDone") || geofs.isApp ? geofs.isApp ? (geofs.mobile.configure(), geofs.start()) : geofs.manualStart || geofs.start() : (geofs.preferencesDefault.mobile = !1, geofs.isMobileDevice ? ($(".geofs-startModalMobile").show(), $(".geofs-startModalMobile .geofs-fly-button-mobile").one("click ", function () {
      geofs.preferencesDefault.mobile = !0; geofs.mobile.configure(); $(".geofs-startModalMobile").hide();
      geofs.start()
    }), $(".geofs-startModalMobile .geofs-fly-button").one("click ", function () { $(".geofs-startModalMobile").hide(); geofs.start() })) : ($(".geofs-startModal").show(), $(".geofs-startModal .geofs-fly-button").one("click ", function () { $(".geofs-startModal").hide(); geofs.start() })))
};
geofs.start = function (a, b) {
  geofs.readPreferences(function () {
    ui.init(); flight.recorder.init(); controls.init(); geofs.nav.init(); geofs.radio.init(); window.localStorage.setItem("startModalDone", !0); try { geofs.world = geofs.api.initWorld("geofs-ui-3dview") } catch (n) { geofs.debug.error(n) } geofs.isMobileDevice && geofs.preferences.mobile || geofs.isApp || geofs.forceMobileMode ? geofs.mobile.turnOn() : (geofs.mobile.turnOff(), geofs.preferences.mobile = !1); window.fireBasicEvent("geofsStarted"); geofs.api.renderingQuality(geofs.preferences.graphics.quality);
    geofs.api.enhanceColors(geofs.preferences.graphics.enhanceColors); geofs.debug.afterWorldInit(); var c = JSON.parse(geofs.localStorage.getItem("flight")) || {}; geofs.lastFlight = $.extend(!0, {}, geofs.lastFlightDefault, c); c = geofs.initialRunways[Math.floor(Math.random() * geofs.initialRunways.length)]; var d = getURLParameters(), e = parseFloat(d.alt) || parseFloat(d.al) || void 0, f = parseFloat(d.heading) || parseFloat(d.h) || void 0, g = parseFloat(d.lat) || parseFloat(d.la) || void 0, k = parseFloat(d.lon) || parseFloat(d.lo) || void 0;
    geofs.initialCoordinates = $.extend({}, b, c, geofs.lastFlight.coordinates, [g, k, e, f, !0]); geofs.initialCoordinates && (geofs.initialCoordinates[0] < -90 || geofs.initialCoordinates[0] > 90 || !geofs.initialCoordinates[0] || geofs.initialCoordinates[1] < -180 || geofs.initialCoordinates[1] > 180 || !geofs.initialCoordinates[1] || geofs.initialCoordinates[2] > 1E5) && (geofs.initialCoordinates = [0, 0, 0]); geofs.aircraft.instance = new geofs.aircraft.Aircraft(geofs.initialCoordinates); var m = a || d.aircraft || d.a || geofs.lastFlight.aircraftId ||
      1; geofs.doPause(1); geofs.probeTerrain(); (function () {
        return (0, $jscomp.asyncExecutePromiseGeneratorProgram)(function (n) {
          if (n.nextAddress == 1) return n.yield(geofs.aircraft.instance.loadWithLivery(m, geofs.initialCoordinates, geofs.lastFlight.liveryId), 2); d && d.aps && (geofs.initialCoordinates[5] = d.aps, geofs.autopilot.turnOn(), geofs.autopilot.setSpeed(parseInt(d.aps)), geofs.autopilot.setVerticalSpeed(parseInt(d.apvs) || 0), geofs.autopilot.setAltitude(parseInt(d.apa || geofs.initialCoordinates[2] * METERS_TO_FEET)),
            geofs.autopilot.setCourse(parseInt(d.aph) || geofs.initialCoordinates[3] || 0)); n.jumpToEnd()
        })
      })(); geofs.camera.init(geofs.initialCoordinates); weather.init(geofs.initialCoordinates); geofs.api.setWaterEffect(geofs.preferences.graphics.waterEffect); geofs.api.setVegetation(geofs.preferences.graphics.vegetation); geofs.api.setBuildings(geofs.preferences.graphics.buildings); geofs.objects.init(); multiplayer.init(); geofs.fx.init(); geofs.initLoggedInUser(); geofs.api.addFrameCallback(geofs.frameCallback); window.fireBasicEvent("geofsInitialized")
  })
};
geofs.unload = function () { geofs.api.destroyWorld(); geofs.saveFlight(); if (geofs.PRODUCTION) try { multiplayer.avgPing && geofs.api.analytics.event("system", "networkLatency", Math.ceil(multiplayer.avgPing / 50) * 50 + "", Math.floor(multiplayer.avgPing)), geofs.api.analytics.event("system", "framerate", Math.ceil(geofs.debug.fps / 5) * 5 + "", geofs.debug.fps * 1) } catch (a) { geofs.debug.error(a, "geofs.unload") } };
geofs.initLoggedInUser = function () { geofs.userRecord.muteListMap = {}; var a = 0; clearInterval(geofs.keepAliveInterval); geofs.keepAliveInterval = setInterval(function () { if (!geofs.pause) { var b = { action: "keeptime" }; a == controls.rawPitch || geofs.autopilot.on || (b.activeFlying = !0); $(".geofs-apiResponse").htmlView("load", "/backend/accounts/api.php", b) } a = controls.rawPitch }, 6E4) }; geofs.terrainProbbingDone = function () { geofs.cautiousWithTerrain && (geofs.cautiousWithTerrain = !1, geofs.debug.log("terrainStable"), $(geofs.viewport).trigger("terrainStable")) };
geofs.terrainProbingDuration = 1E4; geofs.probeTerrain = function () { geofs.cautiousWithTerrain || $(geofs.viewport).trigger("terrainUnstable"); geofs.cautiousWithTerrain = !0; clearTimeout(geofs.probbingTimeout); geofs.probbingTimeout = setTimeout(geofs.terrainProbbingDone, geofs.terrainProbingDuration) }; $(document).on("terrainProviderUpdate", function () { geofs.probeTerrain() }); geofs.togglePause = function () { geofs.pause ? geofs.undoPause(2) : geofs.doPause(2) }; geofs.isPaused = function () { if (geofs.absolutePause || geofs.pause) return !0 };
geofs.doPause = function (a, b) { a = a || 0; geofs.pauses = geofs.pauses || {}; a == 2 && (geofs.userPause = !0); a < geofs.pauseLevel || (b || multiplayer.stopUpdates(), audio.stop(), ui.toggleButton(".geofs-button-pause", !0), geofs.pause = !0, geofs.pauseLevel = a) }; geofs.undoPause = function (a) { a = a || 0; a == 2 && (geofs.userPause = !1); a < geofs.pauseLevel || (geofs.userPause ? geofs.pauseLevel = 2 : (geofs.lastTime = null, multiplayer.startUpdates(), geofs.pause = !1, ui.toggleButton(".geofs-button-pause", !1), geofs.pauseLevel = 0, geofs.api.triggerExplicitRendering())) };
geofs.frameCallback = function (a) {
  geofs.frameNumber++; var b = a - geofs.lastTime; geofs.lastTime = a; b <= 0 && (b = 1); b *= geofs.preferences.simulationSpeed; b > 100 && (b = 100); var c = b / 1E3; geofs.pause || (flight.terrainElevationManagement(), controls.update(c), geofs.autopilot.UI.update(c), flight.tick(c, b, a), multiplayer.update(b), geofs.debug.update(b), geofs.nav.update(c), geofs.radio.update(c), geofs.flightPlan.update(c), instruments.update(), audio.update(), geofs.fx.update(b), geofs.map.updateMap(geofs.aircraft.instance.llaLocation),
    geofs.objects.update(geofs.camera.lla)); geofs.pauseLevel < 3 && (geofs.camera.update(c), weather.update(c), geofs.buildings.update(geofs.camera.lla), geofs.trees.update(geofs.camera.lla), geofs.fx.atmosphere.update(geofs.camera.lla), geofs.api.updateGoogleTiles(geofs.camera.lla), geofs.preferences.graphics.waterEffect && geofs.fx.water.update(geofs.camera.lla), geofs.api.triggerExplicitRendering()); geofs.api.renderingSettings.adaptativeRenderingQuality && geofs.api.adaptativeRenderingQuality()
};
geofs.flyTo = function (a, b) {
  if (a) {
    geofs.doPause(1); var c = geofs.aircraft.instance; a[0] = a[0] || geofs.initialRunways[0][0]; a[1] = a[1] || geofs.initialRunways[0][1]; a[2] = a[2] || 0; a[3] = a[3] || 0; c.absoluteStartAltitude = a[4] ? !0 : !1; c.startAltitude = a[2]; geofs.lastFlightCoordinates = a; var d = a[0], e = a[1], f = a[2], g = [0, 0, 0]; g[0] = a[3]; var k = f == 0; c.llaLocation = [d, e, f]; b ? geofs.camera.update(1) : (geofs.probeTerrain(), geofs.camera.currentModeName == "free" || geofs.camera.currentModeName == "chase" ? geofs.camera.reset() : geofs.camera.set(geofs.camera.currentMode),
      controls.reset(), weather.reset()); geofs.api.waterDetection.reset(); c.reset(k); instruments.reset(); geofs.objects.update(c.llaLocation); geofs.runways.refresh(); geofs.runwaysLights.updateAll(); ui.hideCrashNotification(); geofs.api.getGuarantiedGroundAltitude([d, e, 0]).then(function (m) {
        m = m[0].height || 0; geofs.groundElevation = m; flight.reset(geofs.groundElevation); c.absoluteStartAltitude ? c.startAltitude < geofs.groundElevation && (k = !0) : c.startAltitude += geofs.groundElevation; k && (c.startAltitude = geofs.groundElevation +
          c.definition.startAltitude, c.absoluteStartAltitude = !1); c.llaLocation[2] = c.startAltitude; flight.elevationAtPreviousLocation = m; k ? (g[1] = c.definition.startTilt || 0, c.startOnGround = !0, c.groundContact = !0, c.place(c.llaLocation, g), c.object3d.compute(c.llaLocation), c.render()) : (c.startOnGround = !1, c.place(c.llaLocation, g), c.object3d.compute(c.llaLocation), m = (a[5] || c.definition.minimumSpeed) / MS_TO_KNOTS * c.definition.mass, c.rigidBody.applyCentralImpulse(V3.scale(c.object3d.getWorldFrame()[1], m))); geofs.undoPause(1);
        geofs.camera.update(2); flight.recorder.clear(); $(document).trigger("flyto")
      }).catch(function (m) { c.startOnGround = !1; c.place(c.llaLocation, g); c.object3d.compute(c.llaLocation); m = c.definition.minimumSpeed / 1.94 * c.definition.mass; c.rigidBody.applyCentralImpulse(V3.scale(c.object3d.getWorldFrame()[1], m)); geofs.undoPause(1) })
  }
}; geofs.flyToCamera = function () { geofs.flyTo(geofs.camera.getFlytToCoordinates()); geofs.camera.setToNeutral() };
geofs.resetFlight = function () { window.confirm("Are you sure you want to reset this flight?") && geofs.flyTo(geofs.lastFlightCoordinates || geofs.initialCoordinates, !0) }; window.addEventListener("deferredload", function () { $(document).on("loginchange preferenceRead", function () { geofs.api.setDataProvider(geofs.preferences.graphics.dataProvider) }); geofs.init() }); "use strict"; geofs.preferences = {}; geofs.userRecord = geofs.userRecord || {};
geofs.preferencesDefault = {
  aircraft: "", coordinates: "", controlMode: "mouse", keyboard: {
    sensitivity: 1, exponential: 0, mixYawRoll: !0, steerWithRoll: !0, keys: {
      "Toggle Autopilot": { keycode: 65, label: "<A>" }, "Bank left": { keycode: 37, label: "<Left Arrow>" }, "Bank right": { keycode: 39, label: "<Right Arrow>" }, "Pitch down": { keycode: 38, label: "<Up Arrow>" }, "Pitch up": { keycode: 40, label: "<Down Arrow>" }, "Steer left": { keycode: 188, label: "<" }, "Steer right": { keycode: 190, label: ">" }, Brakes: { keycode: 32, label: "<Space bar>" }, "Parking brake": {
        keycode: 186,
        label: ";"
      }, "Increase throttle": { keycode: 107, label: "+" }, "Decrease throttle": { keycode: 109, label: "-" }, "Increase throttle alt": { keycode: 33, label: "<Page up>" }, "Decrease throttle alt": { keycode: 34, label: "<Page down>" }, "Elevator trim up": { keycode: 36, label: "<Home>" }, "Elevator trim down": { keycode: 35, label: "<End>" }, "Elevator trim neutral": { keycode: 46, label: "<Delete>" }, "Engine switch (on/off)": { keycode: 69, label: "E" }, "Cycle flaps": { keycode: 70, label: "F" }, "Gear toggle (up/down)": { keycode: 71, label: "G" }, "Accessories (hook/floats/rudder) toggle": {
        keycode: 90,
        label: "Z"
      }, "Lower flaps": { keycode: 219, label: "[" }, "Raise flaps": { keycode: 221, label: "]" }, "Airbrake toggle (on/off)": { keycode: 66, label: "B" }, "Optional Animated Part toggle (on/off)": { keycode: 88, label: "X" }
    }
  }, mouse: { sensitivity: 1, exponential: 1, reverse: !1, mixYawRoll: !0, steerWithRoll: !0 }, joystick: {
    sensitivity: 1, exponential: 1, mixYawRoll: !1, steerWithRoll: !1, axis: { pitch: 1, roll: 0, yaw: 5, throttle: 6 }, multiplier: { pitch: !1, roll: !1, yaw: !1, throttle: !1 }, calibration: {}, buttons: {
      0: "setBrakes", 1: "setElevatorTrimDown", 2: "setElevatorTrimUp",
      3: "setFlapsUp", 4: "setFlapsDown", 5: "setGear", 6: "setAirbrakes", 7: "setOptionalAnimatedPart"
    }
  }, orientation: { sensitivity: 1, exponential: 1, mixYawRoll: !0, steerWithRoll: !0, axis: { pitch: 0, roll: 1, yaw: 2 }, multiplier: { pitch: !1, roll: !1, yaw: !1 } }, touch: { sensitivity: .2, exponential: 1.5, mixYawRoll: !0, steerWithRoll: !0, axis: { pitch: 0, roll: 1, yaw: 2 }, multiplier: { pitch: !1, roll: !1, yaw: !1 } }, camera: { headMotion: !1 }, weather: { sun: !1, localTime: 12, season: 1, manual: !0, quality: 0, advanced: { clouds: 0, fog: 0, windSpeed: 0, windDirection: 0, turbulences: 0 } },
  graphics: { quality: 3, slaveQuality: 3, enhanceColors: 1, volumetricClouds: !1, advancedAtmosphere: !0, waterEffect: !1, vegetation: !1, buildings: !1, contrails: !1, dataProvider: "hd", advanced: { resolutionScale: 1, viewingDistance: 3, tileCacheSize: 250, fxaa: !0, msaaSamples: 1, globeLighting: !0, shadowQuality: 1, dropShadow: !0, softShadows: !1, cloudDensity: .6 } }, "interface": { transparent: !0, showYokeCursor: !1, drawFlightPath: !1, recenterMap: !0 }, simBriefUsername: "", crashDetection: !1, showPapi: !0, multiplayer: !0, showCommunityMultiplayer: !1,
  adsb: !1, chat: !1, sound: !0, volume: 1, recorderLength: 1E3, simulationSpeed: 1
};
geofs.preferencesKeycodeLookup = { 8: "<Back space>", 9: "<Tab>", 13: "<Enter>", 16: "<Shift>", 17: "<Control>", 18: "<Alt>", 19: "<Break>", 20: "<Caps Lock>", 32: "<Space bar>", 33: "<Page up>", 34: "<Page down>", 35: "<End>", 36: "<Home>", 37: "<Left Arrow>", 38: "<Up Arrow>", 39: "<Right Arrow>", 40: "<Down Arrow>", 44: "<Print scr>", 45: "<Insert>", 46: "<Delete>", 110: "<Delete>", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "<Num lock>", 145: "<Scroll Lock>" };
geofs.localStorage = window.localStorage || {}; geofs.initPreferences = function () { geofs.$preferencePanel = $(".geofs-preferences"); var a = function (b) { b.stopPropagation() }; geofs.$preferencePanel.keydown(a); geofs.$preferencePanel.keyup(a); $(document).on("expanded", ".geofs-preference-controls", function () { geofs.preferencesStartFeedback() }).on("collapsed", ".geofs-preference-controls", function () { geofs.preferencesStopFeedback() }) }; geofs.isPreferencePanelOpen = function () { return geofs.$preferencePanel.is(":visible") };
geofs.saveFlight = function (a) { geofs.aircraft.instance && (a = geofs.aircraft.instance.getCurrentCoordinates(), geofs.aircraft.instance.groundContact ? a[2] = 0 : a[4] = !0, a = { coordinates: a, aircraftId: geofs.aircraft.instance.aircraftRecord.id, liveryId: geofs.aircraft.instance.liveryId }); a && geofs.localStorage.setItem("flight", JSON.stringify(a)) }; geofs.savePreferences = function () { try { var a = JSON.stringify(geofs.preferences); geofs.localStorage.setItem("settings", a) } catch (b) { geofs.debug.error(b, "Could not save preferences") } $(document).trigger("preferenceSaved") };
geofs.resetPreferences = function (a) { geofs.localStorage.clear(); geofs.flyTo(geofs.initialRunways[0]); geofs.preferences = clone(geofs.preferencesDefault); geofs.preferences.version = geofs.version; geofs.savePreferences(); geofs.preferenceInitialized = !1; a && (geofs.preferenceInitialized = !1, geofs.initializePreferencesPanel()) };
geofs.readPreferences = function (a) {
  var b = {}; try { b = JSON.parse(geofs.localStorage.getItem("settings")), geofs.forcePreferenceResetOnVersionChange && b.version != geofs.version && (geofs.resetPreferences(), geofs.api.notify("Preferences are reset to default after version change.")), b && !b.version && (geofs.debug.error(null, "geofs.readPreferences - !savedPreferences.version"), geofs.api.notify("Unable to read saved preferences. Preferences are reset to default."), geofs.resetPreferences()) } catch (c) {
    geofs.debug.error(c,
      "geofs.readPreferences - Unable to read saved preferences. Preferences are reset to default."), geofs.api.notify("Error while reading saved preferences. Preferences are reset to default."), geofs.resetPreferences()
  } geofs.preferences = $.extend(!0, {}, geofs.preferencesDefault, b); geofs.preferences.version = geofs.version; geofs.userRecord.id || (geofs.preferences.chat = !1); if (a) try { a() } catch (c) { geofs.debug.error(c, "geofs.readPreferences>callback"), geofs.api.notify("Error during GeoFS initialization. Try to reset preferences to default. Please contact support if this error keeps occurring.") } $(document).trigger("preferenceRead")
};
geofs.populateButtonAssignments = function () {
  var a = $(".geofs-joystick-button-container", geofs.$preferencePanel); if (a) {
    var b = ""; for (i in controls.setters) b += '<option value="' + i + '">' + controls.setters[i].label + "</option>"; b += "</select>"; var c = "", d; for (d in controls.joystick.buttons) c += '<div class="geofs-feedback-wrapper"><label>Button ' + controls.joystick.buttons[d].globalId + '</label><div class="geofs-feedback" button="' + d + '"></div>', c += '<select data-gespref="geofs.preferences.joystick.buttons.' + d + '" data-update="{controls.joystick.configure()}">' +
      b + "</div>"; a.html(c); componentHandler.upgradeDom()
  }
};
geofs.populateAxesAssignments = function () {
  var a = $(".geofs-joystick-axes-container", geofs.$preferencePanel); if (a) {
    var b = ""; for (i in controls.axisSetters) b += '<option value="' + i + '">' + controls.axisSetters[i].label + "</option>"; b += "</select>"; var c = "", d; for (d in controls.joystick.axes) c += '<div class="geofs-feedback-wrapper"><label>Axis ' + controls.joystick.axes[d].globalId + "</label>", c += '<select data-gespref="geofs.preferences.joystick.axis.' + d + '">' + b, c += '<div class="progress" axis="' + d + '"><div class="bar"></div></div>',
      c += '<label class="mdl-switch mdl-js-switch mdl-js-ripple-effect" title="Inverse axis">', c += '<input type="checkbox" class="mdl-switch__input" data-gespref="geofs.preferences.joystick.multiplier.' + d + '" data-update="{controls.setMode()}">', c += '<span class="mdl-switch__label">Inverse</span>', c += "</label>"; a.html(c); componentHandler.upgradeDom()
  }
};
geofs.populateKeyAssignments = function () {
  var a = $(".geofs-keyboard-keys-container", geofs.$preferencePanel), b = "", c; for (c in geofs.preferences.keyboard.keys) {
    var d = "keyInput" + geofs.preferences.keyboard.keys[c].keycode; b += '<div class="mdl-textfield mdl-js-textfield mdl-textfield--floating-label"><input id="' + d + '" class="geofs-preferences-key-detect mdl-textfield__input" type="text" data-type="keydetect" data-gespref="geofs.preferences.keyboard.keys.' + c + '" keycode="' + geofs.preferences.keyboard.keys[c].keycode +
      '" value="' + geofs.preferences.keyboard.keys[c].label + '"/><label class="mdl-textfield__label" for="' + d + '">' + c + "</label></div>"
  } a.html(b); a.on("click focus", ".geofs-preferences-key-detect", function (e) { $(".geofs-preference-key-detecting", a).each(function (f, g) { g.value = g._originalValue; $(g).removeClass("geofs-preference-key-detecting") }); e.currentTarget._originalValue = e.currentTarget.value; e.currentTarget.value = ""; $(e.currentTarget).addClass("geofs-preference-key-detecting") }).on("keyup", ".geofs-preferences-key-detect",
    function (e) { var f = e.currentTarget; if ($(f).hasClass("geofs-preference-key-detecting")) { if (e.which != 27) { var g = geofs.preferencesKeycodeLookup[e.which] ? geofs.preferencesKeycodeLookup[e.which] : f.value.toUpperCase(); f.value = g; f.setAttribute("keycode", e.which); geofs.setPreferenceFromInput(f) } else f.value = f._originalValue; $(f).removeClass("geofs-preference-key-detecting"); $(f).blur(); e.stopPropagation(); e.preventDefault() } }).on("keydown", ".geofs-preferences-key-detect", function (e) {
      $(e.currentTarget).hasClass("geofs-preference-key-detecting") &&
        e.which == 9 && (e.stopPropagation(), e.preventDefault())
    }).on("blur", ".geofs-preferences-key-detect", function (e) { $(e.currentTarget).hasClass("geofs-preference-key-detecting") && (e.currentTarget.value == "" && (e.currentTarget.value = e.currentTarget._originalValue), $(e.currentTarget).removeClass("geofs-preference-key-detecting"), e.stopPropagation(), e.preventDefault()) }); componentHandler.upgradeDom()
};
geofs.preferencesDebugInfo = function () {
  geofs.api.debug(!0); for (var a = "Network Latency (avg): " + multiplayer.avgPing + " ms<br/>Frame rate (avg): " + geofs.debug.fps + " fps<br/>--------------<br/><b>Last 10 log messages:</b><br/>", b = 0; b < geofs.debug.logStack.length; b++)a += geofs.debug.logStack[b] + "<br/>"; try {
    var c = $(".geofs-ui-3dview canvas")[0].getContext("webgl") || $(".geofs-ui-3dview canvas")[0].getContext("webgl2"); a += "--------------<br/><b>WebGL info:</b><br/>"; a += "gl.VERSION: " + c.getParameter(c.VERSION) +
      "<br/>"; a += "gl.SHADING_LANGUAGE_VERSION: " + c.getParameter(c.SHADING_LANGUAGE_VERSION) + "<br/>"; a += "gl.VENDOR: " + c.getParameter(c.VENDOR) + "<br/>"; a += "gl.RENDERER: " + c.getParameter(c.RENDERER) + "<br/>"; var d = c.getExtension("WEBGL_debug_renderer_info"); a += "UNMASKED_RENDERER_WEBGL: " + c.getParameter(d.UNMASKED_RENDERER_WEBGL) + "<br/>"; a += "UNMASKED_VENDOR_WEBGL: " + c.getParameter(d.UNMASKED_VENDOR_WEBGL) + "<br/>"
  } catch (e) { } $(".geofs-debug-info", geofs.$preferencePanel).html(a)
};
geofs.preferencesTestJoystick = function () {
  var a = controls.joystick.poll(); a ? ($(".geofs-preferences-joystick-status .alert-success").show().html(controls.joystick.info), $(".geofs-preferences-joystick-status .alert-warning").hide(), $(".geofs-preferences-joystick-status .alert-error").hide()) : (controls.joystick.api ? ($(".geofs-preferences-joystick-status .alert-error").hide(), $(".geofs-preferences-joystick-status .alert-warning").show()) : $(".geofs-preferences-joystick-status .alert-error").show(), $(".geofs-preferences-joystick-status .alert-success").hide());
  return a
}; geofs.preferencesTestOrientation = function () { if (controls.orientation.isAvailable()) return $(".geofs-preferences-orientation").show(), !0; $(".geofs-preferences-orientation").hide(); return !1 };
geofs.preferencesStartFeedback = function () {
  geofs.preferencesFeedbackInterval || (geofs.preferencesFeedbackInterval = setInterval(function () {
    geofs.preferencesTestJoystick() && ($(".geofs-preferences-joystick .progress[axis]", geofs.$preferencePanel).each(function (a, b) { a = controls.joystick.getAxisValue(b.getAttribute("axis")); a = (a + 1) * 50; $(b).find(".bar").css("width", a + "%") }), $(".geofs-preferences-joystick .geofs-feedback[button]", geofs.$preferencePanel).each(function (a, b) {
      controls.joystick.checkButton(parseInt(b.getAttribute("button"))) ?
        $(b).addClass("on") : $(b).removeClass("on")
    })); geofs.preferencesTestOrientation() && $(".geofs-preferences-orientation .progress[axis]", geofs.$preferencePanel).each(function (a, b) { a = controls.orientation.getNormalizedAxis(geofs.preferences.orientation.axis[b.getAttribute("axis")]); a *= 100; b.getAttribute("centered") && (a = (a + 100) / 2); $(b).find(".bar").css("width", a + "%") })
  }, 100))
}; geofs.preferencesStopFeedback = function () { clearInterval(geofs.preferencesFeedbackInterval); geofs.preferencesFeedbackInterval = null };
geofs.initializePreferencesPanel = function () {
  try {
    geofs.preferencesDebugInfo(), geofs.preferenceInitialized || (controls.joystick.ready && (geofs.populateButtonAssignments(), geofs.populateAxesAssignments()), $(controls.joystick).on("joystickReady", function () { geofs.populateButtonAssignments(); geofs.populateAxesAssignments(); geofs.setPreferenceValues(geofs.$preferencePanel.find(".geofs-preferences-joystick")); geofs.setInputHandlers(geofs.$preferencePanel.find(".geofs-preferences-joystick")) }), geofs.setPreferenceValues(geofs.$preferencePanel),
      geofs.setInputHandlers(geofs.$preferencePanel), geofs.populateKeyAssignments(), geofs.preferencesTestJoystick(), geofs.preferencesTestOrientation(), geofs.preferenceInitialized = !0)
  } catch (a) { geofs.debug.error(a, "geofs.initializePreferencesPanel") }
};
geofs.setPreferenceValues = function (a, b) {
  $(a || geofs.$preferencePanel).find("[data-gespref]").each(function (c, d) {
    var e = $(d), f = d.getAttribute("data-type") || d.getAttribute("type"); d.nodeName == "SELECT" && (f = "select"); f = f.toLowerCase(); var g = d.getAttribute("data-gespref").split("."), k = window; for (c = 0; c < g.length - 1; c++)k = k[g[c]]; c = k[g[c]]; switch (f) {
      case "slider": e.slider("value", c, b ? "none" : null); break; case "select": geofs.selectDropdown(d, c); break; case "radio-button": (d = d.getAttribute("data-matchvalue")) && d ==
        c && e.addClass("is-checked"); break; case "checkbox": case "radio": d = (d = d.getAttribute("data-matchvalue")) ? d == c : c == 1; e.prop("checked", d); d ? e.parent(".mdl-radio, .mdl-switch").addClass("is-checked") : e.parent(".mdl-radio, .mdl-switch").removeClass("is-checked"); break; case "keydetect": break; default: d.value = c
    }
  })
};
geofs.setInputHandlers = function (a) {
  $(a).find("[data-gespref]").each(function (b, c) {
    b = $(c); var d = c.getAttribute("data-type") || c.getAttribute("type"); c.nodeName == "SELECT" && (d = "select"); d = d.toLowerCase(); switch (d) {
      case "slider": b.handlerSet || (b.on("change", function (e, f) { geofs.setPreferenceFromInput(e.currentTarget) }), b.handlerSet = !0); break; case "select": c.onchange = function () { geofs.setPreferenceFromInput(event.currentTarget) }; break; case "radio-button": c.onclick = function (e) { geofs.setPreferenceFromInput(e.currentTarget) };
        break; case "checkbox": case "radio": c.onchange = function (e) { geofs.setPreferenceFromInput(e.currentTarget) }; break; case "keydetect": break; default: c.onchange = function (e) { geofs.setPreferenceFromInput(e.currentTarget) }
    }
  })
}; geofs.destroyPreferencePanel = function () { geofs.api.debug(!1); geofs.preferencesStopFeedback() }; geofs.cancelPreferencesPanel = function () { geofs.destroyPreferencePanel(); ui.closePreferencePanel() };
geofs.setPreferenceFromInput = function (a) {
  try {
    var b = a.getAttribute("data-gespref"); if (b) {
      var c = a.getAttribute("data-type") || a.getAttribute("type"); a.nodeName == "SELECT" && (c = "select"); c = c.toLowerCase(); var d = b.split("."); b = window; for (var e = 0; e < d.length - 1; e++)b = b[d[e]]; switch (c) {
        case "radio-button": $(a).is(".is-checked") && (b[d[e]] = a.getAttribute("data-matchvalue")); break; case "checkbox": var f = a.getAttribute("data-matchvalue"); var g = a.checked; f ? g && (b[d[e]] = f) : b[d[e]] = g; break; case "radio": f = a.getAttribute("data-matchvalue");
          g = a.checked; f ? g && (g = b[d[e]] = f) : b[d[e]] = g; break; case "slider": g = parseFloat($(a).slider("value")); b[d[e]] = g; break; case "keydetect": g = a.value; b[d[e]].keycode = parseInt(a.getAttribute("keycode")); b[d[e]].label = g; break; default: g = a.value, b[d[e]] = g
      }var k = a.getAttribute("data-update"); if (k) { var m = new Function("value", k); try { m.call(a, g) } catch (n) { geofs.debug.error(n, "setPreferenceFromInput updateFunction.call") } }
    }
  } catch (n) { geofs.debug.error(n, "geofs.setPreferenceFromInput") }
};
geofs.savePreferencesPanel = function () { geofs.destroyPreferencePanel(); geofs.savePreferences() }; "use strict"; var ui = ui || {}; ui.playerMarkers = {}; ui.playerSymbols = {}; ui.mouseUpHandlers = []; ui.svgPlanePath = "M250.2,59.002c11.001,0,20.176,9.165,20.176,20.777v122.24l171.12,95.954v42.779l-171.12-49.501v89.227l40.337,29.946v35.446l-60.52-20.18-60.502,20.166v-35.45l40.341-29.946v-89.227l-171.14,49.51v-42.779l171.14-95.954v-122.24c0-11.612,9.15-20.777,20.16-20.777z";
ui.svgPlaneStyles = { traffic: { path: ui.svgPlanePath, fillColor: "#9abcc8", fillOpacity: 1, scale: .05, strokeColor: "#4a68b8", strokeWeight: 1, anchor: [250, 250] }, blue: { path: ui.svgPlanePath, fillColor: "#19abff", fillOpacity: 1, scale: .06, strokeColor: "#162b63", strokeWeight: 1, anchor: [250, 250] }, yellow: { path: ui.svgPlanePath, fillColor: "#dbb33c", fillOpacity: 1, scale: .07, strokeColor: "#5d4c1a", strokeWeight: 1, anchor: [250, 250] } };
ui.init = function () {
  ui.mouseUpHandler = function (a) { if (ui.dragging) { if (ui.resizeV || ui.resizeH) ui.dragging.resize && ui.dragging.resize(), ui.resizeV = null, ui.resizeH = null, ui.dragging.style.cursor = "default"; ui.dragging = null } ui.runMouseUpHandlers(a) }; ui.$viewport = $(".geofs-ui-3dview"); $(document).mouseup(ui.mouseUpHandler); $(".geofs-ui-3dview, .geofs-canvas-mouse-overlay").on("click", function (a) { window.focus(); document.activeElement && document.activeElement.blur() }); $(document).on("contextmenu", ".geofs-canvas-mouse-overlay",
    function (a) { a.preventDefault() }); geofs.map.init(); ui.panel.init(); ui.userDialog.init(); ui.chat.init(); ui.vr.init(); $(document).on("keydown", ".geofs-stopKeyboardPropagation", function (a) { a.stopImmediatePropagation() }); $(document).on("keyup", ".geofs-stopKeyupPropagation", function (a) { a.stopImmediatePropagation() }); $(document).on("click mousedown", ".geofs-stopMousePropagation", function (a) { a.stopImmediatePropagation() }); $(document).on("click", "[data-aircraft]", function (a) {
      if (!multiplayer.flightSharing.status ||
        multiplayer.flightSharing.host) geofs.aircraft.instance.change(a.currentTarget.getAttribute("data-aircraft"), a.currentTarget.getAttribute("data-livery")), ui.panel.hide(null, !0), a.stopPropagation()
    }); $(document).on("click", "[data-camera]", function (a) { a = a.currentTarget.getAttribute("data-camera"); Number.isInteger(parseInt(a)) ? geofs.camera.set(parseInt(a)) : geofs.camera.set(null, a) }); $(document).on("click", ".geofs-crashed", function () { geofs.resetFlight() }); $(document).on("click", "[data-location]", function (a) {
      Function("{" +
        a.currentTarget.getAttribute("data-location") + "}")(); ui.panel.hide(null, !0); a.stopPropagation()
    }); $(document).on("keydown", ".address-input", function (a) { a.stopImmediatePropagation() }); $(document).on("submit", ".geofs-locationForm", function (a) { geoDecodeLocation($(".address-input").val(), function (b, c) { geofs != null && geofs.aircraft.instance != null && geofs.flyTo([b, c, 1E3, 0]) }); $(".address-input").val(""); ui.collapseLeft(); a.preventDefault() }); ui.applyPreferences()
}; ui.showManipulatorCursor = function () { ui.$viewport.addClass("geofs-manipulator") };
ui.hideManipulatorCursor = function () { ui.$viewport.removeClass("geofs-manipulator") }; ui.showCrashNotification = function () { $(".geofs-crashOverlay").addClass("geofs-crashed"); geofs.camera.animations.orbitHorizontal.active = !0 }; ui.hideCrashNotification = function () { $(".geofs-crashOverlay").removeClass("geofs-crashed"); geofs.camera.animations.orbitHorizontal.active = !1 };
ui.toggleFullscreen = function () { ui.isFullscreen ? (document.exitFullscreen(), ui.isFullscreen = !1, $("body").removeClass("fullscreen")) : (document.body.requestFullscreen(), ui.isFullscreen = !0, $("body").addClass("fullscreen")) };
ui.applyPreferences = function () { geofs.preferences.interface.transparent ? $("body").addClass("geofs-transparentUI") : $("body").removeClass("geofs-transparentUI"); geofs.preferences.interface.showYokeCursor ? $("body").addClass("geofs-showYokeCursor") : $("body").removeClass("geofs-showYokeCursor"); geofs.handleResize() }; ui.toggleButton = function (a, b) { (b = b == void 0 ? !$(a).hasClass("mdl-button--colored") : b) ? $(a).addClass("mdl-button--colored") : $(a).removeClass("mdl-button--colored") };
ui.expandLeft = function () { $("body").addClass("geofs-expand-left"); geofs.handleResize() }; ui.collapseLeft = function (a) { $("body").removeClass("geofs-expand-left"); geofs.handleResize() }; ui.addMouseUpHandler = function (a) { ui.mouseUpHandlers.push(a) }; ui.runMouseUpHandlers = function (a) { for (var b = 0; b < ui.mouseUpHandlers.length; b++)try { ui.mouseUpHandlers[b](a) } catch (c) { geofs.debug.error(c, "ui.runMouseUpHandlers") } };
ui.panel = {
  init: function () {
    $(document).on("click", "[data-toggle-panel]", function (a) { ui.panel.toggle($(a.currentTarget).attr("data-toggle-panel")); a.stopImmediatePropagation() }); $(document).on("click", function () { ui.panel.hide($(".geofs-toggle-panel.geofs-visible").not("[data-noblur]"), !0) }); $(document).on("click", ".geofs-list-collapsible-item", function (a) { ui.panel.toggleItem(a.currentTarget, a); a.preventDefault(); a.stopImmediatePropagation() }); $(document).on("click", ".geofs-collapsible", function (a) { a.stopImmediatePropagation() });
    $(document).on("click", ".geofs-advanced", function (a) { $(a.currentTarget).toggleClass("geofs-expanded") })
  }, toggleItem: function (a, b) { var c = $(a), d = c.parents(".geofs-list").first(); d.find(".geofs-list-item-expanded").not(b.target).removeClass("geofs-list-item-expanded"); c.toggleClass("geofs-list-item-expanded"); c.hasClass("geofs-list-item-expanded") ? c.trigger("expanded") : c.trigger("collapsed"); c.attr("data-noscroll") || d.scrollTop(a.offsetTop) }, expendItem: function (a, b) {
    var c = $(a), d = c.parents(".geofs-list").first();
    d.find(".geofs-list-item-expanded").not(b.target).removeClass("geofs-list-item-expanded"); c.addClass("geofs-list-item-expanded"); c.trigger("expanded"); d.scrollTop(a.offsetTop)
  }, toggle: function (a, b) { b = $(a); b.attr("data-parentZIndex") ? b.parent().css("z-index", b.attr("data-parentZIndex")) : b.parent().css("z-index", ""); b.attr("data-parentWidth") ? b.parent().css("width", b.attr("data-parentWidth")) : b.parent().css("width", ""); b.hasClass("geofs-visible") ? ui.panel.hide(a, !0) : ui.panel.show(a) }, show: function (a) {
    a =
      $(a); if (ui.panel.hide()) { ui.expandLeft("panel"); a.addClass("geofs-visible"); try { Function(a.attr("data-onshow"))() } catch (b) { geofs.debug.throw(b) } a.find(".geofs-list-item-expanded").trigger("expanded") }
  }, hide: function (a, b) {
    var c = !0, d = $(a || ".geofs-toggle-panel.geofs-visible"); $(d).each(function (e, f) { e = $(f); if (!a && e.attr("data-modal")) return c = !1; e.removeClass("geofs-visible"); try { Function(e.attr("data-onhide"))() } catch (g) { geofs.debug.throw(g) } }); d.length && b && ui.collapseLeft(a); d.find(".geofs-list-collapsible-item").trigger("collapsed");
    return c
  }
}; ui.closePreferencePanel = function () { ui.panel.hide(".geofs-preference-list", !0) }; ui.openMap = function (a) { a = a || {}; var b = a.lat || geofs.aircraft.instance.llaLocation[0] || 0; a = a.lon || geofs.aircraft.instance.llaLocation[1] || 0; geofs.map.startMap(); geofs.map.updateMap([b, a], !0) }; ui.closeMap = function () { geofs.map.stopMap() }; ui.Text = function (a, b) { b = Object.assign({}, this.defaultOptions, b); b.text = a + ""; this._overlay = new geofs.api.cssCompositor(b) };
ui.Text.prototype = { defaultOptions: { rescale: !1, anchor: { x: 0, y: 0 } }, show: function () { this._overlay.setVisibility(!0) }, hide: function () { this._overlay.setVisibility(!1) }, setText: function (a) { this._overlay.setText(a) }, destroy: function () { this._overlay.destroy() } }; ui.clearPlayerList = function () { $(".geofs-player-list").html("") }; ui.initPlayerList = function () { };
ui.userDialog = {
  init: function () {
    $(document).on("click", "[data-player]", function (b) { b = b.currentTarget.getAttribute("data-player"); b != geofs.userRecord.id && ui.userDialog.open(b) }); var a = $(".geofs-user-dialog"); a.on("click", ".geofs-join-user", function (b) { b = a.data("user"); b = multiplayer.users[b.uid]; var c = b.getCoordinates(); c[0] -= Math.cos(c[3] * DEGREES_TO_RAD) * .003; c[1] -= Math.sin(c[3] * DEGREES_TO_RAD) * .003; b.isOnGround() && (c[2] = 0); c && (c[4] = !0, geofs.flyTo(c)); ui.userDialog.close() }).on("click", ".geofs-ignore-user",
      function () { var b = a.data("user"); multiplayer.blockUser(b.acid); ui.userDialog.close() }).on("click", ".geofs-share-user", function () { var b = a.data("user"); multiplayer.flightSharing.request(multiplayer.getUser(b.uid)); ui.userDialog.close() }).on("click", ".geofs-ban-user", function () { var b = a.data("user"); multiplayer.banUser(b.acid); ui.userDialog.close() }).on("click", ".geofs-cancel", function () { ui.userDialog.close() })
  }, open: function (a) {
    var b = multiplayer.getUser(a); b && $(".geofs-user-dialog").data("user", {
      callsign: b.callsign,
      uid: a, acid: b.acid
    }).css("display", "flex").find(".geofs-user-callsign").html(b.callsign)
  }, close: function () { $(".geofs-user-dialog").data("user", null).css("display", "none") }
}; ui.chat = {}; ui.chat.maxNumberMessages = 30;
ui.chat.init = function () { $(".geofs-chat-input").keydown(function (a) { a.which == 27 && ui.chat.hideInput(!0) }).mousedown(function (a) { a.preventDefault() }); $(".geofs-chat-form").submit(function (a) { multiplayer.setChatMessage($(".geofs-chat-input").val()); ui.chat.hideInput(!0); a.preventDefault() }); $(".geofs-chat-button").mouseup(function (a) { ui.chat.showInput(); a.stopPropagation() }); $(".geofs-chat-send-button").mouseup(function (a) { a.stopPropagation() }); ui.addMouseUpHandler(ui.chat.hideInput); ui.chat.visibility() };
ui.chat.showInput = function () { geofs.preferences.chat == 0 ? ui.notification.show("Chat is disabled. You can enable it in the option panel.") : ($(".geofs-chat-input-section").addClass("geofs-visible"), $(".geofs-chat-input").focus()) }; ui.chat.hideInput = function (a) { $(".geofs-chat-input-section").removeClass("geofs-visible"); $(".geofs-chat-input").val(""); a === !0 && $(".geofs-chat-input").blur() };
ui.chat.publish = function (a) { if (geofs.preferences.chat) { var b = decodeURIComponent(a.msg); ui.chat.$container = ui.chat.$container || $(".geofs-chat-messages"); var c = ""; a.acid == geofs.userRecord.id && (c = "myself"); ui.chat.$container.prepend('<div class="geofs-chat-message ' + a.rs + '"><b class="label ' + c + '" data-player="' + a.uid + '" acid="' + a.acid + '" callsign="' + a.cs + '">' + a.cs + ":</b> " + b + "</div>"); ui.chat.$container.find(".geofs-chat-message").each(function (d, e) { $(e).css("opacity", (ui.chat.maxNumberMessages - d) / ui.chat.maxNumberMessages) }).eq(ui.chat.maxNumberMessages).remove() } };
ui.chat.removeUserMessages = function (a) { ui.chat.$container && ui.chat.$container.find("[acid=" + a + "]").remove() }; ui.chat.visibility = function () { geofs.preferences.chat ? $("body").addClass("geofs-chatOn") : $("body").removeClass("geofs-chatOn") }; ui.vr = {}; ui.vr.init = function () { geofs.api.isWebXRAvailable() && $(".geofs-button-vr").css("display", "inline-block") }; ui.vr.toggle = function () { geofs.api.toggleVr(); ui.toggleButton(".geofs-button-vr", geofs.vrOn) }; ui.notification = {}; ui.notification.show = function (a) { geofs.api.notify(a) };
ui.notification.showOnce = function (a, b) { geofs.preferences.key || (geofs.api.notify(a), geofs.preferences.key = "notified", geofs.savePreferences()) }; geofs.handleResize = function () { clearTimeout(geofs.resizingTimeout); geofs.resizingTimeout = setTimeout(function () { for (var a in geofs.resizeHandlers) try { geofs.resizeHandlers[a](geofs.viewport.offsetWidth, geofs.viewport.offsetHeight) } catch (b) { geofs.debug.error(b, "geofs.handleResize") } }, 300) };
geofs.addResizeHandler = function (a, b) { if (!b || !b.resizeHandlerId) return geofs.resizeHandlers[geofs.resizeHandlersIndex] = a, a = geofs.resizeHandlersIndex++, b && (b.resizeHandlerId = a), a }; geofs.removeResizeHandler = function (a) { delete geofs.resizeHandlers[a] };
geofs.getViewportDimentions = function () { geofs.viewportWidth = geofs.viewport.offsetWidth; geofs.viewportHeight = geofs.viewport.offsetHeight; geofs.viewportDimensions = { x: geofs.viewportWidth, y: geofs.viewportHeight }; geofs.camera.cam && (geofs.fovScale = Math.pow(geofs.viewportWidth / VIEWPORT_REFERENCE_WIDTH, .5), geofs.fovScale /= Math.pow(geofs.api.getFOV(geofs.camera.cam), 1)) }; geofs.currentVisibility = 0;
geofs.visibilityCycle = function () {
  geofs.currentVisibility++; geofs.currentVisibility == 4 && (geofs.currentVisibility = 0); geofs.currentVisibility == 0 && (instruments.show(), $("body").removeClass("geofs-uiMinimalistic"), $("body").removeClass("geofs-uiNone")); geofs.currentVisibility == 1 && (instruments.show(), $("body").addClass("geofs-uiMinimalistic"), $("body").removeClass("geofs-uiNone")); geofs.currentVisibility == 2 && (instruments.hide(), instruments.show("controls"), $("body").addClass("geofs-uiMinimalistic"), $("body").removeClass("geofs-uiNone"));
  geofs.currentVisibility == 3 && (instruments.hide(), $("body").removeClass("geofs-uiMinimalistic"), $("body").addClass("geofs-uiNone")); instruments.update()
}; geofs.overlayClassToOpacityMap = { "geofs-instrument-background": .4, "geofs-overlay-moreTransparence": .6 };
function Overlay(a, b, c) {
  var d = this; this.definition = { url: "", anchor: { x: 0, y: 0 }, position: { x: 0, y: 0 }, rotation: 0, size: { x: 0, y: 0 }, offset: { x: 0, y: 0 }, visibility: !0, opacity: 1, scale: { x: 1, y: 1 }, rescale: b ? b.definition.rescale : !1, rescalePosition: !1, inline: !1, alignment: { x: "left", y: "bottom" }, overlays: [] }; this.parent = b; this.children = []; this.definition = $.extend(!0, {}, this.definition, a); this.position = this.definition.position; this.size = this.definition.size; this.iconFrame = this.definition.iconFrame; this.scale = this.definition.scale;
  this.positionOffset = this.definition.offset; this._offset = { x: 0, y: 0 }; this._sizeScale = 1; this.rotation = this.definition.rotation; this.opacity = this.definition.opacity; this.anchor = this.definition.anchor; this.visibility = this.definition.visibility; b ? this.compositor = this.parent.compositor : (this.isRootLayer = !0, b = "css", (a.compositors || "").indexOf(geofs.api.preferredCompositor) > -1 && (b = geofs.api.preferredCompositor), this.compositor = new geofs.api.compositors[b](c, this)); this.compositor.name == "canvas" && (this.opacity =
    geofs.overlayClassToOpacityMap[this.definition.class] || this.opacity); this.compositorLayer = this.compositor.createLayer(c, this.definition.inline); this.compositorLayer.setUrl(this.definition.url); this.compositorLayer.setMask(this.definition.maskUrl, this.definition.clip); this.compositorLayer.setText(this.definition.text); this.compositorLayer.setClass(this.definition.class); this.compositorLayer.setStyle(this.definition.style); this.compositorLayer.setSize(this.definition.size); this.compositorLayer.setAnchor(this.definition.anchor);
  this.compositorLayer.setPosition(this.definition.position); this.compositorLayer.setDrawOrder(this.definition.drawOrder || 0); $(this.compositorLayer).one("load", function (f) { var g = d.definition.size.x / f.currentTarget.naturalSize.x; d.definition.size = f.currentTarget.naturalSize; d._sizeScale = g; d.scaleAndPlace() }); this.compositorLayer.setVisibility(this.definition.visibility); if (this.definition.animations) for (a = 0, b = this.definition.animations.length; a < b; a++) {
    var e = this.definition.animations[a]; e.type == "rotate" &&
      (this.definition.animateRotation = !0); e.type == "show" && (this.animateVisibility = !0, this.animationVisibility = this.definition.visibility)
  } this.definition.manipulator && $(this.compositorLayer._$element).on("mousedown touchstart", function (f) { f.which = 4; controls.manipulator = d.definition.manipulator; controls.wheelManipulator = null; controls.mouseDownHandler(f); f.preventDefault() }).on("mouseup touchend", function (f) { controls.manipulator = null; controls.wheelManipulator = null }).on("mouseenter", function (f) {
    controls.wheelManipulator =
      d.definition.manipulator
  }).on("mouseleave", function (f) { controls.wheelManipulator = null }).addClass("geofs-manipulator"); for (a = 0; a < this.definition.overlays.length; a++)b = this.definition.overlays[a], b.compositor = this.definition.compositors, b = new Overlay(b, this, this.definition.inline || b.inline ? this.compositorLayer.getElement() : b.container || c), this.children[a] = b
} Overlay.prototype.makeDirty = function () { this.dirty = !0 };
Overlay.prototype.setVisibility = function (a) { this.animateVisibility && !this.animationVisibility || this.compositorLayer.setVisibility(a); this.visibility = a; for (var b = 0; b < this.children.length; b++)this.children[b].setVisibility(a) }; Overlay.prototype.setOpacity = function (a) { this.compositorLayer.setOpacity(a); this.opacity = a; for (var b = 0; b < this.children.length; b++)this.children[b].setOpacity(a) };
Overlay.prototype.scaleAllProperties = function (a) {
  a = a || this.scale; var b = 1, c = 1, d = { x: 1 * this._sizeScale, y: 1 * this._sizeScale }; this.definition.rescalePosition && (b = a.x, c = a.y); this.definition.rescale && (d = { x: d.x * a.x, y: d.y * a.y }); this.position = { x: this.definition.position.x * b, y: this.definition.position.y * c }; this.size = { x: this.definition.size.x * d.x, y: this.definition.size.y * d.y }; this.compositorLayer.setSize(this.size); this.positionOffset = { x: this.definition.offset.x * d.x, y: this.definition.offset.y * d.y }; this.compositorLayer.setOffset(this.positionOffset);
  this.compositorLayer.setTranslation({ x: 0, y: 0 }); this.definition.iconFrame ? (this.iconFrame = { x: this.definition.iconFrame.x * d.x, y: this.definition.iconFrame.y * d.y }, this.compositorLayer.setFrameSize(this.iconFrame)) : (this.iconFrame = this.size, this.compositorLayer.setFrameSize(this.size)); this.anchor = { x: this.definition.anchor.x * d.x, y: this.definition.anchor.y * d.y }; this.compositorLayer.setAnchor(this.anchor); this.rotationCenter = { x: this.anchor.x, y: this.iconFrame.y - this.anchor.y }; this.compositorLayer.setRotationCenter(this.rotationCenter)
};
Overlay.prototype.scaleAndPlace = function (a, b, c, d) {
  this.compositor.name == "canvas" && (d = !0); this.scale = this.scaleFromParent(a); (this.definition.rescale && !this.parent || this.definition.rescalePosition) && !d && (c = c || geofs.viewportDimensions, a = clamp(c.x / VIEWPORT_REFERENCE_WIDTH, .3, 1), d = clamp(c.y / VIEWPORT_REFERENCE_HEIGHT, .3, 1), this.scale = S2.scale(this.scale, Math.min(a, d))); this.offset = { x: 0, y: 0 }; this.scaleAllProperties(); this.place(b, c); for (b = 0; b < this.children.length; b++)this.children[b].scaleAndPlace(null,
    null, c)
};
Overlay.prototype.place = function (a, b) {
  !this.parent || this.parent.definition.inline || this.definition.container ? (a = a || this.definition.position, geofs.camera.currentModeName == "cockpit" && this.definition.cockpit ? this.position = a : this.definition.alignment && this.compositor.name == "css" && (b = b || geofs.viewportDimensions, this.definition.alignment.x == "right" && (this.position.x = b.x - a.x * this.scale.x), this.definition.alignment.x == "center" && (this.position.x = b.x / 2 - a.x * this.scale.x), this.definition.alignment.y == "top" &&
    (this.position.y = b.y - a.y * this.scale.y), this.definition.alignment.y == "center" && (this.position.y = b.y / 2 - a.y * this.scale.y))) : (this.definition.animateRotation || (this.rotation = this.definition.rotation + this.parent.rotation), this.position = this.compositor.name == "canvas" ? { x: this.parent.position.x + this.definition.position.x * this.scale.x, y: this.parent.position.y - this.definition.position.y * this.scale.y } : {
      x: this.parent.position.x + this.definition.position.x * this.scale.x, y: this.parent.position.y + this.definition.position.y *
        this.scale.y
    }); this.compositorLayer.setPosition(this.position); this.compositorLayer.setOpacity(this.opacity); this.compositorLayer.setRotation(this.rotation)
}; Overlay.prototype.scaleFromParent = function (a) { a = a || { x: 1, y: 1 }; var b = this.parent ? this.parent.scale : { x: 1, y: 1 }; return { x: this.definition.scale.x * b.x * a.x, y: this.definition.scale.y * b.y * a.y } };
Overlay.prototype.positionFromParentRotation = function () { var a = [this.position.x, this.position.y, 0], b = M33.identity(); b = M33.rotationZ(b, -this.parent.rotation * DEGREES_TO_RAD); a = M33.transform(b, a); return { x: a[0], y: a[1] } };
Overlay.prototype.animate = function (a) {
  if (this.definition.animations) for (var b = 0; b < this.definition.animations.length; b++) {
    var c = this.definition.animations[b], d = geofs.animation.filter(c); if (c.lastValue != d || a || c.forceRefresh || this.parent && this.parent.dirty) switch (this.dirty = !0, c.lastValue = d, c.type) {
      case "moveY": !isNaN(d) && this.visibility && this.compositorLayer.setPositionY(this.position.y + d * this.scale.y); break; case "translateY": !isNaN(d) && this.visibility && this.translateIcon(d, "Y"); break; case "translateX": !isNaN(d) &&
        this.visibility && this.translateIcon(d, "X"); break; case "scaleX": !isNaN(d) && this.visibility && (this.size.x = d * this.scale.x, this.compositorLayer.setSize(this.size)); break; case "scaleFrameX": !isNaN(d) && this.visibility && (this.iconFrame.x = d, this.compositorLayer.setFrameSize(this.iconFrame)); break; case "scaleFrameY": !isNaN(d) && this.visibility && (this.iconFrame.y = d, this.compositorLayer.setFrameSize(this.iconFrame)); break; case "text": this.compositorLayer.setText(d); break; case "title": this.compositorLayer.setTitle(d);
        break; case "opacity": this.setOpacity(d); break; case "show": this.visibility && this.compositorLayer.setVisibility(d); this.animationVisibility = d; break; default: d && this.visibility && this.rotate(d)
    } else this.dirty = !1
  } for (b = 0; b < this.children.length; b++)this.children[b].animate(a); this.isRootLayer && this.compositor.render()
}; Overlay.prototype.translateIcon = function (a, b) { b == "Y" ? this._offset.y = a * this.scale.y * this._sizeScale - this.size.y + this.iconFrame.y : this._offset.x = a * this.scale.x * this._sizeScale; this.compositorLayer.setTranslation(this._offset) };
Overlay.prototype.rotate = function (a) { this.rotation = a; this.parent && (this.rotation += this.parent.rotation); this.compositorLayer.setRotation(this.rotation) }; Overlay.prototype.setText = function (a) { this.compositorLayer.setText(a) }; Overlay.prototype.setTitle = function (a) { this.compositorLayer.setTitle(a) }; Overlay.prototype.destroy = function () { this.compositor && this.compositor.destroy(); this.compositorLayer && this.compositorLayer.destroy(); for (var a = 0; a < this.children.length; a++)this.children[a].destroy() }; "use strict";
geofs.fx = geofs.fx || { globeLoaded: !1 };
geofs.fx.texture2url = {
  smoke: "images/particles/smoke-light.png", whitesmoke: "images/particles/smoke-white.png", darkSmoke: "images/particles/smoke-dark.png", contrails: "images/particles/contrails.png", 1: "images/lights/yellowflare.png", 2: "images/lights/redflare.png", 3: "images/lights/greenflare.png", white: "images/lights/whitelight.png", red: "images/lights/redlight.png", green: "images/lights/greenlight.png", orange: "images/lights/orangelight.png", yellow: "images/lights/yellowlight.png", whitepapi: "images/lights/whitepapi.png",
  redpapi: "images/lights/redpapi.png"
}; geofs.fx.particles = {}; geofs.fx.particleEmitters = {}; geofs.fx.init = function () { $(document).on("globeLoaded", function () { geofs.fx.globeLoaded = !0 }) }; geofs.fx.precisionTime = 0; geofs.fx.update = function (a) { for (var b in geofs.fx.particleEmitters) geofs.fx.particleEmitters[b].update(a); for (b in geofs.fx.particles) geofs.fx.particles[b].update(a); geofs.preferences.graphics.waterEffect && geofs.fx.wake.update(); geofs.pause || (geofs.fx.precisionTime = geofs.api.precisionTime) };
geofs.fx.setParticlesColor = function (a) { for (var b in geofs.fx.particles) geofs.fx.particles[b].setColor(a) }; geofs.fx.maxTimeSinceLastParticleEmission = 5E3;
geofs.fx.ParticleEmitter = function (a) { this._birth = geofs.utils.fastNow(); this._id = this._birth + Math.random(); this._lastEmission = this._birth; this._on = !a.off; this._options = a; this._options.location = this._options.location || [0, 0, 0]; geofs.fx.particleEmitters[this._id] = this; this._options.anchor && geofs.aircraft.instance && (this._options.location = V3.dup(Object3D.utilities.getPointLla(this._options.anchor, geofs.aircraft.instance.llaLocation))) };
geofs.fx.ParticleEmitter.prototype = {
  update: function () {
    if (this._on) {
      var a = geofs.utils.fastNow(); if (a - this._birth > this._options.duration) this.destroy(); else {
        var b = a - this._lastEmission, c = b * this._options.rate; b > geofs.fx.maxTimeSinceLastParticleEmission && (c = 2); b = null; this._options.anchor && (b = V3.dup(Object3D.utilities.getPointLla(this._options.anchor, geofs.aircraft.instance.llaLocation))); if (this._options.followPath) if (this._lastEmissionLocation) {
          var d = V3.sub(b, this._lastEmissionLocation); c = V2.length(lla2xyz(d,
            this._lastEmissionLocation)); c > this._options.pathStep && (this._options.location = b, this._options.startRotation = geofs.utils.lookAt(b, this._lastEmissionLocation, [0, 0, 1]), this._options.startScale = c, new geofs.fx.Particle(this._options, this), this._lastEmissionLocation = V3.dup(b), this._lastEmission = a)
        } else this._lastEmissionLocation = V3.dup(b); else {
          d = null; b && (d = V3.sub(b, this._options.location), d = V3.scale(d, 1 / c)); for (var e = 0; e < c - 1; e++)d && (this._options.location = V3.add(this._options.location, d)), new geofs.fx.Particle(this._options,
            this), this._lastEmission = a
        } b && (this._options.location = b)
      }
    }
  }, isOn: function () { return this._on }, turnOn: function () { this._on = !0 }, turnOff: function () { this._on = !1 }, destroy: function () { delete geofs.fx.particleEmitters[this._id] }
}; geofs.fx.ParticuleEmitter = geofs.fx.ParticleEmitter; geofs.fx.particleBillboardOptions = { sizeInMeters: !0 };
geofs.fx.Particle = function (a, b) {
  a = Object.assign(geofs.fx.particleBillboardOptions, a); this._birth = geofs.utils.fastNow(); this._id = this._birth + Math.random(); this._emitter = b; geofs.fx.particles[this._id] = this; a.url = a.url || geofs.fx.texture2url[a.texture]; a.startOpacity = a.startOpacity || 1; a.endOpacity = a.endOpacity || a.startOpacity; a.startScale = a.startScale || 1; a.endScale = a.endScale || a.startScale; a.easing = a.easing || "linear"; a.randomizeStartScale && (a.startScale += Math.random() * a.randomizeStartScale); a.randomizeEndScale &&
    (a.endScale += Math.random() * a.randomizeEndScale); a.startRotation == "random" && (a.startRotation = Math.random() * TWO_PI); a.endRotation == "random" && (a.endRotation = Math.random() * TWO_PI); a.startRotation = a.startRotation || 0; a.endRotation = a.endRotation || a.startRotation; this.currentLocation = V3.dup(a.location); a.dtOpacity = a.endOpacity - a.startOpacity; a.dtScale = a.endScale - a.startScale; a.dtRotation = a.endRotation - a.startRotation; this._options = a; this.create()
};
geofs.fx.Particle.prototype = {
  create: function () {
    this._currentScale = this._options.startScale; this._currentOpacity = this._options.startOpacity; this._currentRotation = this._options.startRotation; this._options = Object.assign(this._options, { opacity: this._currentOpacity, scale: this._currentScale, rotation: this._currentRotation, color: geofs.fx.cloudManager.cloudColor }); this._options.model ? (this._options.rotation = [this._currentRotation, 0, 0], this._APIElement = new geofs.api.Model(this._options.model, this._options)) :
      this._options.groundTexture ? this._APIElement = new geofs.api.groundTexture(this.currentLocation, this._options.groundTexture, this._options) : (this._options.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(this._options.near || 50, this._options.far || 1E6), this._APIElement = new geofs.api.billboard(this.currentLocation, this._options.url, this._options))
  }, setColor: function (a) { this._APIElement && this._APIElement.setColor(a) }, setLocation: function (a) { this._APIElement && (this.currentLocation = a, this._APIElement.setLocation(this.currentLocation)) },
  setRotation: function (a, b) { this._APIElement && (this._currentRotation = a, this._APIElement.setRotation(this._currentRotation, b)) }, setScale: function (a) { this._APIElement && this._APIElement.setScale(a) }, setPositionOrientationAndScale: function (a, b, c) { this._APIElement && this._APIElement.setPositionOrientationAndScale(a, b, c) }, update: function (a) {
    var b = (geofs.utils.fastNow() - this._birth) / this._options.life; b > 1 ? this.destroy() : this._APIElement && (b = geofs.utils.easingFunctions[this._options.easing](b), this._options.dtOpacity &&
      (this._currentOpacity = clamp(this._options.startOpacity + this._options.dtOpacity * b, 0, 1), this._APIElement.setOpacity(this._currentOpacity)), this._options.dtScale && (this._currentScale = this._options.startScale + this._options.dtScale * b, this._APIElement.setScale(this._currentScale)), this._options.dtRotation && (this._currentRotation = this._options.startRotation + this._options.dtRotation * b, this._APIElement.setRotation(this._currentRotation)), this._options.velocity && this._options.direction && (this._options.velocityDamper &&
        (this._options.velocity *= this._options.velocityDamper * a), this.currentLocation = V3.add(this.currentLocation, V3.scale(this._options.direction, this._options.velocity)), this._APIElement.setLocation(this.currentLocation)), this._options.floatsOnWaves && (this.currentLocation[2] = geofs.fx.water.getWaveHeight(this.currentLocation[0], this.currentLocation[1]), this._APIElement.setLocation(this.currentLocation)))
  }, destroy: function () {
    this._APIElement && (this._APIElement.destroy(), this._APIElement = null); this._emitter =
      null; geofs.fx.particles[this._id] = null; delete geofs.fx.particles[this._id]
  }
}; geofs.fx.light = function (a, b, c) { a = a || [0, 0, 0]; this._billboard = new geofs.api.billboard(a, geofs.fx.texture2url[b], c) }; geofs.fx.light.prototype = { setVisibility: function (a) { this._billboard.setVisibility(a); return !0 }, setLocation: function (a) { this._billboard.setLocation(a) }, destroy: function () { this._billboard.destroy(); this._billboard = null } }; geofs.light = geofs.fx.light;
geofs.fx.dayNightManager = {
  nightSunColors: [Cesium.Color.fromCssColorString("#cc7e5b30"), Cesium.Color.fromCssColorString("#9a6c4625"), Cesium.Color.fromCssColorString("#20202020"), Cesium.Color.fromCssColorString("#20202020"), Cesium.Color.fromCssColorString("#20202020"), Cesium.Color.fromCssColorString("#20202020"), Cesium.Color.fromCssColorString("#20202020"), Cesium.Color.fromCssColorString("#20202020")], daySunColors: [Cesium.Color.fromCssColorString("#cc7e5b30"), Cesium.Color.fromCssColorString("#ffcfb1ff"),
  Cesium.Color.fromCssColorString("#ffffffff"), Cesium.Color.fromCssColorString("#ffffffff"), Cesium.Color.fromCssColorString("#ffffffff"), Cesium.Color.fromCssColorString("#ffffffff"), Cesium.Color.fromCssColorString("#ffffffff"), Cesium.Color.fromCssColorString("#ffffffff")], brightness: { valueRamp: [100, 1, 1, 1, 1, 1, 1, 1] }, saturation: { valueRamp: [.01, .01, 1, 1, 1, 1, 1, 1] }, gamma: { valueRamp: [.1, .1, 1, 1, 1, 1, 1, 1] }, hue: { valueRamp: [0, 0, 0, 0, 0, 0, 0, 0] }, brightnessShift: { valueRamp: [-.6, -.6, -.2, 0, 0] }, groundBrightnessShift: {
    valueRamp: [-1.5,
    -1.3, -.4, 0, 0]
  }, groundAtmoSaturationShift: { valueRamp: [-.6, -.6, 0, 0, 0] }, groundHueShift: { valueRamp: [0, 0, 0, 0, 0] }, cloudsBrightness: { valueRamp: [0, 0, 0, .5, 1, 1] }, fogBrightness: { valueRamp: [.1, .1, .2, .5, 1, 1] }, blackMarbleVisibility: { valueRamp: [1, 1, 1, 0, 0] }, blackMarbleAlpha: { valueRamp: [.1, .1, .1, 0, 0] }, init: function () { var a = this; geofs.api.viewer.scene.moon.show = weather.timeRatio > .55 ? !0 : !1; geofs.fx.dayNightManager.sunColor = geofs.fx.dayNightManager.daySunColor; setTimeout(function () { a.update() }, 0) }, update: function () {
    var a =
      Cesium.Cartesian3.normalize(geofs.api.viewer.scene.sun._boundingVolume.center, new Cesium.Cartesian3), b = Cesium.Cartesian3.normalize(geofs.camera.cam.position, new Cesium.Cartesian3); if ((a = parseFloat(Cesium.Cartesian3.dot(b, a).toPrecision(2))) && a != geofs.fx.sunDotNormal) {
        geofs.fx.sunDotNormal = a; if (a > 0) {
          geofs.fx.dayNightManager.sunColor = geofs.api.color.mixArray(geofs.fx.dayNightManager.daySunColors, clamp(a, 0, 1)); b = geofs.api.color.mixArray(geofs.fx.water.dayHorizonColors, clamp(a, 0, 1)); var c = geofs.api.color.mixArray(geofs.fx.water.dayAzimutColors,
            clamp(a, 0, 1))
        } else geofs.fx.dayNightManager.sunColor = geofs.api.color.mixArray(geofs.fx.dayNightManager.nightSunColors, clamp(-a, 0, 1)), b = geofs.api.color.mixArray(geofs.fx.water.nightHorizonColors, clamp(-a, 0, 1)), c = geofs.api.color.mixArray(geofs.fx.water.nightAzimutColors, clamp(-a, 0, 1)); geofs.isNight = geofs.fx.dayNightManager.sunColor.blue < .35 ? !0 : !1; geofs.fx.water.setColours(b, c); geofs.animation.values.night != geofs.isNight && $("body").trigger("nightChange"); geofs.animation.values.night = geofs.isNight; geofs.api.viewer.scene.skyBox.show =
          a < 0 ? !0 : !1; geofs.fx.dayNightManager.sunIntensity = geofs.fx.dayNightManager.sunColor.alpha; geofs.api.setSceneLight(geofs.fx.dayNightManager.sunColor, geofs.fx.dayNightManager.sunIntensity * weather.belowCloudsBrightness); geofs.fx.cloudManager.setCloudColors(null, null, null, 1, geofs.fx.dayNightManager.sunColor); a = clamp(1 - weather.timeRatio + a, 0, 1); this.illumination != a && (geofs.api.setImageryColorModifier("time", {
            brightness: geofs.animation.filter(this.brightness, a), saturation: geofs.animation.filter(this.saturation,
              a), gamma: geofs.animation.filter(this.gamma, a), hue: geofs.animation.filter(this.hue, a)
          }), this.illumination = a)
      }
  }
};
geofs.fx.atmosphere = {
  color: Cesium.Color.fromCssColorString("#b6d3f5ff"), dayColor: Cesium.Color.fromCssColorString("#b6d3f5ff"), nightColor: Cesium.Color.fromCssColorString("#e0773dff"), brightness: 1, postProcessingStageSet: !1, updatePeriod: 1E3, cloudsUpdatePeriod: 6E5, cloudLayerPosition: .2, planetRadius: 6361E3, realPlanetRadius: 6371E3, create: function (a, b, c, d, e) {
    var f = this; this.advancedAtmosphere != a && this.destroy(); this.volumetricClouds != c && this.destroy(); this.quality != b && this.destroy(); this.realTimeClouds !=
      d && this.destroy(); this.retro != e && this.destroy(); if (!geofs.fx.atmosphere.postProcessingStages) {
        this.reset(); var g = a ? "#define ADVANCED_ATMOSPHERE\n" : "", k = "#define QUALITY_" + b + "\n", m = c ? "#define VOLUMETRIC_CLOUDS\n" : "", n = d ? "#define REALTIME_CLOUDS\n" : "", q = e ? "#define RETRO\n" : "", u = weather.definition.cloudCover * .01; this.quality = b; this.advancedAtmosphere = a; this.volumetricClouds = c && a; this.realTimeClouds = d; this.retro = e; geofs.api.useNativeAtmosphere(!this.advancedAtmosphere); a = geofs.fx.atmosphere.planetRadius +
          111E3; geofs.fx.atmosphere.realPlanetRadius = geofs.fx.atmosphere.planetRadius + 1E4; a *= a; geofs.fx.atmosphere.atmospherePostProcessStage = new Cesium.PostProcessStage({
            fragmentShader: g + q + n + m + k + geofsShaders["atmosphereCommon.glsl"] + geofsShaders["atmosphereOnlyFS.glsl"], uniforms: {
              planetRadius: geofs.fx.atmosphere.planetRadius, realPlanetRadius: geofs.fx.atmosphere.realPlanetRadius, atmoRadiusSquared: a, backgroundFogDensity: 0, backgroundFogColor: geofs.fx.atmosphere.color, volumetricFogDensity: 0, volumetricFogBottom: 0,
              volumetricFogTop: 0
            }
          }); if (c) {
            geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.volumetricCloudsTexture = "volumetricClouds"; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.windVector = weather.currentWindVectorWC; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudCover = u; c = weather.definition.cloudTop - weather.definition.cloudBase; e = c * geofs.fx.atmosphere.cloudLayerPosition; var z = weather.definition.cloudBase + e, B = geofs.fx.atmosphere.realPlanetRadius + weather.definition.cloudBase, p = B +
              c; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudBase = weather.definition.cloudBase; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudTop = weather.definition.cloudTop; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.layerPosition = geofs.fx.atmosphere.cloudLayerPosition; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudThickness = c; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.baseThickness = e; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.layer =
                z; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudBaseRadius = B; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudTopRadius = p; var r = clamp(b * .12, .25, 1); geofs.fx.atmosphere.cloudsPostProcessStage = new Cesium.PostProcessStage({
                  textureScale: r, fragmentShader: g + q + n + m + k + geofsShaders["atmosphereCommon.glsl"] + geofsShaders["volumetricCloudsFS.glsl"], uniforms: {
                    planetRadius: geofs.fx.atmosphere.planetRadius, realPlanetRadius: geofs.fx.atmosphere.realPlanetRadius, atmoRadiusSquared: a, windVector: weather.currentWindVectorWC,
                    cloudCover: u, cloudBase: weather.definition.cloudBase, cloudTop: weather.definition.cloudTop, layerPosition: geofs.fx.atmosphere.cloudLayerPosition, cloudThickness: c, baseThickness: e, layer: z, cloudBaseRadius: B, cloudTopRadius: p, noiseTexture: "/shaders/noise/bluenoise.png"
                  }
                }); d && (u = 1, geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.coverageTexture = weather.realTimeCloudTexture + "?t=" + geofs.utils.hourStamp(), geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudCover = u, geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.coverageTexture =
                  weather.realTimeCloudTexture + "?t=" + geofs.utils.hourStamp(), geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.cloudCover = u); geofs.fx.atmosphere.blurStage = Cesium.PostProcessStageLibrary.createBlurStage(); geofs.fx.atmosphere.blurStage.uniforms.delta = 1; geofs.fx.atmosphere.blurStage.uniforms.sigma = 2; geofs.fx.atmosphere.blurStage.uniforms.stepSize = clamp(6 - b, 1, 4); geofs.fx.atmosphere.postProcessingStages = new Cesium.PostProcessStageComposite({
                    inputPreviousStageTexture: !1, stages: [new Cesium.PostProcessStageComposite({
                      inputPreviousStageTexture: !0,
                      stages: [geofs.fx.atmosphere.cloudsPostProcessStage, geofs.fx.atmosphere.blurStage], name: "volumetricClouds"
                    }), geofs.fx.atmosphere.atmospherePostProcessStage]
                  })
          } else geofs.fx.atmosphere.postProcessingStages = geofs.fx.atmosphere.atmospherePostProcessStage; $(document).on("terrainProviderWillUpdate", function () { geofs.fx.globeLoaded = !1; f.destroy() }); $(document).on("globeLoaded", function () { geofs.fx.atmosphere.addPostProcessingStage(); geofs.fx.atmosphere.tileLoadProgressListener() }); geofs.fx.atmosphere.tileLoadProgressListener =
            geofs.api.viewer.scene.globe.tileLoadProgressEvent.addEventListener(function (C) { C > 2 && (geofs.fx.globeLoaded = !0, $("body").trigger("globeLoaded")) }); geofs.fx.atmosphere.addPostProcessingStage()
      }
  }, addPostProcessingStage: function () { geofs.fx.globeLoaded && !geofs.fx.atmosphere.postProcessingStageSet && (geofs.api.viewer.scene.postProcessStages.add(geofs.fx.atmosphere.postProcessingStages), geofs.fx.atmosphere.postProcessingStageSet = !0) }, reset: function () { }, update: function (a, b) {
    if (geofs.fx.atmosphere.postProcessingStages &&
      (geofs.utils.updateTime(this, this.updatePeriod) || b)) {
      a = geofs.api.viewer.scene.globe.ellipsoid.cartographicToCartesian(new Cesium.Cartographic(a[1] * DEGREES_TO_RAD, a[0] * DEGREES_TO_RAD, 0)); var c = Cesium.Cartesian3.magnitude(a); a = c - 1E4; b = a + 111E3; geofs.fx.atmosphere.realPlanetRadius = c; c = weather.definition.cloudTop - weather.definition.cloudBase; var d = c * geofs.fx.atmosphere.cloudLayerPosition, e = weather.definition.cloudBase + d, f = geofs.fx.atmosphere.realPlanetRadius + weather.definition.cloudBase, g = f + c; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.planetRadius =
        a; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.realPlanetRadius = geofs.fx.atmosphere.realPlanetRadius; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.atmoRadiusSquared = b * b; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudBase = weather.definition.cloudBase; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudTop = weather.definition.cloudTop; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.layerPosition = geofs.fx.atmosphere.cloudLayerPosition; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudThickness =
          c; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.baseThickness = d; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.layer = e; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudBaseRadius = f; geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudTopRadius = g; geofs.fx.atmosphere.cloudsPostProcessStage && (geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.planetRadius = a, geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.realPlanetRadius = geofs.fx.atmosphere.realPlanetRadius,
            geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.cloudBase = weather.definition.cloudBase, geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.cloudTop = weather.definition.cloudTop, geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.layerPosition = geofs.fx.atmosphere.cloudLayerPosition, geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.cloudThickness = c, geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.baseThickness = d, geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.layer = e, geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.cloudBaseRadius =
            f, geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.cloudTopRadius = g); this.realTimeClouds && geofs.utils.updateTime(this, this.cloudsUpdatePeriod) && (geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.coverageTexture = weather.realTimeCloudTexture + "?t=" + geofs.utils.hourStamp(), geofs.fx.atmosphere.cloudsPostProcessStage && (geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.coverageTexture = weather.realTimeCloudTexture + "?t=" + geofs.utils.hourStamp()))
    }
  }, setConditions: function (a, b) {
    geofs.fx.atmosphere.postProcessingStages &&
      this.volumetricClouds && (this.realTimeClouds && (b = 1), geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.windVector = a, geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.cloudCover = b, geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.windVector = a, geofs.fx.atmosphere.cloudsPostProcessStage.uniforms.cloudCover = b, geofs.fx.atmosphere.update(geofs.camera.lla, !0))
  }, setVolumetricFog: function (a, b, c) {
    geofs.fx.atmosphere.postProcessingStages && (geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.volumetricFogBottom =
      a, geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.volumetricFogTop = b, geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.volumetricFogDensity = c)
  }, setFogColor: function (a, b) {
    geofs.fx.atmosphere.postProcessingStages && (b = b || this.brightness, a = a || weather.timeRatio, b *= weather.belowCloudsBrightness, a = Cesium.Color.lerp(geofs.fx.atmosphere.dayColor, geofs.fx.atmosphere.nightColor, a, new Cesium.Color), a = new Cesium.Color(a.red * b, a.green * b, a.blue * b, 1), geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.backgroundFogColor =
      a)
  }, setFogDensity: function (a) { geofs.fx.atmosphere.postProcessingStages && (geofs.fx.atmosphere.atmospherePostProcessStage.uniforms.backgroundFogDensity = a) }, destroy: function () {
    geofs.fx.atmosphere.postProcessingStages && (geofs.api.viewer.scene.postProcessStages.remove(geofs.fx.atmosphere.postProcessingStages), geofs.fx.atmosphere.postProcessingStages.isDestroyed() || geofs.fx.atmosphere.postProcessingStages.destroy(), geofs.fx.atmosphere.postProcessingStageSet = !1, geofs.fx.atmosphere.postProcessingStages = null,
      geofs.fx.atmosphere.atmospherePostProcessStage = null, geofs.fx.atmosphere.cloudsPostProcessStage = null, geofs.fx.atmosphere.tileLoadProgressListener && geofs.fx.atmosphere.tileLoadProgressListener())
  }
};
geofs.fx.cloudManager = {
  cloudCoverToCloudNumber: 15, clouds: {}, numberOfClouds: 0, currentID: 0, maxNumberOfClouds: 0, refreshDistance: 1E3, currentCenter: [0, 0, 0], redAnimation: { valueRamp: [255, 255, 250, 100, 100] }, greenAnimation: { valueRamp: [255, 255, 230, 100, 100] }, blueAnimation: { valueRamp: [255, 255, 200, 100, 100] }, fogBrightnessRamp: [0, 0, 0, 1], groundBrightnessRamp: [-.4, -.4, -.4, 0], setCloudCoverToCloudNumber: function (a) { this.cloudCoverToCloudNumber = a || this.cloudCoverToCloudNumber; geofs.fx.cloudManager.instance && this.setCloudCover(geofs.fx.cloudManager.instance.percentCoverage) },
  init: function (a) { this.cloudSituation = null; var b = lla2xyz(V3.sub(this.currentCenter, a), geofs.aircraft.instance.llaLocation); V3.length(b) > this.refreshDistance && this.destroyAllClouds(); this.currentCenter = a; this.numberOfClouds = 0; geofs.fx.cloudManager.instance = this }, spawnClouds: function () { var a = this.maxNumberOfClouds - this.numberOfClouds; if (a > 0) for (var b = 0; b < a; b++)new geofs.fx.Cloud; else if (a < 0) for (; a < 0;)this.destroyLastCloud(), a++ }, triggerUpdate: function () { this.cloudSituation = null }, update: function (a, b) {
    if (geofs.fx.cloudManager.instance) {
      geofs.fx.cloudManager.instance.currentCenter =
        a; b = clamp((a[2] - (weather.definition.cloudBase - weather.definition.coverHalfThickness)) / weather.definition.cloudCoverThickness, weather.belowCloudsBrightness, 1); var c = a[2] < weather.definition.cloudBase ? 2 : a[2] < weather.definition.cloudBase + weather.definition.coverHalfThickness ? 6 : a[2] < weather.definition.cloudBase + weather.definition.cloudCoverThickness ? 12 : 8; a[2] < weather.definition.fogCeiling && (c += 1); this.cloudSituation != c && (geofs.fx.atmosphere.setVolumetricFog(weather.definition.fogBottom, weather.definition.fogCeiling,
          weather.definition.fog), c <= 7 ? (geofs.fx.atmosphere.setFogDensity(weather.definition.backgroundFogDensity), this.fullCover ? (geofs.fx.precipitation.show(), this.fullCover.entity.show(), geofs.disableShadows(), geofs.api.hideSun(), geofs.api.setImageryColorModifier("cloudcover", { saturation: clamp(b, .2, 1), brightness: clamp(b, .2, 1) }), geofs.api.setAtmosphereColorModifier("cloudcover", { saturationShift: -2, brightnessShift: b - .9, groundBrightnessShift: b - 1.2, groundSaturationShift: b - 1 })) : (geofs.enableShadows(), geofs.api.showSun(),
            geofs.api.removeImageryColorModifier("cloudcover"), geofs.api.removeAtmosphereColorModifier("cloudcover"))) : c & 8 && (geofs.fx.atmosphere.setFogDensity(0), this.fullCover && (this.fullCover.entity.show(), geofs.fx.atmosphere.setVolumetricFog(weather.definition.cloudBase, weather.definition.cloudBase + weather.definition.coverHalfThickness, 1)), geofs.fx.precipitation.hide(), geofs.enableShadows(), geofs.api.showSun(), geofs.api.removeImageryColorModifier("cloudcover"), geofs.api.removeAtmosphereColorModifier("cloudcover")));
      if (c & 4 && this.fullCover) { var d = 0; c < 8 && (d = weather.definition.backgroundFogDensity); a = clamp((weather.definition.coverHalfThickness - Math.abs(weather.definition.cloudBase - a[2])) * .1, d, 1); geofs.fx.atmosphere.setFogDensity(a); a > .5 ? this.fullCover.entity.hide() : this.fullCover.entity.show() } b != this.lastBrightness && (geofs.api.setAtmosphereColorModifier("clouds", {
        cloudsBrightness: b, groundBrightnessShift: geofs.animation.getRampRatio(this.groundBrightnessRamp, b), fogBrightness: geofs.animation.getRampRatio(this.fogBrightnessRamp,
          b)
      }), this.lastBrightness = b); this.cloudSituation = c
    }
  }, setCloudsBrightness: function (a) { geofs.fx.cloudManager.instance && this.setCloudColors(null, null, null, a) }, setCloudColors: function (a, b, c, d, e) {
    if (geofs.fx.cloudManager.instance) {
      a && b && c ? this.cloudColor = Cesium.Color.fromBytes(a, b, c) : e ? this.cloudColor = e : this.cloudColor || (this.cloudColor = Cesium.Color.fromBytes(255, 255, 255)); this.brightness = d || this.brightness || 1; e = this.cloudColor.darken(1 - this.brightness, new Cesium.Color); for (var f in geofs.fx.cloudManager.instance.clouds) geofs.fx.cloudManager.instance.clouds[f].setColor(e);
      this.fullCover && this.fullCover.setColor(e); geofs.fx.atmosphere.setFogColor(); geofs.fx.setParticlesColor(e)
    }
  }, setCloudCover: function (a) {
    geofs.fx.cloudManager.instance && (this.percentCoverage = a || 0, a *= .01, this.percentCoverage >= 100 ? this.fullCover || (this.fullCover = new geofs.fx.CloudCover([geofs.camera.lla[0], geofs.camera.lla[1], weather.definition.cloudBase])) : this.fullCover && (this.fullCover.destroy(), this.fullCover = null), geofs.api.setAtmosphereColorModifier("weatherHaze", {
      groundBrightnessShift: clamp(a *
        .5, 0, .1), fogBrightness: clamp(1 + a, 1, 1.2), brightnessShift: clamp(a * .5, 0, .1)
    }), this.setNumberOfClouds(this.percentCoverage * this.cloudCoverToCloudNumber), this.cloudSituation = null)
  }, setNumberOfClouds: function (a) { geofs.fx.cloudManager.instance && (this.maxNumberOfClouds = a, this.spawnClouds()) }, setCeiling: function (a) { this.fullCover && this.fullCover.update(); for (var b in this.clouds) this.clouds[b].setCeiling(a) }, destroyLastCloud: function () { geofs.fx.cloudManager.instance.currentID--; this.clouds[geofs.fx.cloudManager.instance.currentID].destroy() },
  destroyAllClouds: function () { if (geofs.fx.cloudManager.instance) { for (var a in this.clouds) this.clouds[a].destroy(); this.fullCover && (this.fullCover.destroy(), this.fullCover = null); geofs.fx.cloudManager.instance.currentID = 0 } }, destroy: function () { geofs.fx.cloudManager.instance && (this.destroyAllClouds(), geofs.fx.cloudManager.instance = null) }
};
geofs.fx.Cloud = function (a, b) { this._id = geofs.fx.cloudManager.instance.currentID++; this._type = Object.assign({}, this.defaultType, this.types[Math.floor(Math.random() * this.types.length)]); geofs.fx.cloudManager.instance.numberOfClouds++; geofs.fx.cloudManager.instance.clouds[this._id] = this; this.create(a) };
geofs.fx.Cloud.prototype = {
  shadowSize: .002, shadowTexture: "images/weather/clouds/shadow1.png", defaultType: { belowCeiling: 0, aboveCeiling: 1E3, opacity: .8, minRadius: 1, maxRadius: 1E5, rotationMultiplier: 0, brightnessDelta: 0 }, types: [{ billboard: "images/weather/clouds/1.png", belowCeiling: 500, aboveCeiling: 1E3, minScale: 6, maxScale: 10, maxRadius: 5E4, opacity: .9, shadow: !0 }, { billboard: "images/weather/clouds/6.png", belowCeiling: 500, aboveCeiling: 1E3, minScale: 10, maxScale: 15, maxRadius: 5E4, opacity: .9, shadow: !0 }, {
    billboard: "images/weather/clouds/1.png",
    belowCeiling: 500, aboveCeiling: 1500, maxRadius: 1E5, minScale: 10, maxScale: 15, opacity: .9, shadow: !0
  }, { billboard: "images/weather/clouds/5.png", belowCeiling: 500, aboveCeiling: 1E3, maxRadius: 1E5, minScale: 6, maxScale: 10, opacity: .9, shadow: !0 }, { billboard: "images/weather/clouds/cumuloniumbus.png", belowCeiling: 500, aboveCeiling: 100, maxRadius: 1E5, minScale: 6, maxScale: 10, opacity: .9, shadow: !0 }, {
    model: "models/clouds/flat1.gltf", belowCeiling: 2E3, aboveCeiling: 9E3, minScale: 4E4, maxScale: 45E3, maxRadius: 3E5, rotationMultiplier: 360,
    opacity: 1
  }, { model: "models/clouds/flat2.gltf", belowCeiling: 2E3, aboveCeiling: 9E3, minScale: 4E4, maxScale: 45E3, maxRadius: 3E5, rotationMultiplier: 360, opacity: 1 }], billboardOptions: { sizeInMeters: !0, collection: "default", geofsFixCameraRotation: !0 }, modelOptions: {}, create: function (a) {
    if (!a) {
      a = Math.random() * TWO_PI; var b = Math.sqrt(Math.random()) * (this._type.maxRadius - this._type.minRadius) + this._type.minRadius; a = V3.add(geofs.aircraft.instance.llaLocation, xy2ll([Math.cos(a) * b, Math.sin(a) * b], geofs.aircraft.instance.llaLocation));
      a[2] = Math.random() * (this._type.aboveCeiling - this._type.belowCeiling) + (weather.definition.cloudBase + this._type.belowCeiling)
    } this._location = a; this._type.billboard ? (b = Object.assign({}, this.billboardOptions), b.scale = clamp(Math.random() * (this._type.maxScale - this._type.minScale) + this._type.minScale, this._type.minScale, this._type.maxScale), b.translucencyByDistance = new Cesium.NearFarScalar(this._type.maxRadius / 2, this._type.opacity, this._type.maxRadius, .3), b.opacity = this._type.billboardOpacity, this._entity =
      new geofs.api.billboard(a, this._type.billboard, b)) : this._type.model && (b = Object.assign({}, this.modelOptions), b.scale = clamp(Math.random() * (this._type.maxScale - this._type.minScale) + this._type.minScale, this._type.minScale, this._type.maxScale), b.rotation = [Math.random() * this._type.rotationMultiplier, 0, 0], b.location = a, this._entity = new geofs.api.Model(this._type.model, b)); this.update()
  }, setCeiling: function (a) {
    a = a || weather.definition.cloudBase; this._entity.setLocation([this._entity._lla[0], this._entity._lla[1],
    Math.random() * (this._type.aboveCeiling - this._type.belowCeiling) + (a + this._type.belowCeiling)])
  }, setColor: function (a) { this._entity.setColor(a) }, move: function (a) { this._location = V3.add(this._location, a); this._entity.setLocation(this._location) }, setLocation: function (a) { this._location = a; this._entity.setLocation(a) }, update: function () {
    var a = this, b = ll2xy(V3.sub(this._location, geofs.aircraft.instance.llaLocation), geofs.aircraft.instance.llaLocation); b[2] = 0; if (V2.length(b) > this._type.maxRadius) if (geofs.fx.cloudManager.instance.numberOfClouds <=
      geofs.fx.cloudManager.instance.maxNumberOfClouds) b = V3.scale(V3.normalize(b), this._type.maxRadius * .9), b = V3.add(geofs.aircraft.instance.llaLocation, xyz2lla([-b[0], -b[1], b[2]], geofs.aircraft.instance.llaLocation)), b[2] = this._location[2], this.setLocation(b); else { this.destroy(); return } clearTimeout(this._updateTimeout); this._updateTimeout = setTimeout(function () { a.update() }, 2E4 + Math.random() * 2E4)
  }, destroy: function () {
    clearTimeout(this._updateTimeout); delete geofs.fx.cloudManager.instance.clouds[this._id];
    geofs.fx.cloudManager.instance.numberOfClouds--; this._entity && this._entity.destroy(); this._shadowPrimitive && (geofs.api.viewer.scene.groundPrimitives.remove(this._shadowPrimitive), this._shadowPrimitive.destroy()); this._shadowEntity && geofs.api.viewer.entities.remove(this._shadowEntity)
  }
}; geofs.fx.CloudCover = function (a) { this.create(a) };
geofs.fx.CloudCover.prototype = {
  texture: "models/clouds/cover.jpg", size: 1, options: { url: "models/clouds/cover.gltf", scale: 4E5 }, create: function (a) { if (!this.entity) { var b = Object.assign({}, this.options); b.location = a; this.entity = new geofs.api.Model(null, b); this.update() } }, setColor: function (a) { this.entity.setColor(a) }, setLocation: function (a) { this.entity.setLocation(a) }, update: function () {
    var a = this; this.setLocation([geofs.camera.lla[0], geofs.camera.lla[1], weather.definition.cloudBase]); clearTimeout(this._updateTimeout);
    this._updateTimeout = setTimeout(function () { a.update() }, 2E4)
  }, destroy: function () { clearTimeout(this._updateTimeout); this.entity && this.entity.destroy(); this.entity = null }
};
geofs.fx.precipitation = {
  types: { snow: { speed: .001, model: "models/precipitations/snow.gltf?k=1" }, rain: { speed: .1, model: "models/precipitations/rain.gltf?k=1" } }, visible: !0, init: function () { }, create: function (a, b) { a != geofs.fx.precipitation.type && (geofs.fx.precipitation.apiModel && geofs.fx.precipitation.destroy(), geofs.fx.precipitation.type = a, geofs.fx.precipitation.amount = b, geofs.fx.precipitation.apiModel = new geofs.api.Model(geofs.fx.precipitation.types[a].model), geofs.fx.precipitation.motionOffset = 0) }, update: function (a,
    b) {
    if (geofs.fx.precipitation.apiModel && (a[2] < weather.definition.cloudBase + weather.definition.coverHalfThickness ? this.show() : this.hide(), this.visible)) {
      !geofs.fx.precipitation._material && geofs.fx.precipitation.apiModel._model && geofs.fx.precipitation.apiModel._model.ready && (geofs.fx.precipitation._material = geofs.fx.precipitation.apiModel._model.getMaterial("rainMaterial")); if (geofs.camera.currentModeName == "chase" || geofs.camera.currentModeName == "free") {
        var c = weather.currentWindSpeedMs; a = weather.currentWindDirection +
          180; var d = 90
      } else c = geofs.aircraft.instance.trueAirSpeed, a = Math.atan2(geofs.aircraft.instance.airVelocityDirection[0], geofs.aircraft.instance.airVelocityDirection[1]) * RAD_TO_DEGREES, d = Math.acos(geofs.aircraft.instance.airVelocityDirection[2]) * RAD_TO_DEGREES; c < 2 && (a = 0); a = [a, c * 2, 0]; a[1] = clamp(a[1], 0, d); c = [2, 2, clamp(2 + c * .5, 2, 50)]; geofs.fx.precipitation.apiModel.setPositionOrientationAndScale(geofs.camera.lla, a, c); geofs.fx.precipitation._material && !geofs.pause && (geofs.fx.precipitation.motionOffset -= Math.min(.9,
        .01 + b * geofs.aircraft.instance.trueAirSpeed * geofs.fx.precipitation.types[geofs.fx.precipitation.type].speed), geofs.fx.precipitation.motionOffset < 0 && (geofs.fx.precipitation.motionOffset += 1), geofs.fx.precipitation._material.setValue("motion", geofs.fx.precipitation.motionOffset))
    }
  }, show: function () { !this.visible && geofs.fx.precipitation.apiModel && (geofs.fx.precipitation.apiModel.show(), this.visible = !0) }, hide: function () {
    this.visible && geofs.fx.precipitation.apiModel && (geofs.fx.precipitation.apiModel.hide(),
      this.visible = !1)
  }, destroy: function () { geofs.fx.precipitation.apiModel && (geofs.fx.precipitation.type = "none", geofs.fx.precipitation._material = null, geofs.fx.precipitation.apiModel.destroy(), geofs.fx.precipitation.apiModel = null) }
};
geofs.fx.water = {
  dayHorizonColors: [Cesium.Color.fromCssColorString("#c8976b"), Cesium.Color.fromCssColorString("#d0eef1"), Cesium.Color.fromCssColorString("#d0eef1"), Cesium.Color.fromCssColorString("#d0eef1"), Cesium.Color.fromCssColorString("#d0eef1"), Cesium.Color.fromCssColorString("#d0eef1"), Cesium.Color.fromCssColorString("#d0eef1")], nightHorizonColors: [Cesium.Color.fromCssColorString("#c8976b"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606"),
  Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606")], dayAzimutColors: [Cesium.Color.fromCssColorString("#001528"), Cesium.Color.fromCssColorString("#28537b"), Cesium.Color.fromCssColorString("#28537b"), Cesium.Color.fromCssColorString("#28537b"), Cesium.Color.fromCssColorString("#28537b"), Cesium.Color.fromCssColorString("#28537b"), Cesium.Color.fromCssColorString("#28537b")], nightAzimutColors: [Cesium.Color.fromCssColorString("#001528"),
  Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606"), Cesium.Color.fromCssColorString("#060606")], create: function () {
    if (geofs.api.googleTileset) {
      if (!geofs.fx.water.postProcessingStage) if (geofs.fx.water.postProcessingStage = new Cesium.PostProcessStage({
        fragmentShader: geofsShaders["postprocessedwater.glsl"], uniforms: {
          windSpeed: weather.currentWindSpeedMs ||
            0, geofsTime: 0, camTilt: 0, horizonColor: Cesium.Color.fromCssColorString("#f1f9fbff"), azimutColor: Cesium.Color.fromCssColorString("#38618aff"), normalMap: "/shaders/oceannormal2.jpg", foamTexture: "/shaders/seafoam.jpg"
        }
      }), geofs.fx.globeLoaded) geofs.api.viewer.scene.postProcessStages.add(geofs.fx.water.postProcessingStage); else $(document).on("globeLoaded", function () { geofs.api.viewer.scene.postProcessStages.add(geofs.fx.water.postProcessingStage) })
    } else geofs.api.waterMask = geofs.api.viewer.imageryLayers.addImageryProvider(new Cesium.UrlTemplateImageryProvider({
      url: geofs.landuseServer +
        "{z}/{x}/{y}.png", hasAlphaChannel: !1, enablePickFeatures: !1, maximumAnisotropy: 0, maximumLevel: 12
    })), geofs.api.waterMask.alpha = .01, geofs.api.waterMask.show = !0, geofs.fx.water.material = new Cesium.Material({
      fabric: {
        type: "MyWater", source: geofsShaders["oceanFS.glsl"], uniforms: {
          windSpeed: weather.currentWindSpeedMs || 0, geofsTime: 0, horizonColor: Cesium.Color.fromCssColorString("#f1f9fbff"), azimutColor: Cesium.Color.fromCssColorString("#38618aff"), normalMap: "/shaders/oceannormal2.jpg", foamTexture: "/shaders/seafoam.jpg",
          lightsTexture: "/shaders/noise/citylights.png"
        }
      }
    }), geofs.api.viewer.scene.globe.material = geofs.fx.water.material
  }, setConditions: function (a) { geofs.fx.water.material && (geofs.fx.water.material.uniforms.windSpeed = a, geofs.api.googleTileset && geofs.api.googleTileset.customShader.setUniform("u_windSpeed", a)) }, setColours: function (a, b) {
    geofs.fx.water.material && (geofs.fx.water.material.uniforms.horizonColor = a, geofs.fx.water.material.uniforms.azimutColor = b, geofs.api.googleTileset && (geofs.api.googleTileset.customShader.setUniform("u_horizonColor",
      a), geofs.api.googleTileset.customShader.setUniform("u_azimutColor", b)))
  }, update: function (a) { geofs.fx.water.postProcessingStage && (geofs.fx.water.postProcessingStage.uniforms.camTilt = Math.sin(geofs.camera.htr[1] * DEGREES_TO_RAD)); geofs.fx.water.material && (geofs.fx.water.timeRatio != weather.timeRatio && (geofs.fx.water.timeRatio = weather.timeRatio), geofs.fx.water.material.uniforms.geofsTime = geofs.fx.precisionTime, geofs.api.googleTileset && geofs.api.googleTileset.customShader.setUniform("u_geofsTime", geofs.fx.precisionTime)) },
  getWaveHeight: function (a, b, c) { c = (geofs.fx.precisionTime + (c || 0)) * .001; var d = weather.definition.windSpeedMS * .35; a = Cesium.Cartesian3.fromDegrees(b, a); a = Cesium.Cartesian3.normalize(a, a); a = V2.scale([(Math.sin((a.y / a.x * 2E4 + c) % TWO_PI) + 1) * .5, (Math.sin((a.z * 1E5 + c) % TWO_PI) + 1) * .5], d); return a[0] * a[1] }, destroy: function () {
    geofs.fx.water.postProcessingStage && (geofs.api.viewer.scene.postProcessStages.remove(geofs.fx.water.postProcessingStage), geofs.fx.water.postProcessingStage.isDestroyed() || geofs.fx.water.postProcessingStage.destroy(),
      geofs.fx.water.postProcessingStage = null); geofs.api.viewer.imageryLayers.remove(geofs.api.waterMask, !0); geofs.api.waterMask = null; geofs.fx.water.material = new Cesium.Material({ fabric: { type: "Null", source: "czm_material czm_getMaterial(czm_materialInput materialInput) {czm_material material; return material;}", uniforms: { windSpeed: 0, geofsTime: 0 } } }); geofs.api.viewer.scene.globe.material = geofs.fx.water.material
  }
};
geofs.fx.wake = {
  anchor: [0, 0, 0], altitude: .2, create: function () { geofs.fx.wake.emitter || (geofs.fx.wake.emitter = new geofs.fx.ParticleEmitter({ off: !0, anchor: geofs.fx.wake.anchor, location: geofs.fx.wake.anchor, duration: 1E10, rate: .001, life: 1E4, easing: "easeOutQuart", startOpacity: 1, endOpacity: .001, startScale: 1, endScale: 50, model: "models/wake/wake.gltf", rotationAxis: 0, maximumScale: 2E4 })) }, update: function () {
    geofs.aircraft.instance.waterContact && geofs.preferences.graphics.waterEffect ? (geofs.fx.wake.emitter._options.floatsOnWaves =
      geofs.waterIsSea ? !0 : !1, geofs.fx.wake.anchor[0] = geofs.aircraft.instance.llaLocation[0], geofs.fx.wake.anchor[1] = geofs.aircraft.instance.llaLocation[1], geofs.fx.wake.anchor[2] = geofs.groundElevation + geofs.waveHeight + geofs.fx.wake.altitude, geofs.fx.wake.emitter._options.startRotation = geofs.fx.wake.emitter._options.endRotation = geofs.aircraft.instance.htr[0], geofs.fx.wake.emitter._options.rate = clamp(geofs.aircraft.instance.velocityScalar * 2E-4, .001, .01), geofs.fx.wake.emitter._options.startScale = clamp(geofs.aircraft.instance.velocityScalar *
        .1, 1, 5), geofs.fx.wake.emitter._options.endScale = clamp(geofs.aircraft.instance.definition.mass * 1E-4, 50, 150), geofs.fx.wake.emitter.turnOn()) : geofs.fx.wake.emitter && geofs.fx.wake.emitter.turnOff()
  }, destroy: function () { geofs.fx.wake.emitter && geofs.fx.wake.emitter.turnOff() }
}; "use strict"; window.flight = window.flight || {}; flight.minPenetrationThreshold = .001; flight.arrestingHookDiscardVelocity = .1; flight.arrestingHookDiscardLength = 100; flight.currentAltitudeTestContext = {}; flight.pastAltitudeTestContext = {};
flight.tick = function (a, b, c) {
  var d = clamp(Math.floor(b / geofs.api.renderingSettings.physicsDeltaMs), 1, 10), e = a / d, f = 1 / a, g = geofs.aircraft.instance, k = geofs.animation.values; g.totalThrust = 0; var m = 1, n = 1, q = g.definition.zeroThrustAltitude, u = g.definition.zeroRPMAltitude; q ? m = clamp(q - k.altitude, 0, q) / q : u && (n = clamp(u - k.altitude, 0, u) / u); for (var z = geofs.aircraft.instance.engines, B = z.length, p = 0; p < B; p++) {
    var r = z[p], C = controls.throttle, A = 1, I = r.animations; if (I) for (var aa = 0; aa < I.length; aa++) {
      var X = I[aa]; switch (X.type) {
        case "throttle": C =
          geofs.animation.filter(X); break; case "pitch": A = geofs.animation.filter(X)
      }
    } if (g.engine.on) {
      var ea = (g.definition.maxRPM - g.definition.minRPM) * C + g.definition.minRPM; ea *= n; r.rpm += (ea - r.rpm) * g.definition.engineInertia * a; geofs.aircraft.instance.definition.reverse && (r.rpm < g.definition.minRPM && r.rpm > 0 && !g.engine.startup && (r.rpm = -g.definition.minRPM), r.rpm > -g.definition.minRPM && r.rpm < 0 && !g.engine.startup && (r.rpm = g.definition.minRPM)); r.contrailEmitter && (geofs.preferences.graphics.contrails && g.llaLocation[2] >
        weather.contrailAltitude ? r.contrailEmitter.turnOn() : r.contrailEmitter.turnOff())
    } else r.rpm = r.rpm < 1E-5 ? 0 : r.rpm - r.rpm * g.definition.engineInertia * a; var Ca = Math.abs(r.rpm), ma = r.thrust; r.afterBurnerThrust && C > .9 && (ma = r.afterBurnerThrust); r.rpm < 0 && (ma = r.reverseThrust ? -r.reverseThrust : 0); var fa = ma * clamp(Ca - g.definition.minRPM, 0, g.definition.maxRPM) * g.engine.invRPMRange; fa *= m; fa *= A; r.currentThrust = fa; g.totalThrust += fa
  } B > 0 && (g.engine.rpm = parseInt(Ca)); var J = 0; p = 0; for (var E = geofs.aircraft.instance.balloons.length; p <
    E; p++) { var F = geofs.aircraft.instance.balloons[p], eb = clamp(controls[F.controller.name] * F.controller.ratio || 0, 0, 1); J = F.temperature; J += eb * F.heatingSpeed * a; J -= F.coolingSpeed * (J - weather.atmosphere.airTempAtAltitude) * a; J = clamp(J, 0, 300); F.temperature = J; F.liftingForce = (weather.atmosphere.airDensityAtAltitude - weather.atmosphere.airPressureAtAltitude / (GAS_CONSTANT * (J + KELVIN_OFFSET))) * F.volume * GRAVITY; g.envelopeTemp = J } geofs.waterDepth = geofs.api.waterDetection.getWaterDepth(g.llaLocation[0], g.llaLocation[1]);
  if (geofs.waterDepth > 0) if (geofs.groundIsWater = !0, geofs.groundElevation < .1) { geofs.waterIsSea = !0; var fb = geofs.fx.water.getWaveHeight(g.llaLocation[0], g.llaLocation[1], -1), Da = geofs.fx.water.getWaveHeight(g.llaLocation[0], g.llaLocation[1], 0); geofs.waveVerticalSpeed = (fb - Da) / a; geofs.waveHeight = Da; geofs.debug.watch("waterDepth", geofs.waterDepth); geofs.debug.watch("waveHeight", geofs.waveHeight) } else geofs.waterIsSea = !1, geofs.waveHeight = 0; else geofs.groundIsWater = !1, geofs.waterIsSea = !1, geofs.waveHeight = 0; weather.atmosphere.update(g.llaLocation[2]);
  g.stalling = !1; for (var Ea = 0; Ea < d; Ea++) {
    g.velocity = g.rigidBody.v_linearVelocity; g.velocityDirection = V3.normalize(g.velocity); g.velocityScalar = V3.length(g.velocity); g.groundSpeed = V2.length([g.velocity[0], g.velocity[1]]); g.airVelocity = V3.sub(g.velocity, weather.currentWindVector); g.airVelocityDirection = V3.normalize(g.airVelocity); g.trueAirSpeed = V3.length(g.airVelocity); geofs.aircraft.instance.object3d.getWorldFrame(); p = 0; for (E = g.balloons.length; p < E; p++)F = g.balloons[p], g.rigidBody.applyForce([0, 0, F.liftingForce],
      F.points.forceSourcePoint.worldPosition); for (p = 0; p < g.engines.length; p++) { r = g.engines[p]; var gb = r.object3d.getWorldFrame()[r.forceDirection]; g.rigidBody.applyForce(V3.scale(gb, r.currentThrust), r.points.forceSourcePoint.worldPosition) } if (g.trueAirSpeed > .01) {
        var Fa = g.trueAirSpeed * g.trueAirSpeed, Y = V3.scale(g.airVelocityDirection, -(g.definition.dragCoefficient ? g.definition.dragCoefficient * .5 * weather.atmosphere.airDensityAtAltitude * Fa : g.definition.dragFactor * Fa * weather.atmosphere.airDensityAtAltitude));
        g.rigidBody.applyCentralForce(Y); p = 0; for (E = g.airfoils.length; p < E; p++) {
          var v = g.airfoils[p]; if (!v.disabled) {
            var ha = v.points.forceSourcePoint, hb = v.object3d.getWorldFrame(), G = g.rigidBody.getVelocityInLocalPoint(ha.worldPosition); if (v.propwash) { var Ga = g.engine.rpm * v.propwash, ib = V3.dot(G, g.object3d.worldRotation[1]); G = V3.add(G, V3.scale(g.object3d.worldRotation[1], clamp(Ga - ib, 0, Ga))) } G = V3.sub(G, weather.currentWindVector); G = V3.sub(G, weather.thermals.currentVector); var jb = Object3D.utilities.getPointLla(ha,
              g.llaLocation); G = V3.add(G, weather.getLocalTurbulence(jb)); v.velocity = V3.length(G); var na = V3.normalize(G), ia = v.velocity * v.velocity, oa = hb[v.forceDirection], S = -V3.dot(oa, na), kb = V3.cross(oa, na), lb = V3.rotate(oa, kb, S); if (v.span) {
                var pa = v.aspectRatio || v.span / v.chord, mb = v.area || v.span * v.chord, ja = S * TWO_PI * (pa / (pa + 2)), nb = ja * ja / (PI * pa * (v.efficiencyFactor || PLANFORM_EFFICIENCY_FACTOR)); if (v.stalls == 1) {
                  g.angleOfAttackDeg = S * RAD_TO_DEGREES; var O = Math.abs(g.angleOfAttackDeg); O > v.stallIncidence && (g.stalling = !0, ja *=
                    1 - clamp(O - v.stallIncidence, 0, v.zeroLiftIncidence * .9) / v.zeroLiftIncidence)
                } var Ha = .5 * weather.atmosphere.airDensityAtAltitude * ia * mb; Y = nb * Ha; var ba = ja * Ha
              } else if (v.area) {
                var ka = S * TWO_PI; v.stalls == 1 && (g.angleOfAttackDeg = S * RAD_TO_DEGREES, O = Math.abs(g.angleOfAttackDeg), O > v.stallIncidence && (g.stalling = !0, ka *= 1 - clamp(O - v.stallIncidence, 0, v.zeroLiftIncidence * .9) / v.zeroLiftIncidence)); Y = .5 * ia * (MIN_DRAG_COEF + DRAG_CONSTANT * ka * ka) * weather.atmosphere.airDensityAtAltitude; ba = weather.atmosphere.airDensityAtAltitude *
                  ia * .5 * v.area * ka
              } else { var Ia = v.liftFactor, ob = v.dragFactor; v.stalls == 1 && (g.angleOfAttackDeg = S * RAD_TO_DEGREES, O = Math.abs(g.angleOfAttackDeg), O > v.stallIncidence && (g.stalling = !0, Ia *= .9 - clamp(O - v.stallIncidence, 0, v.zeroLiftIncidence) / v.zeroLiftIncidence)); var Ja = S * ia; ba = Ia * Ja * weather.atmosphere.airDensityAtAltitude; Y = ob * Math.abs(Ja) * weather.atmosphere.airDensityAtAltitude } v.lift = ba; (k[v.name + "Lift"] = ba) && g.rigidBody.applyForce(V3.scale(lb, ba), ha.worldPosition); Y && g.rigidBody.applyForce(V3.scale(na, -Y),
                ha.worldPosition)
          }
        }
      } var qa = 0; g.groundContact = !1; g.waterContact = !1; g.rigidBody.applyForce(g.rigidBody.gravityForce, g.parts.root.points.centerOfMass.worldPosition); if (geofs.withinCollisionRange) {
        var Ka = geofs.aircraft.instance.collisionPoints, P = [], T = 0; p = 0; for (E = Ka.length; p < E; p++) {
          var y = Ka[p]; y.id = p; var t = y.part; y.groundContact = g.groundContact; t.contact = null; var U = V3.add(g.llaLocation, xyz2lla(y.worldPosition, g.llaLocation)); g.rigidBody.getVelocityInLocalPoint(y.worldPosition); var K = geofs.getCollisionResult(U,
            y.worldPosition, g.collResult, y), V = K.location[2], Q = t.object3d.getWorldFrame(), H = g.collResult.normal; if (geofs.waterDepth > 0 && t.buoyancy && !K.object) { var ra = Math.min(V + geofs.waveHeight - U[2], 10); if (ra > 0 && !y.wrongAltitude) { var La = Math.min(ra, 1); var x = { collisionPoint: y, normal: [0, 0, 1], depth: ra, submersionRatio: La, force: La * t.buoyancy, type: "buoyancy" }; t.contact = x; P.push(x) } V -= geofs.waterDepth } else if (t.suspension) {
              var sa = t.points.suspensionOrigin, ta = t.suspension.restLength - (sa.worldPosition[2] + g.llaLocation[2] -
                V), ua = clamp(ta / t.suspension.restLength, 0, 1), pb = ua * t.suspension.restLength; if (ua > 0 && sa.worldPosition[2] >= y.worldPosition[2] && !y.wrongAltitude) {
                  var qb = V3.dot(H, Q[2]); x = { collisionPoint: y, normal: H, force: t.suspension.stiffness * pb, type: "raycast", contactFwdDir: V3.cross(H, V3.normalize(Q[0])), contactSideDir: V3.cross(H, V3.normalize(Q[1])) }; if (ua >= t.suspension.hardPoint || qb < .4) x.type = "hardpoint", x.penetration = V - (y.worldPosition[2] + g.llaLocation[2]), T = Math.max(T, x.penetration); t.contact = x; P.push(x); sa[2] = -ta;
                  var ca = t.name + "Suspension"; k[ca] = ta; t.suspension.rest = !1
                } else t.suspension.rest || (ca = t.name + "Suspension", k[ca] = 0, t.points.suspensionOrigin[2] = 0, t.suspension.rest = !0); var Ma = {}; Ma[t.name] = t; g.placeParts(Ma)
            } else if (t.hook) {
              if (K.object && K.object.arrestingCable && !g.arrestingCableContact) { var W = V - U[2]; W >= -K.object.arrestingCableHeight && (g.arrestingCableContact = { collisionPoint: y, normal: H, type: "arrestingCable", object: K.object, contactFwdDir: V3.cross(H, V3.normalize(Q[0])), contactSideDir: V3.cross(H, V3.normalize(Q[1])) }) } if (g.arrestingCableContact) {
                var Na =
                  geofs.utils.llaDistanceInMeters(U, g.arrestingCableContact.object.location); g.velocityScalar < flight.arrestingHookDiscardVelocity || Na > flight.arrestingHookDiscardLength ? (g.arrestingCableContact.object.model.setPositionOrientationAndScale(g.arrestingCableContact.object.location, null, 1), g.arrestingCableContact = null) : (t.contact = g.arrestingCableContact, P.push(g.arrestingCableContact), g.arrestingCableContact.object.model.setPositionOrientationAndScale(U, null, [Na * 1.6, 1, 1]))
              }
            } else t.catapult ? (g.launchBarContact =
              null, g.onCatapult = !1, K.object && K.object.catapult && (W = V - U[2], W > -.1 && (g.onCatapult = !0, controls.throttle > .5 && (g.launchBarContact = { collisionPoint: y, normal: H, type: "launchBar", object: K.object, contactFwdDir: V3.normalize(Q[1]), contactSideDir: null }, P.push(g.launchBarContact))))) : (W = V - U[2], W >= 0 && !y.wrongAltitude && (T = Math.max(T, W), x = { collisionPoint: y, normal: H, penetration: W, type: "standard", contactFwdDir: V3.cross(H, V3.normalize(Q[0])), contactSideDir: V3.cross(H, V3.normalize(Q[1])) }, t.contact = x, P.push(x)))
        } if (P.length &&
          (g.groundContact = !0, !flight.skipCollisionResponse)) {
          T > flight.minPenetrationThreshold && !geofs.cautiousWithTerrain && (g.llaLocation[2] += T, T = 0); var va = 0; for (E = P.length; va < E; va++) {
            x = P[va]; y = x.collisionPoint; t = y.part; var R = y.contactProperties, M = g.rigidBody.getVelocityInLocalPoint(y.worldPosition); M = V3.add(M, [0, 0, geofs.waveVerticalSpeed]); var Z = V3.dot(x.normal, M); qa = Math.max(qa, Math.abs(Z)); var da = 0; if (x.type == "buoyancy") {
              var rb = clamp(x.force * .1 * Z, 0, x.force); g.rigidBody.applyForce(V3.scale(x.normal, x.force -
                rb), y.worldPosition); var Oa = V3.normalize(M), Pa = V3.length(M), Qa = Pa * Pa * .5; if (t.type == "float") { var Ra = t.object3d.getWorldFrame()[t.forceDirection], sb = -V3.dot(Ra, Oa) * TWO_PI; g.rigidBody.applyForce(V3.scale(Ra, WATER_DENSITY * Qa * t.area * sb * .01), y.worldPosition) } var tb = Qa * WATER_DENSITY * x.submersionRatio; geofs.aircraft.instance.object3d.setVectorWorldPosition(t.dragVector); var ub = V3.mult(Oa, V3.abs(t.dragVector.worldPosition)), vb = V3.scale(ub, -tb); g.rigidBody.applyForce(vb, y.worldPosition); g.waterContact = !0
            } if (x.type ==
              "raycast" || x.type == "hardpoint") da = (x.force - t.suspension.damping * Z) * g.rigidBody.mass * e, da > 0 && g.rigidBody.applyImpulse(V3.scale(x.normal, da), y.worldPosition); x.type == "arrestingCable" && (g.arrestingCableContact.force = V3.scale(M, -t.hook.strength), g.rigidBody.applyForce(g.arrestingCableContact.force, y.worldPosition)); x.type == "launchBar" && (g.launchBarContact.force = V3.scale(geofs.aircraft.instance.object3d.getWorldFrame()[1], t.catapult.strength), g.launchBarContact.force[2] = 0, controls.steering = 0, controls.yaw =
                0, g.rigidBody.applyForce(g.launchBarContact.force, [0, 0, 0]), geofs.debug.watch("catapult", g.launchBarContact.force)); if ((x.type == "standard" || x.type == "hardpoint") && Z < 0) { var Sa = g.rigidBody.computeJacobian(0, Z, y.worldPosition, x.normal), wb = V3.scale(x.normal, Sa); g.rigidBody.applyImpulse(wb, y.worldPosition); da = Sa } var N = da * R.frictionCoef; N = clamp(N, N, g.rigidBody.mass * 2 * e * R.frictionCoef); if (x.type != "buoyancy") if (t.type == "wheel") {
                  var wa = x.contactFwdDir, xa = x.contactSideDir, Ta = V3.dot(xa, M), ya = V3.dot(wa, M); x.forwardProjVel =
                    ya; x.sideProjVel = Ta; var Ua = g.rigidBody.computeJacobian(0, Ta, y.worldPosition, xa), Va = g.rigidBody.computeJacobian(0, ya, y.worldPosition, wa), za = Math.abs(Ua), Aa = Math.abs(Va), Wa = 1, la = 1; Math.abs(ya) > R.lockSpeed ? la = R.rollingFriction : (x.forwardProjVel = 0, x.sideProjVel = 0); var Xa = t.brakesController; if (Xa && Aa > 0) { var xb = clamp(k[Xa] * t.brakesControllerRatio, 0, 1); la = clamp(N / (Aa * R.frictionCoef), 0, 1) * xb } var yb = g.definition.brakeDamping || 3; controls.brakes > .05 && (la = clamp(N / (Aa * R.frictionCoef * yb) * controls.brakes, 0, 1));
                  za > N && (Wa = clamp(N / (za * za), R.dynamicFriction, 1)); g.rigidBody.applyImpulse(V3.scale(xa, Ua * Wa), y.worldPosition); g.rigidBody.applyImpulse(V3.scale(wa, Va * la), y.worldPosition)
                } else { var Ya = V3.sub(M, V3.scale(x.normal, Z)), Za = V3.normalize(Ya), $a = V3.length(Ya); if ($a) { var ab = g.rigidBody.computeJacobian(0, $a, y.worldPosition, Za), Ba = Math.abs(ab), bb = 1; Ba > N && (bb = clamp(N / (Ba * Ba), R.dynamicFriction, 1)); g.rigidBody.applyImpulse(V3.scale(Za, bb * ab), y.worldPosition) } }
          }
        }
      } else for (p = 0, E = geofs.aircraft.instance.suspensions.length; p <
        E; p++)t = geofs.aircraft.instance.suspensions[p], t.suspension && !t.suspension.rest && (ca = t.name + "Suspension", k[ca] = 0, t.points.suspensionOrigin[2] = 0, t.suspension.rest = !0); flight.recorder.playing || flight.sharing.on || (g.rigidBody.integrateVelocities(e), g.rigidBody.integrateTransform(e), geofs.aircraft.instance.object3d.compute(g.llaLocation), geofs.aircraft.instance.htr = geofs.aircraft.instance.object3d.htr, flight.setAnimationValues(e, c), geofs.autopilot.update(e), flight.recorder.record())
  } flight.recorder.playing ==
    1 ? (flight.recorder.play(b), flight.setAnimationValues(a, c)) : flight.sharing.on ? (flight.sharing.update(b), flight.setAnimationValues(a, c)) : (g.rigidBody.setCurrentAcceleration(f, a), g.placeParts()); g.render(); geofs.preferences.crashDetection && qa > 10 && !g.crashed && (g.crashNotified = !0, ui.showCrashNotification(), g.crash()); g.htrAngularSpeed = V3.sub(g.object3d.htr, g.htr); g.htrAngularSpeed = fixAngles(g.htrAngularSpeed); g.htrAngularSpeed = V3.scale(g.htrAngularSpeed, 1 / b); g.htr = g.object3d.htr; p = g.maxAngularVRatio = 0;
  for (E = g.wheels.length; p < E; p++) {
    var D = g.wheels[p]; D.oldAngularVelocity = D.angularVelocity; if (D.contact) {
      D.angularVelocity = D.contact.forwardProjVel * a / D.arcDegree; var cb = D.angularVelocity / D.oldAngularVelocity; D.contact.forwardProjVel > 30 && cb > 40 && new geofs.fx.ParticleEmitter({ anchor: D.contact.collisionPoint, duration: 200, rate: .05, life: 2E3, startScale: .001, endScale: .05, startOpacity: .3, endOpacity: .001, startRotation: "random", endRotation: "random", texture: "smoke" }); g.maxAngularVRatio = Math.max(g.maxAngularVRatio,
        cb)
    } else D.angularVelocity > .01 && (D.angularVelocity *= .9); var db = D.name + "Rotation"; k[db] = fixAngle360((k[db] || 0) + D.angularVelocity)
  }
};
flight.setAnimationValues = function (a, b) {
  var c = geofs.aircraft.instance, d = geofs.animation.values, e = c.llaLocation[2] * METERS_TO_FEET, f = (e - c.oldAltitude * METERS_TO_FEET) * 60 / a || 0; c.oldAltitude = c.llaLocation[2]; var g = fixAngle(weather.currentWindDirection - c.htr[0]), k = c.engine.rpm * c.definition.RPM2PropAS * a; d.acceleration = M33.transform(M33.transpose(c.object3d._rotation), c.rigidBody.v_acceleration); d.accX = d.acceleration[0]; d.accY = d.acceleration[1]; d.accZ = d.acceleration[2]; d.loadFactor = d.acceleration[2] / GRAVITY;
  d.slipball = exponentialSmoothing("slipball", d.acceleration[0], .02); d.ktas = c.trueAirSpeed * MS_TO_KNOTS; d.kiasChangeRate = (d.kias - d.ktas) * a; d.kias = d.ktas; d.kiasUnits = d.ktas % 10; d.kiasTens = d.ktas % 100; d.kiasHundreds = d.ktas % 1E3; d.kiasThousands = d.ktas % 1E4; d.groundSpeed = c.groundSpeed; d.groundSpeedKnt = c.groundSpeed * MS_TO_KNOTS; d.altitudeMeters = c.llaLocation[2]; d.altitude = e; d.haglMeters = geofs.relativeAltitude; d.haglFeet = geofs.relativeAltitude * METERS_TO_FEET; d.groundElevationFeet = geofs.groundElevation * METERS_TO_FEET;
  d.verticalSpeed = f; d.climbrate = f; d.aoa = c.angleOfAttackDeg; d.turnrate = fixAngle(c.htr[0] - d.heading) * 60 / a; d.heading = c.htr[0]; d.heading360 = fixAngle360(c.htr[0]); d.atilt = c.htr[1]; d.aroll = c.htr[2]; d.enginesOn = c.engine.on; d.engineVibration = c.engine.rpm > 100 ? Math.random() * clamp(1E3 / c.engine.rpm, 0, 1) : 0; d.prop = fixAngle360(d.prop + k); d.thrust = c.totalThrust; d.rpm = c.engine.rpm; d.throttle = controls.throttle; d.mixture = controls.mixture; d.carbHeat = controls.carbHeat; d.smoothThrottle = exponentialSmoothing("throttle", d.throttle,
    .02); d.pitch = controls.pitch; d.rawPitch = controls.rawPitch; d.roll = controls.roll; d.yaw = controls.yaw; d.rawYaw = controls.rawYaw; d.steering = controls.steering; d.trim = controls.elevatorTrim; d.brakes = controls.brakes; d.gearPosition = controls.gear.position; d.invGearPosition = 1 - controls.gear.position; d.gearTarget = controls.gear.target; d.flapsValue = controls.flaps.position / controls.flaps.maxPosition; d.accessoriesPosition = controls.accessories.position; d.accessoriesTarget = controls.accessories.target; d.flapsPosition = controls.flaps.position;
  d.flapsTarget = controls.flaps.target; d.flapsPositionRatio = controls.flaps.positionRatio; d.flapsPositionTarget = controls.flaps.positionTarget; d.flapsSteps = geofs.aircraft.instance.definition.flapsSteps; d.airbrakesPosition = controls.airbrakes.position; d.optionalAnimatedPartPosition = controls.optionalAnimatedPart.position; d.optionalAnimatedPartTarget = controls.optionalAnimatedPart.target; d.airbrakesTarget = controls.airbrakes.target; d.parkingBrake = c.brakesOn; d.groundContact = c.groundContact ? 1 : 0; d.arrestingHookTension =
    c.arrestingCableContact ? V3.length(c.arrestingCableContact.force) : 0; d.onCatapult = c.onCatapult; d.catapult = !!c.launchBarContact; d.stalling = !geofs.aircraft.instance.groundContact && c.stalling; d.airTemp = weather.atmosphere.airTempAtAltitude; d.mach = geofs.utils.msToMach(c.trueAirSpeed); d.machUnits = Math.floor(d.mach); d.machTenth = Math.floor((d.mach % 1).toPrecision(2) * 10); d.machHundredth = Math.floor((d.mach % .1).toPrecision(2) * 100); d.altTenThousands = e % 1E5; d.altThousands = e % 1E4; d.altHundreds = e % 1E3; d.altTens = e % 100;
  d.altTensShift = Math.floor(e % 1E5 / 1E4); d.altUnits = e % 10; d.relativeWind = g; d.windSpeed = weather.currentWindSpeed; d.windSpeedLabel = parseInt(weather.currentWindSpeed) + " kts"; d.view = geofs.camera.currentView; d.insideView = geofs.camera.currentDefinition.insideView; d.cameraDotAircraftForward = geofs.camera.dotAircraftForward; d.envelopeTemp = c.envelopeTemp; d.maxAngularVRatio = c.maxAngularVRatio; d.rollingSpeed = c.groundContact ? c.velocityScalar : 0; geofs.camera.currentModeName == "free" || geofs.camera.currentModeName == "chase" ?
    (c = geofs.utils.llaDistanceInMeters3D(geofs.camera.lla, c.llaLocation), d.cameraAircraftSpeed = (d.cameraAircraftDistance - c) / a, d.cameraAircraftDistance = c) : (d.cameraAircraftSpeed = 0, d.cameraAircraftDistance = 0); d.geofsTime = b
}; $(".geofs-recordPlayer-slider").on("userchange", function (a, b) { flight.recorder.setStep(parseInt(b), "slide") }).on("dragstart", function () { geofs.api.nativeMouseHandling = !0 }).on("dragend", function () { geofs.api.nativeMouseHandling = !1 });
flight.recorder = {
  tape: [], rate: 4, maxLength: 1E3, playing: !1, currentStep: 0, lastRecordTime: 0, pathDrawDistanceThreshold: 500, mapPath: [], pathColors: [Cesium.Color.fromCssColorString("#e6e435ff"), Cesium.Color.fromCssColorString("#74e635ff"), Cesium.Color.fromCssColorString("#29d1d3ff"), Cesium.Color.fromCssColorString("#d32929ff"), Cesium.Color.fromCssColorString("#ae35e6ff")], init: function () { this.period = 1E3 / this.rate; this.setRecorderDuration() }, record: function () {
    var a = geofs.utils.now(); if (!(a - flight.recorder.lastRecordTime <
      flight.recorder.period)) { flight.recorder.lastRecordTime = a; var b = geofs.aircraft.instance.llaLocation, c = geofs.aircraft.instance.htr, d = 0; this.lastDrawnLla ? d = geofs.utils.distanceBetweenLocations(this.lastDrawnLla, b) : this.lastDrawnLla = b; d > this.pathDrawDistanceThreshold && (this.drawPath(this.lastDrawnLla, b), this.lastDrawnLla = b); a = flight.recorder.makeRecord(a, b, c); flight.recorder.tape.push(a); flight.recorder.tape.length > flight.recorder.maxLength && flight.recorder.tape.shift() }
  }, makeRecord: function (a, b, c) {
    b =
      b || geofs.aircraft.instance.llaLocation; c = c || geofs.aircraft.instance.htr; return {
        ti: a || geofs.utils.now(), co: [Number(b[0].toFixed(8)), Number(b[1].toFixed(8)), Number(b[2].toFixed(3)), Number(c[0].toFixed(2)), Number(c[1].toFixed(2)), Number(c[2].toFixed(2))], ct: [Number(controls.rawPitch.toFixed(2)), Number(controls.roll.toFixed(2)), Number(controls.yaw.toFixed(2)), Number(controls.throttle.toFixed(2)), controls.gear.position, controls.flaps.position, controls.airbrakes.position, controls.brakes, controls.elevatorTrim],
        ctb: [controls.accessories.position, controls.optionalAnimatedPart.position], st: [geofs.utils.booleanToBinary(geofs.aircraft.instance.groundContact), geofs.utils.booleanToBinary(geofs.aircraft.instance.engine.on), controls.flaps.target, controls.accessories.target, controls.optionalAnimatedPart.target, geofs.aircraft.instance.engine.rpm], ve: geofs.utils.arrayToFixed(geofs.aircraft.instance.rigidBody.getLinearVelocity().concat(geofs.aircraft.instance.rigidBody.getAngularVelocity()), 8), acc: geofs.utils.arrayToFixed(geofs.aircraft.instance.rigidBody.getLinearAcceleration().concat(geofs.aircraft.instance.rigidBody.getAngularAcceleration()),
          8)
      }
  }, setRecorderDuration: function () { flight.recorder.maxLength = parseInt(geofs.preferences.recorderLength * 60 * this.rate) || this.defaultMaxLength; this.setTapeLength(flight.recorder.maxLength) }, setTapeLength: function (a) {
    flight.recorder.maxLength = a || flight.recorder.maxLength; flight.recorder.tape.length > flight.recorder.maxLength && (flight.recorder.tape = flight.recorder.tape.splice(-flight.recorder.maxLength)); flight.recorder.playing && (flight.recorder.setStep(flight.recorder.currentStep, "set"), $(".geofs-recordPlayer-slider").attr("data-max",
      flight.recorder.tape.length - 2))
  }, clear: function () { this.lastDrawnLla = null; this.clearPath(); flight.recorder.tape = [] }, clearPath: function () { geofs.api.map.clearPath(flight.recorder.mapPath) }, setPathDrawState: function () { geofs.savePreferences(); this.clearPath() }, enterPlayback: function () { $(".geofs-recordPlayer-slider").attr("data-max", flight.recorder.tape.length - 2); $("body").addClass("geofs-record-playing"); flight.recorder.currentStep = 0; flight.recorder.startPlayback() }, exitPlayback: function () {
    geofs.doPause();
    flight.recorder.playing = !1; geofs.aircraft.instance.rigidBody.clearForces(); flight.recorder.setStep(flight.recorder.currentStep, "set"); flight.recorder.tape.splice(flight.recorder.currentStep); geofs.aircraft.instance.object3d.resetRotationMatrix(); $("body").removeClass("geofs-record-playing")
  }, pausePlayback: function () { flight.recorder.paused = !0 }, unpausePlayback: function () { flight.recorder.startPlayback() }, startPlayback: function () {
    flight.recorder.playing = !0; flight.recorder.paused = !1; flight.recorder.setStep(flight.recorder.currentStep,
      "set"); geofs.undoPause(2)
  }, setStep: function (a, b) {
    a > flight.recorder.tape.length - 2 && (a = flight.recorder.tape.length - 2, flight.recorder.pausePlayback(), geofs.doPause()); a < 0 && (a = 0); if (!flight.recorder.tape[a]) return geofs.doPause(), !1; flight.recorder.currentStep = a; b == "slide" || b == "set" ? (flight.recorder.liveRecord = Object.assign({}, flight.recorder.tape[a]), flight.interpolator.setAircraft(flight.recorder.liveRecord), geofs.map.updatePlaneMarker(geofs.aircraft.instance.llaLocation[0], geofs.aircraft.instance.llaLocation[1],
      geofs.aircraft.instance.htr[0]), geofs.aircraft.instance.render()) : flight.recorder.liveRecord.st = flight.recorder.tape[a - 1].st; b && b != "set" || $(".geofs-recordPlayer-slider").slider("value", a); b = clamp(flight.recorder.tape[a + 1].ti - flight.recorder.liveRecord.ti, 1, 1E3); flight.recorder.deltaRecord = flight.interpolator.computeDeltaRecord(flight.recorder.liveRecord, flight.recorder.tape[a + 1], b); return !0
  }, play: function (a) {
    if (!flight.recorder.paused) {
      flight.interpolator.increment(flight.recorder.liveRecord, flight.recorder.deltaRecord,
        a); for (a = flight.recorder.currentStep; flight.recorder.tape[a + 1] && flight.recorder.tape[a + 1].ti - flight.recorder.liveRecord.ti < flight.recorder.period;)a++; a > flight.recorder.currentStep ? flight.recorder.setStep(a) : flight.recorder.tape[a + 1].ti - flight.recorder.liveRecord.ti > 1E3 && flight.recorder.setStep(a + 1, "set")
    }
  }, drawPath: function (a, b) {
    if (geofs.preferences.interface.drawFlightPath) {
      var c = { weight: 4, color: geofs.api.color.mixArray(flight.recorder.pathColors, clamp(b[2] / 15E3, 0, 1)).toCssHexString() }; geofs.api.map.createPath(flight.recorder.mapPath,
        [a, b], c)
    }
  }, import: function (a) {
    var b = this, c, d, e; return (0, $jscomp.asyncExecutePromiseGeneratorProgram)(function (f) {
      if (f.nextAddress == 1) return b.clear(), (c = JSON.parse(a)) && c.tape ? f.yield(geofs.aircraft.instance.loadWithLivery(c.aircraft, null, c.aircraft.livery), 2) : f.return(); flight.recorder.tape = c.tape; flight.recorder.tape.length > 1 && flight.recorder.tape.forEach(function (g) { g = [g.co[0], g.co[1], g.co[2]]; d ? e = geofs.utils.distanceBetweenLocations(d, g) : d = g; e > b.pathDrawDistanceThreshold && (b.drawPath(d, g), d = g) });
      c.tape.length > flight.recorder.maxLength && b.setTapeLength(c.tape.length); $(".geofs-recordPlayer-slider").attr("data-max", flight.recorder.tape.length - 2); b.startPlayback(); f.jumpToEnd()
    })
  }, export: function () { return JSON.stringify({ aircraft: geofs.aircraft.instance.aircraftRecord.id, livery: geofs.aircraft.instance.liveryId, tape: flight.recorder.tape }) }, upload: function (a) {
    var b = a.files[0], c = new FileReader; c.onload = function (d) { flight.recorder.import(d.target.result) }; c.onerror = function (d) { geofs.debug.log(d) };
    c.readAsText(b); $(a).val("")
  }, download: function (a) { if (!(flight.recorder.tape.length < 1)) { var b = new Blob([flight.recorder.export()], { type: "text/plain" }); window.URL.createObjectURL(b); a.download = "GeoFS-flight.json"; a.href = window.URL.createObjectURL(b) } }
};
flight.sharing = {
  targetDT: geofs.MPSMinUpdateDelay || 500, start: function (a) { flight.sharing.reset(a); flight.sharing.on = !0 }, stop: function () { flight.sharing.reset(); flight.sharing.on = !1 }, reset: function (a) { flight.sharing.lastRecord = a; flight.sharing.liveRecord = null; flight.sharing.deltaRecord = null; geofs.aircraft.instance.rigidBody.clearForces() }, peerUpdate: function (a, b) {
    if (flight.sharing.lastRecord) if (flight.sharing.liveRecord) {
      b = Date.now(); flight.sharing.now = flight.sharing.now || b; flight.sharing.now = b; b = a.ti -
        flight.sharing.liveRecord.ti; var c = exponentialSmoothing("sharingAveragedDT", a.ti - flight.sharing.lastRecord.ti, null, .01), d = (b - c) * .5; b = Math.max(c, b); b == 0 ? geofs.debug.log("liveToUpdateDT == 0") : (flight.sharing.lastRecord = Object.assign({}, a), flight.sharing.deltaRecord = flight.interpolator.computeDeltaRecord(flight.sharing.liveRecord, flight.sharing.lastRecord, Math.abs(b), d), flight.sharing.liveRecord.st = flight.sharing.lastRecord.st)
    } else flight.sharing.liveRecord = Object.assign({}, a), exponentialSmoothing("sharingAveragedDT",
      flight.sharing.targetDT, 0, 1); else flight.sharing.lastRecord = Object.assign({}, a)
  }, update: function (a) { flight.sharing.liveRecord && flight.sharing.deltaRecord && flight.interpolator.increment(flight.sharing.liveRecord, flight.sharing.deltaRecord, a) }
};
flight.interpolator = {
  computeDeltaRecord: function (a, b, c, d) { d = d || 0; c = 1 / c; var e = M3.sub(b.co, a.co); e[3] = fixAngle(e[3]); e[4] = fixAngle(e[4]); e[5] = fixAngle(e[5]); var f = M3.sub(b.ct, a.ct), g = M3.sub(b.ctb, a.ctb), k = M3.sub(b.ve, a.ve); a = M3.sub(b.acc, a.acc); e = M3.scale(e, c); f = M3.scale(f, c); g = M3.scale(g, c); k = M3.scale(k, c); a = M3.scale(a, c); return { co: e, ct: f, ctb: g, ve: k, acc: a, timeError: d * c } }, increment: function (a, b, c) {
    a.ti += c + b.timeError * c; a.co = M3.add(a.co, M3.scale(b.co, c)); a.co[3] = fixAngle(a.co[3]); a.co[4] = fixAngle(a.co[4]);
    a.co[5] = fixAngle(a.co[5]); a.ct = M3.add(a.ct, M3.scale(b.ct, c)); a.ctb = M3.add(a.ctb, M3.scale(b.ctb, c)); a.ve = M3.add(a.ve, M3.scale(b.ve, c)); a.acc = M3.add(a.acc, M3.scale(b.acc, c)); flight.interpolator.setAircraft(a)
  }, setAircraft: function (a) {
    var b = a.co, c = [b[0], b[1], b[2]]; b = [b[3], b[4], b[5]]; var d = a.ct, e = a.ctb; controls.rawPitch = d[0]; controls.pitch = d[0] + d[8]; controls.roll = d[1]; controls.yaw = d[2]; controls.throttle = d[3]; controls.elevatorTrim = d[8]; controls.gear.position = snapToUnit(d[4]); controls.flaps.position = d[5];
    controls.airbrakes.position = snapToUnit(d[6]); controls.brakes = snapToUnit(d[7]); controls.accessories.position = e[0]; controls.optionalAnimatedPart.position = e[1]; d = a.st; geofs.aircraft.instance.groundContact = d[0]; geofs.aircraft.instance.engine.on = d[1]; controls.flaps.target = d[2]; controls.setPartAnimationDelta(controls.flaps); controls.accessories.target = d[3]; controls.setPartAnimationDelta(controls.accessories); controls.optionalAnimatedPart.target = d[4]; controls.setPartAnimationDelta(controls.optionalAnimatedPart);
    d = [a.ve[3], a.ve[4], a.ve[5]]; geofs.aircraft.instance.rigidBody.setLinearVelocity([a.ve[0], a.ve[1], a.ve[2]]); geofs.aircraft.instance.rigidBody.setAngularVelocity(d); d = [a.acc[3], a.acc[4], a.acc[5]]; geofs.aircraft.instance.rigidBody.setLinearAcceleration([a.acc[0], a.acc[1], a.acc[2]]); geofs.aircraft.instance.rigidBody.setAngularAcceleration(d); geofs.aircraft.instance.object3d.compute(c); geofs.aircraft.instance.place(c, b)
  }
};
flight.terrainElevationManagement = function () {
  var a = geofs.aircraft.instance, b = [a.llaLocation[0], a.llaLocation[1], a.llaLocation[2]]; flight.currentAltitudeTestContext.groundContact = a.groundContact; a.collResult = geofs.getCollisionResult(b, null, null, flight.currentAltitudeTestContext); b = a.collResult.location[2]; geofs.groundElevation = b; geofs.relativeAltitude = a.llaLocation[2] - geofs.groundElevation; geofs.withinCollisionRange = !1; geofs.relativeAltitude < geofs.aircraft.instance.boundingSphereRadius + geofs.aircraft.instance.velocityScalar ?
    (geofs.withinCollisionRange = !0, a.collResult.normal = geofs.getNormalFromCollision(a.collResult, flight.currentAltitudeTestContext)) : a.collResult.normal = [0, 0, 1]; if (!flight.recorder.playing) {
      if (geofs.cautiousWithTerrain) {
        var c = geofs.getGroundAltitude(a.lastLlaLocation, flight.pastAltitudeTestContext).location[2], d = c - flight.elevationAtPreviousLocation; flight.skipCollisionResponse = !1; Math.abs(d) > .2 && (!a.absoluteStartAltitude && (geofs.cautiousWithTerrain || c > a.llaLocation[2]) && (a.llaLocation[2] += d), a.groundContact &&
          (a.llaLocation[2] = b + a.definition.startAltitude, flight.skipCollisionResponse = !0), geofs.probeTerrain())
      } flight.elevationAtPreviousLocation = b; a.lastLlaLocation = a.llaLocation
    }
}; flight.reset = function (a) { flight.currentAltitudeTestContext = { lastGroundAltitude: a }; flight.pastAltitudeTestContext = { lastGroundAltitude: a }; flight.recorder.clear() }; "use strict"; var physics = window.physics || {};
function rigidBody() { this.s_inverseMass = this.mass = 0; this.reset(); this.minLinearVelocity = .1; this.minAngularVelocity = .01; this.impulseQueue = [] } rigidBody.prototype.reset = function () { this.v_linearVelocity = [0, 0, EPSILON]; this.v_angularVelocity = [0, 0, EPSILON]; this.v_totalForce = [0, 0, EPSILON]; this.v_totalTorque = [0, 0, EPSILON]; this.v_prevLinearVelocity = [0, 0, EPSILON]; this.v_prevAngularVelocity = [0, 0, EPSILON]; this.v_acceleration = [0, 0, EPSILON]; this.v_angularAcceleration = [0, 0, EPSILON] };
rigidBody.prototype.setMassProps = function (a, b) { b = b || .1; $.isArray(b) || (b = [b, b, b]); this.mass = a; this.s_inverseMass = 1 / a; this.v_localInvInertia = [b[0] / a, b[1] / a, b[2] / a]; this.m_localInvInertiaTensor = [[this.v_localInvInertia[0], 0, 0], [0, this.v_localInvInertia[1], 0], [0, 0, this.v_localInvInertia[2]]]; this.m_worldInvInertiaTensor = M33.dup(this.m_localInvInertiaTensor); this.gravityForce = [0, 0, -GRAVITY * a] }; rigidBody.prototype.getLinearVelocity = function () { return this.v_linearVelocity };
rigidBody.prototype.getAngularVelocity = function () { return this.v_angularVelocity }; rigidBody.prototype.getLinearAcceleration = function () { return this.v_acceleration }; rigidBody.prototype.getAngularAcceleration = function () { return this.v_angularAcceleration }; rigidBody.prototype.setLinearVelocity = function (a) { this.v_linearVelocity = a }; rigidBody.prototype.setAngularVelocity = function (a) { this.v_angularVelocity = a }; rigidBody.prototype.setLinearAcceleration = function (a) { this.v_acceleration = a };
rigidBody.prototype.setAngularAcceleration = function (a) { this.v_angularAcceleration = a }; rigidBody.prototype.getVelocityInLocalPoint = function (a) { return V3.add(this.v_linearVelocity, V3.cross(a, this.v_angularVelocity)) }; rigidBody.prototype.getForceInLocalPoint = function (a) { var b = V3.add(this.v_totalForce, V3.cross(a, this.v_totalTorque)); return V3.add(b, V3.scale(this.getVelocityInLocalPoint(a), this.mass)) }; rigidBody.prototype.applyCentralForce = function (a) { this.v_totalForce = V3.add(this.v_totalForce, a) };
rigidBody.prototype.applyTorque = function (a) { this.v_totalTorque = V3.add(this.v_totalTorque, a) }; rigidBody.prototype.applyForce = function (a, b) { this.applyCentralForce(a); this.applyTorque(V3.cross(a, b)) }; rigidBody.prototype.applyCentralImpulse = function (a) { this.v_linearVelocity = V3.add(this.v_linearVelocity, V3.scale(a, this.s_inverseMass)) }; rigidBody.prototype.applyTorqueImpulse = function (a) { this.v_angularVelocity = V3.add(this.v_angularVelocity, M33.multiplyV(this.m_worldInvInertiaTensor, a)) };
rigidBody.prototype.applyImpulse = function (a, b) { this.applyCentralImpulse(a); this.applyTorqueImpulse(V3.cross(a, b)) }; rigidBody.prototype.queueImpulse = function (a, b) { this.impulseQueue.push([a, b]) }; rigidBody.prototype.clearImpulseQueue = function () { this.impulseQueue = [] }; rigidBody.prototype.applyImpulseQueue = function () { var a = this; this.impulseQueue.forEach(function (b) { a.applyImpulse(b[0], b[1]) }); this.clearImpulseQueue() };
rigidBody.prototype.computeJacobian = function (a, b, c, d) { a = -(1 + a) * b; b = this.s_inverseMass; c = V3.dot(d, V3.cross(c, M33.multiplyV(this.m_worldInvInertiaTensor, V3.cross(d, c)))); return a / (b + c) }; rigidBody.prototype.computeImpulse = function (a, b, c, d) { a = this.computeJacobian(a, b, c, d); return V3.scale(d, a) };
rigidBody.prototype.integrateVelocities = function (a) { this.v_linearVelocity = V3.add(this.v_linearVelocity, V3.scale(this.v_totalForce, this.s_inverseMass * a)); this.v_angularVelocity = V3.add(this.v_angularVelocity, M33.multiplyV(this.m_worldInvInertiaTensor, V3.scale(this.v_totalTorque, a))) };
rigidBody.prototype.integrateTransform = function (a) { var b = V3.length(this.v_linearVelocity), c = V3.length(this.v_angularVelocity); if (b > this.minLinearVelocity || c > this.minAngularVelocity) b = geofs.aircraft.instance, c = xyz2lla(V3.scale(this.v_linearVelocity, a), b.llaLocation), b.llaLocation = V3.add(b.llaLocation, c), a = V3.scale(this.v_angularVelocity, a), a = M33.transformByTranspose(b.object3d._initialRotation, a), b.object3d.rotateInitialRotation(a); this.clearForces() };
rigidBody.prototype.setCurrentAcceleration = function (a, b) { this.v_acceleration = V3.scale(V3.sub(this.v_linearVelocity, this.v_prevLinearVelocity), a); this.v_acceleration = V3.add([0, 0, GRAVITY], this.v_acceleration); this.v_angularAcceleration = V3.scale(V3.sub(this.v_angularVelocity, this.v_prevAngularVelocity), a); this.v_prevLinearVelocity = V3.dup(this.v_linearVelocity); this.v_prevAngularVelocity = V3.dup(this.v_angularVelocity) };
setInterval(function () { if (geofs.aircraft.instance && geofs.aircraft.instance.object3d) try { geofs.aircraft.instance.object3d.resetRotationMatrix() } catch (a) { geofs.debug.error(a, "resetRotationMatrix interval") } }, 1E4); rigidBody.prototype.clearForces = function () { this.v_totalForce = [0, 0, 0]; this.v_totalTorque = [0, 0, 0] }; rigidBody.prototype.saveState = function () { this.savedLinearVelocity = V3.dup(this.v_linearVelocity); this.savedAngularVelocity = V3.dup(this.v_angularVelocity) };
rigidBody.prototype.restoreState = function () { this.clearForces(); this.v_linearVelocity = V3.dup(this.savedLinearVelocity); this.v_angularVelocity = V3.dup(this.savedAngularVelocity) }; "use strict"; geofs.aircraft = { "default": 1 }; geofs.aircraft.defaultDefinition = { Vspeeds: { VS0: -1, VS: 0, VFE: -1, VNO: 0, VNE: 0 } };
geofs.aircraft.Aircraft = function (a) { geofs.aircraft.instance = this; this.engine = {}; this.engine.rpm = 0; this.engine.on = !0; this.brakesOn = !1; this.groundContact = !0; this.lastLlaLocation = this.llaLocation = [a[0], a[1], a[2]]; this.collResult = { location: [0, 0, 0], normal: [0, 0, 1] }; this.relativeAltitude = 0; this.htr = [0, 0, 0]; this.htrAngularSpeed = [0, 0, 0]; this.airVelocityDirection = [0, 0, 0]; this.trueAirSpeed = 0; this.reset() };
geofs.aircraft.Aircraft.prototype.getCurrentCoordinates = function () { var a = []; a[0] = this.llaLocation[0]; a[1] = this.llaLocation[1]; a[2] = this.llaLocation[2]; a[2] < .5 || this.groundContact ? (this.groundContact = !0, a[2] = 0) : a[4] = !0; a[3] = geofs.aircraft.instance.htr[0]; return a };
geofs.aircraft.Aircraft.prototype.addShadow = function () { this.removeShadow(); if (!this.aircraftRecord) return !1; var a = this.aircraftRecord.fullPath + (this.definition.shadowFile || "shadow.glb"), b = V3.scale(this.definition.shadowBox, this.definition.scale); b[2] = 0; this.shadow = new geofs.shadow(a, b); return !0 }; geofs.aircraft.Aircraft.prototype.removeShadow = function () { try { this.shadow.destroy() } catch (a) { } this.shadow = null };
geofs.aircraft.Aircraft.prototype.loadDefault = function (a) { a && ui.notification.show(a); geofs.aircraft.instance.change(geofs.aircraft.default, null, !0) }; geofs.aircraft.Aircraft.prototype.parseRecord = function (a) { try { var b = JSON.parse(a); this.aircraftRecord = b; if (b.definition) { var c = atob(b.definition); var d = JSON.parse(c)[0] } if (b.error) { this.loadDefault(b.error); return } } catch (e) { return } return d };
geofs.aircraft.Aircraft.prototype.change = function (a, b, c, d) { var e = this; a = a || this.aircraftRecord.id; c = this.load(a, this.getCurrentCoordinates(), c, d); c.then(function () { e.loadLivery(b) }); geofs.api.analytics.event("aircraft", geofs.aircraftList[a].name); return c };
geofs.aircraft.Aircraft.prototype.loadLivery = function (a) { var b = this; if (a) { this.liveryId = a; var c = geofs.camera.currentModeName == "cockpit" ? "cockpit" : "root", d = this.parts[c]["3dmodel"]; if (d) { var e = function () { b.parts[c].textures && b.parts[c].textures.forEach && b.parts[c].textures.forEach(function (f) { d.changeTexture(b.aircraftRecord.fullPath + f.filename + a + ".jpg", f) }) }; d.getReadyPromise().then(function () { e() }) } } else this.liveryId = null };
geofs.aircraft.Aircraft.prototype.loadWithLivery = function (a, b, c) { var d = this; return (0, $jscomp.asyncExecutePromiseGeneratorProgram)(function (e) { if (e.nextAddress == 1) return e.yield(d.load(a, b), 2); c && d.loadLivery(c); e.jumpToEnd() }) };
geofs.aircraft.Aircraft.prototype.load = function (a, b, c, d) {
  var e = this, f = geofs.aircraftList[a] && geofs.aircraftList[a].local ? geofs.aircraftList[a].path + "aircraft.json" : "/models/aircraft/load.php"; return new Promise(function (g, k) {
    e.id != a || c ? (geofs.doPause(1), e.unloadAircraft(), $.ajax(f, {
      data: { id: a, kc: geofs.killCache }, dataType: "text", success: function (m, n, q) {
        if (n != "error") {
          geofs.aircraftList[a] && geofs.aircraftList[a].local && (m = JSON.stringify({
            id: a, name: geofs.aircraftList[a].name, fullPath: geofs.aircraftList[a].path,
            isPremium: !1, isCommunity: !1, definition: btoa(m)
          })); var u = e.parseRecord(m)
        } u ? (geofs.aircraftList[a] && !geofs.aircraftList[a].local && (e.fullPath = e.aircraftRecord.fullPath), e.id = a, e.init(u, b, c, d)) : e.loadDefault("Could not load aircraft file"); g()
      }, error: function (m, n, q) { a != geofs.aircraft.default && e.loadDefault("Could not load aircraft file" + q); k() }
    })) : g()
  })
};
geofs.aircraft.Aircraft.prototype.init = function (a, b, c, d) {
  this.definition = Object.assign({}, geofs.aircraft.defaultDefinition, a); this.setup = a; this.controllers = { pitch: { recenter: !1, sensitivity: 1, ratio: 1 }, roll: { recenter: !0, sensitivity: 1, ratio: 1 }, yaw: { recenter: !0, sensitivity: 1, ratio: 1 } }; this.parts = {}; this.models = []; this.airfoils = []; this.engines = []; this.balloons = []; this.wheels = []; this.collisionPoints = []; this.lights = []; this.suspensions = []; this.manipulators = {}; this.definition.orientation = this.definition.orientation ||
    "Zup"; this.definition.scale = this.definition.scale || 1; this.definition.startupTime = this.definition.startupTime || 1; this.definition.startAltitude *= this.definition.scale; this.definition.cockpitScaleFix = this.definition.cockpitScaleFix || 1; this.definition.motionSensitivity = this.definition.motionSensitivity || 1; geofs.animation.setValue("VS0", this.definition.Vspeeds.VS0); geofs.animation.setValue("VS", this.definition.Vspeeds.VS); geofs.animation.setValue("VFE", this.definition.Vspeeds.VFE); geofs.animation.setValue("VNO",
      this.definition.Vspeeds.VNO); geofs.animation.setValue("VNE", this.definition.Vspeeds.VNE); for (var e in this.definition.cameras) a = this.definition.cameras[e], a.distance *= this.definition.scale, a.position && (a.position = V3.scale(a.position, this.definition.scale)); for (e = 0; e < this.definition.parts.length; e++)a = this.definition.parts[e], a.disabled && (this.definition.parts.splice(e, 1), a = this.definition.parts[e]), this.parts[a.name] = a; this.parts.root || (e = { name: "root", position: [0, 0, 0] }, this.definition.parts.push(e),
        this.parts.root = e); this.parts.root.position = this.parts.root.position || [0, 0, 0]; this.parts.root.points = this.parts.root.points || {}; this.parts.root.points.centerOfMass = this.parts.root.points.centerOfMass || V3.scale(this.parts.root.position, -1); geofs.isApp && (this.parts.camera = { name: "camera", position: [.25, 0, 0] }, this.parts.camera.object3d = new Object3D(this.parts.camera)); instruments.init(this.definition.instruments); this.addParts(this.definition.parts, this.aircraftRecord.fullPath, this.definition.scale, this.definition.orientation);
  this.object3d = this.parts.root.object3d; e = this.boundingSphereRadius = 0; for (a = this.collisionPoints.length; e < a; e++)this.boundingSphereRadius = Math.max(this.boundingSphereRadius, V3.length(this.collisionPoints[e])); this.boundingSphereRadius *= 1.5; for (e in this.definition.contactProperties) a = this.definition.contactProperties[e], a.lockSpeed = a.lockSpeed || .01; this.object3d.compute(this.llaLocation); this.object3d.render(this.llaLocation); this.rigidBody || (this.rigidBody = new rigidBody); this.rigidBody.setMassProps(this.definition.mass,
    this.definition.tensorFactor); this.definition.RPM2PropAS = this.definition.driveRatio / 60 * 360; this.engine.invRPMRange = 1 / (this.definition.maxRPM - this.definition.minRPM); geofs.simpleShadowOn = !1; geofs.useSimpleShadow(!geofs.api.renderingSettings.dropShadow); this._cockpitLoaded = !1; audio.init(this.definition.sounds); if (!c || d) controls.reset(), geofs.camera.reset(); instruments.reset(); this.reset(); this.definition.autopilot ? geofs.autopilot.init && geofs.autopilot.init() : geofs.autopilot.turnOff(); geofs.camera.set(geofs.camera.currentMode);
  b && geofs.flyTo(b, !0)
};
geofs.aircraft.Aircraft.prototype.loadCockpit = function () {
  var a = this, b = geofs.aircraft.instance.aircraftRecord.id, c = geofs.aircraftList[b] && geofs.aircraftList[b].local ? geofs.aircraftList[b].path + "cockpit/cockpit.json" : "/models/aircraft/load.php", d = new Promise(function (e, f) {
    a._cockpitLoaded ? e() : geofs.aircraft.instance.definition.cockpitModel ? $.ajax(c, {
      data: { id: b, kc: geofs.killCache, cockpit: !0 }, dataType: "text", success: function (g, k) {
        geofs.aircraftList[b] && geofs.aircraftList[b].local && (g = JSON.stringify({
          id: b,
          name: geofs.aircraftList[b].name, fullPath: geofs.aircraftList[b].path, isPremium: !1, isCommunity: !1, definition: btoa(g)
        })); if (g = a.parseRecord(g)) a.cockpitSetup = g, a._cockpitLoaded = !0, geofs.aircraftList[b].local || (a.aircraftRecord.fullPath = a.aircraftRecord.fullPath), a.addParts(g.parts, a.aircraftRecord.fullPath + "cockpit/", a.cockpitSetup.scale, geofs.aircraft.instance.definition.orientation), instruments.rescale(), a.definition.cockpitScaleFix && a.fixCockpitScale(a.definition.cockpitScaleFix), a.object3d.compute(a.llaLocation),
          a.placeParts(), a.render(); e()
      }, error: function (g, k) { f() }
    }) : (geofs.aircraft.instance._cockpitLoaded = !0, f())
  }); d.then(function () { a.loadLivery(a.liveryId) }); return d
};
geofs.aircraft.Aircraft.prototype.addParts = function (a, b, c, d) {
  c = c || 1; for (d = 0; d < a.length; d++) { var e = a[d]; if (e.include) { var f = geofs.includes[e.include]; $.extend(!0, e, f[0]); for (var g = 1; g < f.length; g++) { var k = Object.assign({}, f[g], { parent: e.name }); k.name = e.name + k.name; a.push(k) } } if (e.indices && e.indices > 0) { for (g = 2; g <= e.indices; g++)k = Object.assign({}, e, { indices: null }), k.name = e.name + g, k.node += g, a.push(k); e.name += "1"; e.node += "1" } } for (d = 0; d < a.length; d++) {
    e = a[d]; e.points = e.points || {}; e.type = e.type || !1; e.brakesController =
      e.brakesController || !1; e.animations = e.animations || []; geofs.aircraft.instance.parts[e.name] = e; geofs.aircraft.instance.addOffsets(e, c); e.forceDirection && (e.forceDirection = AXIS_TO_INDEX[e.forceDirection]); e.rotation && (e.rotation = V3.toRadians(e.rotation)); e.modelOnlyRotation && (e.modelOnlyRotation = V3.toRadians(e.modelOnlyRotation)); e.scale = e.scale || [1, 1, 1]; e.scale = V3.scale(e.scale, c); e.originalScale = e.scale; geofs.version < 4 && (e.gltf2model = null); if (f = e.gltf2model || e.model) g = f.url || f, b && g[0] != "/" && !e.include &&
        (g = b + g), k = { shadows: e.shadows ? window[e.shadows] : SHADOWS_ALL, incrementallyLoadTextures: !1, forceZup: e.gltf2model || e.forceZup }, f.shader && (k.customShader = geofs.api.generateShader(f.shader, b)), e["3dmodel"] = new geofs.api.Model(g, k), this.models.push(e["3dmodel"]._model), e.renderer && (e.rendererInstance = new instruments.Renderer(e.renderer)); e.light && (e.lightBillboard = new geofs.fx.light(null, e.light, { scale: .2 }), geofs.aircraft.instance.lights.push(e)); e.object3d = new Object3D(e); e.suspension && (e.suspension.length ?
          (e.suspension.origin = [e.collisionPoints[0][0], e.collisionPoints[0][1], e.collisionPoints[0][2] + e.suspension.length], f = e.suspension.length) : (e.suspension.origin = [e.collisionPoints[0][0], e.collisionPoints[0][1], 0], f = -e.collisionPoints[0][2]), e.suspension.restLength = f, e.suspension.motion == "rotation" ? (f = V3.length(e.collisionPoints[0]), f = Math.atan2(e.collisionPoints[0][0] / f, e.collisionPoints[0][2] / f), f = {
            type: "rotate", axis: e.suspension.axis || "Y", value: e.name + "Suspension", ratio: (f < 0 ? f + HALF_PI : f - HALF_PI) *
              RAD_TO_DEGREES * (e.suspension.ratio || 1)
          }) : f = { type: "translate", axis: e.suspension.axis || "Z", value: e.name + "Suspension", ratio: e.suspension.ratio || 1 }, e.animations.push(f), e.suspension.hardPoint = e.suspension.hardPoint || .5, e.points.suspensionOrigin = V3.dup(e.suspension.origin), geofs.aircraft.instance.suspensions.push(e)); for (g = 0; g < e.animations.length; g++)f = e.animations[g], f.ratio = f.ratio || 1, f.offset = f.offset || 0, f.currentValue = null, f.delay && (f.ratio /= 1 - Math.abs(f.delay)), f.type == "rotate" && (k = f.method || "rotate",
            f.frame == "parent" && (k = "rotateParentFrame"), f.rotationMethod = e.object3d[k + f.axis]), f.type == "translate" && (geofs.isArray(f.axis) || (f.axis = AXIS_TO_VECTOR[f.axis])); e.type == "wheel" && (e.radius = e.radius || 1, e.arcDegree = e.radius * TWO_PI / 360, e.angularVelocity = 0, geofs.aircraft.instance.wheels.push(e)); e.type == "airfoil" && (e.lift = 0, geofs.aircraft.instance.airfoils.push(e), e.stalls = e.stalls || !1, e.stallIncidence = e.stallIncidence || 12, e.zeroLiftIncidence = e.zeroLiftIncidence || 16, e.aspectRatio = e.aspectRatio || DEFAULT_AIRFOIL_ASPECT_RATIO,
              e.aspectRatioCoefficient = e.aspectRatio / e.aspectRatio + 2); e.type == "engine" && (e.rpm = 0, geofs.aircraft.instance.definition.originalInertia = geofs.aircraft.instance.definition.engineInertia, geofs.aircraft.instance.engines.push(e), e.contrail && (e.contrailEmitter = new geofs.fx.ParticleEmitter({
                off: !0, anchor: e.points.contrailAnchor, duration: 1E10, rate: .05, life: 4E4, easing: "easeOutQuart", startScale: .01, endScale: .01, randomizeStartScale: .02, randomizeEndScale: .15, startOpacity: .1, endOpacity: 1E-5, startRotation: "random",
                texture: "whitesmoke"
              }))); e.type == "balloon" && (e.temperature = e.initialTemperature || 0, e.coolingSpeed = e.coolingSpeed || 0, geofs.aircraft.instance.balloons.push(e)); if (e.collisionPoints) {
                f = e.collisionPoints; g = geofs.aircraft.instance.definition.contactProperties[e.contactType || e.type]; for (k = 0; k < f.length; k++)f[k].part = e, f[k].contactProperties = g, geofs.aircraft.instance.collisionPoints.push(f[k]); e.volume || e.buoyancy || (e.volume = e.type == "airfoil" ? this.definition.mass / (f.length * 400) : .1, e.area = e.area || 0); e.dragVector =
                  e.dragVector || [1, 1, 1]; e.dragVector = V3.scale(e.dragVector, 1 / f.length)
              } e.volume && (e.buoyancy = WATER_DENSITY * GRAVITY * e.volume); e.controller && (geofs.aircraft.instance.controllers[e.controller.name] = e.controller)
  } for (d = 0; d < a.length; d++)e = a[d], e.name != "root" && (e.parent || (e.parent = "root"), geofs.aircraft.instance.parts[e.parent].object3d.addChild(e.object3d)), e.node && (e.object3d.setModel(e.object3d.findModelInAncestry()), e.manipulator && (b = e.manipulator, typeof b === "string" && (b = geofs.aircraft.instance.aircraftRecord.isCommunity ?
    null : geofs.utils.getFunctionFromString(b)), b && (geofs.aircraft.instance.manipulators[e.node] = b, controls.addNodeClickHandler(e.node, function (m) { controls.manipulator = geofs.aircraft.instance.manipulators[m]; controls.mouse.down = 4 }))))
}; geofs.aircraft.Aircraft.prototype.setVisibility = function (a) { this.object3d && this.object3d.setVisibility(a) };
geofs.aircraft.Aircraft.prototype.unloadAircraft = function () {
  for (var a in geofs.aircraft.instance.parts) { var b = geofs.aircraft.instance.parts[a]; b.object3d && (b.object3d.destroy(), delete geofs.aircraft.instance.parts[a].object3d, b.rendererInstance && b.rendererInstance.destroy(), b.particleEmitterInstance && b.particleEmitterInstance.destroy()); this.models = []; b.contrailEmitter && b.contrailEmitter.destroy() } geofs.aircraft.instance.parts = null; this.removeShadow(); if (geofs.aircraft.instance.lights) for (a = 0, b = geofs.aircraft.instance.lights.length; a <
    b; a++)geofs.aircraft.instance.lights[a].lightBillboard.destroy(); controls.clearNodeClickHandlers()
};
geofs.aircraft.Aircraft.prototype.reset = function (a) {
  this.crashNotified = this.crashed = !1; this.groundContact = a; this.arrestingCableContact = null; for (var b in this.collisionPoints) this.collisionPoints[b].lastGroundAltitude = null, this.collisionPoints[b].part.contact = null; a ? (geofs.animation.values.gearPosition = 0, controls.gear.position = 0, controls.gear.target = 0) : (geofs.animation.values.gearPosition = 1, controls.gear.position = 1, controls.gear.target = 1); this.rigidBody && this.rigidBody.reset(); for (b in this.parts) {
    a =
      this.parts[b]; a.object3d && a.object3d.reset(); if (a.animations) for (var c = 0; c < a.animations.length; c++)a.animations[c].currentValue = null; a.type == "wheel" && (a.angularVelocity = .01, a.oldAngularVelocity = .01)
  } this.engine.on = !0; if (this.engines) for (b = 0; b < this.engines.length; b++)this.engines[b].rpm = this.definition.minRPM; this.engine.rpm = 0; geofs.animation.resetValues({
    altitude: 0, altitudeMeters: 0, prop: 0, throttle: 0, yaw: 0, pitch: 0, roll: 0, atilt: 0, aroll: 0, cameraAircraftDistance: 0, kias: 0, mach: 0, heading: 0, verticalSpeed: 0,
    optionalAnimatedPartPosition: 0, turnrate: 0, accX: 0, accY: 0, accZ: 0
  }); this.animationValue = geofs.animation.values; geofs.autopilot.resetPIDs && geofs.autopilot.resetPIDs()
}; geofs.aircraft.Aircraft.prototype.place = function (a, b) { this.lastLlaLocation = this.llaLocation = a; b && (this.htr = V3.dup(b), b = V3.toRadians(b), this.object3d.setInitialRotation([b[1], b[2], b[0]])); this.placeParts() }; geofs.aircraft.Aircraft.prototype.placeParts = function (a) { a = a || geofs.aircraft.instance.parts; for (var b in a) this.placePart(a[b]) };
geofs.aircraft.Aircraft.prototype.placePart = function (a) {
  if (a.animations) {
    a.object3d.resetAnimatedTransform(); for (var b = 0, c = a.animations.length; b < c; b++) {
      var d = a.animations[b], e = geofs.animation.filter(d); if (!isNaN(e)) {
        switch (d.type) {
          case "rotate": e *= DEGREES_TO_RAD; d.rotationMethod.call(a.object3d, e); e = null; break; case "scale": var f = V3.add(a.originalScale, V3.scale(d.axis, e)); a.object3d.setScale(f); break; case "translate": a.object3d.translate(V3.scale(d.axis, e)); e = null; break; case "opacity": a.object3d.setOpacity(e);
            break; case "show": e <= 0 && a.object3d.visible && a.object3d.setVisibility(!1); case "justshow": e > 0 && (a.object3d.visible || a.object3d.setVisibility(!0)); break; case "hide": e <= 0 && !a.object3d.visible && a.object3d.setVisibility(!0); case "justhide": e > 0 && a.object3d.visible && a.object3d.setVisibility(!1); break; case "render": a.rendererInstance && a.object3d.visible && a.rendererInstance.update(a, e); break; case "sound": e > 0 ? d.playing || (d.playing = !0, f = function () { audio.playSoundLoop(d.name, d.loop) }, d.retard ? (clearTimeout(d.timeOut),
              d.timeOut = setTimeout(f, d.retard)) : f()) : d.playing && (clearTimeout(d.timeOut), audio.stopSoundLoop(d.name), d.playing = !1); break; case "property": a[d.name] = e
        }d.currentValue = e
      }
    }
  }
}; geofs.aircraft.Aircraft.prototype.render = function () { this.object3d.render(this.llaLocation); this.shadow && this.shadow.setLocationRotation(this.llaLocation, this.htr) };
geofs.aircraft.Aircraft.prototype.startEngine = function () { this.engine.on || geofs.aircraft.instance.crashed === !0 || (this.engine.on = !0, this.engine.startup = !0, geofs.aircraft.instance.definition.engineInertia = 2 / this.definition.startupTime, setTimeout(function () { geofs.aircraft.instance.engine.startup = !1; geofs.aircraft.instance.definition.engineInertia = geofs.aircraft.instance.definition.originalInertia }, this.definition.startupTime * 1E3), audio.playStartup()) };
geofs.aircraft.Aircraft.prototype.stopEngine = function () { this.engine.on && (geofs.aircraft.instance.definition.engineInertia = 2 / (this.definition.shutdownTime || 1), controls.throttle = 0, this.engine.on = !1, audio.playShutdown()) };
geofs.aircraft.Aircraft.prototype.addOffsets = function (a, b) { a.position && !a.doNotScalePosition && (a.position = V3.scale(a.position, b)); a.points.forceSourcePoint && (a.points.forceSourcePoint = V3.scale(a.points.forceSourcePoint, b)); if (a.collisionPoints) for (var c = 0; c < a.collisionPoints.length; c++)a.collisionPoints[c] = V3.scale(a.collisionPoints[c], b); if (a.animations) for (c = 0; c < a.animations.length; c++)a.animations[c].type == "translate" && (a.animations[c].ratio *= b) };
geofs.aircraft.Aircraft.prototype.fixCockpitScale = function (a) { if (a) for (var b in this.parts) { var c = this.parts[b]; c.model && (c.object3d.setScale(V3.scale(c.originalScale, a)), a == 1 ? c.object3d.setScaleOffset(null) : c.object3d.setScaleOffset(a)) } }; geofs.aircraft.Aircraft.prototype.crash = function () { this.engine.on = !1; this.crashed = !0; new geofs.fx.ParticleEmitter({ anchor: { worldPosition: [0, 0, 0] }, duration: 1E3, rate: .01, life: 1E4, near: 10, startScale: .05, endScale: 1, startOpacity: .5, endOpacity: 1E-4, texture: "darkSmoke" }) };
"use strict"; window.geofs = window.geofs || {}; geofs.objects = { on: !0, currentTileCoords: {}, zoomLevel: 9, objectList: [], collidableObjectList: [], collidableObject: !1 }; geofs.objects.init = function () { geofs.objects.collidableInterval = setInterval(geofs.objects.updateCollidables, 2E3); $("body").on("nightChange", function () { geofs.objects.updateDayNightTextures(geofs.isNight) }); geofs.objects.on = !0 };
geofs.objects.update = function (a) { geofs.objects.on && (a = geofs.coord2tile(a[0], a[1], geofs.objects.zoomLevel), a.x != geofs.objects.currentTileCoords.x || a.y != geofs.objects.currentTileCoords.y) && ($.getJSON(geofs.objectServer + (geofs.objects.zoomLevel + "/") + a.x + "/" + a.y + ".json" + geofs.killCache, function (b) { geofs.objects.unloadModels(); geofs.objects.objectList = b || []; geofs.objects.preProcessObjects(); geofs.objects.updateCollidables(); geofs.objects.loadModels() }), geofs.objects.currentTileCoords = a) };
geofs.objects.destroy = function () { clearInterval(geofs.objects.collidableInterval); geofs.objects.on = !1; geofs.objects.unloadModels(); geofs.objects.currentTileCoords = {} };
geofs.objects.preProcessObjects = function () {
  geofs.objects.objectList.forEach(function (a) {
    a.collisionTriangles = a.collisionTriangles || []; a.options = a.options || {}; a.htr = a.htr || [0, 0, 0]; if (a.collisionTriangles) {
      var b = a.rotateModelOnly ? M33.setFromEuler(V3.toRadians([0, 0, 0])) : M33.setFromEuler(V3.toRadians([a.htr[1], a.htr[2], a.htr[0]])); for (var c = 0, d = a.collisionTriangles.length; c < d; c++) {
        for (var e = a.collisionTriangles[c], f = 0; f < 3; f++)e[f] = M33.transform(b, e[f]); e.u = V3.sub(e[1], e[0]); e.v = V3.sub(e[2], e[0]); e.n =
          V3.cross(e.u, e.v)
      }
    }
  })
}; geofs.objects.unloadModels = function () { geofs.objects.objectList.forEach(function (a) { a.model && (a.model.destroy(), a.model = null) }) }; geofs.objects.loadModels = function (a) { geofs.objects.objectList.forEach(function (b) { b.url && (b.options.url = b.url, b.options.location = b.location, b.options.rotation = b.htr, b.options.scale = b.scale, b.model = new geofs.api.Model(null, b.options), b.nightTexture && geofs.isNight && b.model.getReadyPromise().then(function () { b.model.changeTexture(b.nightTexture, b) })) }) };
geofs.objects.updateDayNightTextures = function (a) { geofs.objects.objectList.forEach(function (b) { b.nightTexture && b.model.getReadyPromise().then(function () { b.model.changeTexture(a ? b.nightTexture : b.dayTexture, b) }) }) };
geofs.objects.updateCollidables = function () { geofs.objects.collidableObjectList = []; geofs.objects.collidableObject = !1; geofs.objects.objectList.forEach(function (a) { var b = lla2xyz(V3.sub(geofs.aircraft.instance.llaLocation, a.location), geofs.aircraft.instance.llaLocation); V3.length(b) < a.collisionRadius && (a.metricOffset = b, geofs.objects.collidableObject = !0, geofs.objects.collidableObjectList.push(a)) }) }; geofs.objects.areCollidableObjectAtLocation = function (a, b) { return geofs.objects.collidableObject ? !0 : !1 };
geofs.objects.getAltitudeAtLocation = function (a, b) {
  if (geofs.objects.collidableObject) for (var c = [a[0], a[1], 1E5], d = 0, e = geofs.objects.collidableObjectList.length; d < e; d++)for (var f = geofs.objects.collidableObjectList[d], g = lla2xyz(V3.sub(c, f.location), f.location), k = [g[0], g[1], 0], m = 0, n = f.collisionTriangles.length; m < n; m++) {
    var q = f.collisionTriangles[m], u = intersect_RayTriangle([g, k], q); if (u) {
      c = u.point[2] + f.location[2]; if (f.thickness && a[2] < c - f.thickness && !b) return null; if (f.collisionCallback) try { eval(f.collisionCallback) } catch (z) {
        geofs.debug.error(z,
          "objects.getAltitudeAtLocation")
      } return { location: [a[0], a[1], c], normal: V3.normalize(q.n), object: f }
    }
  }
}; geofs.objects.move = function (a, b, c, d) { geofs.objects.objectList[a].model.translate([(b || 0) * 1E-5, (c || 0) * 1E-5, (d || 0) * .1]) }; geofs.objects.rotate = function (a, b) { geofs.objects.objectList[a].model.rotate([(b || 0) * .1, 0, 0]) }; geofs.objects.scale = function (a, b) { geofs.objects.objectList[a].model.scale((b || 1) * .01) }; geofs.objects.getLla = function (a) { return geofs.objects.objectList[a].model._model._apiLla };
geofs.objects.getHtr = function (a) { return geofs.objects.objectList[a].model._model._apiHtr }; geofs.objects.getScale = function (a) { return geofs.objects.objectList[a].model._model._apiScale }; "use strict"; var controls = window.controls || {}; controls = { states: {}, mouse: {} }; controls.mouse.down = !1; controls.mouse.orbit = {}; controls.mouse.offset = { ratioX: .01, ratioY: .01 }; controls.keyboard = {}; controls.keyboard.rollIncrement = .5; controls.keyboard.pitchIncrement = .5; controls.keyboard.yawIncrement = .5;
controls.keyboard.throttleIncrement = .8; controls.keyboard.recenterRatio = .05; controls.keyboard.override = !1; controls.keyboard.overrideRudder = !1; controls.keyboard.exponential = 0; controls.throttleIncrement = .1; controls.touch = { pitch: 0, roll: 0, yaw: 0, throttle: 0 }; controls.orientation = { values: [0, 0, 0], generalMultiplier: 1 }; controls.mixYawRoll = !1; controls.exponential = 1; controls.steerWithRoll = !0; controls.mode = "mouse";
controls.init = function () {
  controls.reset(); geofs.addResizeHandler(controls.initViewportDimensions, controls); $(document).on("keydown", controls.keyDown).on("keyup", controls.keyUp); window.onfocus = function () { controls.controlKeyPressed = !1 }; controls.mouseHandler = function (a) {
    var b = a; !a.pageX && a.changedTouches && (b = a.changedTouches[a.changedTouches.length - 1]); if (a.type != "touchmove" || b.target.className != "geofs-control-cursor") if (geofs.debugOn && geofs.debug.placingObjectId) {
      var c = controls.mouse.lastX - b.pageX,
        d = controls.mouse.lastY - b.pageY; controls.shiftKeyPressed ? controls.controlKeyPressed ? geofs.objects.scale(geofs.debug.placingObjectId, d) : geofs.objects.rotate(geofs.debug.placingObjectId, d) : controls.controlKeyPressed ? geofs.objects.move(geofs.debug.placingObjectId, c, d, 0) : controls.altKeyPressed && geofs.objects.move(geofs.debug.placingObjectId, 0, 0, d); controls.mouse.lastX = b.pageX; controls.mouse.lastY = b.pageY
    } else if (controls.mouse.down !== !1) {
      var e = controls.mouse.originalX - b.pageX; var f = controls.mouse.originalY -
        b.pageY; c = controls.mouse.lastX - b.pageX; d = controls.mouse.lastY - b.pageY; controls.mouse.down == 4 && controls.manipulator && controls.updateManipulator(controls.manipulator, { ix: c, iy: d, ixr: c * controls.pageRatioX, iyr: d * controls.pageRatioY, dx: e * controls.pageRatioX, dy: f * controls.pageRatioY }); controls.mouse.down != 1 || geofs.api.nativeMouseHandling || a.type == "touchmove" && b.target.className != "geofs-view-pad" || (controls.controlKeyPressed ? geofs.camera.translate(c * controls.mouse.offset.ratioX, 0, -d * controls.mouse.offset.ratioY) &&
          (a.preventDefault(), a.stopPropagation && a.stopPropagation(), a.stopImmediatePropagation && a.stopImmediatePropagation()) : geofs.camera.rotate(c * controls.mouse.orbit.ratioX, d * controls.mouse.orbit.ratioY) && (a.preventDefault(), a.stopPropagation && a.stopPropagation(), a.stopImmediatePropagation && a.stopImmediatePropagation())); controls.mouse.down == 3 && !geofs.api.nativeMouseHandling && geofs.camera.translate(0, -d * controls.mouse.orbit.ratioZ, 0) && (a.preventDefault(), a.stopImmediatePropagation && a.stopImmediatePropagation());
      controls.mouse.lastX = b.pageX; controls.mouse.lastY = b.pageY
    } else controls.mode != "mouse" || controls.mouseOnHold || (controls.mouse.xValue = clamp((a.pageX - controls.mouse.oX - controls.mouse.cX) * controls.mouse.rX, -1, 1), controls.mouse.yValue = clamp((a.pageY - controls.mouse.tY - controls.mouse.cY) * controls.mouse.rY, -1, 1), controls.keyboard.override = !1)
  }; $(document).on("wheel", function (a) {
    controls.wheelManipulator && (a = a.originalEvent.deltaY > 0 ? -1 : 1, controls.updateManipulator(controls.wheelManipulator, {
      ix: 0, iy: a, ixr: 0,
      iyr: 0, dx: 0, dy: a
    }))
  }); $(document).on("click", ".geofs-orientationReset, .geofs-orientationCalibrate", function () { controls.orientation.recenter() }); $(document).on("mousemove touchmove", function (a) { controls.mouseHandler(a) }); controls.mouseDownHandler = function (a) {
    var b = a; controls.mouse.down = a.which; controls.mouse.down === 0 && (controls.mouse.down = 1); !geofs.camera.isHandlingMouseRotation() || a.type == "touchmove" && a.target.className != "geofs-view-pad" || (a.preventDefault(), a.stopImmediatePropagation && a.stopImmediatePropagation(),
      !a.pageX && a.changedTouches && (b = a.changedTouches[a.changedTouches.length - 1]), controls.mouse.originalX = b.pageX, controls.mouse.originalY = b.pageY, controls.mouse.lastX = controls.mouse.originalX, controls.mouse.lastY = controls.mouse.originalY, geofs.camera.saveRotation(), geofs.camera.saveOffset()); controls.mouse.clickedElement = a.currentTarget; controls.mouse.clickedNode = geofs.api.getNodeNameFromScreenCoords(b.pageX - controls.mouse.oX, b.pageY - controls.mouse.oY); controls.mouse.clickedNode && (geofs.debug.log(controls.mouse.clickedNode),
        controls.runNodeClickHandlers(controls.mouse.clickedNode)); controls.mouse.down == 4 && controls.manipulator && controls.applyManipulator(controls.manipulator)
  }; controls.mouseUpHandler = function (a) { geofs.camera.isHandlingMouseRotation() && geofs.camera.saveRotation(); controls.mouse.down = !1; controls.mouse.clickedNode = null; controls.mouse.clickedElement = null; controls.manipulator && (controls.releaseManipulator(controls.manipulator), controls.manipulator = null); a && a.preventDefault && a.preventDefault() }; $(document).on("mousedown touchstart",
    ".geofs-canvas-mouse-overlay", controls.mouseDownHandler); $(document).on("mouseup", controls.mouseUpHandler); $(document).on("touchend", ".geofs-canvas-mouse-overlay", controls.mouseUpHandler); $("body, .geofs-canvas-mouse-overlay").on("click touchend", function () { controls.mode != "orientation" || controls.orientation.iOSpermissionRequested || controls.orientation.requestIOSPermission() }); $(".geofs-canvas-mousewheel-overlay").on("wheel", function (a) {
      a.originalEvent.deltaY / 120 < 0 ? geofs.camera.decreaseFOV() : geofs.camera.increaseFOV();
      a.preventDefault(); a.stopPropagation()
    }); controls.joystick.init(); controls.orientation.init(); geofs.autopilot.UI.init(); controls.setMode(geofs.preferences.controlMode)
}; controls.nodeClickHandlers = {}; controls.addNodeClickHandler = function (a, b) { controls.nodeClickHandlers[a] = b }; controls.runNodeClickHandlers = function (a) { for (var b in controls.nodeClickHandlers) if (b == a) controls.nodeClickHandlers[b](a) }; controls.removeNodeClickHandler = function (a) { delete controls.nodeClickhandlerHandlers[a] };
controls.clearNodeClickHandlers = function () { controls.nodeClickHandlers = {} };
controls.addHammerHandlers = function () {
  controls.addHammerHandlersAreSet || (controls.addHammerHandlersAreSet = !0, function () { var a = $(".geofs-view-pad")[0], b = new Hammer(a); b.get("pinch").set({ enable: !0 }); b.on("pinchstart", function (c) { b.geoFSFOV = geofs.api.getFOV(geofs.camera.cam); c.preventDefault() }); b.on("doubletap", function (c) { geofs.camera.setToNeutral(); c.preventDefault() }); b.on("pinchmove", function (c) { geofs.camera.setFOV(1 / c.scale * b.geoFSFOV); controls.mouse.down = !1; c.preventDefault() }) }(), function () {
    function a() {
      b.css("left",
        "0px"); b.css("top", controls.elevatorTrim * 15 + "px")
    } var b = $(".geofs-control-cursor"), c = $(".geofs-control-pad"), d = new Hammer(c[0]); d.get("pinch").set({ enable: !0 }); d.get("pan").set({ threshold: 0 }); d.on("panstart", function (e) { var f = $(e.target); clearTimeout(controls.trimInterval); f.hasClass("geofs-control-trimup") ? controls.trimInterval = setInterval(function () { d.trim(f, "Up") }, 500) : f.hasClass("geofs-control-trimdown") && (controls.trimInterval = setInterval(function () { d.trim(f, "Down") }, 500)); e.preventDefault() });
    d.trim = function (e, f) { e.addClass("geofs-control-flash"); clearTimeout(e.flashtimeout); e.flashtimeout = setTimeout(function () { e.removeClass("geofs-control-flash") }, 100); controls["trim" + f](); a() }; d.on("press", function (e) { var f = $(e.target); clearTimeout(controls.trimInterval); f.hasClass("geofs-control-trimup") ? controls.trimInterval = setInterval(function () { d.trim(f, "Up") }, 200) : f.hasClass("geofs-control-trimdown") && (controls.trimInterval = setInterval(function () { d.trim(f, "Down") }, 200)); e.preventDefault() }); d.on("panend pressup",
      function (e) { clearTimeout(controls.trimInterval); e.preventDefault() }); d.on("panmove", function (e) { var f = $(e.target); if (!f.hasClass("geofs-control-trimup") && !f.hasClass("geofs-control-trimdown")) { f = clamp(e.deltaX, -controls.controlPad.eX, controls.controlPad.eX); var g = clamp(e.deltaY, -controls.controlPad.hY, controls.controlPad.hY); controls.touch.roll = f * controls.controlPad.rX; controls.touch.pitch = g * controls.controlPad.rY; b.css("left", f + "px"); b.css("top", g + "px"); e.preventDefault() } }); d.on("panend pancancel",
        function (e) { clearTimeout(controls.trimInterval); var f = $(e.target); f.hasClass("geofs-control-trimup") && d.trim(f, "Up"); f.hasClass("geofs-control-trimdown") && d.trim(f, "Down"); controls.touch.roll = 0; controls.touch.pitch = 0; a(); e.preventDefault() }); d.on("tap", function (e) {
          var f = $(e.target); f.hasClass("geofs-control-trimup") && controls.trimUp(); f.hasClass("geofs-control-trimdown") && controls.trimDown(); clearTimeout(controls.trimInterval); f.hasClass("geofs-control-option-x") && controls.setters.setOptionalAnimatedPart.set();
          f.hasClass("geofs-control-option-z") && controls.setters.setAccessories.set(); f.addClass("geofs-control-flash"); clearTimeout(f.flashtimeout); f.flashtimeout = setTimeout(function () { f.removeClass("geofs-control-flash") }, 100); a(); e.preventDefault()
        })
  }(), function () {
    var a = $(".geofs-throttle-cursor"); $(".geofs-throttle-pad"); var b = new Hammer(a[0]); controls.hammerThrottle = b; b.get("pinch").set({ enable: !0 }); b.get("pan").set({ threshold: 0 }); var c = $(".geofs-rudder-cursor"), d = $(".geofs-rudder-pad"); $(document).on("preferenceRead preferenceSaved",
      function () { geofs.preferences.controlMode == "touch" && !geofs.preferences.touch.mixYawRoll || geofs.preferences.controlMode == "orientation" && !geofs.preferences.orientation.mixYawRoll ? ($(".geofs-throttle-pad").addClass("geofs-rudder-on"), d.show()) : ($(".geofs-throttle-pad").removeClass("geofs-rudder-on"), d.hide()) }); $(document).on("flyto", function () { a.css("bottom", "0%"); b.lastY = 0 }); geofs.api.addFrameCallback(function () {
        if (geofs.autopilot.on) {
          var e = clamp(controls.throttle * 100, 5, 90); a.css("bottom", e + "%"); b.lastY =
            controls.throttle * controls.throttlePad.hY
        }
      }); b.on("panstart", function (e) { b.startY = b.lastY || 0; e.preventDefault() }); b.on("pan", function (e) { var f = b.startY - e.deltaY; f = clamp(f, 0, controls.throttlePad.hY); b.lastY = f; f = clamp(f * controls.throttlePad.rY, 0, 1); controls.throttle = f; a.css("bottom", clamp(f * 100, 5, 90) + "%"); f = clamp(e.deltaX, -controls.rudderPad.eX, controls.rudderPad.eX); controls.touch.yaw = f * controls.rudderPad.rX; controls.orientation.yaw = controls.touch.yaw; c.css("left", f + "px"); e.preventDefault() }); b.on("panmove",
        function (e) { e.preventDefault() }); b.on("panend pancancel", function (e) { controls.touch.yaw = 0; controls.orientation.yaw = 0; c.css("left", "0px"); e.preventDefault() })
  }())
};
controls.initViewportDimensions = function () {
  var a = $(".geofs-canvas-mouse-overlay"), b = a[0]; controls.mouse.oX = a.offset().left; controls.mouse.oY = a.offset().top; controls.mouse.cX = b.offsetWidth / 2; controls.mouse.rX = 1 / controls.mouse.cX; controls.mouse.tY = a.offset().top; controls.mouse.cY = b.offsetHeight / 2; controls.mouse.rY = 1 / controls.mouse.cY; controls.throttlePad = $(".geofs-throttle-pad")[0]; controls.throttlePad && (controls.throttlePad.tY = controls.throttlePad.offsetTop, controls.throttlePad.hY = controls.throttlePad.offsetHeight,
    controls.throttlePad.rY = 1 / controls.throttlePad.hY); controls.controlPad = $(".geofs-control-pad")[0]; controls.controlPad && (controls.controlPad.tY = controls.controlPad.offsetTop, controls.controlPad.hY = 75, controls.controlPad.rY = 1 / controls.controlPad.hY, controls.controlPad.oX = controls.controlPad.offsetLeft, controls.controlPad.eX = 75, controls.controlPad.rX = 1 / controls.controlPad.eX); controls.rudderPad = $(".geofs-rudder-pad")[0]; controls.rudderPad && (controls.rudderPad.oX = controls.rudderPad.offsetLeft, controls.rudderPad.eX =
      50, controls.rudderPad.rX = 1 / controls.rudderPad.eX); controls.viewportWidth = b.offsetWidth; controls.viewportHeight = b.offsetHeight; controls.mouse.orbit.ratioX = 360 / controls.viewportWidth; controls.mouse.orbit.ratioY = 360 / controls.viewportHeight; controls.pageRatioX = 1 / controls.viewportWidth; controls.pageRatioY = 1 / controls.viewportHeight; controls.mouse.orbit.ratioZ = .1; geofs.isMobileDevice && controls.addHammerHandlers()
};
controls.resetWithAircraftDefinition = function () { controls.flaps.maxPosition = geofs.aircraft.instance.definition.flapsPositions ? geofs.aircraft.instance.definition.flapsPositions[geofs.aircraft.instance.definition.flapsPositions.length - 1] : geofs.aircraft.instance.definition.flapsSteps };
controls.reset = function () {
  controls.roll = 0; controls.rawPitch = 0; controls.pitch = 0; controls.yaw = 0; controls.throttle = 0; controls.mixture = 1; controls.carbHeat = 1; controls.reverse = 0; controls.brakes = 0; controls.engine = {}; controls.engine.on = !1; controls.elevatorTrim = 0; controls.elevatorTrimMin = -.5; controls.elevatorTrimMax = .5; controls.elevatorTrimStep = .01; controls.gear = {}; controls.gear.position = 0; controls.gear.target = 0; controls.flaps = {}; controls.flaps.position = 0; controls.flaps.target = 0; controls.flaps.maxPosition =
    1; controls.flaps.positionRatio = 0; controls.airbrakes = {}; controls.airbrakes.position = 0; controls.airbrakes.target = 0; controls.optionalAnimatedPart = {}; controls.optionalAnimatedPart.position = 0; controls.optionalAnimatedPart.target = 0; controls.accessories = {}; controls.accessories.position = 0; controls.accessories.target = 0; controls.states.left = !1; controls.states.right = !1; controls.states.up = !1; controls.states.down = !1; controls.states.rudderLeft = !1; controls.states.rudderRight = !1; controls.states.increaseThrottle =
      !1; controls.states.decreaseThrottle = !1; controls.mouse.xValue = 0; controls.mouse.yValue = 0; controls.initViewportDimensions(); geofs.aircraft.instance && geofs.aircraft.instance.definition && controls.resetWithAircraftDefinition()
};
controls.setMode = function (a) {
  a = a || geofs.preferences.controlMode || "mouse"; controls.mode = a; controls.mode == "orientation" ? (controls.orientation.init(), controls.orientation.available ? $("body").addClass("geofs-orientation") : (controls.setMode("touch"), $("body").removeClass("geofs-orientation")), controls.exponential = 1, controls.mixYawRoll = geofs.preferences.orientation.mixYawRoll, controls.steerWithRoll = geofs.preferences.orientation.steerWithRoll, controls.sensitivity = geofs.preferences.orientation.sensitivity,
    controls.multiplier = { pitch: geofs.preferences.orientation.multiplier.pitch ? -1 : 1, roll: geofs.preferences.orientation.multiplier.roll ? -1 : 1, yaw: 1 }) : $("body").removeClass("geofs-orientation"); controls.mode == "touch" ? (controls.exponential = 1, controls.mixYawRoll = geofs.preferences.touch.mixYawRoll, controls.steerWithRoll = geofs.preferences.touch.steerWithRoll, controls.sensitivity = geofs.preferences.touch.sensitivity, controls.multiplier = { pitch: 1, roll: 1, yaw: 1 }, $("body").addClass("geofs-touch")) : $("body").removeClass("geofs-touch");
  controls.mode == "joystick" && (controls.exponential = 1, controls.mixYawRoll = geofs.preferences.joystick.mixYawRoll, controls.steerWithRoll = geofs.preferences.joystick.steerWithRoll, controls.sensitivity = geofs.preferences.joystick.sensitivity, controls.multiplier = { pitch: 1, roll: 1, yaw: 1, throttle: geofs.preferences.joystick.multiplier.throttle ? -1 : 1 }); controls.mode == "mouse" && (controls.exponential = 1, controls.mixYawRoll = geofs.preferences.mouse.mixYawRoll, controls.steerWithRoll = geofs.preferences.mouse.steerWithRoll,
    controls.sensitivity = geofs.preferences.mouse.sensitivity, controls.multiplier = { pitch: geofs.preferences.mouse.reverse ? -1 : 1, roll: 1, yaw: 1 }); controls.mode == "keyboard" && (controls.exponential = 0, controls.mixYawRoll = geofs.preferences.keyboard.mixYawRoll, controls.steerWithRoll = geofs.preferences.keyboard.steerWithRoll, controls.sensitivity = geofs.preferences.keyboard.sensitivity, controls.multiplier = { pitch: 1, roll: 1, yaw: 1 }); geofs.preferences.controlMode = a; geofs.setPreferenceValues()
};
controls.axisSetters = {
  none: { label: "none", value: null }, pitch: { label: "Pitch", overridesPeer: !0, process: function (a) { return controls.rawPitch = a * geofs.preferences.joystick.sensitivity } }, roll: { label: "Roll", overridesPeer: !0, process: function (a) { return controls.roll = a * geofs.preferences.joystick.sensitivity } }, yaw: { label: "Yaw", overridesPeer: !0, process: function (a) { return controls.yaw = a * geofs.preferences.joystick.sensitivity } }, throttle: {
    label: "Throttle", overridesPeer: !0, process: function (a) {
      return controls.throttle =
        (a + 1) / 2
    }
  }, reverse: { label: "Reverse", process: function (a) { return controls.reverse = (a + 1) / 2 } }, throttlereverse: { label: "Throttle & Reverse", process: function (a) { return geofs.aircraft.instance.definition.reverse ? controls.throttle = a : controls.throttle = (a + 1) / 2 } }, increaseThrottle: { label: "Increase/Decrease Throttle", process: function (a, b) { return controls.throttle += a * b } }, brakes: { label: "Brakes", overridesAutopilot: !0, overridesPeer: !0, process: function (a) { return controls.brakes = a } }, airbrakesPosition: {
    label: "Air Brakes",
    overridesAutopilot: !0, overridesPeer: !0, process: function (a) { controls.airbrakes.target = (a + 1) / 2; controls.setPartAnimationDelta(controls.airbrakes) }
  }, flapsPosition: { label: "Flaps", overridesAutopilot: !0, process: function (a) { controls.flaps.positionTarget = (a + 1) / 2 * controls.flaps.maxPosition; controls.setPartAnimationDelta(controls.flaps) } }, hatView: {
    label: "Hat Button View", overridesAutopilot: !0, max: 3, process: function (a, b) {
      var c = 0, d = 0; a > -1 && a < 0 && (c = -40); a > -.4 && a < .7 && (d = -40); a > .4 && a < 1.1 && (c = 40); if (a == 1 || a < -.7 &&
        a > -1.1) d = 40; if (c || d) geofs.camera.rotate(c * b, d * b), geofs.camera.saveRotation()
    }
  }, lookAround: { label: "Look left/right", overridesAutopilot: !0, process: function (a) { a != geofs.lookAroundValue && (geofs.camera.lookAround(a * 90), geofs.lookAroundValue = a) } }, lookUpDown: { label: "Look up/down", overridesAutopilot: !0, process: function (a) { a != geofs.lookUpDownValue && (geofs.camera.lookAround(null, a * -90), geofs.lookUpDownValue = a) } }
};
controls.setters = {
  none: { label: "none", set: function () { }, unset: function () { } }, toggleEngines: { label: "Turn Engines ON/OFF ", set: function () { geofs.aircraft.instance.engine.on ? geofs.aircraft.instance.stopEngine() : geofs.aircraft.instance.startEngine() } }, setBrakes: { label: "Brakes", set: function () { geofs.aircraft.instance.brakesOn = !0; controls.brakes = 1 }, unset: function () { geofs.aircraft.instance.brakesOn = !1; controls.brakes = 0 } }, toggleAutoPilot: { label: "Autopilot", set: function () { geofs.autopilot.toggle() } }, toggleParkingBrake: {
    label: "Parking brake",
    set: function () { geofs.aircraft.instance.brakesOn ? (geofs.aircraft.instance.brakesOn = !1, controls.brakes = 0) : (geofs.aircraft.instance.brakesOn = !0, controls.brakes = 1) }
  }, setAirbrakes: { label: "Air Brakes", set: function () { controls.airbrakes.target = controls.airbrakes.target == 0 ? 1 : 0; controls.setPartAnimationDelta(controls.airbrakes) } }, setOptionalAnimatedPart: { label: "Optional Animated Parts", set: function () { controls.optionalAnimatedPart.target = controls.optionalAnimatedPart.target == 0 ? 1 : 0; controls.setPartAnimationDelta(controls.optionalAnimatedPart) } },
  setAccessories: { label: "Accessories (hook/floats/rudder)", set: function () { controls.accessories.target = controls.accessories.target == 0 ? 1 : 0; controls.setPartAnimationDelta(controls.accessories) } }, setFlapsUp: { label: "Flaps Up", set: function () { controls.flaps.target > 0 && (controls.flaps.target--, geofs.aircraft.instance.definition.flapsPositions && (controls.flaps.positionTarget = geofs.aircraft.instance.definition.flapsPositions[controls.flaps.target]), controls.setPartAnimationDelta(controls.flaps)) } }, setFlapsDown: {
    label: "Flaps down",
    set: function () { controls.flaps.target < geofs.aircraft.instance.definition.flapsSteps && (controls.flaps.target++, geofs.aircraft.instance.definition.flapsPositions && (controls.flaps.positionTarget = geofs.aircraft.instance.definition.flapsPositions[controls.flaps.target]), controls.setPartAnimationDelta(controls.flaps)) }
  }, cycleFlaps: {
    label: "Cycle Flaps", set: function () {
      controls.flaps.target < geofs.aircraft.instance.definition.flapsSteps ? controls.flaps.target++ : controls.flaps.target = 0; geofs.aircraft.instance.definition.flapsPositions &&
        (controls.flaps.positionTarget = geofs.aircraft.instance.definition.flapsPositions[controls.flaps.target]); controls.setPartAnimationDelta(controls.flaps)
    }
  }, setGear: { label: "Toggle Gear (up/down)", set: function () { if (geofs.aircraft.instance.definition.gearOperationAllowedOnGround || !geofs.aircraft.instance.groundContact || geofs.debugOn) controls.gear.target = controls.gear.target == 0 ? 1 : 0, controls.setPartAnimationDelta(controls.gear) } }, increaseThrottle: {
    label: "Increase Throttle", set: function (a) {
      controls.throttle +=
        controls.throttleIncrement
    }
  }, decreaseThrottle: { label: "Decrease Throttle", set: function (a) { controls.throttle -= controls.throttleIncrement } }, setReverseNone: { label: "Set reverse to none", set: function () { controls.reverse = 0 } }, setReverseFull: { label: "Set reverse to full", set: function () { controls.reverse = 1 } }, fullReverse: { label: "Full reverse while pressed", set: function () { controls.reverse = 1 }, unset: function () { controls.reverse = 0 } }, toggleReverse: {
    label: "Toggle Reverse (full/none)", set: function () {
      controls.reverse = controls.reverse >
        0 ? 0 : 1
    }
  }, setReverseOnThrottleAxis: { label: "Set reverse on throttle axis", set: function () { controls.throttleAsReverse = 1 }, unset: function () { controls.throttleAsReverse = 0 } }, setElevatorTrimUp: { label: "Elevator Trim Up", set: function () { controls.states.elevatorTrimUp = !0 }, unset: function () { controls.states.elevatorTrimUp = !1 } }, setElevatorTrimDown: { label: "Elevator Trim Down", set: function () { controls.states.elevatorTrimDown = !0 }, unset: function () { controls.states.elevatorTrimDown = !1 } }, setElevatorTrimNeutral: {
    label: "Elevator Trim Neutral",
    set: function () { controls.elevatorTrim = 0 }
  }, lookLeft: { label: "Look Left", overridesAutopilot: !0, set: function () { geofs.camera.lookAround(-90) }, unset: function () { geofs.camera.lookAround(0) } }, lookRight: { label: "Look Right", overridesAutopilot: !0, set: function () { geofs.camera.lookAround(90) }, unset: function () { geofs.camera.lookAround(0) } }, cameraRight: {
    label: "Rotate View Right", overridesAutopilot: !0, set: function () { geofs.camera.animations.orbitHorizontal.active = !0; geofs.camera.animations.orbitHorizontal.rate = 1 }, unset: function () {
      geofs.camera.animations.orbitHorizontal.active =
        !1
    }
  }, cameraLeft: { label: "Rotate View Left", overridesAutopilot: !0, set: function () { geofs.camera.animations.orbitHorizontal.active = !0; geofs.camera.animations.orbitHorizontal.rate = -1 }, unset: function () { geofs.camera.animations.orbitHorizontal.active = !1 } }, cameraUp: { label: "Rotate View Up", overridesAutopilot: !0, set: function () { geofs.camera.animations.orbitVertical.active = !0; geofs.camera.animations.orbitVertical.rate = 1 }, unset: function () { geofs.camera.animations.orbitVertical.active = !1 } }, cameraDown: {
    label: "Rotate View Down",
    overridesAutopilot: !0, set: function () { geofs.camera.animations.orbitVertical.active = !0; geofs.camera.animations.orbitVertical.rate = -1 }, unset: function () { geofs.camera.animations.orbitVertical.active = !1 }
  }, reset: { label: "Reset Flight", overridesAutopilot: !0, set: function () { geofs.resetFlight() } }
}; controls.trimUp = function (a) { controls.elevatorTrim < controls.elevatorTrimMax && (controls.elevatorTrim += controls.elevatorTrimStep) };
controls.trimDown = function (a) { controls.elevatorTrim > controls.elevatorTrimMin && (controls.elevatorTrim -= controls.elevatorTrimStep) };
controls.update = function (a) {
  try { controls.updateKeyboard(a) } catch (c) { geofs.debug.error(c, "controls.updateTouch") } if (controls.mode == "joystick") try { controls.updateJoystick(a) } catch (c) { geofs.debug.error(c, "controls.updateJoystick") } if (!geofs.autopilot.on) {
    controls.states.elevatorTrimUp ? (controls.trimUp(), controls.setters.setElevatorTrimUp.unset()) : controls.states.elevatorTrimDown && (controls.trimDown(), controls.setters.setElevatorTrimDown.unset()); if ((controls.mode == "mouse" || controls.mode == "touch") && !controls.keyboard.override) try { controls.updateMouse(a) } catch (c) {
      geofs.debug.error(c,
        "controls.updateMouse")
    } if (controls.mode == "orientation") try { controls.updateOrientation(a) } catch (c) { geofs.debug.error(c, "controls.updateOrientation") } if (controls.mode == "touch") try { controls.updateTouch(a) } catch (c) { geofs.debug.error(c, "controls.updateTouch") } var b = controls.exponential; controls.keyboard.override && (b = controls.keyboard.exponential); controls.roll *= controls.multiplier.roll; controls.rawPitch *= controls.multiplier.pitch; controls.yaw *= controls.multiplier.yaw; controls.roll *= Math.pow(Math.abs(controls.roll),
      b); controls.rawPitch *= Math.pow(Math.abs(controls.rawPitch), b); controls.rawYaw = controls.yaw; controls.mixYawRoll && (controls.yaw = controls.roll); controls.steering = controls.steerWithRoll ? Math.abs(controls.yaw) > Math.abs(controls.roll) ? controls.yaw : controls.roll : controls.yaw; controls.keyboard.overrideRudder && (b = geofs.preferences.keyboard.exponential); controls.yaw *= Math.pow(Math.abs(controls.yaw), b); controls.rawYaw = controls.yaw
  } controls.roll = clamp(controls.roll, -1, 1); controls.rawPitch = clamp(controls.rawPitch,
    -1, 1); controls.yaw = clamp(controls.yaw, -1, 1); controls.pitch = controls.rawPitch + controls.elevatorTrim; b = 0; geofs.aircraft.instance.definition.reverse && (b = -1, controls.throttle > 0 && (controls.reverse = 0)); controls.throttle = controls.throttleAsReverse ? clamp(-controls.throttle, b, 0) : clamp(controls.throttle - controls.reverse, b, 1); controls.animatePart("gear", a); controls.animatePart("flaps", a); controls.animatePart("airbrakes", a); controls.animatePart("optionalAnimatedPart", a); controls.animatePart("accessories", a)
};
controls.setPartAnimationDelta = function (a) { a.delta = a.positionTarget ? a.positionTarget - a.position : a.target - a.position };
controls.animatePart = function (a, b) { var c = controls[a]; var d = c.positionTarget ? c.positionTarget : c.target; c.position != d && geofs.aircraft.instance.definition[a + "TravelTime"] && (c.position += c.delta / (geofs.aircraft.instance.definition[a + "TravelTime"] / b), c.delta < 0 && c.position <= d && (c.position = d, c.delta = null), c.delta > 0 && c.position >= d && (c.position = d, c.delta = null), c.positionRatio = c.maxPosition ? c.position / c.maxPosition : c.position) };
controls.updateMouse = function (a) { controls.roll = controls.mouse.xValue * geofs.preferences.mouse.sensitivity; controls.rawPitch = controls.mouse.yValue * geofs.preferences.mouse.sensitivity };
controls.updateKeyboard = function (a) {
  var b = controls.keyboard.rollIncrement * a * geofs.preferences.keyboard.sensitivity; controls.states.left ? controls.roll -= b : controls.states.right ? controls.roll += b : geofs.aircraft.instance.controllers.roll.recenter && (controls.roll -= [controls.roll - 0] * controls.keyboard.recenterRatio * geofs.preferences.keyboard.sensitivity); b = controls.keyboard.pitchIncrement * a * geofs.preferences.keyboard.sensitivity * geofs.aircraft.instance.controllers.pitch.sensitivity; controls.states.up ? controls.rawPitch -=
    b * geofs.aircraft.instance.controllers.pitch.ratio : controls.states.down ? controls.rawPitch += b * geofs.aircraft.instance.controllers.pitch.ratio : geofs.aircraft.instance.controllers.pitch.recenter && (controls.rawPitch -= [controls.rawPitch - 0] * b); b = controls.keyboard.yawIncrement * a * geofs.preferences.keyboard.sensitivity; controls.states.rudderLeft ? controls.yaw -= b : controls.states.rudderRight ? controls.yaw += b : geofs.aircraft.instance.controllers.yaw.recenter && (controls.yaw -= [controls.yaw - 0] * controls.keyboard.recenterRatio *
      geofs.preferences.keyboard.sensitivity); a *= controls.keyboard.throttleIncrement; controls.states.increaseThrottle ? controls.throttle += a : controls.states.decreaseThrottle && (controls.throttle -= a)
}; controls.recenter = function () { controls.mouse.xValue = 0; controls.mouse.yValue = 0; controls.yaw = 0; controls.roll = 0; controls.rawPitch = 0 };
controls.keyDown = function (a) {
  switch (a.which) {
    case geofs.preferences.keyboard.keys["Toggle Autopilot"].keycode: controls.setters.toggleAutoPilot.set(); break; case geofs.preferences.keyboard.keys["Bank left"].keycode: controls.states.left = !0; a.returnValue = !1; controls.keyboard.override = !0; break; case geofs.preferences.keyboard.keys["Bank right"].keycode: controls.states.right = !0; a.returnValue = !1; controls.keyboard.override = !0; break; case geofs.preferences.keyboard.keys["Pitch down"].keycode: controls.states.up =
      !0; a.returnValue = !1; controls.keyboard.override = !0; break; case geofs.preferences.keyboard.keys["Pitch up"].keycode: controls.states.down = !0; a.returnValue = !1; controls.keyboard.override = !0; break; case geofs.preferences.keyboard.keys["Steer left"].keycode: controls.states.rudderLeft = !0; a.returnValue = !1; controls.keyboard.overrideRudder = !0; break; case geofs.preferences.keyboard.keys["Steer right"].keycode: controls.states.rudderRight = !0; a.returnValue = !1; controls.keyboard.overrideRudder = !0; break; case geofs.preferences.keyboard.keys["Increase throttle"].keycode: case geofs.preferences.keyboard.keys["Increase throttle alt"].keycode: controls.states.increaseThrottle =
        !0; a.returnValue = !1; break; case geofs.preferences.keyboard.keys["Decrease throttle"].keycode: case geofs.preferences.keyboard.keys["Decrease throttle alt"].keycode: controls.states.decreaseThrottle = !0; a.returnValue = !1; break; case geofs.preferences.keyboard.keys.Brakes.keycode: controls.setters.setBrakes.set(); break; case geofs.preferences.keyboard.keys["Parking brake"].keycode: controls.setters.toggleParkingBrake.set(); break; case geofs.preferences.keyboard.keys["Engine switch (on/off)"].keycode: controls.setters.toggleEngines.set();
      break; case geofs.preferences.keyboard.keys["Gear toggle (up/down)"].keycode: controls.setters.setGear.set(); break; case geofs.preferences.keyboard.keys["Lower flaps"].keycode: controls.setters.setFlapsDown.set(); break; case geofs.preferences.keyboard.keys["Raise flaps"].keycode: controls.setters.setFlapsUp.set(); break; case geofs.preferences.keyboard.keys["Cycle flaps"].keycode: controls.setters.cycleFlaps.set(); break; case geofs.preferences.keyboard.keys["Airbrake toggle (on/off)"].keycode: controls.setters.setAirbrakes.set();
      break; case geofs.preferences.keyboard.keys["Accessories (hook/floats/rudder) toggle"].keycode: controls.setters.setAccessories.set(); break; case geofs.preferences.keyboard.keys["Optional Animated Part toggle (on/off)"].keycode: controls.setters.setOptionalAnimatedPart.set(); break; case geofs.preferences.keyboard.keys["Elevator trim up"].keycode: controls.setters.setElevatorTrimUp.set(); break; case geofs.preferences.keyboard.keys["Elevator trim down"].keycode: controls.setters.setElevatorTrimDown.set(); break;
    case geofs.preferences.keyboard.keys["Elevator trim neutral"].keycode: controls.setters.setElevatorTrimNeutral.set(); break; case 13: controls.recenter(); break; case 16: controls.shiftKeyPressed = !0; break; case 17: controls.controlKeyPressed = !0; break; case 18: controls.altKeyPressed = !0; break; case 27: flight.recorder.playing && (flight.recorder.exitPlayback(), a.preventDefault()); break; case 86: flight.recorder.enterPlayback(); break; case 83: audio.toggleMute(); break; case 80: geofs.togglePause(); break; case 67: geofs.camera.cycle();
      break; case 78: ui.panel.toggle(".geofs-map-list"); break; case 79: ui.panel.toggle(".geofs-preference-list"); break; case 9: geofs.flyToCamera(); break; case 72: geofs.visibilityCycle(); break; case 77: controls.mode == "mouse" ? controls.mouseOnHold = !controls.mouseOnHold : (controls.mouseOnHold = !1, controls.setMode("mouse")); controls.mouseOnHold ? $("body").addClass("geofs-mouseHold") : $("body").removeClass("geofs-mouseHold"); break; case 75: controls.setMode("keyboard"); break; case 74: controls.setMode("joystick"); break; case 81: controls.controlKeyPressed &&
        (geofs.camera.animations.orbitHorizontal.active = !geofs.camera.animations.orbitHorizontal.active); break; case 65: controls.controlKeyPressed && (geofs.camera.animations.orbitVertical.active = !geofs.camera.animations.orbitVertical.active); break; case 82: geofs.resetFlight(); break; case 89: controls.controlKeyPressed && (weather.animate = !weather.animate); break; case 97: geofs.camera.setRotation(45); break; case 98: geofs.camera.setRotation(0); break; case 99: geofs.camera.setRotation(-45); break; case 100: geofs.camera.setRotation(90);
      break; case 101: geofs.camera.setToNeutral(); break; case 102: geofs.camera.setRotation(-90); break; case 103: geofs.camera.setRotation(135); break; case 104: geofs.camera.setRotation(180); break; case 105: geofs.camera.setRotation(-135)
  }a.keyCode >= 48 && a.keyCode <= 57 && (controls.throttle = (a.keyCode - 48) / 9)
};
controls.keyUp = function (a) {
  switch (a.which) {
    case geofs.preferences.keyboard.keys["Bank left"].keycode: controls.states.left = !1; a.returnValue = !1; break; case geofs.preferences.keyboard.keys["Bank right"].keycode: controls.states.right = !1; a.returnValue = !1; break; case geofs.preferences.keyboard.keys["Pitch down"].keycode: controls.states.up = !1; a.returnValue = !1; break; case geofs.preferences.keyboard.keys["Pitch up"].keycode: controls.states.down = !1; a.returnValue = !1; break; case geofs.preferences.keyboard.keys["Steer left"].keycode: controls.states.rudderLeft =
      !1; a.returnValue = !1; break; case geofs.preferences.keyboard.keys["Steer right"].keycode: controls.states.rudderRight = !1; a.returnValue = !1; break; case geofs.preferences.keyboard.keys["Increase throttle"].keycode: case geofs.preferences.keyboard.keys["Increase throttle alt"].keycode: controls.states.increaseThrottle = !1; a.returnValue = !1; break; case geofs.preferences.keyboard.keys["Decrease throttle"].keycode: case geofs.preferences.keyboard.keys["Decrease throttle alt"].keycode: controls.states.decreaseThrottle =
        !1; a.returnValue = !1; break; case geofs.preferences.keyboard.keys["Elevator trim up"].keycode: controls.setters.setElevatorTrimUp.unset(); break; case geofs.preferences.keyboard.keys["Elevator trim down"].keycode: controls.setters.setElevatorTrimDown.unset(); break; case geofs.preferences.keyboard.keys.Brakes.keycode: controls.setters.setBrakes.unset(); break; case 16: controls.shiftKeyPressed = !1; break; case 17: controls.controlKeyPressed = !1; break; case 18: controls.altKeyPressed = !1; break; case 84: ui.chat.showInput()
  }
};
controls.joystick = {}; controls.joystick.deadZoneUp = .1; controls.joystick.deadZoneDown = -.1; controls.joystick.ready = !1; controls.joystick.sticksNumber = 0; controls.joystick.calibrationDurationSeconds = 15;
controls.joystick.poll = function () {
  controls.joystick.sticks = []; if (!controls.joystick.api) return !1; var a = controls.joystick.api.call(navigator); if (a.length > 0) {
    for (var b = 0; b < 5; b++)a[b] && controls.joystick.sticks.push(a[b]); controls.joystick.sticksNumber != controls.joystick.sticks.length && (controls.joystick.info = "", controls.joystick.sticks.forEach(function (c) { controls.joystick.info += c.id + "<br/>" }), controls.joystick.configure(), $(controls.joystick).trigger("joystickReady"), controls.joystick.sticksNumber =
      controls.joystick.sticks.length); return controls.joystick.sticks.length ? controls.joystick.ready = !0 : controls.joystick.ready = !1
  } return controls.joystick.ready = !1
}; controls.joystick.init = function () { controls.joystick.api = ("function" == typeof navigator.getGamepads ? navigator.getGamepads : null) || ("function" == typeof navigator.webkitGetGamepads ? navigator.webkitGetGamepads : null) || null; controls.joystick.poll() };
controls.joystick.configure = function () {
  controls.joystick.oldButtonsValue = 0; controls.joystick.buttons = {}; controls.joystick.axes = {}; controls.joystick.buttonHandlers = []; var a = 0, b = 0; controls.joystick.sticks.forEach(function (c, d) {
    c.hash = geofs.utils.hashCode(c.id); for (var e in c.buttons) {
      var f = c.hash + e; if (geofs.preferences.joystick.buttons[f] && controls.setters[geofs.preferences.joystick.buttons[f]]) {
        var g = controls.setters[geofs.preferences.joystick.buttons[f]].set, k = controls.setters[geofs.preferences.joystick.buttons[f]].unset;
        g && controls.joystick.addButtonListener(f, "buttondown", g); k && controls.joystick.addButtonListener(f, "buttonup", k)
      } controls.joystick.buttons[f] = { stick: d, globalId: a, id: e }; a++
    } for (var m in c.axes) f = c.hash + m, controls.joystick.axes[f] = { stick: d, globalId: b, id: m, enabled: c.axes[m] != 0 }, b++
  })
};
controls.joystick.startCalibration = function () { for (var a in controls.joystick.axes) controls.joystick.axes[a].range = { min: 0, max: 0 }; controls.joystick.calibrating = !0; controls.joystick.calibratingTime = controls.joystick.calibrationDurationSeconds; controls.joystick.calibrationInterval = setInterval(controls.joystick.calibrationStatus, 250); $(".geofs-joystick-calibration .geofs-calibrating").show(); $(".geofs-joystick-calibration .geofs-calibrated").hide(); $(".geofs-joystick-calibration .geofs-joystick-startCalibration").hide() };
controls.joystick.calibrationStatus = function () { controls.joystick.calibratingTime -= .25; $(".geofs-joystick-calibration .geofs-joystick-calibrationProgress").text(parseInt(controls.joystick.calibratingTime)); controls.joystick.calibratingTime <= 0 && controls.joystick.stopCalibration() };
controls.joystick.stopCalibration = function () { clearInterval(controls.joystick.calibrationInterval); controls.joystick.calibrating = !1; $(".geofs-joystick-calibration .geofs-calibrating").hide(); $(".geofs-joystick-calibration .geofs-calibrated").show(); $(".geofs-joystick-calibration .geofs-joystick-startCalibration").show() }; controls.joystick.resetCalibration = function () { for (var a in controls.joystick.axes) geofs.preferences.joystick.calibration[a] = { center: 0, multiplier: 1 } };
controls.joystick.checkButton = function (a) { if (a = controls.joystick.buttons[a]) return controls.joystick.sticks[a.stick].buttons[a.id].pressed }; controls.joystick.getAxisValue = function (a, b, c) { if (controls.joystick.axes && (a = controls.joystick.axes[a])) return clamp(controls.joystick.sticks[a.stick].axes[a.id], b || -1, c || 1) };
controls.updateJoystick = function (a) {
  if (controls.joystick.poll()) {
    for (var b in controls.joystick.axes) {
      var c = controls.joystick.axes[b], d = geofs.preferences.joystick.axis[b], e = geofs.preferences.joystick.calibration[b] || { center: 0, multiplier: 1 }; if (d != "none" && (d = controls.axisSetters[d]) && !(geofs.autopilot.on && !d.overridesAutopilot || flight.sharing.on && !multiplayer.flightSharing.control && d.overridesPeer || flight.recorder.playing)) {
        var f = controls.joystick.getAxisValue(b, d.min, d.max); controls.joystick.calibrating &&
          (c.range.max = Math.max(c.range.max, f), c.range.min = Math.min(c.range.min, f), e = c.range.max - c.range.min, e = { center: c.range.min + e / 2, multiplier: 2 / e }, geofs.preferences.joystick.calibration[b] = e); f = (f - e.center) * e.multiplier; geofs.preferences.joystick.multiplier[b] && (f *= -1); d.process && d.process(f, a)
      }
    } if (controls.joystick.buttons) for (b in controls.joystick.buttons) if ((c = controls.joystick.buttons[b]) && geofs.preferences.joystick.buttons[b] != "none" && (d = c.oldValue, e = controls.joystick.checkButton(b), e != d)) {
      try {
        var g =
          e ? controls.joystick.buttonHandlers.buttondown[b] : controls.joystick.buttonHandlers.buttonup[b]
      } catch (k) { } if (g) for (d = 0; d < g.length; d++)g[d](a); c.oldValue = e
    }
  }
}; controls.joystick.addButtonListener = function (a, b, c) { controls.joystick.buttonHandlers[b] = controls.joystick.buttonHandlers[b] || []; controls.joystick.buttonHandlers[b][a] = controls.joystick.buttonHandlers[a] || []; controls.joystick.buttonHandlers[b][a].push(c) }; controls.applyManipulator = function (a) { a.setter && controls.setters[a.setter].set && controls.setters[a.setter].set() };
controls.updateManipulator = function (a, b) { if (typeof a == "function") try { a(b.ix, b.iy, b.dx, b.dy) } catch (c) { geofs.debug.error(c) } else typeof controls[a.control] != "undefined" && typeof b[a.input] != "undefined" && (b = controls[a.control] + b[a.input] * (a.ratio || 1), a.min && b < a.min && (b = a.min), a.max && b > a.max && (b = a.max), controls[a.control] = b) }; controls.releaseManipulator = function (a) { a.setter && controls.setters[a.setter].unset && controls.setters[a.setter].unset() };
controls.manipulators = { setThrottle: function (a, b, c, d) { controls.throttle = d } };
controls.orientation.init = function () {
  controls.orientation.eventListenerSet || (controls.orientation.centers = null, $(".geofs-orientationCalibrate").show(), geofs.api.hasOrientation() ? (controls.orientation.available = !0, window.addEventListener("deviceorientation", function (a) { controls.orientation.available = !0; controls.orientation.values = [a.gamma, a.beta, a.alpha]; controls.orientation.centers || (controls.orientation.centers = V3.dup(controls.orientation.values), controls.orientation.fixPitch(controls.orientation.centers)) }),
    window.addEventListener("orientationchange", function (a) { controls.orientation.setScreenOrientation() }), controls.orientation.setScreenOrientation(), controls.orientation.eventListenerSet = !0) : controls.orientation.available = !1)
}; controls.orientation.setScreenOrientation = function () { controls.orientation.generalMultiplier = 1; window.orientation < 0 && (controls.orientation.generalMultiplier = -1) };
controls.orientation.requestIOSPermission = function () { typeof DeviceMotionEvent.requestPermission === "function" && DeviceMotionEvent.requestPermission().then(function (a) { controls.orientation.setScreenOrientation() }).catch(console.error); controls.orientation.iOSpermissionRequested = !0 }; controls.orientation.fixPitch = function (a) { a && Math.abs(a[1]) > 90 && (a[0] < 0 && (a[0] += 180), a[0] > 0 && (a[0] -= 180)) }; controls.orientation.recenter = function () { controls.orientation.centers = null; $(".geofs-orientationCalibrate").hide() };
controls.orientation.isAvailable = function () { return controls.orientation.available };
controls.orientation.getNormalizedAxis = function (a) { if (controls.orientation.values) { if (a == 0) return controls.orientation.fixPitch(controls.orientation.values), a = controls.orientation.values[0] - controls.orientation.centers[0], geofs.debug.watch("beta", controls.orientation.values[0]), geofs.debug.watch("centeredPitch", a), a / -30; if (a == 1) return a = controls.orientation.values[1], a > 90 && (a = 180 - a), a < -90 && (a = -180 - a), geofs.debug.watch("gamma", controls.orientation.values[1]), a / 30 } };
controls.orientation.getHtr = function () { return [controls.orientation.values[2], controls.orientation.values[1] + 270, controls.orientation.values[0]] };
controls.updateOrientation = function (a) { if (controls.orientation.centers) { a = controls.orientation.getNormalizedAxis(geofs.preferences.orientation.axis.pitch); var b = controls.orientation.getNormalizedAxis(geofs.preferences.orientation.axis.roll); controls.rawPitch = a * controls.orientation.generalMultiplier; controls.roll = b * controls.orientation.generalMultiplier; controls.yaw = controls.orientation.yaw; controls.keyboard.overrideRudder = !1 } };
controls.updateTouch = function (a) { controls.rawPitch = controls.touch.pitch; controls.roll = controls.touch.roll; controls.yaw = controls.touch.yaw };
geofs.autopilot = {
  on: !1, mode: "HDG", speedMode: "knots", PIDs: {}, values: { course: 0, altitude: 0, speed: 0, verticalSpeed: 0 }, defaults: {
    maxBankAngle: 30, maxPitchAngle: 20, minPitchAngle: -20, baseClimbrate: 700, baseDescentrate: -1E3, maxClimbrate: 6E3, maxDescentrate: -6E3, ILSDescentrate: -2E3, ILSClimbrate: 0, verticalSpeedHoldMargin: 1E3, targetBankAngleRatio: 2, yawBankAngleRatio: .005, pitchAnglePID: [.01, .002, .01], elevatorPitchPID: [.01, .001, 1E-7], bankAnglePID: [.15, .001, .01], aileronsRollPID: [.1, .001, 1E-7], throttlePID: [.1, .001,
      .1], effectivenessRatioMaximum: 1.5
  }, init: function () {
    var a = Object.assign({}, geofs.autopilot.defaults, geofs.aircraft.instance.definition.autopilot); geofs.autopilot.PIDs.pitchAngle = new PID(a.pitchAnglePID[0], a.pitchAnglePID[1], a.pitchAnglePID[2]); geofs.autopilot.PIDs.elevatorPitch = new PID(a.elevatorPitchPID[0], a.elevatorPitchPID[1], a.elevatorPitchPID[2]); geofs.autopilot.PIDs.bankAngle = new PID(a.bankAnglePID[0], a.bankAnglePID[1], a.bankAnglePID[2]); geofs.autopilot.PIDs.aileronsRoll = new PID(a.aileronsRollPID[0],
      a.aileronsRollPID[1], a.aileronsRollPID[2]); geofs.autopilot.PIDs.throttle = new PID(a.throttlePID[0], a.throttlePID[1], a.throttlePID[2]); geofs.autopilot.definition = a; $("#Qantas94Heavy-ap-nav").length > 0 && (geofs.autopilot = controls.autopilot, geofs.autopilot.UI = { update: function () { } }, geofs.autopilot.values = { course: 0, altitude: 0, speed: 0, verticalSpeed: 0 })
  }, setMode: function (a) {
    if (geofs.autopilot.on) {
      a = a || geofs.autopilot.mode; geofs.autopilot.VNAV = !1; geofs.autopilot.currentNAVUnit && (geofs.autopilot.currentNAVUnit =
        null); if (a != "HDG") { if (!geofs.nav.currentNAVUnit) { this.setMode("HDG"); return } geofs.autopilot.currentNAVUnit = geofs.nav.currentNAVUnit; geofs.autopilot.VNAV = geofs.autopilot.currentNAVUnit.VNAV } geofs.autopilot.mode = a
    }
  }, setCourse: function (a, b) { var c = geofs.autopilot.values.course; try { geofs.autopilot.values.course = fixAngle360(a), geofs.nav.setHDG(geofs.autopilot.values.course), geofs.autopilot.mode == "NAV" && (b || geofs.autopilot.setMode("NOR")) } catch (d) { geofs.autopilot.values.course = c } }, setAltitude: function (a,
    b) { b = geofs.autopilot.values.altitude; try { geofs.autopilot.values.altitude = a } catch (c) { geofs.autopilot.values.altitude = b } }, setSpeed: function (a, b) { b = geofs.autopilot.values.speed; try { geofs.autopilot.values.speed = a } catch (c) { geofs.autopilot.values.speed = b } }, setSpeedMode: function (a) {
      a != geofs.autopilot.speedMode && (a == "mach" ? (geofs.autopilot.values.speed = Number(geofs.utils.knotsToMach(geofs.autopilot.values.speed).toFixed(2)), $(".geofs-autopilot-mach").addClass("numberValue").val(geofs.autopilot.values.speed),
        $(".geofs-autopilot-knots").removeClass("numberValue"), $(".geofs-speed-mode .switchLeft").removeClass("green-pad"), $(".geofs-speed-mode .switchRight").addClass("green-pad")) : (geofs.autopilot.values.speed = parseInt(geofs.utils.machToKnots(geofs.autopilot.values.speed)), $(".geofs-autopilot-mach").removeClass("numberValue"), $(".geofs-autopilot-knots").addClass("numberValue").val(geofs.autopilot.values.speed), $(".geofs-speed-mode .switchLeft").addClass("green-pad"), $(".geofs-speed-mode .switchRight").removeClass("green-pad")),
        geofs.autopilot.speedMode = a)
    }, setVerticalSpeed: function (a) { var b = geofs.autopilot.values.verticalSpeed; if (a) { geofs.autopilot.values.verticalSpeed || (a = geofs.autopilot.targetVerticalSpeed || 0); try { geofs.autopilot.values.verticalSpeed = parseInt(clamp(a, geofs.autopilot.definition.maxDescentrate, geofs.autopilot.definition.maxClimbrate)) } catch (c) { geofs.autopilot.values.verticalSpeed = b } } else geofs.autopilot.values.verticalSpeed = null }, update: function (a) {
      if (geofs.autopilot.on) {
        var b = geofs.animation.values, c =
          geofs.autopilot, d = c.definition, e = clamp(b.kias / 150, 1, 5), f = clamp(b.kias / 100, 1, d.effectivenessRatioMaximum), g = geofs.autopilot.currentNAVUnit; if (g && g.inRange && g.LNAV) {
            if (c.mode == "NAV") { var k = clamp(g.courseDeviation * 10, -45, 45); k = fixAngle360(g.course + k); c.setCourse(k, !0) } else c.mode == "NOR" && Math.abs(g.courseDeviation) < 4.5 && (c.setMode("NAV"), c.setCourse(g.course, !0)); geofs.autopilot.VNAV && c.setVerticalSpeed(g.height / (g.distance / geofs.aircraft.instance.groundSpeed / 60) * METERS_TO_FEET * (g.direction == "to" ? -1 :
              1) + g.glideAngleDeviation * geofs.aircraft.instance.groundSpeed * 10)
          } g = fixAngle(fixAngle360(b.heading) - c.values.course); g = clamp(g * d.targetBankAngleRatio, -d.maxBankAngle, d.maxBankAngle); c.PIDs.bankAngle.set(g, -d.maxBankAngle, d.maxBankAngle); k = c.PIDs.bankAngle.compute(b.aroll, a); c.PIDs.aileronsRoll.set(k, -1, 1); controls.roll = -c.PIDs.aileronsRoll.compute(controls.roll, a) / f; controls.yaw = -g * d.yawBankAngleRatio; if (!geofs.autopilot.VNAV) {
            var m = c.values.altitude - b.altitude; g = clamp(e * d.baseClimbrate, 0, d.maxClimbrate);
            k = clamp(e * d.baseDescentrate, d.maxDescentrate, 0); c.targetVerticalSpeed = clamp(m * 2 * e, k, g)
          } c.values.verticalSpeed && (!geofs.autopilot.VNAV && Math.abs(m) < d.verticalSpeedHoldMargin && Math.abs(c.targetVerticalSpeed) < Math.abs(c.values.verticalSpeed) ? c.setVerticalSpeed(null) : c.targetVerticalSpeed = c.values.verticalSpeed); c.PIDs.pitchAngle.set(c.targetVerticalSpeed, d.minPitchAngle, d.maxPitchAngle); d = c.PIDs.pitchAngle.compute(b.verticalSpeed, a); c.PIDs.elevatorPitch.set(d, -1, 1); controls.rawPitch = c.PIDs.elevatorPitch.compute(-b.atilt,
            a) / f; c.PIDs.throttle.set(c.values.speed, 0, 1); controls.throttle = c.PIDs.throttle.compute(geofs.autopilot.speedMode == "knots" ? b.kias : b.mach, a); controls.throttle = clamp(controls.throttle, 0, 1)
      }
    }, toggle: function () { geofs.autopilot.on ? geofs.autopilot.turnOff() : geofs.autopilot.turnOn() }, resetPIDs: function () { for (var a in geofs.autopilot.PIDs) geofs.autopilot.PIDs[a].reset() }, turnOn: function () {
      if (geofs.aircraft.instance.definition.autopilot) {
        var a = geofs.animation.values; geofs.autopilot.resetPIDs(); geofs.autopilot.setAltitude(a.altitude);
        geofs.autopilot.setCourse(a.heading); geofs.autopilot.setSpeed(a.kias); geofs.autopilot.setVerticalSpeed(a.verticalSpeed); var b = clamp(a.kias / 100, 1, geofs.autopilot.definition.effectivenessRatioMaximum); geofs.autopilot.PIDs.pitchAngle.initialize(-a.atilt, a.verticalSpeed); geofs.autopilot.PIDs.elevatorPitch.initialize(controls.rawPitch * b, -a.atilt); geofs.autopilot.PIDs.throttle.initialize(controls.throttle, a.kias); geofs.autopilot.on = !0; $(document).trigger("autopilotOn")
      }
    }, turnOff: function () {
      geofs.autopilot.on =
        !1; $(document).trigger("autopilotOff")
    }
};
geofs.autopilot.UI = {
  values: { course: 0, altitude: 0, speed: 0, verticalSpeed: 0 }, init: function () {
    var a = this; this.$autopilotPad = $(".geofs-autopilot-pad"); this.$autopilotHDGButton = $(".geofs-autopilot-HDG"); this.$autopilotNavButton = $(".geofs-autopilot-NAV"); this.$displays = {}; this.$displays.course = $(".geofs-autopilot-course"); this.$displays.altitude = $(".geofs-autopilot-altitude"); this.$displays.speed = $(".geofs-autopilot-speed"); this.$displays.verticalSpeed = $(".geofs-autopilot-verticalSpeed"); $(document).on("autopilotOn",
      function () { clearTimeout(geofs.autopilot.autopilotPadTimeout); a.$autopilotPad.removeClass("red-pad").addClass("green-pad"); a.update(); a.$displays.course.trigger("change"); a.$displays.altitude.trigger("change"); a.$displays.speed.trigger("change"); a.$displays.verticalSpeed.trigger("change"); $(".geofs-autopilot-controls").show(); $(".geofs-autopilot-toggle").html("Engaged").addClass("mdl-button--colored") }); $(document).on("autopilotOff", function () {
        a.$autopilotPad.removeClass("green-pad").addClass("red-pad");
        $(".geofs-autopilot-controls").hide(); $(".geofs-autopilot-toggle").html("Disengaged").removeClass("mdl-button--colored"); clearTimeout(geofs.autopilot.autopilotPadTimeout); geofs.autopilot.autopilotPadTimeout = setTimeout(function () { a.$autopilotPad.removeClass("red-pad").removeClass("green-pad") }, 3E3)
      }); $(document).on("pointerdown keydown change update wheel", ".numberUp, .numberDown, .numberValue", function (b) {
        var c = $(b.currentTarget), d = $(b.currentTarget).parent().find(".numberValue"), e = Number(d.attr("smallstep")),
          f = Number(d.attr("stepthreshold")), g = Number(d.attr("step")), k = Number(d.attr("min")), m = Number(d.attr("max")), n = Number(d.attr("decimals")) || 0, q = Math.pow(10, n), u = 0, z = 0; if (c.hasClass("numberUp") || b.which == 38) u = 1; if (c.hasClass("numberDown") || b.which == 40) u = -1; b.type == "wheel" && (u = b.originalEvent.deltaY > 0 ? -1 : 1); c = d.val(); e && (u > 0 && c < f && (g = e), u < 0 && c <= f && (g = e)); z = g * u; z *= q; var B = d.attr("data-loop"), p = d.attr("data-method"), r = function () {
            var A = d.val(); A *= q; A = parseInt(Math.round(A)) || 0; if (z) {
              var I = A % z; A = I > 0 ? z > 0 ? A +
                (z - I) : A - I : A + z
            } A = Number((A / q).toFixed(n)); A = B && A > m ? k : B && A < k ? m : clamp(A, k, m); d.val(A); b.type != "update" && (geofs.autopilot[p](A), clearTimeout(window.spinnerRepeat))
          }, C = function () { r(); clearTimeout(window.spinnerRepeat); window.spinnerRepeat = setTimeout(C, 50) }; z && (r(), b.type != "wheel" && (window.spinnerRepeat = setTimeout(C, 500))); b.type != "change" && b.type != "update" || r(); b.stopImmediatePropagation()
      }).on("pointerup pointercancel mouseleave touchend", ".numberUp, .numberDown", function () { clearTimeout(window.spinnerRepeat) }).on("pointerup",
        ".switchLeft, .switchMiddle, .switchRight", function (b) { var c = $(b.currentTarget); b = c.attr("value"); c = c.attr("data-method"); geofs.autopilot[c](b) }).on("click", ".geofs-autopilot-pad", function (b) { geofs.autopilot.toggle() }).on("keyup", ".numberValue", function (b) { clearTimeout(window.spinnerRepeat); b.stopImmediatePropagation() })
  }, update: function () {
    var a = geofs.autopilot, b; for (b in this.values) {
      var c = a.values[b] == null ? "-----" : Number(a.values[b]); this.values[b] != c && (this.$displays[b].val(c).trigger("update"),
        this.values[b] = c)
    } if ((b = geofs.autopilot.currentNAVUnit) && (b.inRange != this.inRange || b != this.navUnit) || a.mode != this.mode) {
      a.mode == "HDG" && (this.$autopilotHDGButton.addClass("green-pad"), this.$autopilotNavButton.removeClass("orange-pad").removeClass("green-pad")); a.mode == "NOR" && this.$autopilotHDGButton.addClass("green-pad"); a.mode == "NAV" && this.$autopilotHDGButton.removeClass("green-pad"); if (a.mode == "NAV" || a.mode == "NOR") {
        if (!b.LNAVCapable) { a.setMode("HDG"); return } b.inRange ? this.$autopilotNavButton.removeClass("orange-pad").addClass("green-pad") :
          this.$autopilotNavButton.removeClass("green-pad").addClass("orange-pad")
      } b ? (this.inRange = b.inRange, this.navUnit = b) : (this.inRange = !1, this.navUnit = null); this.mode = a.mode
    }
  }
}; ui = ui || {}; ui.hud = {}; ui.hud.autopilotIndicator = function () { };
geofs.map = {
  dontMoveTimeoutValue: 1E4, mapUpdateInterval: 10, minimumPanRatio: .4, cloudLayerUpdatePeriod: 18E5, init: function (a, b, c) {
    var d = this; this._options = a = a || {}; geofs.api.map.init(a, b || 0, c || 0); this.navaidsLayer = geofs.api.map.addLayer("navaids"); a.standalone || (this.planeMarker = new geofs.api.map.marker({ zIndex: 1E3, icon: geofs.api.map.getIcon("yellow", geofs.map.icons.yellow) }), this.planeMarker.addToMap(), geofs.setInputHandlers(".geofs-map-list"), geofs.setPreferenceValues(".geofs-map-list")); this.setMouseClickBehavior();
    a.standalone && (this.mapActive = !0); geofs.api.map.updateMarkerLayers(); this.ATCMode = !1; $(document).on("click", ".geofs-map-atc-button", function (e) { d.toggleATCMode(); e.preventDefault(); e.stopPropagation() })
  }, runwayMarkerRadius: 7, runwayMarkerPopup: function (a) {
    a = a.options.runway; var b = a.lat + "," + a.lon, c = a.name.split("|"); if (a.type == "ILS") var d = geofs.nav.isNavaidInRange(a), e = a.freq / 1E3 + "MHz"; return '<div class="geofs-map-popup"><header><span class="mdl-chip"><span class="geofs-map-runway-chipIcon mdl-chip__contact mdl-color-text--white">' +
      c[0] + '</span><span class="mdl-chip__text">' + c[1] + " (" + c[2] + ')</span></span></header><button class="mdl-button mdl-js-button mdl-button--fab mdl-button--colored mdl-button--mini-fab" href="http://flyto://' + b + ",0," + a.heading + '" title="Take-off from"><i class="material-icons">flight_takeoff</i></button><button class="mdl-button mdl-js-button mdl-button--fab mdl-button--colored mdl-button--mini-fab" href="http://flyto://' + b + ",1000," + a.heading + '" title="Fly by"><i class="material-icons">flight</i></button><button class="mdl-button mdl-js-button mdl-button--fab mdl-button--colored mdl-button--mini-fab" href="http://flyto://' +
      b + ",0," + a.heading + ',approach,4800,450" title="Approach"><i class="material-icons">flight_land</i></button><button class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab geofs-addToFlightPlan" title="Set Flight Plan Departure" onclick="geofs.flightPlan.setDeparture(' + a.id + ');geofs.api.map.closeAllPopups();"><i class="material-icons">flight_takeoff</i></button><button class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab geofs-addToFlightPlan" title="Set Flight Plan Arrival" onclick="geofs.flightPlan.setDestination(' +
      a.id + ');geofs.api.map.closeAllPopups();"><i class="material-icons">flight_land</i></button>' + (a.type == "ILS" ? '<span class="mdl-chip" title="Tune in ILS" onclick="geofs.nav.selectNavaid(' + a.id + '); geofs.api.map.closeAllPopups();" style="cursor: pointer;" ><span class="geofs-map-radio-chipIcon mdl-chip__contact mdl-color-text--white"><i class="material-icons">sensors</i></span><span class="mdl-chip__text">' + e + (d ? "" : " (Out of range)") + "</span></span>" : "") + "</div>"
  }, navaidMarkerPopup: function (a) {
    a = a.options.navaid;
    var b = a.lat + "," + a.lon, c = geofs.nav.isNavaidInRange(a), d; a.freq >= 1E3 && (d = a.freq / 1E3 + "MHz"); a.freq < 1E3 && (d = a.freq + "KHz"); a.freq == "GPS" && (d = "GPS"); return '<div class="geofs-map-popup"><header><span class="mdl-chip"><span class="mdl-chip__text"><b>' + a.type + '</b> <span class="geofs-navaidName">' + a.name + " (" + a.icao + ")</span> " + (a.ident ? '<code class="geofs-morse"><span>' + a.ident + "</span>" + geofs.utils.textToMorse(a.ident) + "</code>" : "") + (a.type == "FIX" ? '<i class="material-icons" title="Remove FIX" onclick="geofs.nav.removeNavaid(' +
      a.id + '); geofs.api.map.closeAllPopups();">delete</i>' : "") + '</span></span></header><button class="mdl-button mdl-js-button mdl-button--fab mdl-button--colored mdl-button--mini-fab" href="http://flyto://' + b + ',1000,0" title="Fly by"><i class="material-icons">flight</i></button><button class="mdl-button mdl-js-button mdl-button--fab mdl-button--mini-fab geofs-addToFlightPlan" title="Add to Flight Plan" onclick="geofs.flightPlan.addNavaidAsWaypoint(' + a.id + ');geofs.api.map.closeAllPopups();"><i class="material-symbols-outlined"">list_alt_add</i></button><span type="button" class="mdl-chip" title="Tune in NAV" onclick="geofs.nav.selectNavaid(' +
      a.id + ');geofs.api.map.closeAllPopups();" style="cursor: pointer;" ><span class="geofs-map-radio-chipIcon mdl-chip__contact mdl-color-text--white"><i class="material-icons">sensors</i></span><span class="mdl-chip__text">' + d + "</span></span>" + (c ? "" : '<span class="mdl-chip geofs-outofrange"><span class="mdl-chip__text">Out of range</span></span>') + "</div>"
  }, icons: {
    ILS: { url: "images/map/icons/ils.png?v=1", size: [30, 30], anchor: [0, 0], offset: [0, 15], minZoom: 8 }, DME: {
      url: "images/map/icons/dme.png", size: [20, 20],
      anchor: [10, 10], minZoom: 5
    }, NDB: { url: "images/map/icons/ndb.png", size: [40, 40], anchor: [20, 20], minZoom: 7 }, "NDB-DME": { url: "images/map/icons/ndb-dme.png", size: [40, 40], anchor: [20, 20], minZoom: 7 }, TACAN: { url: "images/map/icons/tacan.png", size: [20, 20], anchor: [10, 10], minZoom: 6 }, VOR: { url: "images/map/icons/vor.png", size: [20, 20], anchor: [10, 10], minZoom: 6 }, "VOR-DME": { url: "images/map/icons/vor-dme.png", size: [20, 20], anchor: [10, 10], minZoom: 6 }, VORTAC: { url: "images/map/icons/vortac.png", size: [20, 20], anchor: [10, 10], minZoom: 6 },
    FIX: { url: "images/map/icons/fixflyby.png", size: [30, 30], anchor: [15, 15], minZoom: 1 }, WPT: { url: "images/map/icons/wptflyby.png", size: [40, 40], anchor: [20, 20], minZoom: 1 }, yellow: { url: geofs.localUrl + "images/map/icons/yellow.png", size: [40, 40], anchor: [20, 20], className: "geofs-myself-icon" }, blue: { url: geofs.localUrl + "images/map/icons/blue.png", size: [30, 30], anchor: [15, 15], className: "geofs-map-icon" }, traffic: { url: geofs.localUrl + "images/map/icons/blue.png", size: [20, 20], anchor: [10, 10], className: "geofs-traffic-icon" }
  },
  resize: function () { geofs.api.map._map.invalidateSize() }, addRunwayMarker: function (a) { geofs.api.map.addLayeredMarker(a.major ? "major" : "minor", { coords: [a.lat, a.lon], radius: geofs.map.runwayMarkerRadius, color: "#ffffff", zIndex: 1E3, fillColor: a.major ? "#184888" : "#ffd200", popup: geofs.map.runwayMarkerPopup, pane: "overlayPane", popupMinWidth: 200, closeButton: !1, keepToFront: !0, runway: a }) }, addNavaidMarker: function (a) {
    var b = this.icons[a.type]; if (b) {
      var c = { url: b.url, size: b.size, rotate: a.heading || 0 }; b.offset && (c.offset =
        b.offset); b = { coords: [a.lat, a.lon], opacity: b.opacity, radius: b.size[0] / 2, zIndex: 1, img: c, popupMinWidth: 200, closeButton: !1, pane: "overlayPane", navaid: a, minZoom: b.minZoom }; a.type != "ILS" && (b.popup = geofs.map.navaidMarkerPopup); a = new geofs.api.map.marker(b); a.addToMap(); return a
    }
  }, getLocationPopupContent: function (a) {
    a = a[0] + "," + a[1]; return '<div class="geofs-map-popup" style="width: 150px;"><button class="mdl-button mdl-js-button" href="http://flyto://' + a + ', 0, 0, true">Ground</button><button class="mdl-button mdl-js-button" href="http://flyto://' +
      a + ', 457, 0, true">1,000 feet</button><button class="mdl-button mdl-js-button" href="http://flyto://' + a + ', 1524, 0, true">5,000 feet</button><button class="mdl-button mdl-js-button" href="http://flyto://' + a + ', 3048, 0, true">10,000 feet</button><button class="mdl-button mdl-js-button" href="http://flyto://' + a + ', 10668, 0, true">35,000 Feet</button><span type="button" class="mdl-chip" title="Add GPS FIX" onclick="let navaid = geofs.nav.addGPSFIX([' + a + ']);geofs.api.map.closeAllPopups();" style="cursor: pointer;" ><span class="geofs-map-radio-chipIcon geofs-map-radio-chipIcon-FIX mdl-chip__contact mdl-color-text--white"><i class="material-icons">change_history</i></span><span class="mdl-chip__text">GPS FIX</span></span></div>'
  },
  mapClickHandler: function (a) { var b = $(a.target).closest("[href]").attr("href"); if (b && (b = b.split("://"), b[1] == "flyto")) { b = b[2].split(","); var c = parseFloat(b[3]), d = [parseFloat(b[0]), parseFloat(b[1]), parseFloat(b[2]), c]; b[4] == "approach" ? (c *= DEGREES_TO_RAD, c = xy2ll(V2.scale([Math.sin(c), Math.cos(c)], parseFloat(b[5])), d), d[0] -= c[0], d[1] -= c[1], d[2] = d[2] * FEET_TO_METERS + parseFloat(b[6]), d[4] = !1) : d[4] = b[4]; geofs.flyTo(d); geofs.api.map.closeAllPopups(); a.preventDefault() } }, setMouseClickBehavior: function () {
    var a =
      this; geofs.api.map._map.on("contextmenu click", function (b) { if (b.originalEvent.button == 2 || b.type == "contextmenu" && geofs.isMobileDevice || geofs.platform == "ios") { if (geofs.platform == "ios" && geofs.api.map.genericPopupIsOpenForIOS) geofs.api.map.genericPopupIsOpenForIOS = !1; else { var c = geofs.api.map.getCoordsFromMouseEvent(b); geofs.api.map.openGenericPopup(a.getLocationPopupContent(c), c); geofs.api.map.genericPopupIsOpenForIOS = !0 } b.originalEvent.preventDefault() } }); $(geofs.api.map._holder).click(function (b) {
        try {
          a.mapClickHandler &&
            (a.mapClickHandler(b), a.stopMovingMap())
        } catch (c) { }
      }).on("mousedown touchstart", function () { a.stopMovingMap(!0) }).on("mouseup touchend", function () { a.stopMovingMap() })
  }, stopMap: function () { this.mapActive = !1 }, startMap: function () { this.stopMap(); this.resize(); geofs.preferences.weather.manual ? this.hideWeather() : this.showWeather(); this.mapActive = !0; geofs.nav.loadNavaidsAndRunways() }, stopMovingMap: function (a) {
    var b = this; clearTimeout(this.dontMoveTimeout); a || (this.dontMoveTimeout = setTimeout(function () {
      b.dontMove =
        !1; b.updateMap(geofs.aircraft.instance.llaLocation, !0)
    }, this.dontMoveTimeoutValue)); this.dontMove = !0
  }, updateMap: function (a, b) {
    var c = a[0], d = a[1], e = geofs.utils.now(); if (!(e - this.lastMapUpdate < this.mapUpdateInterval) || b) if (this.lastMapUpdate = e, geofs.api.map && this.mapActive) {
      if (!this.dontMove && geofs.preferences.interface.recenterMap) {
        geofs.api.map.getCenterLla(); e = geofs.api.map.getPixelSize(); var f = e.x / 2, g = e.y / 2; a = geofs.api.map.llaToPixel(a); var k = [0, 0]; geofs.flightPlan.isOpen && (k = [0, -$(".geofs-flightPlan")[0].offsetHeight /
          3]); (Math.max(Math.abs(a.x - f + k[0]), Math.abs(a.y - g + k[1])) > e.x * this.minimumPanRatio || b) && geofs.api.map.updateMap(c, d, k)
      } this.updatePlaneMarker(c, d, geofs.aircraft.instance.htr[0]); this.weatherOverlay && geofs.utils.updateTime(this, this.cloudLayerUpdatePeriod) && (this.hideWeather(), this.showWeather())
    }
  }, updatePlaneMarker: function (a, b, c) { this.planeMarker.update(a, b, c) }, addPlayerMarker: function (a, b, c) {
    ui.playerMarkers[a] || (b = { coords: [0, 0], icon: geofs.api.map.getIcon(b, geofs.map.icons[b || "blue"]), label: c || "-" },
      ui.playerMarkers[a] = new geofs.api.map.marker(b)); geofs.api.map._map && this.mapActive && ui.playerMarkers[a].addToMap(); return ui.playerMarkers[a]
  }, updatePlayerMarker: function (a, b, c, d, e, f) {
    if (geofs.api.map._map && this.mapActive && (ui.playerMarkers[a] || this.addPlayerMarker(a, d, c), ui.playerMarkers[a])) {
      var g = parseInt(b[2] * METERS_TO_FEET); d = fixAngle360(b[3]); c = (c || "-") + "<br/>" + (e != "unknown" ? "" + e + "<br/>" : "") + f + "kt " + parseInt(d) + "dg<br/>" + geofs.utils.displayAltitude(g); ui.playerMarkers[a].update(b[0], b[1], d,
        c)
    }
  }, deletePlayerMarker: function (a) { ui.playerMarkers[a] && ui.playerMarkers[a].destroy(); ui.playerMarkers[a] = null; delete ui.playerMarkers[a] }, toggleATCMode: function () { this.ATCMode = !this.ATCMode; this.setTooltipVisibility(this.ATCMode); $(geofs.api.map._holder).toggleClass("geofs-atc-map") }, setTooltipVisibility: function (a) { this.tooltipVisibility = a; geofs.api.map.setTooltipVisibility(a); if (geofs.api.map._map && this.mapActive) for (var b in ui.playerMarkers) ui.playerMarkers[b].resetTooltip() }, showWeather: function () {
    var a =
      this; this.weatherOverlay || (this.weatherOverlay = geofs.api.map.addImageLayer(weather.realTimeCloudMap + "?t=" + geofs.utils.hourStamp(), 1, [[70, -180], [-70, 180]]), this.weatherOverlayZoomHandler = function () { a.weatherOverlay.setOpacity(clamp(1.3 - geofs.api.map._map.getZoom() * .1, 0, 1)) }, geofs.api.map._map.on("zoomend", this.weatherOverlayZoomHandler))
  }, hideWeather: function () {
    this.weatherOverlay && geofs.api.map.removeImageLayer(this.weatherOverlay); this.weatherOverlayZoomHandler && geofs.api.map._map.off("zoomend",
      this.weatherOverlayZoomHandler); this.weatherOverlay = null
  }
};
geofs.nav = {
  navaidsAndRunwaysLoaded: !1, fixesLoaded: !1, navaids: [], navaidsICAOMap: {}, frequencies: [], units: { GPS: {}, NAV1: {}, ADF: {} }, currentNAVUnit: null, HDG: 0, ADFManCourse: 0, types: {
    RNW: { range: Infinity, GPS: !0, DME: !0, LNAV: !0, VNAV: !1, RNAV: !1 }, WPT: { range: Infinity, GPS: !0, DME: !0, LNAV: !0, VNAV: !1, RNAV: !0 }, FIX: { range: Infinity, GPS: !0, DME: !0, LNAV: !0, VNAV: !1, RNAV: !0 }, DST: { range: Infinity, ILS: !0, GPS: !0, DME: !0, LNAV: !0, VNAV: !0, RNAV: !1 }, ILS: { range: 33E3, ILS: !0, DME: !0, LNAV: !0, VNAV: !0, RNAV: !1 }, DME: {
      range: 48E4, DME: !0, LNAV: !1,
      VNAV: !1, RNAV: !1
    }, NDB: { range: 14E4, ADF: !0, LNAV: !1, VNAV: !1, RNAV: !1 }, "NDB-DME": { range: 14E4, ADF: !0, DME: !0, LNAV: !1, VNAV: !1, RNAV: !1 }, VOR: { range: 24E4, VOR: !0, LNAV: !0, VNAV: !1, RNAV: !1 }, "VOR-DME": { range: 24E4, VOR: !0, DME: !0, LNAV: !0, VNAV: !1, RNAV: !1 }, TACAN: { range: 24E4, VOR: !0, DME: !0, LNAV: !0, VNAV: !1, RNAV: !1 }, VORTAC: { range: 24E4, VOR: !0, DME: !0, LNAV: !0, VNAV: !1, RNAV: !1 }
  }, init: function () { this.$NAVFrenquency = $(".geofs-nav-frequency"); this.$NAVModeButton = $('[name="NAV1MODE"]'); this.$GPSModeButton = $('[name="GPSMODE"]') }, loadFixes: function () {
    geofs.nav.FixesLoaded ||
      $.getJSON("data/fixes.json" + geofs.killCache, function (a) { geofs.nav.fixes = a[0]; geofs.nav.FixesLoaded = !0 })
  }, loadNavaidsAndRunways: function () {
    var a = this; geofs.nav.navaidsAndRunwaysLoaded || ($.getJSON("data/navaids.json" + geofs.killCache, function (b) { b.forEach(function (c) { a.addNavaid({ icao: c[0], ident: c[1], name: c[2], type: c[3], lat: c[4], lon: c[5], freq: c[6], magDec: c[7], DMEfreq: c[8] }) }); geofs.api.map.updateMarkerLayers(); geofs.nav.navaidsAndRunwaysLoaded = !0 }), $.getJSON("data/runways.json" + geofs.killCache, function (b) {
      b.forEach(function (c) {
        runway =
          { name: c[0], heading: c[1], lat: c[2], lon: c[3], major: c[4], freq: c[5], ident: c[6], slope: c[7] }; c = runway.name.split("|"); runway.icao = c[2]; runway.type = runway.freq ? "ILS" : "RNW"; geofs.nav.addNavaid(runway); geofs.map.addRunwayMarker(runway)
      }); geofs.api.map.updateMarkerLayers()
    }))
  }, addNavaid: function (a) {
    a.id = this.navaids.length; this.navaids.push(a); this.navaidsICAOMap[a.icao] = this.navaidsICAOMap[a.icao] || []; var b = [a.lat, a.lon]; b.navaid = a; this.navaidsICAOMap[a.icao].push(b); this.frequencies[a.freq] = this.frequencies[a.freq] ||
      []; this.frequencies[a.freq].push(a); a.marker = geofs.map.addNavaidMarker(a); return a
  }, getNavaid: function (a) { return this.navaids[a] }, removeNavaid: function (a) { var b = this.navaids[a]; b && (b.assignedToUnit && this.clear(b.assignedToUnit), b.marker && b.marker.destroy(), this.navaids[a] = null, delete this.navaidsICAOMap[b.icao]) }, addWaypoint: function (a, b, c) { return this.addNavaid({ icao: b || "WPT", ident: "", name: b || "WPT", type: c || "WPT", lat: a[0], lon: a[1], freq: "GPS", magDec: 0, DMEfreq: null }) }, addGPSFIX: function (a, b) {
    return this.addNavaid(geofs.nav.generateGPSFIXNavaid(a,
      b))
  }, generateGPSFIXNavaid: function (a, b, c, d) { var e = a[0].toFixed(3) + " " + a[1].toFixed(3); return FIXNavaid = { icao: b || "FIX", ident: d || "", name: c || "GPS: " + e, type: "FIX", lat: a[0], lon: a[1], freq: "GPS", magDec: 0, DMEfreq: null } }, selectNavaid: function (a, b) {
    if (a = geofs.nav.navaids[a]) {
      var c = geofs.nav.types[a.type]; c.GPS ? (geofs.nav.setNavaid(a, "GPS"), geofs.nav.setNAVMode("GPS", "GPS", b)) : c.ADF ? geofs.radio.tuneADFFrequency(a.freq) : (geofs.radio.tuneNAVFrequency(a.freq, null, "NAV1"), c.LNAV && geofs.nav.setNAVMode("NAV", "NAV1",
        b)); geofs.radio.scanFrequenciesAround(); geofs.radio.show(); geofs.autopilot.setMode()
    }
  }, setNAVMode: function (a, b, c) {
    if (this.currentNAVUnit) { if (this.currentNAVUnit.NAVMode == a && !c) return; this.currentNAVUnit.isCurrentNAV = !1; this.currentNAVUnitName = this.currentNAVUnit = this.currentNAVUnit.NAVMode = null } if (a && b) {
      c = this.units[b]; a == "NAV" && (this.$NAVFrenquency.removeClass("GPS"), this.$NAVModeButton.addClass("on"), this.$GPSModeButton.removeClass("on"), geofs.radio.displayNAVFrequency(null, "NAV1"), geofs.radio.displayOBS(c.OBS));
      if (a == "GPS") { if (!c.navaid) return; this.$NAVFrenquency.addClass("GPS"); this.$NAVModeButton.removeClass("on"); this.$GPSModeButton.addClass("on"); geofs.radio.displayNAVFrequency(c.navaid.type); geofs.radio.displayOBS(c.OBS) } c.NAVMode = a; c.isCurrentNAV = !0; this.currentNAVUnit = c; this.currentNAVUnitName = b
    } geofs.autopilot.setMode(); geofs.animation.setValue("NAVMODE", a)
  }, setNavaid: function (a, b) {
    var c = geofs.nav.types[a.type]; a = $.extend(!0, a, c); b = c.ADF ? "ADF" : b || "NAV1"; unit = this.units[b]; if (unit.navaid && (unit.navaid.id !=
      a.id && geofs.nav.currentNAVUnitName != b && this.clear(b), unit.navaid.id == a.id)) return; unit.navaid = a; a.assignedToUnit = b; unit.inRange = this.isNavaidInRange(a); unit.LNAVCapable = c.LNAV; unit.VNAVCapable = c.VNAV; unit.RNAVCapable = c.RNAV; unit.LNAV = unit.inRange && c.LNAV; unit.VNAV = unit.inRange && c.VNAV; unit.RNAV = unit.inRange && c.RNAV; unit.course = 0; unit.glideAngleDeviation = 0; unit.bearingToStation = 0; unit.courseDeviation = 0; c.VOR ? this.setOBS(b, parseInt(this.computeBearingToNavaid(a)), null, !0) : c.ILS ? a.runway || (a.runway =
        geofs.runways.newRunwayFromNavaidObject(a), a.lat = a.runway.aimingPointLla1[0], a.lon = a.runway.aimingPointLla1[1]) : c.GPS && this.setOBS(b, "TRK"); a.elevation || (a.elevation = 0, geofs.api.getGuarantiedGroundAltitude([a.lat, a.lon, 0]).then(function (d) { a.elevation = d[0].height || 0 }))
  }, setOBS: function (a, b, c, d) { a = a || geofs.nav.currentNAVUnitName || "NAV1"; a = this.units[a]; b == "TRK" ? a.OBS = b : (a.OBS == "TRK" && (a.OBS = parseInt(a.bearing || 0)), a.OBS = fixAngle360(b != null ? b : a.OBS + parseInt(c))); d && geofs.radio.displayOBS(a.OBS) }, setHDG: function (a,
    b, c) { this.HDG = fixAngle360(a != null ? a : this.HDG + b); c && geofs.autopilot.setCourse(this.HDG); geofs.animation.setValue("navHDG", this.HDG) }, setADFManCourse: function (a, b) { this.ADFManCourse = fixAngle360(a != null ? a : this.ADFManCourse + b); geofs.animation.setValue("ADFManCourse", this.ADFManCourse) }, clear: function (a) {
      if (a) {
        if (a = this.units[a]) a.navaid && (a.navaid.assignedToUnit = null, a.navaid.runway && a.navaid.runway.destroy()), a.OBS = null, a.navaid = null, a.inRange = !1, a.LNAVCapable = !1, a.VNAVCapable = !1, a.RNAVCapable = !1, a.LNAV =
          !1, a.VNAV = !1, a.RNAV = !1, a.isCurrentNAV && this.setNAVMode(null)
      } else for (var b in this.units) this.clear(b)
    }, isNavaidInRange: function (a) { return geofs.utils.distanceBetweenLocations([geofs.aircraft.instance.llaLocation[0], geofs.aircraft.instance.llaLocation[1]], [a.lat, a.lon]) < geofs.nav.types[a.type].range ? !0 : !1 }, update: function (a) { this.hasDME = !1; for (var b in this.units) this.updateUnit(a, b) }, computeBearingToNavaid: function (a) {
      return geofs.utils.bearingBetweenLocations([geofs.aircraft.instance.llaLocation[0],
      geofs.aircraft.instance.llaLocation[1]], [a.lat, a.lon])
    }, updateUnit: function (a, b) {
      var c = this.units[b], d = c.navaid; if (d) {
        var e = geofs.nav.types[d.type], f = geofs.aircraft.instance.htr[0], g = geofs.utils.distanceBetweenLocations([geofs.aircraft.instance.llaLocation[0], geofs.aircraft.instance.llaLocation[1]], [d.lat, d.lon]), k = Math.abs(g - c.distance); c.distance = g; c.bearing = this.computeBearingToNavaid(d); c.height = geofs.aircraft.instance.llaLocation[2] - d.elevation; c.glideAngle = Math.atan2(c.height, c.distance) * RAD_TO_DEGREES;
        c.glideAngleDeviation = 0; e.VOR ? (c.course = c.OBS, c.LNAV = c.inRange, c.VNAV = !1, c.RNAV = !1) : e.ILS ? (c.course = d.heading, c.glideAngleDeviation = (d.slope || STANDARD_GLIDE_ANGLE) - c.glideAngle, c.LNAV = c.inRange || d.fromFlightPlan, c.VNAV = c.inRange || d.fromFlightPlan, c.RNAV = !1) : e.ADF ? (c.course = f, c.LNAV = !1, c.VNAV = !1, c.RNAV = !1) : e.GPS && (c.course = c.OBS == "TRK" ? c.bearing : c.OBS, c.LNAV = !0, c.VNAV = !1, c.RNAV = !0); c.bearingToStation = fixAngle(f - c.bearing); c.courseDeviation = fixAngle(c.bearing - c.course); Math.abs(c.courseDeviation) > 90 ?
          (c.direction = "from", c.courseDeviation = -fixAngle(c.courseDeviation - 180)) : c.direction = "to"; e.DME && c.inRange ? (this.hasDME = !0, c.DME = (Math.sqrt(c.distance * c.distance + c.height * c.height) * METERS_TO_NM).toFixed(1), c.speedToSignal = Math.round(k / a * MS_TO_KNOTS), c.timeToSignal = Math.round(c.distance / geofs.aircraft.instance.groundSpeed / 60)) : (c.DME = "---", c.speedToSignal = "---", c.timeToSignal = "---"); c.distance > e.range || c.glideAngle > 50 && !e.GPS && !d.fromFlightPlan ? (c.inRange = !1, c.course = 0, c.courseDeviation = 0, c.glideAngleDeviation =
            0, c.direction = "", c.distance = 0, c.DME = "---", c.speedToSignal = "---", c.timeToSignal = "---") : c.inRange = !0; this.setUnitAnimationValue(c, b); c.isCurrentNAV && this.setUnitAnimationValue(c, "NAV")
      }
    }, setUnitAnimationValue: function (a, b) {
      geofs.animation.setValue(b + "Course", a.course); geofs.animation.setValue(b + "OBS", a.OBS); geofs.animation.setValue(b + "BearingToStation", a.bearingToStation); geofs.animation.setValue(b + "CourseDeviation", a.courseDeviation); geofs.animation.setValue(b + "Direction", a.direction); geofs.animation.setValue(b +
        "Distance", a.distance); geofs.animation.setValue(b + "DME", a.DME); geofs.animation.setValue(b + "SpeedToSignal", a.speedToSignal); geofs.animation.setValue(b + "TimeToSignal", a.timeToSignal); geofs.animation.setValue(b + "Bearing", a.bearing); geofs.animation.setValue(b + "GlideAngleDeviation", a.glideAngleDeviation); geofs.animation.setValue(b + "InRange", a.inRange); geofs.animation.setValue(b + "LNAV", a.LNAV); geofs.animation.setValue(b + "VNAV", a.VNAV); geofs.debug.watch(b + "LNAV", a.LNAV); geofs.debug.watch(b + "VNAV", a.VNAV)
    }
};
geofs.flightPlan = {
  mapPath: [], waypointArray: [], isInitialized: !1, isOpen: !1, trackedWaypoint: null, totalDistance: 0, totalTime: 0, DMEMargin: 6E-4, legColor: "#f67df6", activeLegColor: "#b100b1", init: function () { this.isInitialized || (this.isInitialized = !0, ui.addMouseUpHandler(geofs.flightPlan.closeWaypointDropdown), $(".geofs-flightPlan").on("keyup", function (a) { a.which == 27 && geofs.flightPlan.closeWaypointDropdown() }), $(document).on("flyto", geofs.flightPlan.refreshWaypoints)) }, toggle: function () {
    geofs.flightPlan.isOpen ?
      ($(".geofs-map-list").removeClass("geofs-flightPlanOpen"), $(".geofs-flightPlan-pad").removeClass("blue-pad"), geofs.flightPlan.isOpen = !1) : ($(".geofs-map-list").addClass("geofs-flightPlanOpen"), $(".geofs-flightPlan-pad").addClass("blue-pad"), geofs.flightPlan.isOpen = !0, geofs.nav.loadFixes(), this.init(), componentHandler.upgradeDom())
  }, gotoWaypoint: function (a) {
    var b = geofs.flightPlan.waypointArray[a]; if (a < geofs.flightPlan.waypointArray.length - 1) {
      var c = b.alt === "" ? geofs.aircraft.instance.llaLocation[2] : geofs.utils.parseAltitude(b.alt) *
        FEET_TO_METERS; geofs.flyTo([b.lat, b.lon, c, b.heading || geofs.flightPlan.waypointArray[a + 1].track, !0]); this.selectWaypoint(a + 1)
    }
  }, update: function (a) {
    if (geofs.flightPlan.waypointArray.length) if (!geofs.flightPlan.trackedWaypoint) geofs.flightPlan.selectWaypoint(0); else if (geofs.flightPlan.trackedWaypoint.id != geofs.flightPlan.waypointArray.length - 1) {
      a = geofs.animation.getValue(geofs.nav.currentNAVUnitName + "DME"); var b = clamp(geofs.flightPlan.DMEMargin * geofs.aircraft.instance.llaLocation[2], 1, 100); a < b && geofs.flightPlan.selectWaypoint(geofs.flightPlan.trackedWaypoint.id +
        1); geofs.flightPlan.isOpen && (geofs.flightPlan.distanceLeft = geofs.flightPlan.totalDistance - (geofs.flightPlan.trackedWaypoint.distanceThusfar - a), $(".flightPlanDistance").html("(" + parseInt(geofs.flightPlan.distanceLeft) + "nm)"))
    }
  }, selectWaypoint: function (a) {
    var b = geofs.flightPlan.waypointArray[a]; if (b) if (b.valid) {
      geofs.flightPlan.trackedWaypoint && (geofs.flightPlan.trackedWaypoint.selected = !1, $(".geofs-flightPlanWaypoint.geofs-selected").removeClass("geofs-selected")); b.navaid || (b.navaid = geofs.nav.addWaypoint([b.lat,
      b.lon], b.ident), b.type == "DST" && (b.navaid.type = "DST", b.navaid.heading = b.heading), geofs.nav.types[b.navaid.type] || (b.navaid.type = "WPT"), b.navaid.fromFlightPlan = !0); if (b.alt !== "") { alt = geofs.utils.parseAltitude(b.alt); a = parseInt(alt * FEET_TO_METERS); if (isNaN(a) || isNaN(alt)) return; geofs.autopilot.setAltitude(alt, !0) } if (b.spd) {
        a = parseInt(b.spd); geofs.autopilot.setSpeedMode("knots"); (b.spd + "").toUpperCase().substr(0, 1) == "M" && (geofs.autopilot.setSpeedMode("mach"), a = parseFloat(b.spd.substr(1))); if (isNaN(a)) return;
        geofs.autopilot.setSpeed(a, !0)
      } geofs.radio.clear("NAV1"); geofs.nav.selectNavaid(b.navaid.id, !0); geofs.flightPlan.trackedWaypoint = b; geofs.flightPlan.trackedWaypoint.selected = !0; geofs.flightPlan.refreshWaypoints()
    } else geofs.flightPlan.selectWaypoint(a + 1)
  }, setDeparture: function (a) { geofs.flightPlan.addNavaidAsWaypoint(a, "DPT") }, setDestination: function (a) { geofs.flightPlan.addNavaidAsWaypoint(a, "DST") }, addFixAsWaypoint: function (a, b, c) { geofs.flightPlan.setWaypoint({ id: c, ident: a, lat: b[0], lon: b[1], type: "FIX" }) },
  addNavaidAsWaypoint: function (a, b, c) { a = geofs.nav.navaids[a]; geofs.flightPlan.setWaypoint({ id: c, ident: a.icao || a.ident, lon: a.lon, lat: a.lat, type: b || a.type, heading: a.heading }) }, setWaypoint: function (a) {
    a = Object.assign({ ident: "", lat: "", lon: "", distance: "", track: "", alt: "", spd: "" }, a); var b = geofs.flightPlan.waypointArray.length; a.id !== void 0 ? geofs.flightPlan.waypointArray[a.id] = a : (a.id = b, a.type == "DPT" ? (a.alt = 0, geofs.flightPlan.waypointArray.unshift(a)) : a.type == "DST" ? (a.alt = 0, geofs.flightPlan.waypointArray.push(a)) :
      b && geofs.flightPlan.waypointArray[b - 1].type == "DST" ? geofs.flightPlan.waypointArray.splice(-1, 0, a) : geofs.flightPlan.waypointArray.push(a)); geofs.flightPlan.refreshWaypoints()
  }, createWaypointHTML: function (a) {
    var b = a.lat ? a.lat.toFixed(2) + "," + a.lon.toFixed(2) : ""; a = '<div class="geofs-flightPlanWaypoint' + (a.selected ? " geofs-selected" : "") + '" id="flightPlanWaypoint' + a.id + '"><span class="geofs-waypointIdent" onclick="geofs.flightPlan.selectWaypoint(' + a.id + ');">' + a.ident + '<span class="geofs-waypointCoords">' +
      b + '</span></span><span class="geofs-waypointProperty">' + a.distanceNM.toFixed(1) + 'nm<span class="geofs-waypointCoords">(' + a.distanceThusfar + 'nm)</span></span><span class="geofs-waypointProperty">' + a.track + '\u00b0</span><div class="mdl-textfield mdl-js-textfield"><input class="mdl-textfield__input" type="text" id="alt' + a.id + '" value="' + a.alt + '" onchange="geofs.flightPlan.setWaypointAltitude(this, ' + a.id + ');"><label class="mdl-textfield__label" for="alt' + a.id + '">Ft.</label></div><div class="mdl-textfield mdl-js-textfield" style="margin-right: 0px;"><input class="mdl-textfield__input" type="text" id="spd' +
      a.id + '" value="' + a.spd + '" onchange="geofs.flightPlan.setWaypointSpeed(this, ' + a.id + ');"><label class="mdl-textfield__label" for="spd' + a.id + '">Kts/M.</label></div><button class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons" onclick="geofs.flightPlan.selectWaypoint(' + a.id + ');">check</i></button><button class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons" onclick="geofs.flightPlan.gotoWaypoint(' + a.id + ');">fast_forward</i></button>' + (a.type != "DPT" && a.type !=
        "DST" ? '<button class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons" onclick="geofs.flightPlan.moveWaypoint(' + a.id + ', -1);">arrow_upward</i></button>' : "") + (a.type != "DPT" && a.type != "DST" ? '<button class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons" onclick="geofs.flightPlan.moveWaypoint(' + a.id + ', 1);">arrow_downward</i></button>' : "") + '<button class="mdl-button mdl-js-button mdl-button--icon"><i class="material-icons" onclick="geofs.flightPlan.deleteWaypoint(' +
      a.id + ');">close_small</i></button></div>'; $(".geofs-flightPlanList").append(a)
  }, setWaypointAltitude: function (a, b) { a = $(a).val(); geofs.flightPlan.waypointArray[b].alt = a }, setWaypointSpeed: function (a, b) { a = $(a).val(); geofs.flightPlan.waypointArray[b].spd = a }, setFixDistance: function (a, b) { for (var c = 0, d = b.length; c < d; c++)b[c].distance = geofs.utils.llaDistanceInMeters(a, b[c]) }, searchWaypoint: function (a, b) {
    try { var c = $(a).val().toUpperCase().trim() } catch (g) { } if (c) {
      a = []; var d = c.split(","); d.length > 1 && !isNaN(d[0]) &&
        !isNaN(d[1]) && (a[0] = [parseFloat(d[0]), parseFloat(d[1])], c = "FIX"); var e; a = a.concat((e = geofs.nav.fixes[c]) != null ? e : []); var f; a = a.concat((f = geofs.nav.navaidsICAOMap[c]) != null ? f : []); a.length > 1 ? (geofs.flightPlan.setFixDistance(geofs.aircraft.instance.llaLocation, a), a.sort(function (g, k) { return g.distance - k.distance }), geofs.flightPlan.generateWaypointDropdown(c, a, b)) : a[0] && (e = a[0], e.navaid ? geofs.flightPlan.addNavaidAsWaypoint(e.navaid.id, e.navaid.type, b) : geofs.flightPlan.addFixAsWaypoint(c, e, b), geofs.flightPlan.refreshWaypoints())
    }
  },
  closeWaypointDropdown: function () { $(".geofs-waypointDropdown").remove(); $(".geofs-addWaypoint input").val("") }, generateWaypointDropdown: function (a, b, c) {
    c == void 0 && (c = ""); var d = '<div class="geofs-waypointDropdown control-pad control-pad-label">'; b.forEach(function (e) {
      if (e.navaid.type == "RNW" || e.navaid.type == "ILS") d += '<i class="material-icons" style="vertical-align: middle;" title="Set as departure" onmouseup="geofs.flightPlan.setDeparture(' + e.navaid.id + ');geofs.flightPlan.closeWaypointDropdown();">flight_takeoff</i>',
        d += '<i class="material-icons" style="vertical-align: middle;" title="Set as destination" onmouseup="geofs.flightPlan.setDestination(' + e.navaid.id + ');geofs.flightPlan.closeWaypointDropdown();">flight_land</i>'; d += '<div class="geofs-waypointResult" '; e.navaid ? (d += 'onmouseup="geofs.flightPlan.addNavaidAsWaypoint(' + e.navaid.id + ",'" + e.navaid.type + "'", d += c != "" ? ",'" + c + "'" : "", d += ');geofs.flightPlan.closeWaypointDropdown();">', d += " " + e.navaid.name + " [" + e.navaid.type + "]") : (d += "onmouseup=\"geofs.flightPlan.addFixAsWaypoint('" +
          a + "',[" + e[0] + "," + e[1] + "]", d += c !== "" ? ",'" + c + "'" : "", d += ');geofs.flightPlan.closeWaypointDropdown();">', d += " lat: " + e[0] + ", lon: " + e[1]); d += " (" + (e.distance * METERS_TO_NM).toFixed(1) + "nm)</div>"; d += "<br/>"
    }); d += "</div>"; geofs.flightPlan.closeWaypointDropdown(); $("#flightPlanWaypoint" + c).append(d)
  }, moveWaypoint: function (a, b) {
    b = clamp(a + b, 0, geofs.flightPlan.waypointArray.length - 1); geofs.flightPlan.waypointArray[b].type != "DPT" && geofs.flightPlan.waypointArray[b].type != "DST" && (a = geofs.flightPlan.waypointArray.splice(a,
      1)[0], geofs.flightPlan.waypointArray.splice(b, 0, a), geofs.flightPlan.refreshWaypoints())
  }, deleteWaypoint: function (a) { if (a = geofs.flightPlan.waypointArray.splice(a, 1)[0]) geofs.flightPlan.selectWaypoint(a.id), a.navaid && a.navaid.fromFlightPlan && geofs.nav.removeNavaid(a.navaid.id), geofs.flightPlan.refreshWaypoints() }, refreshWaypoints: function () {
    $(".geofs-flightPlanList").html(""); geofs.api.map.clearPath(geofs.flightPlan.mapPath); var a = [geofs.aircraft.instance.llaLocation[0], geofs.aircraft.instance.llaLocation[1]],
      b; geofs.flightPlan.totalDistance = 0; geofs.flightPlan.totalTime = 0; geofs.flightPlan.waypointArray.forEach(function (c, d) {
        c.id = d; if (d > 0) { var e = geofs.flightPlan.waypointArray[d - 1]; e.lat && e.lon && (a = [e.lat, e.lon]) } else a = [c.lat, c.lon]; c.lat && c.lon && (b = [c.lat, c.lon], c.distanceNM = geofs.utils.distanceBetweenLocations(a, b) * METERS_TO_NM, geofs.flightPlan.totalDistance = parseInt(geofs.flightPlan.totalDistance + c.distanceNM), c.distanceThusfar = geofs.flightPlan.totalDistance, c.track = parseInt(geofs.utils.bearingBetweenLocations(a,
          b)), c.valid = !0); geofs.flightPlan.createWaypointHTML(c); d > 0 && geofs.api.map.createGreatCirclePath(geofs.flightPlan.mapPath, a, b, { weight: 3, color: c.selected ? geofs.flightPlan.activeLegColor : geofs.flightPlan.legColor })
      }); componentHandler.upgradeDom()
  }, paste: function (a) {
    var a, b; return (0, $jscomp.asyncExecutePromiseGeneratorProgram)(function (c) {
      if (c.nextAddress == 1) return c.setCatchFinallyBlocks(2), c.yield(navigator.clipboard.readText(), 4); if (c.nextAddress != 2) return a = c.yieldResult, geofs.flightPlan.import(a),
        c.leaveTryBlock(0); b = c.enterCatchBlock(); geofs.debug.log(b); c.jumpToEnd()
    })
  }, copy: function () { var a; return (0, $jscomp.asyncExecutePromiseGeneratorProgram)(function (b) { if (b.nextAddress == 1) return b.setCatchFinallyBlocks(2), b.yield(navigator.clipboard.writeText(geofs.flightPlan.export()), 4); if (b.nextAddress != 2) return b.leaveTryBlock(0); a = b.enterCatchBlock(); geofs.debug.log(a); b.jumpToEnd() }) }, importSimBrief: function () {
    if (geofs.preferences.simBriefUsername) try {
      var a = "https://www.simbrief.com/api/xml.fetcher.php?username=" +
        geofs.preferences.simBriefUsername + "&json=v2"; $.getJSON(a, function (b) { a = b.fms_downloads.directory + b.fms_downloads.gfs.link; $.getJSON(a, function (c) { geofs.flightPlan.import(c) }) })
    } catch (b) { geofs.api.notify("Failed to load SimBrief flightplan."), geofs.debug.log(b) } else geofs.api.notify('Please setup a <a href="https://dispatch.simbrief.com/home" target="_blank" rel="nofollow">SimBrief</a> account and enter your username in the GeoFS option panel to be able to use this import function')
  }, import: function (a) {
    var b =
      []; a instanceof Object || (a = JSON.parse(a)); b = a.nodes ? a.nodes : a; b.forEach(function (c, d) { c.ident || (c.ident = "----"); c.alt == void 0 && (c.alt = ""); c.spd == void 0 && (c.spd = "") }); geofs.flightPlan.waypointArray = b; geofs.flightPlan.refreshWaypoints()
  }, export: function () { var a = [], b; geofs.flightPlan.waypointArray.forEach(function (c, d) { b = { ident: c.ident, type: c.type, lat: c.lat, lon: c.lon }; c.alt != void 0 && (b.alt = c.alt); c.spd != void 0 && (b.spd = c.spd); c.heading != void 0 && (b.heading = c.heading); a.push(b) }); return JSON.stringify(a) },
  upload: function (a) { a = a.files[0]; var b = new FileReader; b.onload = function (c) { geofs.flightPlan.import(c.target.result) }; b.onerror = function (c) { geofs.debug.log(c) }; b.readAsText(a) }, download: function (a) { if (!(geofs.flightPlan.waypointArray.length < 2)) { var b = geofs.flightPlan.waypointArray[0].ident + "-" + geofs.flightPlan.waypointArray[geofs.flightPlan.waypointArray.length - 1].ident + ".json", c = new Blob([geofs.flightPlan.export()], { type: "text/plain" }); window.URL.createObjectURL(c); a.download = b; a.href = window.URL.createObjectURL(c) } },
  clear: function () { window.confirm("Clear the whole flight plan?") && (geofs.flightPlan.waypointArray = [], geofs.flightPlan.trackedWaypoint = null, geofs.flightPlan.refreshWaypoints(), $(".flightPlanDistance").html("")) }
};
geofs.radio = {
  visible: !1, units: { NAV1: { frequency: 0, rawFrequency: 0 }, ADF: { frequency: 0, rawFrequency: 0 } }, frequencyScanInterval: 5E3, NAVFrequencyRange: [108E3, 117950], ADFFrequencyRange: [190, 1750], init: function () {
    var a = this; this.$radioNavFreq = $('[name="NAVFrequency"]'); this.$radioADFFreq = $('[name="ADFFrequency"]'); this.$radioOBSDisplay = $('[name="radioOBS"]'); this.$radioDMEDisplay = $('[name="dme"]'); this.$radioGroundSpeedDisplay = $('[name="groundSpeed"]'); this.$radioTTSDisplay = $('[name="timeToStation"]'); $(document).on("keydown keyup change",
      ".geofs-radio-display", function (b) { var c = $(b.currentTarget), d = c.val(); switch (c.attr("name")) { case "ADFFrequency": geofs.radio.tuneADFFrequency(d); break; case "NAVFrequency": geofs.radio.tuneNAVFrequency(d, null, "NAV1"); break; case "radioOBS": geofs.nav.setOBS(null, d) }b.stopImmediatePropagation() }); $(document).on("click", ".geofs-radio-pad", function (b) { geofs.radio.toggle(); b.preventDefault(); b.stopImmediatePropagation() }); $(document).on("click", ".geofs-radio-ident", function (b) {
        b = b.currentTarget; var c = b.getAttribute("data-unit");
        $(".geofs-radio-ident").removeClass("on"); a.units[c].identEnabled ? geofs.radio.disableAllIdent() : (b.classList.add("on"), geofs.radio.disableAllIdent(), geofs.radio.enableUnitIdent(c))
      }); this.navKnob = new Indicator({
        container: ".geofs-nav-frequency", overlay: {
          url: "images/instruments/radioknob.png", class: "geofs-radio-knob", size: { x: 40, y: 40 }, anchor: { x: 20, y: 20 }, position: { x: -5, y: 25 }, rescale: !1, rescalePosition: !1, manipulator: function (b, c) { geofs.radio.tuneNAVFrequency(null, c, "NAV1") }, animations: [{
            type: "rotate",
            value: "NAV1Frequency", ratio: -.1
          }]
        }
      }); this.adfKnob = new Indicator({ container: ".geofs-adf-frequency", overlay: { url: "images/instruments/radioknob.png", class: "geofs-radio-knob", size: { x: 40, y: 40 }, anchor: { x: 20, y: 20 }, position: { x: -5, y: 25 }, rescale: !1, rescalePosition: !1, manipulator: function (b, c) { geofs.radio.tuneADFFrequency(null, c) }, animations: [{ type: "rotate", value: "ADFFrequency", ratio: -2 }] } }); this.OBSKnob = new Indicator({
        container: ".geofs-radio-OBS", overlay: {
          url: "images/instruments/radioknob.png", class: "geofs-radio-knob",
          size: { x: 40, y: 40 }, anchor: { x: 20, y: 20 }, position: { x: -5, y: 25 }, rescale: !1, rescalePosition: !1, manipulator: function (b, c) { instruments.manipulators.setNAVOBS(null, c) }, animations: [{ type: "rotate", value: "NAV1OBS", ratio: -1 }]
        }
      }); setInterval(function () { a.scanFrequenciesAround() }, this.frequencyScanInterval)
  }, scanUnitFrequency: function (a) {
    var b = geofs.nav.frequencies[this.units[a].frequency]; if (b && b.length) return geofs.utils.sortLocationByDistance(geofs.aircraft.instance.llaLocation, b), geofs.nav.setNavaid(b[0], a), this.startIdent(a),
      b[0]; this.stopIdent(a); geofs.nav.clear(a); return !1
  }, scanFrequenciesAround: function () { for (var a in this.units) this.scanUnitFrequency(a) }, tuneNAVFrequency: function (a, b, c) {
    var d = this.units[c]; d.rawFrequency = a || parseFloat(d.rawFrequency) || 0; b != void 0 && (d.rawFrequency += b * 10); d.rawFrequency = clamp(d.rawFrequency, this.NAVFrequencyRange[0], this.NAVFrequencyRange[1]); a = Math.round(d.rawFrequency / 100 * 2) / .02; a != d.frequency && (d.frequency = a, geofs.animation.setValue(c + "Frequency", d.frequency), this.displayNAVFrequency(null,
      c), this.scanUnitFrequency(c) && geofs.nav.setNAVMode("NAV", "NAV1"))
  }, tuneADFFrequency: function (a, b) { var c = this.units.ADF; c.rawFrequency = a || parseFloat(c.rawFrequency) || 0; b && (c.rawFrequency += b * .5); c.rawFrequency = clamp(c.rawFrequency, this.ADFFrequencyRange[0], this.ADFFrequencyRange[1]); a = Math.round(c.rawFrequency); a != c.frequency && (c.frequency = a, geofs.animation.setValue("ADFFrequency", c.frequency), this.displayADFFrequency(), this.scanUnitFrequency("ADF")) }, displayNAVFrequency: function (a, b) {
    b = this.units[b ||
      "NAV1"]; this.$radioNavFreq.val(a || (b.frequency / 1E3).toFixed(2))
  }, displayADFFrequency: function (a) { this.$radioADFFreq.val(a || this.units.ADF.frequency) }, displayOBS: function (a) { this.$radioOBSDisplay.val(a) }, clear: function (a) {
    if (a) { var b = this.units[a]; if (!b) return; b.frequency = 0; b.rawFrequency = 0 } else for (b in this.units) this.clear(b); switch (a) { case "NAV1": case "NAV2": this.displayNAVFrequency(" "); this.displayOBS(" "); break; case "ADF": this.displayADFFrequency(" ") }this.$radioDMEDisplay.val(""); this.$radioGroundSpeedDisplay.val("");
    this.$radioTTSDisplay.val("")
  }, enableUnitIdent: function (a) { this.units[a].identEnabled = !0; this.startIdent(a) }, disableAllIdent: function () { for (var a in this.units) this.units[a].identEnabled = !1; this.stopIdent() }, startIdent: function (a) {
    if (this.units[a].identEnabled) {
      var b = geofs.nav.units[a], c = b.navaid; c && ((c = c.ident, b.inRange) ? c != this.units[a].indenting && (this.stopIdent(), this.units[a].indenting = c, a = c.split("").map(function (d) { return "sounds/morse/" + d + ".ogg" }), this.identSequencer = audio.impl.html5.playSequence(a,
        1E4)) : this.stopIdent())
    }
  }, stopIdent: function (a) { if (!a || this.units[a].identEnabled) { for (var b in this.units) this.units[b].indenting = null; this.identSequencer && (this.identSequencer.stop(), this.identSequencer = null) } }, update: function (a) {
    this.visible && (this.$radioDMEDisplay.val(geofs.animation.getValue("NAVDME")), this.$radioGroundSpeedDisplay.val(geofs.animation.getValue("NAVSpeedToSignal")), this.$radioTTSDisplay.val(geofs.animation.getValue("NAVTimeToSignal")), this.navKnob.update(), this.adfKnob.update(),
      this.OBSKnob.update())
  }, toggle: function () { geofs.radio.visible ? geofs.radio.hide() : geofs.radio.show() }, show: function () { geofs.radio.visible || (geofs.radio.visible = !0, $(".geofs-radio-pad").addClass("blue-pad"), $(".geofs-radio-controls").show(), geofs.nav.loadNavaidsAndRunways()) }, hide: function () { geofs.radio.visible && (geofs.radio.visible = !1, $(".geofs-radio-pad").removeClass("blue-pad"), $(".geofs-radio-controls").hide()) }
}; "use strict"; var weather = window.weather || {};
geofs.weatherServer = geofs.weatherServer || "/backend/weather/"; weather.METARProxy = geofs.weatherServer + "metar.php?icao="; weather.realTimeCloudTexture = geofs.weatherServer + "clouds-2048.jpg"; weather.realTimeCloudMap = geofs.weatherServer + "clouds.png"; weather.minimumCloudCover = 10; weather.updateRate = 6E4; weather.timeRatio = 1; weather.seasonRatio = 1; weather.contrailTemperatureThreshold = -30; weather.contrailAltitude = 1E4;
weather.defaults = { cloudCover: 0, cloudBase: 1E3, cloudTop: 3E3, cloudThickness: 4E3, cloudCoverThickness: 200, fogDensity: 0, fogCeiling: 1E3, fogBottom: 0, precipitationType: "none", precipitationAmount: 0, thunderstorm: 0, visibility: 1E4, windDirection: 0, windSpeedMS: 0, windGustMS: 0, windLayerHeight: 7E3, windLayerNb: 3, turbulences: 0, thermals: 0, airPressureSL: AIR_PRESSURE_SL, airTemperatureSL: AIR_TEMP_SL }; weather.definition = Object.assign({}, weather.defaults);
weather.definitionBounds = { cloudCover: [0, 100], cloudBase: [0, 1E4], cloudTop: [0, 1E4], fogDensity: [0, 1], precipitationAmount: [0, 1], thunderstorm: [0, 1], windDirection: [0, 360], windSpeedMS: [0, 100], windGustMS: [0, 100], turbulences: [0, 1], thermals: [0, 1] };
weather.init = function (a) {
  weather.currentWindVector = [0, 0, 0]; weather.currentWindVectorWC = new Cesium.Cartesian3(0, 0, 0); weather.currentWindDirection = 0; weather.currentWindSpeed = 0; weather.currentWindSpeedMs = 0; weather.activeWindLayer = 0; weather.windLayers = []; geofs.fx.cloudManager.init(a); weather.reset(a); weather.interval = setInterval(function () { weather.refresh() }, weather.updateRate); weather.generateDefinition(a); weather.refresh(a); weather.atmosphere.init(); a = function (b, c) {
    b = ("00" + parseInt((c % 1).toFixed(2) *
      60)).slice(-2); c = parseInt(c); $(this).find(".slider-input-overlay").html(c + ":" + b)
  }; $(document).on("change", ".geofs-timeSlider", a); a.call($(".geofs-timeSlider"), null, geofs.preferences.weather.localTime); a = function (b, c) { var d; c >= 0 && (d = "Spring"); c > 25 && (d = "Summer"); c > 50 && (d = "Autumn"); c > 75 && (d = "Winter"); $(this).find(".slider-input-overlay").html(d) }; $(document).on("change", ".geofs-seasonSlider", a); a.call($(".geofs-seasonSlider"), null, geofs.preferences.weather.season); weather.manualWeatherUIContainer = $(".geofs-manualWeather")
};
weather.reset = function (a) { weather.set(Object.assign({}, weather.defaults), a); weather.refresh(a) };
weather.refresh = function (a) {
  a = a || geofs.camera.lla; var b = function (e) { if (e) try { var f = JSON.parse(e) } catch (g) { geofs.debug.error(g, "weather.refresh error parsing JSON data") } f = f || []; f.timestamp = geofs.utils.now(); weather.set(Object.assign({}, weather.defaults, weather.definition, f), a) }, c = parseInt(Math.abs(a[0])); weather.isSnowable = Math.abs(c) > 39 || geofs.groundElevation > 3E3 ? !0 : !1; if (geofs.preferences.weather.manual) weather.generateDefinition(a), weather.set(weather.manualDefinition, a); else {
    var d = []; geofs.runways.getNearRunways(a).map(function (e) { d.push(e[0]) });
    d = d.join(","); d != "" ? (c = weather.METARProxy + d + "&kc" + geofs.utils.now(), $.ajax(c, { success: b, error: b })) : b()
  }
}; weather.sanitizedDefinition = function (a) { for (var b in weather.definitionBounds) a[b] = clamp(a[b], weather.definitionBounds[0], weather.definitionBounds[1]); return a };
weather.generateDefinition = function (a, b) {
  a = a || geofs.camera.lla; a = parseInt(Math.abs(a[0])); var c = geofs.preferences.weather.localTime, d = weather.timeRatio, e = geofs.preferences.weather.quality, f = e / 100, g = geofs.preferences.weather.season; weather.roundedLatitude = a; weather.manualQuality = e; weather.manualSeason = g; weather.manualTimeOfDay = c; b && (geofs.preferences.weather.advanced.clouds = Math.min(100, e * 2), geofs.preferences.weather.advanced.cloudBase = weather.defaults.cloudBase, geofs.preferences.weather.advanced.cloudThickness =
    500 + weather.defaults.cloudThickness * e * .02, geofs.preferences.weather.advanced.cloudTop = weather.defaults.cloudBase + (geofs.preferences.weather.advanced.cloudThickness || weather.defaults.cloudThickness), geofs.preferences.weather.advanced.fog = (1 - Math.abs(d - .5) * 2) * (f > .45 ? 1 - f : 0) * 100, geofs.preferences.weather.advanced.fogCeiling = geofs.groundElevation * 2 + 50 || 0, geofs.preferences.weather.advanced.precipitationAmount = e > 50 ? (e - 50) * 2 : 0, geofs.preferences.weather.advanced.windSpeedMS = e / 6, geofs.preferences.weather.advanced.turbulences =
    f * Math.abs(d - .5) * 2, geofs.preferences.weather.advanced.thermals = Math.min(1, f * 4) * Math.abs(d - .5) * 2); weather.manualDefinition = {
      cloudCover: geofs.preferences.weather.advanced.clouds || weather.defaults.cloudCover, cloudBase: geofs.preferences.weather.advanced.cloudBase || weather.defaults.cloudBase, cloudTop: (geofs.preferences.weather.advanced.cloudBase || weather.defaults.cloudBase) + (geofs.preferences.weather.advanced.cloudThickness || weather.defaults.cloudThickness), fogDensity: geofs.preferences.weather.advanced.fog ||
        weather.defaults.fogDensity, fogBottom: 0, fogCeiling: geofs.preferences.weather.advanced.fogCeiling || weather.defaults.fogCeiling, precipitationAmount: geofs.preferences.weather.advanced.precipitationAmount || weather.defaults.precipitationAmount, precipitationType: g > 75 && weather.isSnowable ? "snow" : "rain", thunderstorm: e > 90 ? (e - 90) * 10 : 0, visibility: 1E4, windDirection: geofs.preferences.weather.advanced.windDirection || weather.defaults.windDirection, windSpeedMS: geofs.preferences.weather.advanced.windSpeedMS || weather.defaults.windSpeedMS,
      windGustMS: (geofs.preferences.weather.advanced.windSpeedMS || weather.defaults.windSpeedMS) / 4, windLayerHeight: 7E3, windLayerNb: 3, turbulences: geofs.preferences.weather.advanced.turbulences || weather.defaults.turbulences, thermals: geofs.preferences.weather.advanced.thermals || weather.defaults.thermals, airTemperatureSL: clamp((100 - g - Math.abs(a)) * .4 * (1 - d), -50, 50), timestamp: geofs.utils.now()
    }; return weather.manualDefinition
};
weather.setManual = function () { $('[gespref="geofs.preferences.weather.quality"]').removeClass("geofs-disabled"); $(".geofs-advancedWeather .slider").addClass("geofs-disabled"); var a = weather.generateDefinition(null, !0); weather.set(a); geofs.setPreferenceValues(weather.manualWeatherUIContainer, !0) };
weather.setAdvanced = function () { $('[gespref="geofs.preferences.weather.quality"]').addClass("geofs-disabled"); $(".geofs-advancedWeather .slider").removeClass("geofs-disabled"); geofs.preferences.weather.advanced.precipitationAmount > 0 && (geofs.preferences.weather.advanced.clouds = Math.max(geofs.preferences.weather.advanced.clouds, geofs.preferences.weather.advanced.precipitationAmount * 2)); geofs.setPreferenceValues(weather.manualWeatherUIContainer, !0); var a = weather.generateDefinition(); weather.set(a) };
weather.set = function (a, b) {
  a = weather.sanitizedDefinition(a || weather.definition || {}); b = b || geofs.camera.lla; weather.setDateAndTime(b); geofs.fx.dayNightManager.init(); geofs.preferences.weather.manual ? ($(".geofs-manualWeather").show(), $(".geofs-metarDisplay").html("").parent().hide(), weather.generateDefinition()) : ($(".geofs-manualWeather").hide(), $(".geofs-metarDisplay").html(a.METAR).parent().show()); weather.definition = Object.assign({}, weather.defaults, a); a = weather.definition.precipitationAmount * .01;
  weather.initWind(weather.definition.windDirection, weather.definition.windSpeedMS); weather.definition.windSpeedMS > 0 ? (weather.windActive = !0, weather.setWindIndicatorVisibility(!0)) : (weather.windActive = !1, weather.windOff(), weather.setWindIndicatorVisibility(!1)); weather.definition.fog = weather.definition.fogDensity * .01; weather.definition.backgroundFogDensity = clamp((a - .5) * 4, 0, 2); weather.definition.coverHalfThickness = weather.definition.cloudCoverThickness / 2; b = weather.definition.cloudCover; b < weather.minimumCloudCover &&
    (weather.definition.cloudCover = 0); geofs.api.renderingSettings.volumetricClouds && (b = 0); geofs.fx.cloudManager.instance.setCloudCover(b); weather.definition.precipitationAmount > 0 ? geofs.fx.precipitation.create(weather.definition.precipitationType, weather.definition.precipitationAmount) : geofs.fx.precipitation.destroy(); weather.belowCloudsBrightness = clamp(1 - a, 0, 1); weather.currentWindVectorWC = new Cesium.Cartesian3(0, 0, 0); weather.windLayers.length && (weather.currentWindVectorWC = weather.windLayers[0].vectorWC);
  geofs.fx.atmosphere.setConditions(weather.currentWindVectorWC, weather.definition.cloudCover * .01); geofs.fx.water.setConditions(weather.currentWindSpeedMs); setTimeout(function () { geofs.fx.dayNightManager.update() }, 0); weather.definition.precipitationType == "snow" ? (geofs.isSnow = !0, geofs.api.setImageryColorModifier("snow", { brightness: 2.5, contrast: 1.5, saturation: .1 })) : (geofs.isSnow = !1, geofs.api.removeImageryColorModifier("snow")); geofs.fx.cloudManager.instance.triggerUpdate(); window.fireBasicEvent("geofsWeatherChange")
};
weather.animationRate = -5;
weather.update = function (a) {
  if (weather.animate) { if (geofs.preferences.weather.quality == 0 || geofs.preferences.weather.quality == 100) weather.animationRate *= -1; geofs.preferences.weather.quality = clamp(geofs.preferences.weather.quality + a * weather.animationRate, 0, 100); weather.setManual() } var b = geofs.camera.lla; if (weather.windLayers.length > 0) {
    for (var c = geofs.aircraft.instance.llaLocation[2], d = 0, e = 1; e < weather.windLayers.length && !(c < weather.windLayers[e].floor); e++)d = e; weather.windLayers[d].computeAndSet(b); weather.activeWindLayer =
      d
  } weather.setThermals(b, a); geofs.fx.cloudManager.update(b, a); geofs.fx.precipitation.update(b, a); geofs.fx.dayNightManager.update(b, a)
}; weather.setWindIndicatorVisibility = function (a) { instruments.list.wind && (a ? instruments.visible && instruments.list.wind.show() : instruments.list.wind.hide()) };
weather.setDateAndTime = function (a) {
  a = a || geofs.camera.lla || [0, 0, 0]; a = a[1] * LONGITUDE_TO_HOURS; if (geofs.preferences.weather.manual) weather.localTime = geofs.preferences.weather.localTime || 12, weather.localSeason = geofs.preferences.weather.season, weather.zuluTime = boundHours24(weather.localTime - a), geofs.api.setTimeAndDate(weather.zuluTime * 60 * 60, Math.floor(weather.localSeason * 3.65)); else {
    var b = new Date; geofs.api.setClock(b); weather.zuluTime = b.getUTCHours(); weather.localTime = boundHours24(weather.zuluTime + a);
    a = (Date.UTC(b.getFullYear(), b.getMonth(), b.getDate()) - Date.UTC(b.getFullYear(), 0, 0)) / 24 / 60 / 60 / 1E3; weather.localSeason = (a - 60) * .27
  } weather.timeRatio = Math.abs(weather.localTime / 12 - 1); weather.timeRatio = Number.parseFloat(weather.timeRatio.toFixed(2)); weather.seasonRatio = Math.sin(weather.localSeason * 2.7 * DEGREES_TO_RAD); geofs.isSnowy = !1; weather.localSeason >= 0 && (geofs.season = "spring"); weather.localSeason > 25 && (geofs.season = "summer"); weather.localSeason > 50 && (geofs.season = "autumn"); if (weather.localSeason < 0 ||
    weather.localSeason > 75) geofs.season = "winter", weather.isSnowable && (geofs.isSnowy = !0); geofs.animation.values.season != geofs.season && $("body").trigger("seasonChange"); geofs.animation.values.night = geofs.isNight; geofs.animation.values.season = geofs.season; geofs.animation.values.minutes = (weather.localTime % 1).toFixed(2) * 60; geofs.animation.values.hours = weather.localTime; window.fireBasicEvent("geofsTimeChange")
};
weather.getLocalTurbulence = function (a) { return [0, 0, geofs.perlin.get(a[0], a[1], 2500) * weather.definition.turbulences * 4] }; weather.thermals = { currentVector: [0, 0, 0], minradius: 200, maxradius: 1E3, minspeed: 0, maxspeed: 7, invertionRange: 500 }; weather.setThermals = function (a) { weather.thermals.currentVector = weather.getLocalThermal(a) };
weather.getLocalThermal = function (a) { if (weather.definition.thermals == 0) return [0, 0, 0]; var b = clamp(a[2] / (weather.definition.cloudBase - geofs.groundElevation), 0, 1); b = clamp((1 - b) * 5, 0, 1); var c = 1 + weather.definition.thermals; a = V3.sub(a, V3.scale(weather.currentWindVectorLla, a[2] * .1)); a = geofs.perlin.get(a[0], a[1], 200); a = clamp(Math.pow(Math.abs(a) * c, 3) * Math.sign(a) * weather.thermals.maxspeed * weather.definition.thermals, weather.thermals.minspeed, weather.thermals.maxspeed) * b; isNaN(a) && (a = 0); return [0, 0, a] };
weather.Wind = function (a, b, c, d) {
  this.mainDirection = a; this.speedKnots = b * MS_TO_KNOTS; this.speedMs = b; var e = this.mainDirection * DEGREES_TO_RAD; this.vector = [Math.sin(e), Math.cos(e), 0]; this.vectorMs = V3.scale(this.vector, this.speedMs); this.vectorCross = V3.cross(this.vector, [0, 0, 1]); this.floor = c; this.ceiling = d; this.direction = this.mainDirection; this.speed = this.speedMs; a = new Cesium.HeadingPitchRoll(a * DEGREES_TO_RAD, 0, 0); a = Cesium.Transforms.headingPitchRollToFixedFrame(geofs.camera.cam.position, a); this.vectorWC =
    Cesium.Matrix4.multiplyByPointAsVector(a, new Cesium.Cartesian3(0, -b, 0), new Cesium.Cartesian3)
}; weather.Wind.prototype.randomize = function () { var a = clamp(weather.definition.cloudBase / geofs.animation.values.altitudeMeters, 0, 1); this.speed = this.speedMs + exponentialSmoothing("windGust", weather.definition.windGustMS * (Math.random() - .5) * a, .1) };
weather.Wind.prototype.computeAndSet = function (a) { a = a || [0, 0, 0]; this.randomize(); var b = [0, 0, 0]; this.speed && (b = this.computeTerrainLift()); weather.currentWindVector = V3.scale(b, this.speed); weather.currentWindVectorLla = xyz2lla(weather.currentWindVector, a); weather.currentWindDirection = this.direction; weather.currentWindSpeedMs = this.speed; weather.currentWindSpeed = this.speed * MS_TO_KNOTS };
weather.Wind.prototype.computeTerrainLift = function (a) { a = a || geofs.aircraft.instance.llaLocation; var b = V3.sub(a, xyz2lla(V3.scale(this.vector, 100), a)), c = geofs.groundElevation, d = geofs.api.getGroundAltitude(b, weather.Wind); geofs.debugOn && geofs.debug.placeProbe([b[0], b[1], d]); b = a[2] - c; var e = c - d; d = clamp(e * 5, 10, 500); e = Math.atan(e / 100); b = clamp(d - b, 0, d) / d; b = V3.rotate(this.vector, this.vectorCross, e * b); b.origin = [a[0], a[2], c]; return b };
weather.initWind = function (a, b) { weather.windLayers = []; a = fixAngle(a + 180); var c = weather.definition.windLayerHeight + Math.random() * weather.definition.windLayerHeight; weather.windLayers.push(new weather.Wind(a, b, 0, c)); if (b) { weather.windLayers[0].computeAndSet(); for (var d = 1; d < weather.windLayerNb; d++) { var e = c; c = e + weather.windLayerHeight + Math.random() * weather.definition.windLayerHeight; var f = b + (Math.random() * 10 - 5), g = fixAngle(a + Math.random() * 360); weather.windLayers.push(new weather.Wind(g, f, e, c)) } } };
weather.windOff = function () { weather.windLayers = []; weather.currentWindVector = [0, 0, 0]; weather.currentWindVectorLla = [0, 0, 0]; weather.currentWindVectorWC = new Cesium.Cartesian3(0, 0, 0); weather.currentWindDirection = 0; weather.currentWindSpeed = 0; weather.currentWindSpeedMs = 0 }; weather.atmosphere = {}; weather.atmosphere.init = function () { weather.atmosphere.update() };
weather.atmosphere.update = function (a) {
  a = a || geofs.aircraft.instance.altitude || 0; var b = weather.definition.airTemperatureSL + KELVIN_OFFSET; weather.atmosphere.airTempAtAltitude = weather.definition.airTemperatureSL - a * TEMPERATURE_LAPSE_RATE; weather.atmosphere.airTempAtAltitudeKelvin = weather.atmosphere.airTempAtAltitude + KELVIN_OFFSET; weather.atmosphere.airPressureAtAltitude = weather.definition.airPressureSL * Math.pow(clamp(1 - a * TEMPERATURE_LAPSE_RATE / b, 0, 1), GM_RL); weather.atmosphere.airDensityAtAltitude = weather.atmosphere.airPressureAtAltitude *
    MOLAR_MASS_DRY_AIR / (IDEAL_GAS_CONSTANT * weather.atmosphere.airTempAtAltitudeKelvin); weather.contrailAltitude = (weather.contrailTemperatureThreshold - weather.definition.airTemperatureSL) / -TEMPERATURE_LAPSE_RATE
}; "use strict"; window.geofs = window.geofs || {};
geofs.camera = {
  animations: { orbitHorizontal: { rate: 5 }, orbitVertical: { rate: 2, min: -60, max: 60 } }, currentMode: 0, currentModeName: "follow", currentDefinition: {}, lastCurrentMode: 0, worldPosition: [0, 0, 0], openSlave: !1, motionRange: [.5, .5, .5], FOVIncrement: .1, defaultFOV: 1.4, currentFOV: 1.4, minFOV: .2, maxFOV: 2.5, groundAvoidanceMargin: .5, groundAvoidanceIgnore: 100, shortestDistance: 5, init: function (a) {
    geofs.camera.cam = geofs.api.initAndGetCamera(); geofs.camera.lla = a || [0, 0, 0]; geofs.camera.htr = [0, 0, 0]; geofs.camera.hasMoved =
      !1; $(document).on("click", "[data-cameraAnim]", function (b) { b = $(b.currentTarget).attr("data-cameraAnim"); geofs.camera.animations[b].active = !geofs.camera.animations[b].active }).on("click", ".geofs-stopAllAnim", function () { for (var b in geofs.camera.animations) geofs.camera.animations[b].active = !1 }).on("click", ".geofs-startAllAnim", function () { for (var b in geofs.camera.animations) geofs.camera.animations[b].active = !0 })
  }, setFOV: function (a) {
    geofs.camera.currentFOV = a || geofs.camera.defaultFOV; geofs.camera.currentFOV =
      clamp(geofs.camera.currentFOV, geofs.camera.minFOV, geofs.camera.maxFOV); geofs.api.setFOV(geofs.camera.cam, geofs.camera.currentFOV); geofs.getViewportDimentions(); geofs.camera.currentModeName == "cockpit" && instruments.updateCockpitPositions()
  }, increaseFOV: function (a) { var b = geofs.api.getFOV(geofs.camera.cam); b += a || geofs.camera.FOVIncrement; b > geofs.camera.maxFOV && (b = geofs.camera.maxFOV); geofs.camera.setFOV(b) }, decreaseFOV: function (a) {
    var b = geofs.api.getFOV(geofs.camera.cam); b -= a || geofs.camera.FOVIncrement;
    b < geofs.camera.minFOV && (b = geofs.camera.minFOV); geofs.camera.setFOV(b)
  }, reset: function () {
    geofs.camera.definitions = { follow: { distance: 5, lookAtHeight: -1, orientation: [0, 10, 0] }, cockpit: { offsetBounds: [0, 0, 0, 0, 0, 0], insideView: !0 }, cockpitless: { insideView: !0 }, chase: { reset: !0 }, free: { reset: !0 }, fixed: {} }; var a = "", b; for (b in geofs.aircraft.instance.definition.cameras) geofs.camera.definitions[b] || (a += '<li class="mdl-menu__item" data-camera="' + b + '">' + b + "</li>"); a.length ? $(".geofs-extra-views").show().find(".geofs-extra-views-holder").html(a) :
      $(".geofs-extra-views").hide(); a = $.extend(!0, {}, geofs.camera.definitions, geofs.aircraft.instance.definition.cameras); var c = 0; geofs.camera.modes = []; for (b in a) {
        var d = a[b]; d.name = b; d.mode = c; d.view = d.view || d.name; d.insideView = d.insideView || d.view == "cockpit"; d.position = d.position || [0, 0, 0]; d.orientations = {}; d.orientations.neutral = d.orientation || [0, 0, 0]; d.orientations.current = V3.dup(d.orientations.neutral); d.orientations.last = V3.dup(d.orientations.neutral); d.offsets = {}; d.offsets.neutral = [0, 0, 0 + (d.lookAtHeight ||
          0)]; d.offsets.current = V3.dup(d.offsets.neutral); d.offsets.last = V3.dup(d.offsets.neutral); geofs.camera.definitions[b] = d; geofs.camera.modes.push(geofs.camera.definitions[b]); c++
      } for (b in geofs.camera.definitions) d = geofs.camera.definitions[b], d.orientations.current = V3.dup(d.orientations.neutral), d.orientations.last = V3.dup(d.orientations.neutral), d.offsets.current = V3.dup(d.offsets.neutral), d.offsets.last = V3.dup(d.offsets.neutral); geofs.camera.definitions.follow.distance /= geofs.camera.defaultFOV; geofs.camera.definitions.follow.lastUsedHtr =
        V3.dup(geofs.aircraft.instance.htr); geofs.camera.definitions.fixed.lastUsedHtr = V3.dup(geofs.aircraft.instance.htr); geofs.camera.definitions.fixed.distance = geofs.camera.definitions.follow.distance; geofs.camera.definitions.fixed.offsets.neutral[1] = -geofs.camera.definitions.follow.distance; geofs.camera.definitions.fixed.offsets.current[1] = -geofs.camera.definitions.follow.distance; geofs.camera.definitions.fixed.offsets.last[1] = -geofs.camera.definitions.follow.distance; geofs.camera.set(0); geofs.camera.setToNeutral();
    geofs.camera.lla = [0, 0, 0]; geofs.camera.htr = [0, 0, 0]; geofs.camera.update(1)
  }, cycle: function () { var a = geofs.camera.currentMode + 1; a >= geofs.camera.modes.length && (a = 0); geofs.camera.set(a) }, set: function (a, b) {
    if (a == -1) geofs.camera.reset(); else {
      geofs.camera.currentDefinition = geofs.camera.modes[a] || geofs.camera.definitions[b] || geofs.camera.definitions[0]; geofs.camera.currentMode = geofs.camera.currentDefinition.mode; geofs.camera.currentModeName = geofs.camera.currentDefinition.name; geofs.camera.currentView = geofs.camera.currentDefinition.view;
      geofs.camera.setFOV(geofs.camera.currentDefinition.FOV); if (geofs.camera.currentModeName == "follow" || geofs.camera.currentModeName == "fixed") a = V3.scale(geofs.aircraft.instance.object3d.getWorldFrame()[1], -geofs.camera.definitions.follow.distance), a = xyz2lla(a, geofs.aircraft.instance.llaLocation), geofs.camera.lla = V3.add(geofs.aircraft.instance.llaLocation, a), geofs.camera.avoidGround(), a = lookAt(geofs.aircraft.instance.llaLocation, geofs.camera.lla, [0, 0, 1]), a = [a[0], -a[1] + 90, 0], geofs.api.setCameraPositionAndOrientation(geofs.camera.cam,
        geofs.camera.lla, a); geofs.camera.currentModeName == "free" || geofs.camera.currentModeName == "chase" ? ($(".geofs-canvas-mouse-overlay").css("pointer-events", "none"), geofs.api.nativeMouseHandling = !0) : ($(".geofs-canvas-mouse-overlay").css("pointer-events", "auto"), geofs.api.nativeMouseHandling = !1); geofs.aircraft.instance && (geofs.camera.currentModeName == "cockpitless" ? geofs.aircraft.instance.setVisibility(!1) : geofs.aircraft.instance.setVisibility(!0)); geofs.camera.currentModeName == "cockpit" || geofs.camera.currentDefinition.nearClipping ?
          (geofs.aircraft.instance.definition.cockpitScaleFix && geofs.aircraft.instance.fixCockpitScale(geofs.aircraft.instance.definition.cockpitScaleFix), geofs.aircraft.instance.loadCockpit(), instruments.updateCockpitPositions(), geofs.api.configureInsideView(), geofs.camera.motionOffset = [0, 0, 0], $("body").addClass("geofs-cockpitView"), geofs.animation.values.overlaysVisibility = "hidden") : (geofs.aircraft.instance.fixCockpitScale(1), geofs.camera.currentDefinition.insideView ? geofs.api.configureInsideView() : geofs.api.configureOutsideView(),
            $("body").removeClass("geofs-cockpitView"), geofs.animation.values.overlaysVisibility = "visible"); geofs.animation.values.view = geofs.camera.currentView; geofs.animation.values.cameraMode = geofs.camera.currentModeName; geofs.aircraft.instance.placeParts(); geofs.aircraft.instance.render(); instruments.updateScreenPositions(); instruments.update(); $(document).trigger("cameraChange"); geofs.camera.hasMoved = !0; geofs.camera.update(1)
    }
  }, lookAround: function (a, b) {
    if (geofs.camera.isHandlingMouseRotation()) {
      var c = geofs.camera.definitions[geofs.camera.currentModeName];
      a != void 0 && (c.orientations.current[0] = a); b != void 0 && (c.orientations.current[1] = b); geofs.camera.saveRotation(); geofs.camera.currentModeName == "cockpit" && (geofs.camera.hasMoved = !0); return !0
    } return !1
  }, rotate: function (a, b, c) {
    a = a || 0; b = b || 0; c = c || 0; if (geofs.camera.isHandlingMouseRotation()) {
      var d = geofs.camera.definitions[geofs.camera.currentModeName]; d.orientations.current[0] -= a; d.orientations.current[1] += b; d.orientations.current[2] += c || 0; geofs.camera.currentModeName == "cockpit" && (geofs.camera.hasMoved = !0);
      return !0
    } return !1
  }, translate: function (a, b, c) {
    a = a || 0; b = b || 0; c = c || 0; if (geofs.camera.isHandlingMouseRotation()) {
      var d = geofs.camera.definitions[geofs.camera.currentModeName], e = geofs.aircraft.instance.object3d.getWorldFrame(), f = M33.rotationXYZ(M33.identity(), [-geofs.camera.htr[1] * DEGREES_TO_RAD, 0, geofs.camera.htr[0] * DEGREES_TO_RAD]); geofs.camera.currentModeName == "follow" ? (d.distance += b, a = [a, 0, c]) : (a = M33.transform(f, [a, b, c]), a = M33.transformByTranspose(e, a)); d.offsets.current = V3.add(d.offsets.current, a);
      d.offsetBounds && (d.offsets.current[0] = clamp(d.offsets.current[0], d.offsetBounds[0], d.offsetBounds[1]), d.offsets.current[1] = clamp(d.offsets.current[1], d.offsetBounds[2], d.offsetBounds[3]), d.offsets.current[2] = clamp(d.offsets.current[2], d.offsetBounds[4], d.offsetBounds[5])); geofs.camera.currentModeName == "cockpit" && (geofs.camera.hasMoved = !0); return !0
    } return !1
  }, setPosition: function (a, b, c) {
    a = a || 0; b = b || 0; c = c || 0; if (geofs.camera.isHandlingMouseRotation()) {
      var d = geofs.camera.definitions[geofs.camera.currentModeName],
        e = geofs.aircraft.instance.object3d.getWorldFrame(), f = M33.rotationXYZ(M33.identity(), [-geofs.camera.htr[1] * DEGREES_TO_RAD, 0, geofs.camera.htr[0] * DEGREES_TO_RAD]); geofs.camera.currentModeName == "follow" ? (d.distance += b, a = [a, 0, c]) : (a = M33.transform(f, [a, b, c]), a = M33.transformByTranspose(e, a)); d.offsets.current = V3.dup(a); geofs.camera.currentModeName == "cockpit" && (geofs.camera.hasMoved = !0); return !0
    } return !1
  }, isHandlingMouseRotation: function () {
    return geofs.camera.currentModeName == "follow" || geofs.camera.currentModeName ==
      "cockpit" || geofs.camera.currentModeName == "fixed" || geofs.camera.currentDefinition.rotatable ? !0 : !1
  }, setRotation: function (a, b, c) {
    var d = geofs.camera.definitions[geofs.camera.currentModeName]; return geofs.camera.currentModeName == "follow" || geofs.camera.currentModeName == "fixed" ? (d.orientations.current[0] = a, d.orientations.current[1] = b || d.orientations.last[1], d.orientations.current[2] = c || d.orientations.last[2], !0) : geofs.camera.currentModeName == "cockpit" ? (d.orientations.current[0] = a || d.orientations.last[0],
      d.orientations.current[1] = b || d.orientations.last[1], d.orientations.current[2] = c || d.orientations.last[2], geofs.camera.hasMoved = !0) : !1
  }, saveRotation: function () { if (geofs.camera.definitions) { var a = geofs.camera.definitions[geofs.camera.currentModeName]; a.orientations.last = V3.dup(a.orientations.current) } }, saveOffset: function () { if (geofs.camera.definitions) { var a = geofs.camera.definitions[geofs.camera.currentModeName]; a.offsets.last = V3.dup(a.offsets.current) } }, setToNeutral: function () {
    var a = geofs.camera.definitions[geofs.camera.currentModeName];
    a.orientations.current = V3.dup(a.orientations.neutral); a.orientations.last = V3.dup(a.orientations.neutral); a.offsets.current = V3.dup(a.offsets.neutral); a.offsets.last = V3.dup(a.offsets.neutral); geofs.camera.setFOV(a.FOV || geofs.camera.defaultFOV); geofs.camera.currentModeName == "cockpit" && (geofs.camera.hasMoved = !0)
  }, setGroundAltitude: function () { var a = geofs.getCollisionResult(geofs.camera.lla, geofs.camera.worldPosition, geofs.aircraft.instance.collResult, geofs.camera); geofs.camera.groundAltitude = a.location[2] },
  avoidGround: function () { geofs.relativeAltitude > geofs.camera.groundAvoidanceIgnore || (geofs.camera.setGroundAltitude(), geofs.camera.lla[2] - geofs.camera.groundAltitude <= geofs.camera.groundAvoidanceMargin && (geofs.camera.lla[2] = geofs.camera.groundAltitude + geofs.camera.groundAvoidanceMargin), geofs.camera.hasMoved = !0) }, getFlytToCoordinates: function () {
    geofs.camera.setGroundAltitude(); var a = clone(geofs.camera.lla); a[2] = clamp(a[2], 0, 3E4); a[3] = geofs.camera.htr[0]; geofs.camera.lla[2] - geofs.camera.groundAltitude <
      geofs.camera.groundAvoidanceMargin ? (a[2] = 0, a[4] = !1) : a[4] = !0; return a
  }, update: function (a) {
    var b = geofs.aircraft.instance; if (geofs.aircraft.instance.object3d) {
      var c = geofs.aircraft.instance.object3d.getWorldFrame(), d = geofs.camera.currentDefinition; geofs.camera.animations.orbitHorizontal.active && (geofs.camera.rotate(geofs.camera.animations.orbitHorizontal.rate * a), geofs.camera.saveRotation()); if (geofs.camera.animations.orbitVertical.active) {
        var e = geofs.camera.animations.orbitVertical; fixAngle(geofs.camera.htr[1]);
        geofs.camera.rotate(null, e.rate * a); geofs.camera.saveRotation()
      } if (geofs.camera.currentModeName == "follow") {
        var f = d.orientations.current[0]; e = d.orientations.current[1]; var g = 1 - Math.exp(-a / .5); a = d.lastUsedHtr[0] + fixAngle(b.htr[0] - d.lastUsedHtr[0]) * g; g = d.lastUsedHtr[1] + fixAngle(b.htr[1] - d.lastUsedHtr[1]) * g; d.lastUsedHtr = [a, g, 0]; f = a + f; e = g + e; f = M33.rotationXYZ(M33.identity(), [e * DEGREES_TO_RAD, 0, f * DEGREES_TO_RAD]); geofs.camera.worldPosition = V3.add(d.position, d.offsets.current); e = M33.transform(f, geofs.camera.worldPosition);
        e = V3.add(b.llaLocation, xyz2lla(e, b.llaLocation)); d = V3.scale(f[1], -d.distance); d = xyz2lla(d, e); geofs.camera.lla = V3.add(e, d); geofs.camera.avoidGround(); geofs.camera.htr = lookAt(e, geofs.camera.lla, [0, 0, 1]); geofs.camera.htr = [fixAngle360(geofs.camera.htr[0]), fixAngle360(-geofs.camera.htr[1]), 0]; geofs.api.setCameraPositionAndOrientation(geofs.camera.cam, geofs.camera.lla, geofs.camera.htr)
      } else geofs.camera.currentModeName == "chase" ? (geofs.camera.avoidGround(), geofs.camera.lla = geofs.api.getCameraLla(geofs.camera.cam),
        controls.mouse.down || (geofs.camera.htr = lookAt(b.llaLocation, geofs.camera.lla, [0, 0, 1]), geofs.camera.htr = [fixAngle360(geofs.camera.htr[0]), fixAngle360(-geofs.camera.htr[1]), 0], geofs.api.setCameraPositionAndOrientation(geofs.camera.cam, geofs.camera.lla, geofs.camera.htr))) : geofs.camera.currentModeName == "free" ? (geofs.camera.avoidGround(), geofs.camera.lla = geofs.api.getCameraLla(geofs.camera.cam), geofs.camera.htr[0] = geofs.api.getHeading(geofs.camera.cam), geofs.camera.htr[1] = geofs.api.getTilt(geofs.camera.cam)) :
        (f = d.orientations.current[0], e = d.orientations.current[1], a = d.orientations.current[2], g = c, d.parent && (g = geofs.aircraft.instance.parts[d.parent].object3d.getWorldFrame()), f = M33.rotationXYZ(g, [-e * DEGREES_TO_RAD, a * DEGREES_TO_RAD, f * DEGREES_TO_RAD]), geofs.camera.htr = M33.getOrientation(f), geofs.camera.worldPosition = V3.add(d.position, d.offsets.current), geofs.camera.currentModeName == "cockpit" && geofs.preferences.camera.headMotion && (e = V3.scale([-geofs.animation.values.accX, -geofs.animation.values.accY, -geofs.animation.values.accZ],
          .001 * b.definition.motionSensitivity), e = V3.exponentialSmoothing("gsmooth", e, .1), geofs.camera.motionOffset[0] = e[0] / (geofs.camera.motionRange[0] / (geofs.camera.motionRange[0] - geofs.camera.motionOffset[0])), geofs.camera.motionOffset[1] = e[1] / (geofs.camera.motionRange[1] / (geofs.camera.motionRange[1] - geofs.camera.motionOffset[1])), geofs.camera.motionOffset[2] = e[2] / (geofs.camera.motionRange[2] / (geofs.camera.motionRange[2] - geofs.camera.motionOffset[2])), geofs.camera.motionOffset = V3.clamp(geofs.camera.motionOffset,
            -.2, .2), geofs.camera.worldPosition = V3.add(geofs.camera.worldPosition, geofs.camera.motionOffset), geofs.camera.hasMoved = !0), geofs.camera.worldPosition = b.object3d.setVectorWorldPosition(geofs.camera.worldPosition), geofs.camera.currentModeName == "cockpit" && (geofs.camera.worldPosition = V3.scale(geofs.camera.worldPosition, geofs.aircraft.instance.definition.cockpitScaleFix)), d.parent && (geofs.camera.worldPosition = V3.add(geofs.camera.worldPosition, geofs.aircraft.instance.parts[d.parent].object3d.getWorldPosition())),
          geofs.camera.lla = V3.add(b.llaLocation, xyz2lla(geofs.camera.worldPosition, b.llaLocation)), geofs.camera.avoidGround(), geofs.camera.htr = [fixAngle360(geofs.camera.htr[0]), fixAngle360(-geofs.camera.htr[1]), -geofs.camera.htr[2]], geofs.api.setCameraPositionAndOrientation(geofs.camera.cam, geofs.camera.lla, geofs.camera.htr)); geofs.camera.radianRoll = geofs.camera.htr[2] * DEGREES_TO_RAD; b = V3.normalize(lla2xyz(V3.sub(geofs.camera.lla, b.llaLocation), geofs.camera.lla)); geofs.camera.dotAircraftForward = V3.dot(b, c[1]);
      geofs.camera.openSlave && geofs.camera.updateSlaveData(); geofs.camera.currentModeName == "cockpit" && geofs.camera.hasMoved && (instruments.updateCockpitPositions(), geofs.camera.hasMoved = !1)
    }
  }, openSlaveWindow: function (a) { var b = "left=" + ((window.screenX || window.screenLeft) + a * (window.outerWidth || 1024)); window.open("slave.php?order=" + a, ("geofsSlave" + a).replace("-", "l"), b) && (geofs.camera.openSlave = !0) }, updateSlaveData: function () {
    geofs.camera.transform = M33.setFromEuler([-geofs.camera.htr[1] * DEGREES_TO_RAD, -geofs.camera.htr[2] *
      DEGREES_TO_RAD, geofs.camera.htr[0] * DEGREES_TO_RAD])
  }
}; "use strict"; var instruments = window.instruments || {}; instruments.stackPosition = { x: 100, y: 0 }; instruments.margins = [0, 0, 0, 0]; instruments.defaultMargin = 10; instruments.visible = !0; instruments.list = {}; instruments.gaugesBackgroundOpacity = .4;
instruments.definitions = {
  airspeed: {
    container: ".geofs-instruments-container", stackX: !0, compositors: "canvas,css", overlay: {
      url: "images/instruments/background.png", class: "geofs-instrument-background", size: { x: 200, y: 200 }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{ animations: [{ type: "rotate", value: "kias", ratio: -1.5, min: 0 }], url: "images/instruments/airspeed-hand.png", anchor: { x: 10, y: 34 }, size: { x: 20, y: 120 }, position: { x: 0, y: 0 }, class: "APPLegacyOverlayReordering" }, {
        url: "images/instruments/airspeed-raw.png",
        anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }
      }]
    }
  }, airspeedArcs: {
    container: ".geofs-instruments-container", compositors: "canvas,css", stackX: !0, overlay: {
      url: "images/instruments/background.png", class: "geofs-instrument-background", size: { x: 200, y: 200 }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{ url: "images/instruments/airspeed-raw.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 } }, {
        animations: [{ type: "rotate", value: "kias", ratio: -1.5, min: 0 }], url: "images/instruments/airspeed-hand.png",
        anchor: { x: 10, y: 34 }, size: { x: 20, y: 120 }, position: { x: 0, y: 0 }
      }, { url: "/images/instruments/airspeed-yellow-arc.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 }, animations: [{ type: "rotate", offset: 60, "function": "{return geofs.aircraft.instance.definition.Vspeeds.VNE}", ratio: -1.5 }] }, { url: "/images/instruments/airspeed-red-mark.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 }, animations: [{ type: "rotate", "function": "{return geofs.aircraft.instance.definition.Vspeeds.VNE}", ratio: -1.5 }] },
      { url: "/images/instruments/airspeed-green-arc.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 }, animations: [{ type: "rotate", "function": "{return geofs.aircraft.instance.definition.Vspeeds.VS}", ratio: -1.5 }] }, { url: "/images/instruments/airspeed-green-arc.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 }, animations: [{ type: "rotate", "function": "{return geofs.aircraft.instance.definition.Vspeeds.VS + 40}", ratio: -1.5 }, { type: "show", "function": "{return geofs.aircraft.instance.definition.Vspeeds.VNO - geofs.aircraft.instance.definition.Vspeeds.VS > 80}" }] },
      { url: "/images/instruments/airspeed-green-arc.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 }, animations: [{ type: "rotate", offset: 60, "function": "{return geofs.aircraft.instance.definition.Vspeeds.VNO}", ratio: -1.5 }] }, { url: "/images/instruments/airspeed-white-arc.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 }, animations: [{ type: "rotate", "function": "{return geofs.aircraft.instance.definition.Vspeeds.VS0}", ratio: -1.5 }, { type: "show", "function": "{return geofs.aircraft.instance.definition.Vspeeds.VS0 >= 0}" }] },
      { url: "/images/instruments/airspeed-white-arc.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 }, animations: [{ type: "rotate", offset: 60, "function": "{return geofs.aircraft.instance.definition.Vspeeds.VFE}", ratio: -1.5 }, { type: "show", "function": "{return geofs.aircraft.instance.definition.Vspeeds.VS0 >= 0}" }] }]
    }
  }, airspeedJet: {
    container: ".geofs-instruments-container", compositors: "canvas,css", stackX: !0, overlay: {
      url: "images/instruments/background.png", class: "geofs-instrument-background", size: {
        x: 200,
        y: 200
      }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{ animations: [{ type: "rotate", value: "kias", ratio: -.6, min: 0 }], url: "images/instruments/airspeed-hand.png", anchor: { x: 10, y: 34 }, size: { x: 20, y: 120 }, position: { x: 0, y: 0 }, class: "APPLegacyOverlayReordering" }, { url: "images/instruments/airspeed-high.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 } }]
    }
  }, airspeedSupersonic: {
    container: ".geofs-instruments-container", compositors: "canvas,css", stackX: !0, overlay: {
      url: "images/instruments/background.png",
      class: "geofs-instrument-background", size: { x: 200, y: 200 }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{ animations: [{ type: "rotate", value: "kias", ratio: -.3, min: 0 }], url: "images/instruments/airspeed-hand.png", anchor: { x: 10, y: 34 }, size: { x: 20, y: 120 }, position: { x: 0, y: 0 }, class: "APPLegacyOverlayReordering" }, { url: "images/instruments/airspeed-supersonic.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 } }, {
        url: "images/instruments/machsubindicator.png", class: "geofs-overlay-moreTransparence",
        anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }
      }, { animations: [{ type: "rotate", value: "mach", ratio: -72, min: 0 }], url: "images/instruments/mach-hand.png", anchor: { x: 5, y: 5 }, size: { x: 11, y: 31 }, position: { x: -70, y: -70 } }]
    }
  }, altitude_legacy: {
    container: ".geofs-instruments-container", compositors: "canvas,css", stackX: !0, overlay: {
      url: "images/instruments/background.png", class: "geofs-instrument-background", size: { x: 200, y: 200 }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{
        url: "images/instruments/altitude.png",
        anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }
      }, { animations: [{ type: "rotate", value: "altitude", ratio: -.0036 }], url: "images/instruments/tenthousandhand.png", anchor: { x: 8, y: 0 }, size: { x: 16, y: 91 }, position: { x: 0, y: 0 } }, { animations: [{ type: "rotate", value: "altitude", ratio: -.036 }], url: "images/instruments/small-hand.png", anchor: { x: 10, y: 28 }, size: { x: 20, y: 87 }, position: { x: 0, y: 0 } }, {
        animations: [{ type: "rotate", value: "altitude", ratio: -.36 }], url: "images/instruments/airspeed-hand.png", anchor: { x: 10, y: 34 }, size: { x: 20, y: 120 }, position: {
          x: 0,
          y: 0
        }
      }]
    }
  }, altitude: {
    container: ".geofs-instruments-container", compositors: "canvas,css", stackX: !0, overlay: {
      url: "images/instruments/background.png", class: "geofs-instrument-background", size: { x: 200, y: 200 }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{ url: "images/instruments/altitude2/altitude.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 } }, {
        animations: [{ type: "rotate", value: "altitude", ratio: -.011, preoffset: -1E4, min: 1E4, max: 15E3 }], url: "images/instruments/altitude2/stripe_mask.png",
        class: "geofs-instrument-background", anchor: { x: 58, y: 54 }, size: { x: 116, y: 111 }, position: { x: 0, y: 0 }
      }, { animations: [{ type: "rotate", value: "altitude", ratio: -.0036 }], url: "images/instruments/tenthousandhand.png", anchor: { x: 8, y: 0 }, size: { x: 16, y: 91 }, position: { x: 0, y: 0 } }, { animations: [{ type: "rotate", value: "altitude", ratio: -.036 }], url: "images/instruments/small-hand.png", anchor: { x: 10, y: 28 }, size: { x: 20, y: 87 }, position: { x: 0, y: 0 } }, {
        animations: [{ type: "rotate", value: "altitude", ratio: -.36 }], url: "images/instruments/airspeed-hand.png",
        anchor: { x: 10, y: 34 }, size: { x: 20, y: 120 }, position: { x: 0, y: 0 }
      }]
    }
  }, vario: {
    container: ".geofs-instruments-container", compositors: "canvas,css", stackX: !0, overlay: {
      url: "images/instruments/background.png", class: "geofs-instrument-background", size: { x: 200, y: 200 }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{ url: "images/instruments/vario.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 } }, {
        animations: [{ type: "rotate", value: "verticalSpeed", ratio: -.09, max: 1900, min: -1900, offset: 90 }], url: "images/instruments/airspeed-hand.png",
        anchor: { x: 10, y: 34 }, size: { x: 20, y: 120 }, position: { x: 0, y: 0 }
      }]
    }
  }, varioJet: {
    container: ".geofs-instruments-container", compositors: "canvas,css", stackX: !0, overlay: {
      url: "images/instruments/background.png", class: "geofs-instrument-background", size: { x: 200, y: 200 }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{ url: "images/instruments/vario-high.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 } }, {
        animations: [{ type: "rotate", value: "verticalSpeed", ratio: -.025, max: 6E3, min: -6E3, offset: 90 }],
        url: "images/instruments/airspeed-hand.png", anchor: { x: 10, y: 34 }, size: { x: 20, y: 120 }, position: { x: 0, y: 0 }
      }]
    }
  }, compass: {
    container: ".geofs-instruments-container", compositors: "canvas,css", stackX: !0, overlay: {
      url: "images/instruments/background.png", class: "geofs-instrument-background", size: { x: 200, y: 200 }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{
        animations: [{ type: "rotate", value: "heading", ratio: 1 }], url: "images/instruments/compass-grad.png", anchor: { x: 90, y: 90 }, size: {
          x: 181,
          y: 181
        }, position: { x: 0, y: 0 }, overlays: [{ animations: [{ type: "rotate", value: "navHDG", ratio: -1 }], url: "images/instruments/hdg-bug.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 } }]
      }, { url: "images/instruments/compass-hand.png", anchor: { x: 25, y: 26 }, size: { x: 50, y: 109 }, position: { x: 0, y: 0 } }, {
        url: "images/instruments/hdg-knob.png", class: "geofs-overlay-moreTransparence", drawOrder: 200, anchor: { x: 22, y: 22 }, size: { x: 44, y: 44 }, position: { x: 80, y: -80 }, iconFrame: { x: 44, y: 44 }, manipulator: function (a, b) {
          instruments.manipulators.setHDG(a,
            b)
        }, animations: [{ type: "rotate", value: "navHDG", ratio: -2 }]
      }]
    }
  }, turncoordinator: {
    container: ".geofs-instruments-container", compositors: "canvas,css", stackX: !0, overlay: {
      url: "images/instruments/turncoordinator/background.png", class: "geofs-instrument-background", size: { x: 200, y: 200 }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{
        animations: [{ type: "rotate", value: "slipball", ratio: -4, fmin: -10, fmax: 10 }], url: "images/instruments/turncoordinator/ball.png", anchor: { x: 100, y: 300 },
        size: { x: 200, y: 200 }, position: { x: 0, y: 200 }
      }, { animations: [{ type: "rotate", value: "turnrate", ratio: -.11, fmin: -40, fmax: 40 }], url: "images/instruments/turncoordinator/hand.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 } }, { url: "images/instruments/turncoordinator/markings.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 } }]
    }
  }, attitude: {
    container: ".geofs-instruments-container", compositors: "canvas,css", stackX: !0, overlay: {
      url: "images/instruments/background.png", class: "geofs-instrument-background", size: {
        x: 200,
        y: 200
      }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{ url: "images/instruments/attitude.png", class: "geofs-instrument-background", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 } }, {
        animations: [{ type: "rotate", value: "aroll", name: "attitude", ratio: -1, min: -50, max: 50 }, { type: "translateY", value: "atilt", ratio: -2, offset: 50, min: -25, max: 25 }], url: "images/instruments/attitude-hand.png", maskUrl: "images/instruments/attitude-mask.png", clip: [100, 100, 71], class: "geofs-overlay-moreTransparence",
        anchor: { x: 100, y: 100 }, size: { x: 200, y: 300 }, position: { x: 0, y: 0 }, iconFrame: { x: 200, y: 200 }
      }, { animations: [{ type: "rotate", value: "aroll", ratio: -1, min: -60, max: 60 }], url: "images/instruments/attitude-grad.png", class: "geofs-overlay-moreTransparence", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 } }, { url: "images/instruments/attitude-pointer.png", class: "geofs-overlay-keepOpaque", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 } }]
    }
  }, attitudeJet: {
    container: ".geofs-instruments-container", compositors: "canvas,css",
    stackX: !0, overlay: {
      url: "images/instruments/background.png", class: "geofs-instrument-background", size: { x: 200, y: 200 }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{
        animations: [{ type: "rotate", value: "aroll", ratio: -1, min: -180, max: 180 }, { type: "translateY", value: "atilt", ratio: -2, offset: 300, min: -90, max: 90 }], url: "images/instruments/attitude-jet-hand.png", maskUrl: "images/instruments/attitude-jet-mask.png", clip: [100, 100, 71], class: "geofs-overlay-moreTransparence", anchor: {
          x: 100,
          y: 100
        }, size: { x: 200, y: 800 }, position: { x: 0, y: 0 }, iconFrame: { x: 200, y: 200 }
      }, { url: "images/instruments/attitude-jet.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 } }, { animations: [{ type: "rotate", value: "aroll", ratio: -1, min: -60, max: 60 }], url: "images/instruments/attitude-jet-pointer.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 } }]
    }
  }, rpm3000: {
    container: ".geofs-instruments-container", compositors: "canvas,css", stackX: !0, hideOnMobile: !0, position: { x: 100, y: 100 }, overlay: {
      url: "images/instruments/background.png",
      class: "geofs-instrument-background", size: { x: 100, y: 100 }, anchor: { x: 100, y: 100 }, position: { x: 50, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{ url: "images/instruments/RPM3000/rpm3000.png", anchor: { x: 100, y: 100 }, size: { x: 100, y: 100 } }, { animations: [{ type: "rotate", value: "rpm", ratio: -.09, offset: 160 }], url: "images/instruments/rpm-hand.png", anchor: { x: 14, y: 14 }, size: { x: 28, y: 55 }, position: { x: 0, y: 0 } }]
    }
  }, rpm: {
    container: ".geofs-instruments-container", compositors: "canvas,css", hideOnMobile: !0, stackX: !0, overlay: {
      url: "images/instruments/background.png",
      class: "geofs-instrument-background", size: { x: 100, y: 100 }, anchor: { x: 100, y: 100 }, position: { x: 50, y: 50 }, rescale: !0, rescalePosition: !0, overlays: [{ url: "images/instruments/rpm.png", anchor: { x: 100, y: 100 }, size: { x: 100, y: 100 } }, { animations: [{ type: "rotate", value: "rpm", ratio: -.03, offset: 120 }], url: "images/instruments/rpm-hand.png", anchor: { x: 14, y: 14 }, size: { x: 28, y: 55 }, position: { x: 0, y: 0 } }]
    }
  }, rpmJet: {
    container: ".geofs-instruments-container", compositors: "canvas,css", hideOnMobile: !0, stackX: !0, overlay: {
      url: "images/instruments/background.png",
      class: "geofs-instrument-background", size: { x: 200, y: 200 }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{ url: "images/instruments/jet-rpm.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 } }, { animations: [{ type: "rotate", value: "rpm", ratio: -.036, offset: 0 }], url: "images/instruments/jet-rpm-hand.png", anchor: { x: 6, y: 15 }, size: { x: 14, y: 34 }, position: { x: -38, y: 45 } }, {
        animations: [{ type: "rotate", value: "rpm", ratio: -.027, offset: 0 }], url: "images/instruments/airspeed-hand.png", anchor: { x: 10, y: 34 },
        size: { x: 20, y: 120 }, position: { x: 0, y: 0 }
      }]
    }
  }, adf: {
    container: ".geofs-instruments-container", compositors: "canvas,css", stackX: !0, overlay: {
      url: "images/instruments/background.png", class: "geofs-instrument-background", size: { x: 200, y: 200 }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{ url: "images/instruments/cdi/background.png", class: "geofs-instrument-background", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 } }, {
        url: "images/instruments/adf/needle.png", anchor: { x: 100, y: 100 }, size: {
          x: 200,
          y: 200
        }, position: { x: 0, y: 0 }, iconFrame: { x: 200, y: 200 }, offset: { x: 0, y: 0 }, animations: [{ type: "rotate", value: "ADFBearingToStation", ratio: 1 }]
      }, { url: "images/instruments/cdi/compass.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 }, animations: [{ type: "rotate", value: "ADFManCourse", ratio: 1 }] }, { url: "images/instruments/adf/cover.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 } }, {
        url: "images/instruments/adf/VARKnob.png", class: "geofs-overlay-moreTransparence", drawOrder: 200, anchor: {
          x: 22,
          y: 22
        }, size: { x: 44, y: 44 }, position: { x: -80, y: -80 }, iconFrame: { x: 44, y: 44 }, manipulator: function (a, b) { instruments.manipulators.setADFManCourse(a, b) }, animations: [{ type: "rotate", value: "ADFManCourse", ratio: -2 }]
      }]
    }
  }, rmi: {
    container: ".geofs-instruments-container", compositors: "canvas,css", stackX: !0, overlay: {
      url: "images/instruments/background.png", class: "geofs-instrument-background", size: { x: 200, y: 200 }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{
        url: "images/instruments/rmi/background.png",
        class: "geofs-instrument-background", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }
      }, { url: "images/instruments/rmi/ADFNeedle.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 }, iconFrame: { x: 200, y: 200 }, offset: { x: 0, y: 0 }, animations: [{ type: "rotate", value: "ADFBearingToStation", ratio: 1 }] }, { url: "images/instruments/rmi/VORNeedle.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 }, iconFrame: { x: 200, y: 200 }, offset: { x: 0, y: 0 }, animations: [{ type: "rotate", value: "NAVBearingToStation", ratio: 1 }] }, {
        url: "images/instruments/rmi/compass.png",
        anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 }, animations: [{ type: "rotate", value: "heading", ratio: 1 }]
      }, { url: "images/instruments/rmi/cover.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 } }]
    }
  }, cdi: {
    container: ".geofs-instruments-container", compositors: "canvas,css", stackX: !0, overlay: {
      url: "images/instruments/background.png", class: "geofs-instrument-background", size: { x: 200, y: 200 }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{
        url: "images/instruments/cdi/background.png",
        class: "geofs-instrument-background", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }
      }, { url: "images/instruments/cdi/cross.png", class: "geofs-instrument-background", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 } }, { url: "images/instruments/cdi/grads.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 } }, { url: "images/instruments/cdi/to.png", size: { x: 30, y: 13 }, position: { x: 17, y: 27 }, animations: [{ type: "show", value: "NAVDirection", eq: "to" }] }, {
        url: "images/instruments/cdi/from.png", size: { x: 44, y: 13 }, position: { x: 17, y: 12 }, animations: [{
          type: "show",
          value: "NAVDirection", eq: "from"
        }]
      }, { url: "images/instruments/cdi/navvloc.png", size: { x: 36, y: 24 }, position: { x: -50, y: 15 }, animations: [{ type: "show", value: "NAVMODE", eq: "NAV" }] }, { url: "images/instruments/cdi/gps.png", size: { x: 27, y: 10 }, position: { x: -45, y: -30 }, animations: [{ type: "show", value: "NAVMODE", eq: "GPS" }] }, { url: "images/instruments/cdi/navflag.png", class: "geofs-overlay-moreTransparence", size: { x: 24, y: 11 }, position: { x: -12, y: -60 }, animations: [{ type: "show", value: "NAVLNAV", lt: 1 }] }, {
        url: "images/instruments/cdi/gsflag.png",
        class: "geofs-overlay-moreTransparence", size: { x: 11, y: 24 }, position: { x: 55, y: -12 }, animations: [{ type: "show", value: "NAVVNAV", lt: 1 }]
      }, { url: "images/instruments/cdi/coursedeviationneedle.png", anchor: { x: 1, y: 100 }, size: { x: 6, y: 129 }, position: { x: -100, y: -25 }, iconFrame: { x: 200, y: 200 }, offset: { x: 100, y: 0 }, animations: [{ type: "translateX", value: "NAVCourseDeviation", ratio: 5, fmin: -50, fmax: 50 }] }, {
        url: "images/instruments/cdi/glideslopeneedle.png", anchor: { x: 100, y: 1 }, size: { x: 125, y: 6 }, position: { x: 25, y: -100 }, iconFrame: { x: 200, y: 200 },
        offset: { x: 0, y: -100 }, animations: [{ type: "translateY", value: "NAVGlideAngleDeviation", ratio: -60, fmin: -60, fmax: 60 }]
      }, { url: "images/instruments/cdi/compass.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 }, animations: [{ type: "rotate", value: "NAVOBS", ratio: 1 }] }, { url: "images/instruments/cdi/cover.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 } }, {
        url: "images/instruments/cdi/obs.png", class: "geofs-overlay-moreTransparence", drawOrder: 500, anchor: { x: 22, y: 22 }, size: { x: 44, y: 44 }, position: {
          x: -80,
          y: -80
        }, iconFrame: { x: 44, y: 44 }, manipulator: function (a, b) { instruments.manipulators.setNAVOBS(a, b) }, animations: [{ type: "rotate", value: "NAVOBS", ratio: -2 }]
      }]
    }
  }, hsi: {
    container: ".geofs-instruments-container", compositors: "canvas,css", stackX: !0, overlay: {
      url: "images/instruments/hsi/background.png", class: "geofs-instrument-background", size: { x: 200, y: 200 }, anchor: { x: 100, y: 100 }, position: { x: 100, y: 100 }, rescale: !0, rescalePosition: !0, overlays: [{
        url: "images/instruments/hsi/glideslopegrades.png", anchor: { x: 100, y: 100 }, size: {
          x: 200,
          y: 200
        }, position: { x: 0, y: 0 }, iconFrame: { x: 200, y: 200 }
      }, { url: "images/instruments/hsi/glideslopeindicators.png", anchor: { x: 100, y: 100 }, size: { x: 182, y: 13 }, position: { x: 0, y: 0 }, iconFrame: { x: 200, y: 200 }, offset: { x: 9, y: -94 }, animations: [{ type: "translateY", value: "NAVGlideAngleDeviation", ratio: -60, fmin: -40, fmax: 40 }] }, {
        url: "images/instruments/hsi/compass.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 }, animations: [{ type: "rotate", value: "heading", ratio: 1 }], overlays: [{
          url: "images/instruments/hsi/bar.png",
          class: "geofs-instrument-background", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, animations: [{ type: "rotate", value: "NAVOBS", ratio: -1 }]
        }, { url: "images/instruments/hsi/grads.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, animations: [{ type: "rotate", value: "NAVOBS", ratio: -1 }] }, { url: "images/instruments/hsi/to.png", anchor: { x: 100, y: 100 }, size: { x: 15, y: 14 }, position: { x: 0, y: 0 }, iconFrame: { x: 200, y: 200 }, offset: { x: 110, y: 69 }, animations: [{ type: "show", value: "NAVDirection", eq: "to" }, { type: "rotate", value: "NAVOBS", ratio: -1 }] }, {
          url: "images/instruments/hsi/from.png",
          anchor: { x: 100, y: 100 }, size: { x: 15, y: 14 }, position: { x: 0, y: 0 }, iconFrame: { x: 200, y: 200 }, offset: { x: 110, y: 115 }, animations: [{ type: "show", value: "NAVDirection", eq: "from" }, { type: "rotate", value: "NAVOBS", ratio: -1 }]
        }, { url: "images/instruments/hsi/white-needle.png", anchor: { x: 100, y: 100 }, size: { x: 200, y: 200 }, position: { x: 0, y: 0 }, iconFrame: { x: 200, y: 200 }, offset: { x: 0, y: 0 }, animations: [{ type: "rotate", value: "NAVOBS", ratio: -1 }] }, {
          url: "images/instruments/hsi/yellowbar.png", anchor: { x: 100, y: 100 }, size: { x: 4, y: 80 }, position: { x: 0, y: 0 },
          iconFrame: { x: 200, y: 200 }, offset: { x: 98, y: 60 }, animations: [{ type: "translateX", value: "NAVCourseDeviation", ratio: 5, fmin: -50, fmax: 50 }, { type: "rotate", value: "NAVOBS", ratio: -1 }]
        }, { url: "images/instruments/hsi/bug.png", anchor: { x: 100, y: 100 }, size: { x: 20, y: 16 }, position: { x: 0, y: 0 }, iconFrame: { x: 200, y: 200 }, offset: { x: 90, y: 21 }, animations: [{ type: "rotate", value: "navHDG", ratio: -1 }] }]
      }, {
        url: "images/instruments/hsi/nav.png", class: "geofs-overlay-moreTransparence", anchor: { x: 0, y: 0 }, size: { x: 41, y: 24 }, position: { x: -56, y: 52 }, animations: [{
          type: "show",
          value: "NAVLNAV", lt: 1
        }]
      }, { url: "images/instruments/hsi/courseknob.png", class: "geofs-overlay-moreTransparence", drawOrder: 200, anchor: { x: 22, y: 22 }, size: { x: 44, y: 44 }, position: { x: -80, y: -80 }, iconFrame: { x: 44, y: 44 }, manipulator: function (a, b) { instruments.manipulators.setNAVOBS(a, b) }, animations: [{ type: "rotate", value: "NAVOBS", ratio: -2 }] }, {
        url: "images/instruments/hsi/headingknob.png", class: "geofs-overlay-moreTransparence", drawOrder: 200, anchor: { x: 22, y: 22 }, size: { x: 44, y: 44 }, position: { x: 80, y: -80 }, iconFrame: { x: 44, y: 44 },
        manipulator: function (a, b) { instruments.manipulators.setHDG(a, b) }, animations: [{ type: "rotate", value: "navHDG", ratio: -2 }]
      }, { url: "images/instruments/hsi/plane.png", anchor: { x: 21, y: 23 }, size: { x: 42, y: 46 }, position: { x: 0, y: -7 } }]
    }
  }, wind: {
    container: ".geofs-wind-container", overlay: {
      url: "images/instruments/wind/plane.png", anchor: { x: 0, y: 0 }, alignment: { x: "left", y: "bottom" }, position: { x: 0, y: 0 }, rescale: !1, rescalePosition: !1, size: { x: 50, y: 50 }, class: "control-pad", overlays: [{
        animations: [{
          type: "rotate", value: "relativeWind",
          ratio: -1
        }], url: "images/instruments/wind/pointer.png", anchor: { x: 25, y: 25 }, size: { x: 50, y: 50 }, position: { x: 26, y: 23 }
      }, { animations: [{ type: "text", value: "windSpeedLabel" }], text: "-", class: "control-pad-sticker", anchor: { x: 0, y: 0 }, size: { x: 40, y: 12 }, position: { x: 5, y: -8 } }, { text: "wind", class: "control-pad-label", anchor: { x: 0, y: 0 }, size: { x: 50, y: 15 }, position: { x: 0, y: 40 } }]
    }
  }, trim: {
    group: "controls", container: ".geofs-pads-container", overlay: {
      anchor: { x: 0, y: 0 }, alignment: { x: "right", y: "bottom" }, position: { x: 60, y: 240 }, inline: !0, rescale: !1,
      rescalePosition: !1, size: { x: 50, y: 50 }, class: "control-pad trim-overlay", url: "images/instruments/trim-indicator-background.png", overlays: [{ animations: [{ value: "trim", type: "translateY", ratio: 38 }], url: "images/instruments/trim-indicator-hand.png", anchor: { x: 0, y: 0 }, size: { x: 50, y: 50 }, position: { x: 0, y: 0 } }]
    }
  }, catapult: {
    group: "alarms", container: ".geofs-alarms-container", overlay: {
      anchor: { x: 0, y: 0 }, alignment: { x: "right", y: "bottom" }, position: { x: 0, y: 0 }, inline: !0, rescale: !1, rescalePosition: !1, size: { x: 100, y: 25 }, animations: [{
        value: "onCatapult",
        type: "show", when: [1]
      }], class: "control-pad-transparent", overlays: [{ class: "control-pad-dyn-label green-pad", animations: [{ value: "catapult", type: "show", whenNot: [1] }], text: "ON CATAPULT", anchor: { x: 0, y: 0 }, size: { x: 100, y: 25 }, position: { x: 0, y: 0 } }, { animations: [{ value: "catapult", type: "show", when: [1] }], text: "CATAPULT", class: "control-pad-dyn-label orange-pad", anchor: { x: 0, y: 0 }, size: { x: 100, y: 25 }, position: { x: 0, y: 0 } }]
    }
  }, stall: {
    group: "alarms", container: ".geofs-alarms-container", overlay: {
      anchor: { x: 0, y: 0 }, alignment: {
        x: "right",
        y: "bottom"
      }, position: { x: 0, y: 0 }, inline: !0, rescale: !1, rescalePosition: !1, size: { x: 100, y: 25 }, animations: [{ value: "stalling", type: "show", when: [1] }], class: "control-pad-transparent orange-pad control-pad-dyn-label", text: "STALL"
    }
  }, optionx: {
    group: "controls", container: ".geofs-pads-container", overlay: {
      anchor: { x: 0, y: 0 }, alignment: { x: "right", y: "bottom" }, position: { x: 60, y: 10 }, inline: !0, rescale: !1, rescalePosition: !1, size: { x: 50, y: 25 }, class: "control-pad", manipulator: { setter: "setOptionalAnimatedPart" }, overlays: [{
        class: "control-pad-dyn-label",
        text: "OPTION", drawOrder: 1, anchor: { x: 0, y: 0 }, size: { x: 50, y: 25 }, position: { x: 0, y: 0 }
      }, { animations: [{ value: "optionalAnimatedPartPosition", type: "scaleFrameY", ratio: 50 }], class: "blue-pad", anchor: { x: 0, y: 0 }, size: { x: 50, y: 25 }, position: { x: 0, y: 0 } }]
    }
  }, optionz: {
    group: "controls", container: ".geofs-pads-container", overlay: {
      anchor: { x: 0, y: 0 }, alignment: { x: "right", y: "bottom" }, position: { x: 60, y: 10 }, inline: !0, rescale: !1, rescalePosition: !1, size: { x: 50, y: 25 }, class: "control-pad", manipulator: { setter: "setAccessories" }, overlays: [{
        class: "control-pad-dyn-label",
        text: "ACCES", drawOrder: 1, anchor: { x: 0, y: 0 }, size: { x: 50, y: 25 }, position: { x: 0, y: 0 }
      }, { animations: [{ value: "accessoriesPosition", type: "scaleFrameY", ratio: 50 }], class: "blue-pad", anchor: { x: 0, y: 0 }, size: { x: 50, y: 25 }, position: { x: 0, y: 0 } }]
    }
  }, brakes: {
    group: "controls", container: ".geofs-pads-container", overlay: {
      anchor: { x: 0, y: 0 }, alignment: { x: "right", y: "bottom" }, position: { x: 60, y: 10 }, inline: !0, rescale: !1, rescalePosition: !1, size: { x: 50, y: 45 }, class: "control-pad brakes-overlay", manipulator: { setter: "toggleParkingBrake" }, overlays: [{
        animations: [{
          value: "brakes",
          type: "show", when: [1]
        }], class: "control-pad-dyn-label orange-pad", text: "BRAKES<br/>ON", anchor: { x: 0, y: 0 }, size: { x: 50, y: 45 }, position: { x: 0, y: 0 }
      }, { animations: [{ value: "brakes", type: "show", when: [0] }], class: "control-pad-dyn-label", text: "BRAKES", anchor: { x: 0, y: 0 }, size: { x: 50, y: 45 }, position: { x: 0, y: 0 } }]
    }
  }, gear: {
    group: "controls", container: ".geofs-pads-container", overlay: {
      anchor: { x: 0, y: 0 }, alignment: { x: "right", y: "bottom" }, position: { x: 60, y: 60 }, inline: !0, rescale: !1, rescalePosition: !1, size: { x: 50, y: 45 }, class: "control-pad gear-overlay",
      manipulator: { setter: "setGear" }, overlays: [{ animations: [{ value: "gearPosition", type: "show", when: [0] }], drawOrder: 1, class: "control-pad-dyn-label green-pad", text: "GEAR<br/>DOWN", anchor: { x: 0, y: 0 }, size: { x: 50, y: 45 }, position: { x: 0, y: 0 } }, { animations: [{ value: "gearPosition", type: "show", when: [1] }], drawOrder: 1, class: "control-pad-dyn-label", text: "GEAR<br/>UP", anchor: { x: 0, y: 0 }, size: { x: 50, y: 45 }, position: { x: 0, y: 0 } }, {
        animations: [{ value: "gearPosition", type: "show", whenNot: [0, 1] }], drawOrder: 1, class: "control-pad-dyn-label",
        text: "GEAR<br/>TRANS", anchor: { x: 0, y: 0 }, size: { x: 50, y: 45 }, position: { x: 0, y: 0 }
      }, { animations: [{ value: "invGearPosition", type: "scaleFrameY", ratio: 50 }, { value: "gearPosition", type: "show", whenNot: [0, 1] }], inline: !0, class: "orange-pad", anchor: { x: 0, y: 0 }, size: { x: 50, y: 45 }, position: { x: 0, y: 0 } }]
    }
  }, flaps: {
    group: "controls", container: ".geofs-pads-container", overlay: {
      anchor: { x: 0, y: 0 }, alignment: { x: "right", y: "bottom" }, position: { x: 60, y: 120 }, inline: !0, rescale: !1, rescalePosition: !1, size: { x: 50, y: 45 }, class: "control-pad flaps-overlay",
      manipulator: { setter: "cycleFlaps" }, overlays: [{ animations: [{ type: "text", value: "", concat: ["FLAPS<br/>", "flapsTarget", " / ", "flapsSteps"] }], drawOrder: 1, class: "control-pad-dyn-label", text: "0", anchor: { x: 0, y: 0 }, size: { x: 50, y: 45 }, position: { x: 0, y: 0 } }, { animations: [{ value: "flapsPositionRatio", type: "scaleFrameY", ratio: 50 }, { value: "flapsPositionRatio", type: "show", whenNot: [0] }], inline: !0, alignment: { x: "right", y: "top" }, class: "blue-pad", anchor: { x: 0, y: 0 }, size: { x: 50, y: 45 }, position: { x: 0, y: 0 } }]
    }
  }, spoilers: {
    group: "controls",
    container: ".geofs-pads-container", overlay: {
      anchor: { x: 0, y: 0 }, alignment: { x: "right", y: "bottom" }, position: { x: 60, y: 180 }, inline: !0, rescale: !1, rescalePosition: !1, size: { x: 50, y: 45 }, class: "control-pad spoiler-overlay", manipulator: { setter: "setAirbrakes" }, overlays: [{ animations: [{ value: "airbrakesPosition", type: "show", when: [0] }], drawOrder: 1, class: "control-pad-dyn-label", text: "SPLR<br/>RET", anchor: { x: 0, y: 0 }, size: { x: 50, y: 45 }, position: { x: 0, y: 0 } }, {
        animations: [{ value: "airbrakesPosition", type: "show", whenNot: [0] }], drawOrder: 1,
        class: "control-pad-dyn-label", text: "SPLR<br/>DEP", anchor: { x: 0, y: 0 }, size: { x: 50, y: 45 }, position: { x: 0, y: 0 }
      }, { animations: [{ value: "airbrakesPosition", type: "scaleFrameY", ratio: 50 }], class: "orange-pad", anchor: { x: 0, y: 0 }, size: { x: 50, y: 45 }, position: { x: 0, y: 0 } }]
    }
  }
};
instruments.includesDefinitions = {
  "3d-altimeter": [{ model: "models/gauges/altimeter/altimeter.gltf" }, { name: "hundreds", node: "hundreds", animations: [{ type: "rotate", axis: "Y", value: "altitude", ratio: -.36 }] }, { name: "thousands ", node: "thousands", animations: [{ type: "rotate", axis: "Y", value: "altitude", ratio: -.036 }] }, { name: "tenthousands ", node: "tenthousands", animations: [{ type: "rotate", axis: "Y", value: "altitude", ratio: -.0036 }] }, {
    name: "stripe_hand ", node: "stripe_hand", animations: [{
      type: "rotate", axis: "Y", value: "altitude",
      ratio: -.011, preoffset: -1E4, min: 1E4, max: 15E3
    }]
  }], "3d-ias": [{ model: "models/gauges/ias/ias.gltf" }, { name: "hand ", node: "hand", animations: [{ type: "rotate", axis: "Y", value: "kias", ratio: -1.5, min: 0 }] }], "3d-ias-arcs": [{ model: "models/gauges/ias-arcs/ias-arcs.gltf" }, { name: "hand", node: "hand", animations: [{ type: "rotate", axis: "Y", value: "kias", ratio: -1.5, min: 0 }] }, { name: "yellowArc", node: "yellowArc", animations: [{ type: "rotate", axis: "Y", value: "VNO", ratio: -1.5 }] }, {
    name: "blackArc", node: "blackArc", animations: [{
      type: "rotate",
      axis: "Y", value: "VNE", ratio: -1.5
    }]
  }, { name: "greenArc", node: "greenArc", animations: [{ type: "rotate", axis: "Y", value: "VS", ratio: -1.5 }] }, { name: "whiteArc", node: "whiteArc", animations: [{ type: "rotate", axis: "Y", value: "VS0", ratio: -1.5 }] }, { name: "blackArc2", node: "blackArc2", animations: [{ type: "rotate", axis: "Y", value: "VFE", ratio: -1.5 }] }], "3d-ias-high": [{ model: "models/gauges/kias-high/kiashigh.gltf" }, { name: "hand ", node: "kiashand", animations: [{ type: "rotate", axis: "Y", value: "kias", ratio: -.6, min: 0 }] }], "3d-ias-supersonic": [{ model: "models/gauges/kias-supersonic/kiassupersonic.gltf" },
  { name: "hand ", node: "kiashand", animations: [{ type: "rotate", axis: "Y", value: "kias", ratio: -.3, min: 0 }] }], "3d-compass": [{ model: "models/gauges/compass/compass.gltf" }, { name: "compass-hand ", node: "compass-hand", animations: [{ type: "rotate", axis: "Y", value: "heading", ratio: 1 }] }], "3d-vario": [{ model: "models/gauges/vario/vario.gltf" }, { name: "hand ", node: "hand", animations: [{ type: "rotate", axis: "Y", value: "climbrate", ratio: -.09, max: 1900, min: -1900, offset: 90 }] }], "3d-vario-high": [{ model: "models/gauges/vario-high/vario-high.gltf" },
  { name: "hand ", node: "hand", animations: [{ type: "rotate", axis: "Y", value: "climbrate", ratio: -.025, max: 6E3, min: -6E3, offset: 90 }] }], "3d-attitude": [{ model: "models/gauges/attitude/attitude.gltf" }, { name: "hand", node: "hand", animations: [{ type: "rotate", axis: "Y", value: "aroll", ratio: -1, min: -50, max: 50 }, { type: "translate", axis: "Z", value: "atilt", ratio: 7E-4, min: -25, max: 25 }] }, { name: "ring", node: "ring", animations: [{ type: "rotate", axis: "Y", value: "aroll", ratio: -1, min: -50, max: 50 }] }], "3d-attitude-jet": [{ model: "models/gauges/attitude-jet/attitude.gltf" },
  { name: "ball", node: "ball", animations: [{ type: "rotate", axis: "Y", value: "aroll", ratio: -1 }, { type: "rotate", axis: "X", value: "atilt", ratio: 1 }] }, { name: "hand", node: "hand", animations: [{ type: "rotate", axis: "Y", value: "aroll", ratio: -1, min: -50, max: 50 }] }], "3d-attitude-jet2": [{ model: "models/gauges/attitude-jet2/attitudejet.gltf" }, { name: "ball", node: "ball", animations: [{ type: "rotate", axis: "Y", value: "aroll", ratio: -1 }, { type: "rotate", axis: "X", value: "atilt", ratio: 1 }] }, {
    name: "hand", node: "hand", animations: [{
      type: "rotate", axis: "Y",
      value: "aroll", ratio: -1, min: -50, max: 50
    }]
  }], "3d-rpm-3000": [{ model: "models/gauges/rpm3000/rpm3000.gltf" }, { name: "hand", node: "hand", animations: [{ type: "rotate", axis: "Y", value: "rpm", ratio: -.09, offset: 160 }] }], "3d-rpm": [{ model: "models/gauges/rpm/rpm.gltf" }, { name: "hand", node: "hand", animations: [{ type: "rotate", axis: "Y", value: "rpm", ratio: -.03, offset: 120 }] }], "3d-jet-rpm": [{ model: "models/gauges/jet-rpm/rpm.gltf" }, { name: "hand", node: "hand", animations: [{ type: "rotate", axis: "Y", value: "rpm", ratio: -.027 }] }, {
    name: "smallhand",
    node: "smallhand", animations: [{ type: "rotate", axis: "Z", value: "rpm", ratio: .036 }]
  }], "3d-turn-coordinator": [{ model: "models/gauges/turn-coordinator/turncoordinator.gltf" }, { name: "turn-rate-hand", node: "turn-rate-hand", animations: [{ type: "rotate", axis: "Y", value: "turnrate", ratio: -.11, fmin: -40, fmax: 40 }] }, { name: "ball", node: "ball", animations: [{ type: "rotate", axis: "Y", value: "accX", ratio: -4, fmin: -15, fmax: 15 }] }], "3d-gmeter": [{ model: "models/gauges/gmeter/gmeter.gltf" }, {
    name: "hand ", node: "hand", animations: [{
      type: "rotate",
      axis: "Y", value: "accZ", ratio: -2.25, min: -30, max: 180, offset: 0
    }]
  }], "3d-compassball": [{ model: "models/gauges/compassball/compassball.gltf" }, { name: "ball ", node: "ball", animations: [{ type: "rotate", axis: "X", value: "atilt", ratio: -1, fmin: -10, fmax: 10 }, { type: "rotate", axis: "Y", value: "aroll", ratio: 1, fmin: -10, fmax: 10 }, { type: "rotate", axis: "Z", value: "heading360", ratio: -1, offset: 0 }] }], "3d-manifold": [{ model: "models/gauges/manifold/manifold.gltf" }, {
    name: "handmanifoldpressure", node: "handmanifoldpressure", animations: [{
      type: "rotate",
      axis: "Y", value: "rpm", ratio: -.018, offset: 0
    }]
  }, { name: "handfuelflow", node: "handfuelflow", animations: [{ type: "rotate", axis: "Y", value: "rpm", ratio: -.028, offset: 0 }] }], "3d-oil": [{ model: "models/gauges/oil/oil.gltf" }, { name: "handoilpressure", node: "handoilpressure", animations: [{ type: "rotate", axis: "Y", value: "rpm", ratio: -.3, offset: 0, fmin: -120 }] }, { name: "handoiltemp", node: "handoiltemp", animations: [{ type: "rotate", axis: "Y", value: "rpm", ratio: -.1, offset: 0, fmin: -120 }] }], "3d-cdi": [{ model: "models/gauges/cdi/cdi.gltf" }, {
    name: "obsKnob",
    node: "obsKnob", manipulator: function (a, b) { instruments.manipulators.setNAVOBS(a, b) }, animations: [{ type: "rotate", axis: "Y", value: "NAVOBS", ratio: -1 }]
  }, { name: "compass", node: "compass", animations: [{ type: "rotate", axis: "Y", value: "NAVOBS", ratio: 1 }] }, { name: "courseDeviation", node: "courseDeviation", animations: [{ type: "translate", axis: "X", value: "NAVCourseDeviation", ratio: .0015, fmin: -.02, fmax: .02 }] }, {
    name: "glideSlope", node: "glideSlope", animations: [{
      type: "translate", axis: "Z", value: "NAVGlideAngleDeviation", ratio: .015,
      fmin: -.02, fmax: .02
    }]
  }, { name: "toMask", node: "toMask", animations: [{ type: "show", value: "NAVDirection", eq: "from" }] }, { name: "fromMask", node: "fromMask", animations: [{ type: "show", value: "NAVDirection", eq: "to" }] }, { name: "navvlocmask", node: "navvlocmask", animations: [{ type: "hide", value: "NAVMODE", eq: "NAV" }] }, { name: "gpsmask", node: "gpsmask", animations: [{ type: "hide", value: "NAVMODE", eq: "GPS" }] }, { name: "navflag", node: "navflag", animations: [{ type: "show", value: "NAVLNAV", lt: 1 }] }, {
    name: "gsflag", node: "gsflag", animations: [{
      type: "show",
      value: "NAVVNAV", lt: 1
    }]
  }], "3d-hsi": [{ model: "models/gauges/hsi/hsi.gltf" }, { name: "courseKnob", node: "courseKnob", manipulator: function (a, b) { instruments.manipulators.setNAVOBS(a, b) }, animations: [{ type: "rotate", axis: "Y", value: "NAVOBS", ratio: -1 }] }, { name: "headingKnob", node: "headingKnob", manipulator: function (a, b) { instruments.manipulators.setHDG(a, b) }, animations: [{ type: "rotate", axis: "Y", value: "navHDG", ratio: -1 }] }, { name: "course", node: "course", animations: [{ type: "rotate", axis: "Y", value: "NAVOBS", ratio: -1 }] }, {
    name: "compass",
    node: "compass", animations: [{ type: "rotate", axis: "Y", value: "heading", ratio: 1 }]
  }, { name: "bug", node: "bug", animations: [{ type: "rotate", axis: "Y", value: "navHDG", ratio: -1 }] }, { name: "deviation", node: "deviation", animations: [{ type: "translate", axis: "X", value: "NAVCourseDeviation", ratio: .001, fmin: -.02, fmax: .02 }] }, { name: "direction", node: "direction", animations: [{ type: "rotate", axis: "Y", value: "NAVDirection", eq: "from", ratio: 180 }] }, {
    name: "glideSlope", node: "glideSlope", animations: [{
      type: "translate", axis: "Z", value: "NAVGlideAngleDeviation",
      ratio: .015, fmin: -.02, fmax: .02
    }]
  }, { name: "nav_flag", node: "nav_flag", animations: [{ type: "rotate", axis: "Y", value: "NAVLNAV", ratio: 25 }] }], "3d-rmi": [{ model: "models/gauges/rmi/rmi.gltf" }, { name: "compass", node: "compass", animations: [{ type: "rotate", axis: "Y", value: "heading", ratio: 1 }] }, { name: "ADFNeedle", node: "ADFNeedle", animations: [{ type: "rotate", axis: "Y", value: "ADFBearingToStation", ratio: 1 }] }, { name: "VORNeedle", node: "VORNeedle", animations: [{ type: "rotate", axis: "Y", value: "NAVBearingToStation", ratio: 1 }] }], "3d-BoeingPFD": [{
    model: {
      url: "models/gauges/glassPanel/glassPanel.gltf",
      shader: { name: "glassPanel", textures: { diffuse: "" } }
    }, shadows: "SHADOWS_NONE", renderer: { willReadFrequently: !0, name: "PFDBoeing", width: 512, height: 512, images: { background: "images/instruments/BoeingPFD/background.png", attitude: "images/instruments/BoeingPFD/attitude.png", overlays: "images/instruments/BoeingPFD/overlays.png" } }, animations: [{ type: "render", value: "geofsTime" }]
  }], "3d-AirbusPFD": [{
    model: { url: "models/gauges/glassPanel/glassPanel.gltf", shader: { name: "glassPanel", textures: { diffuse: "" } } }, shadows: "SHADOWS_NONE",
    renderer: { name: "PFDAirbus", width: 512, height: 512, images: { background: "images/instruments/airbusPFD/background.png", attitude: "images/instruments/airbusPFD/attitude.png", overlays: "images/instruments/airbusPFD/overlays.png" } }, animations: [{ type: "render", value: "geofsTime" }]
  }], "3d-EICAS": [{
    model: { url: "models/gauges/glassPanel/EICAS.gltf", shader: { name: "glassPanel", textures: { diffuse: "" } } }, shadows: "SHADOWS_NONE", renderer: { name: "genericEICAS", width: 512, height: 512, images: { background: "images/instruments/EICAS/background.png" } },
    animations: [{ type: "render", value: "geofsTime" }]
  }], "3d-HUD": [{ model: { url: "models/gauges/glassPanel/HUD.gltf", shader: { name: "HUD", textures: { diffuse: "" }, translucent: !0 } }, safeTransparency: !0, renderer: { name: "genericHUD", width: 512, height: 512, images: { background: "images/instruments/glassHUD/background.png", overlays: "images/instruments/glassHUD/overlays.png" } }, animations: [{ type: "render", value: "geofsTime" }], shadows: "SHADOWS_NONE" }], "3d-G1000": [{
    model: {
      url: "models/gauges/glassPanel/g1000.gltf", shader: {
        name: "glassPanel",
        textures: { diffuse: "" }
      }
    }, renderer: { name: "G1000", width: 1024, height: 1024, images: { background: "images/instruments/G1000/background.png", overlays: "images/instruments/G1000/overlays.png" } }, animations: [{ type: "render", value: "geofsTime" }], shadows: "SHADOWS_NONE"
  }]
};
instruments.manipulators = { setNAV1OBS: function (a, b) { geofs.nav.setOBS("NAV1", null, b, !0) }, setNAVOBS: function (a, b) { geofs.nav.setOBS(null, null, b, !0) }, setHDG: function (a, b) { geofs.nav.setHDG(null, b, !0) }, setADFManCourse: function (a, b) { geofs.nav.setADFManCourse(null, b) } };
instruments.init = function (a) {
  instruments.stackPosition = { x: 100, y: 0 }; geofs.includes = Object.assign(geofs.includes, instruments.includesDefinitions); a && a != "default" || (a = { compass: "", airspeed: "", attitude: "", altitude2: "", vario: "", rpm: "", brakes: "" }); a == "jet" && (a = { compass: "", airspeedJet: "", attitudeJet: "", altitude2: "", varioJet: "", rpmJet: "", brakes: "" }); a.stall = ""; for (var b in instruments.list) instruments.list[b].destroy(); instruments.list = {}; instruments.groups = {}; instruments.containers = {}; for (b in a) {
    var c = $.extend(!0,
      {}, instruments.definitions[b], a[b]); c && (c.container && (instruments.containers[c.container] = instruments.containers[c.container] || $(c.container)[0]), c.overlay ? (instruments.list[b] = new Indicator(c), c = c.group || "all", instruments.groups[c] = instruments.groups[c] || {}, instruments.groups[c][b] = instruments.list[b]) : c.include && (geofs.aircraft.instance.addParts([c]), geofs.aircraft.instance.parts[c.name].animations.push({ value: "overlaysVisibility", type: "hide", eq: "hidden" })))
  } instruments.list.wind || (instruments.definitions.wind.visibility =
    weather.windActive ? !0 : !1, instruments.list.wind = new Indicator($.extend(!0, {}, instruments.definitions.wind))); instruments.resizeHandler || (instruments.resizeHandler = geofs.addResizeHandler(function () { instruments.updateScreenPositions() }))
}; instruments.reset = function () { instruments.updateScreenPositions() }; instruments.toggle = function () { instruments.visible ? instruments.hide() : instruments.show() }; instruments.add = function (a, b) { instruments.list[b] = a };
instruments.hide = function (a) { var b = instruments.list; a && (b = instruments.groups[a] || {}); for (var c in b) b[c].hide(); a || (geofs.animation.values.overlaysVisibility = "hidden"); instruments.visible = !1 }; instruments.show = function (a) { var b = instruments.list; a && (b = instruments.groups[a] || {}); for (var c in b) b[c].show(); a || (geofs.animation.values.overlaysVisibility = "visible"); instruments.visible = !0 }; instruments.setOpacity = function (a) { for (var b in instruments.list) instruments.list[b].overlay.setOpacity(a) };
instruments.rescale = function () { for (var a in instruments.list) instruments.list[a].scale(); instruments.updateCockpitPositions() }; instruments.update = function (a) { for (var b in instruments.list) instruments.list[b].update(a) }; instruments.updateCockpitPositions = function () { for (var a in instruments.list) instruments.list[a].updateCockpitPosition(); instruments.update(!0) };
instruments.updateScreenPositions = function () {
  var a = {}, b; for (b in instruments.list) {
    var c = instruments.list[b]; geofs.camera.currentModeName == "cockpit" && c.definition.cockpit ? c.updateCockpitPosition() : c.overlay && (c.overlay.rotation = 0, c.overlay.scaleAndPlace(), c.definition.container && (a[c.definition.container] = a[c.definition.container] || { x: 0, y: 0 }, a[c.definition.container].x = Math.max(a[c.definition.container].x, c.overlay.position.x + c.overlay.size.x - c.overlay.anchor.x), a[c.definition.container].y = Math.max(a[c.definition.container].y,
      c.overlay.position.y + c.overlay.size.y - c.overlay.anchor.y)))
  } if (geofs.api.preferredCompositor == "css") for (b in instruments.containers) instruments.containers[b].style.width = a[b].x + "px", instruments.containers[b].style.height = a[b].y + "px"; instruments.update(!0)
};
var Indicator = function (a) {
  this.definition = Object.assign({}, this.definition, a); this.scale(); var b = a.overlay; b.cockpit = !!this.definition.cockpit; b.compositors = this.definition.compositors; this.visibility = a.visibility != void 0 ? a.visibility : !0; geofs.api.preferredCompositor == "css" && (a.stackX && (b.position.x = instruments.stackPosition.x + b.position.x, instruments.stackPosition.x += b.size.x + instruments.defaultMargin), a.stackY && (a = b.position.y, b.position.y = instruments.stackPosition.y + b.size.y / 2 + a, instruments.stackPosition.y +=
    b.size.y + instruments.defaultMargin + a), b.position.y = b.alignment && b.alignment.y == "top" ? b.position.y + instruments.margins[0] : b.position.y + instruments.margins[2], b.position.x = b.alignment && b.alignment.x == "right" ? b.position.x + instruments.margins[1] : b.position.x + instruments.margins[3]); this.overlay = new Overlay(b, null, this.definition.container); this.setVisibility(this.visibility); return this
};
Indicator.prototype.scale = function () { if (this.definition.cockpit && this.definition.cockpit.position) { var a = geofs.aircraft.instance.definition.scale * geofs.aircraft.instance.definition.cockpitScaleFix; this.definition.cockpit.originalScale = this.definition.cockpit.originalScale || this.definition.cockpit.scale; this.definition.cockpit.scale = this.definition.cockpit.originalScale * a } }; Indicator.prototype.show = function () { this.overlay.setVisibility(!0); this.visibility = !0 };
Indicator.prototype.hide = function () { this.overlay.setVisibility(!1); this.visibility = !1 }; Indicator.prototype.setVisibility = function (a) { this.overlay.setVisibility(a); this.visibility = a };
Indicator.prototype.updateCockpitPosition = function () {
  if (this.definition.cockpit) {
    var a = this.definition.cockpit.position; geofs.aircraft.instance.object3d.setVectorWorldPosition(a); a.worldPosition = V3.scale(a.worldPosition, geofs.aircraft.instance.definition.cockpitScaleFix); var b = V3.add(geofs.aircraft.instance.llaLocation, xyz2lla(a.worldPosition, geofs.aircraft.instance.llaLocation)), c = geofs.api.getScreenCoordFromLla(b); c && (b = c.x, c = c.y, a = .8 / V3.length(V3.sub(geofs.camera.worldPosition, a.worldPosition)) *
      this.definition.cockpit.scale, this.overlay.scale = { x: a * geofs.fovScale, y: a * geofs.fovScale }, this.overlay.position = { x: b, y: geofs.viewportHeight - c }, this.overlay.rotation = fixAngle(geofs.camera.currentDefinition.orientations.current[0]) * .3, this.overlay.scaleAndPlace(this.overlay.scale, this.overlay.position, null, !0))
  }
};
Indicator.prototype.update = function (a) { this.overlay.animate(a); if (this.definition.animations) for (a = 0; a < this.definition.animations.length; a++) { var b = this.definition.animations[a], c = geofs.animation.filter(b); if (b.lastValue == c) break; b.lastValue = c; switch (b.type) { case "show": this.visibility && this.overlay.setVisibility(c) } } }; Indicator.prototype.destroy = function () { this.overlay && this.overlay.destroy() }; instruments.rendererInstancesByName = {};
instruments.Renderer = function (a) { this.definition = Object.assign({}, a); instruments.rendererInstancesByName[this.definition.name] ? this.reuseExistingRenderer = instruments.rendererInstancesByName[this.definition.name] : (this.canvasAPI = new geofs.api.Canvas(a), this.loadImages(), instruments.rendererInstancesByName[this.definition.name] = this) };
instruments.Renderer.prototype = {
  loadImages: function () { this.images = {}; for (var a in this.definition.images) this.images[a] = new Image, this.images[a].src = this.definition.images[a] }, update: function (a, b) {
    this.reuseExistingRenderer ? b = instruments.rendererInstancesByName[this.definition.name].canvasAPI : (instruments.renderers[this.definition.name](this), b = this.canvasAPI); if (a) {
      if (a.safeTransparency) try {
        geofs.version >= 4 ? a.object3d.model._model._nodesByName.glassPanel._runtimeNode.runtimePrimitives[0].drawCommand._originalCommand.command._pass =
          10 : a.object3d.model._model._nodeCommands[0].command._pass = 9, a.safeTransparency = !1
      } catch (c) { } a.object3d.model.setTextureFromCanvas(b, this.definition.textureIndex)
    }
  }, destroy: function () { for (var a in this.images) this.images[a] = null, delete this.images[a]; this.images = null; this.canvasAPI && this.canvasAPI.destroy(); instruments.rendererInstancesByName[this.definition.name] = null; delete instruments.rendererInstancesByName[this.definition.name] }, drawGrads: function (a, b) {
    var c = a.context, d = b.pattern.length; b.position.x =
      b.position[0]; b.position.y = b.position[1]; b.center = b.center || [0, 0]; b.center.x = b.center[0]; b.center.y = b.center[1]; b.size.x = b.size[0]; b.size.y = b.size[1]; b.rotation && (c.translate(b.position[0], b.position[1]), c.rotate(b.rotation), b.position = [0, 0]); var e = V2.sub(b.position, b.center); b.x = e[0]; b.y = e[1]; b.value = b.value || 0; b.zero = b.zero || [0, 0]; b.zero.x = b.zero[0]; b.zero.y = b.zero[1]; e = b.interval * d; var f = e * b.pixelRatio; b.value -= (b.size[b.orientation] - b.zero[b.orientation]) / f * e; var g = b.value % e; b.value -= g; g *= b.pixelRatio;
    g <= -f * .5 && (g += f, b.value -= e); b[b.orientation] -= g * b.direction; b.direction < 0 && (b[b.orientation] += b.size[b.orientation]); var k = b.orientation == "x" ? "y" : "x"; b[k] += b.zero[k]; e = Math.ceil(b.size[b.orientation] / (b.interval * b.pixelRatio)); c.beginPath(); var m = 0; for (f = {}; m <= e + d; f = { position$jscomp$21: void 0 }, m++)g = b.pattern[m % d], f.position$jscomp$21 = Math.round(b[b.orientation] + m * b.interval * b.direction * b.pixelRatio), g.forEach(function (n) {
      return function (q) {
        var u = b.x, z = b.y; q.offset = q.offset || { x: 0, y: 0 }; b.orientation ==
          "x" ? (b.align == "bottom" && (z += b.size.y), b.align == "middle" && (z += b.center.y), c.moveTo(n.position$jscomp$21, z), c.lineTo(n.position$jscomp$21, z + q.length)) : (b.align == "right" && (u += b.size.x), b.align == "center" && (u += b.center.x), c.moveTo(u + q.offset.x, n.position$jscomp$21 + q.offset.y), c.lineTo(u + q.offset.x + q.length, n.position$jscomp$21 + q.offset.y)); if (q.legend) {
            var B = b.value + b.interval * m; q.process && (B = q.process(B)); b.orientation == "x" ? c.fillText(B, n.position$jscomp$21 + q.legendOffset.x, z + q.legendOffset.y) : c.fillText(B,
              u + q.legendOffset.x, n.position$jscomp$21 + q.legendOffset.y)
          }
      }
    }(f)); c.stroke(); b.sprites && b.sprites.forEach(function (n) { var q = b[b.orientation] + (n.value - b.value) * b.pixelRatio * b.direction; n.clamp && (q = clamp(q, b.position[b.orientation], b.position[b.orientation] + b.height)); n.destination = [b[k], q]; a.drawSprite(n) })
  }
};
instruments.renderers = {
  PFDBoeing: function (a) {
    var b = exponentialSmoothing("smoothKias", geofs.animation.getValue("kias"), .1), c = [893, 980]; c = V2.parseInt(V2.scale(c, .25)); var d = a.canvasAPI.context; a.canvasAPI.clear("#000000"); a.canvasAPI.drawRotatedSprite({ image: a.images.attitude, origin: [0, 0], size: [350, 1400], center: [175, 700], destination: c, rotation: geofs.animation.getValue("aroll") * DEGREES_TO_RAD, translation: [0, geofs.animation.getValue("atilt") * 5] }); a.canvasAPI.drawRotatedSprite({
      image: a.images.overlays,
      origin: [245, 56], size: [23, 21], center: [11, 120], destination: c, rotation: geofs.animation.getValue("aroll") * DEGREES_TO_RAD, translation: [0, 0]
    }); d.drawImage(a.images.background, 0, 0); d.fillStyle = "#00ff08"; d.textAlign = "center"; d.font = "18px sans-serif"; var e = "", f = "", g = ""; geofs.autopilot.on && (e = "SPD", geofs.autopilot.mode == "NAV" ? (f = "LNAV", g = geofs.autopilot.VNAV ? "V/S" : "ALT") : (f = "HDG SEL", g = "ALT")); d.fillText(e, 133, 20); d.fillText(f, 230, 20); d.fillText(g, 325, 20); d.fillStyle = "#ffffff"; d.textAlign = "center"; d.font = "14px sans-serif";
    f = e = ""; geofs.animation.getValue("NAVMODE") == "GPS" && (e = "GPS"); geofs.animation.getValue("NAVMODE") == "NAV" && (e = "VOR/LOC"); geofs.autopilot.VNAV && (f = "G/S"); d.fillText(e, 230, 33); d.fillText(f, 325, 33); geofs.animation.getValue("haglFeet") <= 2500 && (d.fillStyle = "#ffffff", d.textAlign = "right", d.font = "bold 20px sans-serif", d.fillText(Math.floor(geofs.animation.getValue("haglFeet")), 350, 95)); a.canvasAPI.drawSprite({
      image: a.images.overlays, origin: [101, 0], size: [13, 20], center: [6, 10], destination: [355, c[1]], translation: [0,
        clamp(geofs.animation.getValue("NAVGlideAngleDeviation") * -107, -75, 75)]
    }); a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [114, 0], size: [20, 13], center: [10, 6], destination: [c[0], 390], translation: [clamp(geofs.animation.getValue("NAVCourseDeviation") * 6.5, -75, 75), 0] }); a.canvasAPI.drawRotatedSprite({ image: a.images.overlays, origin: [101, 101], size: [310, 310], center: [155, 155], destination: [c[0], 602], rotation: -geofs.animation.getValue("heading") * DEGREES_TO_RAD }); a.canvasAPI.drawRotatedSprite({
      image: a.images.overlays,
      origin: [243, 88], size: [26, 13], center: [12, 165], destination: [c[0], 602], rotation: (-geofs.animation.getValue("heading") + geofs.autopilot.values.course) * DEGREES_TO_RAD
    }); d.lineWidth = 2; d.fillStyle = "#FFFFFF"; d.strokeStyle = "#FFFFFF"; d.textAlign = "right"; d.font = "22px sans-serif"; d.save(); d.beginPath(); d.rect(11, 60, 90, 381); d.rect(5, 210, 50, 70); d.clip("evenodd"); a.drawGrads(a.canvasAPI, {
      position: [64, 60], zero: [0, 190], size: [90, 380], orientation: "y", direction: -1, value: b, interval: 10, pixelRatio: 3.16, pattern: [[{
        length: 10,
        legend: !0, legendOffset: { x: -8, y: 7 }
      }], [{ length: 10 }]], sprites: [{ image: a.images.overlays, origin: [134, 0], size: [31, 19], center: [5, 10], value: geofs.autopilot.values.speed, clamp: !0 }]
    }); d.restore(); d.save(); d.beginPath(); d.rect(365, 60, 84, 381); d.rect(400, 210, 65, 70); d.clip("evenodd"); d.font = "16px sans-serif"; a.drawGrads(a.canvasAPI, {
      position: [385, 60], zero: [0, 190], size: [84, 380], orientation: "y", direction: -1, value: geofs.animation.getValue("altitude"), interval: 100, pixelRatio: .475, pattern: [[{
        length: 10, legend: !0, legendOffset: {
          x: 60,
          y: 7
        }
      }], [{ length: 10 }]], sprites: [{ image: a.images.overlays, origin: [223, 0], size: [33, 56], center: [5, 28], value: geofs.autopilot.values.altitude, clamp: !0 }, { image: a.images.overlays, origin: [256, 0], size: [64, 25], center: [2, 0], value: geofs.animation.getValue("groundElevationFeet") }]
    }); d.restore(); d.save(); d.beginPath(); d.rect(7, 220, 48, 50); d.rect(404, 220, 65, 50); d.rect(475, 116, 28, 262); d.clip(); d.beginPath(); d.lineWidth = 3; d.strokeStyle = "#FFFFFF"; e = clamp(Math.log(Math.abs(geofs.animation.getValue("verticalSpeed") / 1E3)) *
      35 + 60, 0, 125) * Math.sign(geofs.animation.getValue("verticalSpeed")); d.moveTo(530, c[1]); d.lineTo(482, c[1] - e); d.stroke(); a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [166, 0], size: [13, 5], center: [0, 2], destination: [480, c[1]], translation: [0, -clamp(Math.log(Math.abs(geofs.autopilot.values.verticalSpeed / 1E3)) * 35 + 60, 0, 125) * Math.sign(geofs.autopilot.values.verticalSpeed)] }); a.canvasAPI.drawSprite({
        image: a.images.overlays, origin: [0, 0], size: [16, 512], center: [0, 512], destination: [8, 256], translation: [0, geofs.utils.stickyRounding(b %
          1E3 * .01, .01) * 48]
      }); a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [0, 0], size: [16, 512], center: [0, 512], destination: [24, 256], translation: [0, geofs.utils.stickyRounding(b % 100 * .1, .1) * 48] }); a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [16, 0], size: [16, 512], center: [0, 487], destination: [40, 256], translation: [0, b % 10 * 25] }); geofs.animation.getValue("altTenThousands") > 9999 ? a.canvasAPI.drawSprite({
        image: a.images.overlays, origin: [0, 0], sprite: [16, 512], size: [14, 512], center: [0, 512], destination: [406,
          256], translation: [0, geofs.utils.stickyRounding(geofs.animation.getValue("altTenThousands") * 1E-4, .01) * 48]
      }) : a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [70, 490], size: [16, 21], center: [0, 21], destination: [406, 256], translation: [0, 0] }); a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [0, 0], sprite: [16, 512], size: [14, 512], center: [0, 512], destination: [420, 256], translation: [0, geofs.utils.stickyRounding(geofs.animation.getValue("altThousands") * .001, .01) * 48] }); a.canvasAPI.drawSprite({
        image: a.images.overlays,
        origin: [32, 0], size: [12, 512], center: [0, 512], destination: [434, 253], translation: [0, geofs.utils.stickyRounding(geofs.animation.getValue("altHundreds") * .01, .1) * 40]
      }); a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [44, 0], size: [24, 512], center: [0, 496], destination: [445, 256], translation: [0, geofs.animation.getValue("altTens") * .8] }); d.restore()
  }, PFDAirbus: function (a) {
    var b = exponentialSmoothing("smoothKias", geofs.animation.getValue("kias"), .1), c = [893, 980]; c = V2.parseInt(V2.scale(c, .25)); var d = a.canvasAPI.context;
    a.canvasAPI.clear("#000000"); a.canvasAPI.drawRotatedSprite({ image: a.images.attitude, origin: [0, 0], size: [350, 1400], center: [175, 700], destination: c, rotation: geofs.animation.getValue("aroll") * DEGREES_TO_RAD, translation: [0, geofs.animation.getValue("atilt") * 5] }); a.canvasAPI.drawRotatedSprite({ image: a.images.overlays, origin: [248, 0], size: [36, 28], center: [18, 135], destination: c, rotation: geofs.animation.getValue("aroll") * DEGREES_TO_RAD, translation: [0, 0] }); d.drawImage(a.images.background, 0, 0); d.fillStyle = "#00ff08";
    d.textAlign = "center"; d.font = "18px sans-serif"; var e = "", f = "", g = ""; geofs.autopilot.on && (e = "SPD", geofs.autopilot.mode == "NAV" ? (f = "NAV", geofs.autopilot.VNAV ? (f = "LOC", g = "G/S") : g = "ALT") : (f = "HDG SEL", g = "ALT")); d.fillText(e, 80, 20); d.fillText(g, 170, 20); d.fillText(f, 280, 20); geofs.animation.getValue("haglFeet") <= 2500 && (d.fillStyle = "#ffffff", d.textAlign = "right", d.font = "bold 20px sans-serif", d.fillText(Math.floor(geofs.animation.getValue("haglFeet")), 350, 95)); a.canvasAPI.drawSprite({
      image: a.images.overlays, origin: [99,
        0], size: [16, 24], center: [8, 12], destination: [355, c[1]], translation: [0, clamp(geofs.animation.getValue("NAVGlideAngleDeviation") * -107, -75, 75)]
    }); a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [116, 0], size: [24, 16], center: [12, 8], destination: [c[0], 410], translation: [clamp(geofs.animation.getValue("NAVCourseDeviation") * 6.5, -75, 75), 0] }); d.lineWidth = 2; d.fillStyle = "#FFFFFF"; d.strokeStyle = "#FFFFFF"; d.font = "20px sans-serif"; d.textAlign = "right"; d.save(); d.beginPath(); d.rect(14, 110, 80, 270); d.clip("evenodd");
    a.drawGrads(a.canvasAPI, { position: [62, 110], zero: [0, 135], size: [80, 270], orientation: "y", direction: -1, value: b, interval: 10, pixelRatio: 3.2, pattern: [[{ length: 10, legend: !0, legendOffset: { x: -8, y: 7 } }], [{ length: 10 }]], sprites: [{ image: a.images.overlays, origin: [143, 0], size: [25, 27], center: [-8, 13], value: geofs.autopilot.values.speed, clamp: !0 }] }); d.restore(); d.save(); d.beginPath(); d.rect(376, 110, 50, 270); d.rect(382, 227, 45, 36); d.clip("evenodd"); a.drawGrads(a.canvasAPI, {
      position: [418, 110], size: [50, 270], zero: [0, 135], orientation: "y",
      direction: -1, value: geofs.animation.getValue("altitude"), interval: 100, pixelRatio: .25, pattern: [[{ length: 6, legend: !0, legendOffset: { x: -2, y: 7 }, process: function (k) { return Math.round(k / 100) } }], [{ length: 6 }], [{ length: 6 }], [{ length: 6 }], [{ length: 6 }]], sprites: [{ image: a.images.overlays, origin: [223, 0], size: [25, 62], center: [5, 31], value: geofs.autopilot.values.altitude, clamp: !0 }, { image: a.images.overlays, origin: [383, 0], size: [42, 255], center: [0, 0], value: geofs.animation.getValue("groundElevationFeet") }]
    }); d.restore(); d.save();
    d.beginPath(); d.rect(105, 455, 236, 37); d.clip("evenodd"); d.textAlign = "center"; a.drawGrads(a.canvasAPI, { position: [105, 455], zero: [118, 0], size: [236, 37], orientation: "x", direction: 1, value: geofs.animation.getValue("heading360"), interval: 5, pixelRatio: 4.75, pattern: [[{ length: 10, legend: !0, legendOffset: { x: 0, y: 30 }, process: function (k) { return Math.round(fixAngle360(k) / 10) } }], [{ length: 5 }]] }); d.restore(); d.save(); d.beginPath(); d.rect(382, 232, 45, 26); d.rect(428, 223, 29, 45); d.rect(473, 90, 28, 314); d.clip(); d.beginPath();
    d.lineWidth = 3; d.strokeStyle = "#FFFFFF"; b = clamp(Math.log(Math.abs(geofs.animation.getValue("verticalSpeed") / 1E3)) * 100 + 75, 0, 125) * Math.sign(geofs.animation.getValue("verticalSpeed")); d.moveTo(530, c[1]); d.lineTo(482, c[1] - b); d.stroke(); a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [166, 0], size: [13, 5], center: [0, 2], destination: [480, c[1]], translation: [0, -clamp(Math.log(Math.abs(geofs.autopilot.values.verticalSpeed / 1E3)) * 35 + 60, 0, 160) * Math.sign(geofs.autopilot.values.verticalSpeed)] }); geofs.animation.getValue("altTenThousands") >
      9999 && a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [16, 0], sprite: [16, 512], size: [16, 512], center: [0, 487], destination: [382, 256], translation: [0, geofs.utils.stickyRounding(geofs.animation.getValue("altTenThousands") * 1E-4, .01) * 25] }); a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [16, 0], sprite: [16, 512], size: [16, 512], center: [0, 487], destination: [397, 256], translation: [0, geofs.utils.stickyRounding(geofs.animation.getValue("altThousands") * .001, .01) * 25] }); a.canvasAPI.drawSprite({
        image: a.images.overlays,
        origin: [16, 0], sprite: [16, 512], size: [16, 512], center: [0, 487], destination: [412, 256], translation: [0, geofs.utils.stickyRounding(geofs.animation.getValue("altHundreds") * .01, .1) * 25]
      }); a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [44, 0], size: [24, 512], center: [0, 496], destination: [430, 246], translation: [0, geofs.animation.getValue("altTens") * .8] }); d.restore()
  }, genericHUD: function (a) {
    var b = exponentialSmoothing("smoothKias", geofs.animation.getValue("kias"), .1), c = [256, 256], d = a.canvasAPI.context; a.canvasAPI.clear();
    d.fillStyle = "#00ff00"; d.strokeStyle = "#00ff00"; d.save(); d.beginPath(); d.arc(c[0], c[1], 200, 0, 6.28); d.clip(); d.textAlign = "left"; a.drawGrads(a.canvasAPI, {
      position: c, center: [100, 100], zero: [100, 100], size: [200, 200], orientation: "y", direction: -1, rotation: geofs.animation.getValue("aroll") * DEGREES_TO_RAD, value: -geofs.animation.getValue("atilt"), interval: 5, pixelRatio: 20, pattern: [[{ length: 40, offset: { x: -50, y: 0 }, legend: !0, legendOffset: { x: -80, y: 5 }, process: function (g) { return Math.round(g) } }, {
        length: 40, offset: {
          x: 10,
          y: 0
        }, legend: !0, legendOffset: { x: 60, y: 5 }, process: function (g) { return Math.round(g) }
      }]]
    }); d.restore(); a.canvasAPI.drawRotatedSprite({ image: a.images.overlays, origin: [248, 0], size: [36, 28], center: [18, 210], destination: [256, 256], rotation: geofs.animation.getValue("aroll") * DEGREES_TO_RAD, translation: [0, 0] }); d.drawImage(a.images.background, 0, 0); d.lineWidth = 2; d.font = "20px sans-serif"; d.textAlign = "right"; d.save(); d.beginPath(); d.rect(84, 130, 90, 280); d.rect(68, 243, 75, 25); d.clip("evenodd"); a.drawGrads(a.canvasAPI,
      { position: [104, 116], zero: [0, 140], size: [50, 280], orientation: "y", direction: -1, value: b, interval: 10, pixelRatio: 1.3, align: "right", pattern: [[{ length: -10, legend: !0, legendOffset: { x: -14, y: 7 } }], [{ length: -7 }], [{ length: -7 }], [{ length: -7 }], [{ length: -7 }], [{ length: -10 }], [{ length: -7 }], [{ length: -7 }], [{ length: -7 }], [{ length: -7 }]], sprites: [{ image: a.images.overlays, origin: [143, 0], size: [15, 27], center: [-50, 13], value: geofs.autopilot.values.speed, clamp: !0 }] }); d.restore(); d.save(); d.beginPath(); d.rect(350, 116, 60, 280); d.rect(368,
        243, 75, 25); d.clip("evenodd"); a.drawGrads(a.canvasAPI, {
          position: [358, 116], zero: [0, 140], size: [47, 280], orientation: "y", direction: -1, value: geofs.animation.getValue("altitude"), interval: 100, pixelRatio: .13, pattern: [[{ length: 10, legend: !0, legendOffset: { x: 47, y: 7 }, process: function (g) { return Math.round(g / 100) } }], [{ length: 7 }], [{ length: 7 }], [{ length: 7 }], [{ length: 7 }]], sprites: [{ image: a.images.overlays, origin: [223, 0], size: [25, 62], center: [9, 31], value: geofs.autopilot.values.altitude, clamp: !0 }, {
            image: a.images.overlays,
            origin: [383, 0], size: [42, 255], center: [0, 0], value: geofs.animation.getValue("groundElevationFeet")
          }]
        }); d.restore(); d.save(); d.beginPath(); d.rect(173, 440, 165, 30); d.clip("evenodd"); d.textAlign = "center"; a.drawGrads(a.canvasAPI, { position: [173, 440], zero: [82, 0], size: [165, 30], orientation: "x", direction: 1, value: geofs.animation.getValue("heading360"), interval: 5, pixelRatio: 7.25, pattern: [[{ length: 10, legend: !0, legendOffset: { x: 0, y: 30 }, process: function (g) { return Math.round(fixAngle360(g) / 10) } }], [{ length: 5 }]] }); d.restore();
    d.font = "20px sans-serif"; d.textAlign = "right"; d.fillText(Math.round(geofs.animation.getValue("kias")), 129, 264); d.fillText(Math.round(geofs.animation.getValue("altitude")), 441, 264); geofs.animation.getValue("haglFeet") <= 2500 && d.fillText(Math.round(geofs.animation.getValue("haglFeet")), 410, 426); var e = b = "", f = ""; geofs.autopilot.on && (b = "SPD", geofs.autopilot.mode == "NAV" ? (e = "NAV", geofs.autopilot.VNAV ? (e = "LOC", f = "G/S") : f = "ALT") : (e = "HDG", f = "ALT")); d.fillText(b, 143, 430); d.fillText(f, 143, 450); d.fillText(e, 143,
      470); d.fillText(geofs.animation.getValue("mach").toFixed(2), 140, 125); d.fillText("G" + geofs.animation.getValue("loadFactor").toFixed(1), 408, 455); a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [99, 0], size: [16, 24], center: [8, 12], destination: [349, c[1]], translation: [0, clamp(geofs.animation.getValue("NAVGlideAngleDeviation") * -107, -75, 75)] }); a.canvasAPI.drawSprite({
        image: a.images.overlays, origin: [116, 0], size: [24, 16], center: [12, 8], destination: [c[0], 401], translation: [clamp(geofs.animation.getValue("NAVCourseDeviation") *
          6.5, -75, 75), 0]
      })
  }, G1000: function (a) {
    var b = exponentialSmoothing("smoothKias", geofs.animation.getValue("kias"), .1), c = [460, 288], d = a.canvasAPI.context; d.fillStyle = "#ffffff"; d.strokeStyle = "#ffffff"; a.canvasAPI.clear(); d.save(); d.translate(c[0], c[1]); var e = clamp(geofs.animation.getValue("atilt") * 8, -1E3, 1E3), f = geofs.animation.getValue("aroll") * DEGREES_TO_RAD; d.rotate(f); d.fillStyle = "#004bff"; d.beginPath(); d.rect(-1E3, -2E3 - e, 2E3, 2E3); d.fill(); d.fillStyle = "#553108"; d.beginPath(); d.rect(-1E3, 0 - e, 2E3, 2E3); d.fill();
    d.lineWidth = 2; d.moveTo(-1E3, 0 - e); d.lineTo(1E3, 0 - e); d.stroke(); d.restore(); d.save(); d.beginPath(); d.arc(c[0], c[1], 200, 0, 6.28); d.clip(); d.font = "24px sans-serif"; d.lineWidth = 2; d.textAlign = "center"; a.drawGrads(a.canvasAPI, {
      position: c, center: [100, 100], zero: [100, 100], size: [200, 200], orientation: "y", direction: -1, rotation: geofs.animation.getValue("aroll") * DEGREES_TO_RAD, value: -geofs.animation.getValue("atilt"), interval: 2.5, pixelRatio: 8, pattern: [[{
        length: 50, offset: { x: -50, y: 0 }, legend: !0, legendOffset: {
          x: -65,
          y: 8
        }, process: function (g) { return Math.abs(Math.round(g)) }
      }, { length: 50, offset: { x: 0, y: 0 }, legend: !0, legendOffset: { x: 65, y: 8 }, process: function (g) { return Math.abs(Math.round(g)) } }], [{ length: 20, offset: { x: -10, y: 0 } }], [{ length: 40, offset: { x: -20, y: 0 } }], [{ length: 20, offset: { x: -10, y: 0 } }]]
    }); d.restore(); a.canvasAPI.drawRotatedSprite({ image: a.images.overlays, origin: [101, 27], size: [32, 32], center: [16, 187], destination: c, rotation: geofs.animation.getValue("aroll") * DEGREES_TO_RAD, translation: [0, 0] }); e = (-geofs.animation.getValue("heading") +
      geofs.animation.getValue("NAVOBS")) * DEGREES_TO_RAD; d.fillStyle = "#00000055"; d.beginPath(); d.arc(c[0], 586, 145, 0, 6.28); d.fill(); a.canvasAPI.drawRotatedSprite({ image: a.images.overlays, origin: [101, 101], size: [310, 310], center: [155, 155], destination: [c[0], 586], rotation: -geofs.animation.getValue("heading") * DEGREES_TO_RAD }); a.canvasAPI.drawRotatedSprite({
        image: a.images.overlays, origin: [422, 101], size: [30, 13], center: [15, 153], destination: [c[0], 586], rotation: (geofs.animation.getValue("navHDG") - geofs.animation.getValue("heading")) *
          DEGREES_TO_RAD
      }); a.canvasAPI.drawRotatedSprite({ image: a.images.overlays, origin: [184, 71], size: [144, 16], center: [72, 8], destination: [c[0], 586], rotation: e }); a.canvasAPI.drawRotatedSprite({ image: a.images.overlays, origin: [422, 128], size: [30, 258], center: [15, 129], destination: [c[0], 586], rotation: e }); a.canvasAPI.drawRotatedSprite({ image: a.images.overlays, origin: [455, 185], size: [22, 14], center: [11, 71], destination: [c[0], 586], rotation: e + (geofs.animation.getValue("NAVDirection") == "to" ? 0 : PI) }); a.canvasAPI.drawRotatedSprite({
        image: a.images.overlays,
        origin: [455, 202], size: [4, 106], center: [2, 53], destination: [c[0], 586], rotation: e, translation: [clamp(-geofs.animation.getValue("NAVCourseDeviation") * 6.5, -75, 75), 0]
      }); d.drawImage(a.images.background, 0, 0); d.lineWidth = 2; d.font = "20px monospace"; d.textAlign = "right"; d.fillStyle = "#ffffff"; d.strokeStyle = "#ffffff"; d.save(); d.beginPath(); d.rect(154, 114, 87, 342); d.rect(160, 268, 46, 42); d.rect(206, 253, 22, 70); d.clip("evenodd"); a.drawGrads(a.canvasAPI, {
        position: [154, 114], zero: [0, 171], size: [87, 342], orientation: "y", direction: -1,
        value: b, interval: 5, pixelRatio: 6, align: "right", pattern: [[{ length: -10, legend: !0, legendOffset: { x: -14, y: 7 } }], [{ length: -7 }]], sprites: [{ image: a.images.overlays, origin: [143, 0], size: [25, 27], center: [-8, 13], value: geofs.autopilot.values.speed, clamp: !0 }]
      }); d.restore(); d.save(); d.beginPath(); d.rect(680, 114, 131, 342); d.rect(720, 268, 54, 42); d.rect(774, 257, 34, 64); d.textAlign = "left"; d.clip("evenodd"); a.drawGrads(a.canvasAPI, {
        position: [705, 114], size: [108, 342], zero: [0, 171], orientation: "y", direction: -1, value: geofs.animation.getValue("altitude"),
        interval: 20, pixelRatio: .5, pattern: [[{ length: 10, legend: !0, legendOffset: { x: 15, y: 7 }, process: function (g) { return Math.round(g) } }], [{ length: 5 }], [{ length: 5 }], [{ length: 5 }], [{ length: 5 }]], sprites: [{ image: a.images.overlays, origin: [68, 0], size: [13, 26], center: [0, 13], value: geofs.autopilot.values.altitude, clamp: !0 }]
      }); d.restore(); d.save(); d.beginPath(); d.rect(160, 268, 46, 42); d.rect(206, 253, 22, 70); d.rect(720, 268, 54, 42); d.rect(774, 257, 34, 64); d.clip(); a.canvasAPI.drawSprite({
        image: a.images.overlays, origin: [16, 0], size: [16,
          512], center: [0, 446], destination: [164, 272], translation: [0, geofs.utils.stickyRounding(b % 1E3 * .01, .01) * 35]
      }); a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [16, 0], size: [16, 512], center: [0, 446], destination: [185, 272], translation: [0, geofs.utils.stickyRounding(b % 100 * .1, .1) * 35] }); a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [16, 0], size: [16, 512], center: [0, 446], destination: [208, 272], translation: [0, b % 10 * 35] }); a.canvasAPI.drawSprite({
        image: a.images.overlays, origin: [16, 0], sprite: [16, 512], size: [16,
          512], center: [0, 446], destination: [720, 272], translation: [0, geofs.utils.stickyRounding(geofs.animation.getValue("altTenThousands") * 1E-4, .01) * 35]
      }); a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [16, 0], sprite: [16, 512], size: [16, 512], center: [0, 446], destination: [740, 272], translation: [0, geofs.utils.stickyRounding(geofs.animation.getValue("altThousands") * .001, .01) * 35] }); a.canvasAPI.drawSprite({
        image: a.images.overlays, origin: [32, 0], size: [12, 512], center: [0, 442], destination: [761, 269], translation: [0, geofs.utils.stickyRounding(geofs.animation.getValue("altHundreds") *
          .01, .1) * 40]
      }); a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [44, 0], size: [24, 512], center: [0, 458], destination: [780, 270], translation: [0, geofs.animation.getValue("altTens") * .05 * 30] }); d.restore(); a.canvasAPI.drawSprite({ image: a.images.overlays, origin: [101, 0], size: [13, 21], center: [0, 10], destination: [685, c[1]], translation: [0, clamp(geofs.animation.getValue("NAVGlideAngleDeviation") * -107, -90, 90)] }); b = clamp(geofs.animation.getValue("verticalSpeed") * .07, -150, 150); a.canvasAPI.drawSprite({
        image: a.images.overlays,
        origin: [133, 36], size: [68, 20], center: [0, 10], destination: [811, 288], translation: [0, -b]
      }); d.font = "22px monospace"; d.textAlign = "right"; d.fillText(Math.round(geofs.animation.getValue("verticalSpeed") / 10) * 10, 877, 295 - b); d.font = "32px monospace"; d.textAlign = "center"; d.fillText(Math.round(geofs.animation.getValue("heading360")) + "\u00b0", 460, 425); d.font = "26px monospace"; d.textAlign = "left"; d.fillStyle = "#ff00ff"; c = b = a = ""; geofs.autopilot.on && (a = "SPD", geofs.autopilot.mode == "NAV" ? (b = "NAV", geofs.autopilot.VNAV ? (b =
        "LOC", c = "G/S") : c = "ALT") : (b = "HDG", c = "ALT")); d.fillText(a, 270, 24); d.fillText(c, 397, 24); d.fillText(b, 489, 24)
  }, genericEICAS: function (a) {
    var b = a.canvasAPI.context; a.canvasAPI.clear("#000000FF"); b.fillStyle = "#000000"; b.lineWidth = 2; b.strokeStyle = "#ffffff"; b.beginPath(); for (var c = 64, d = 3.48 / geofs.aircraft.instance.definition.maxRPM, e = 0; e < geofs.aircraft.instance.engines.length; e++) {
      var f = geofs.aircraft.instance.engines[e].rpm; a.canvasAPI.drawSprite({
        image: a.images.background, origin: [0, 0], size: [128, 512], center: [0,
          0], destination: [e * 128, 0]
      }); c += e * 128; b.moveTo(c, 68); b.lineTo(c + Math.cos(f * d) * 42, 68 + Math.sin(f * d) * 42)
    } b.stroke()
  }
}; "use strict"; var audio = window.audio || {};
audio.init = function (a) { audio.maxFilterFreq = 24E3; a = a || []; audio.soundplayer = audio.impl.webAudio.createPlayer(); audio.sounds = {}; for (var b = 0, c = a.length; b < c; b++) { var d = a[b]; d.file += geofs.killCache; d.file = d.file.replace(".ogg", ".mp3"); audio.sounds[d.id] = d; d.playing = !1; d.loading = !1; d.loaded = !1; d = d.effects; for (var e in d) { var f = d[e]; f.lastValue = null; e == "volume" && (f.ratio = (f.ratio || 1) * 100) } } geofs.preferences.sound ? audio.on !== !1 && (audio.on = !0) : audio.mute() };
audio.update = function () {
  if (audio.on && audio.soundplayer && !geofs.pause) for (var a in audio.sounds) {
    var b = audio.sounds[a], c = b.effects, d; for (d in c) {
      var e = c[d], f = geofs.animation.filter(e); b.loaded || b.loading || audio.soundplayer.loadSound(b); if (b.loaded) {
        switch (d) {
          case "filter": if (e.lastValue == f) continue; audio.soundplayer.setFilter(b, f); break; case "volume": b.playing || audio.soundplayer.startSound(b, !0); var g = 1; geofs.animation.values.cameraAircraftDistance && (g = clamp(1 / Math.pow(geofs.animation.values.cameraAircraftDistance *
            .001, 2), 0, 1)); f *= g; audio.soundplayer.setVolume(b, f); break; case "pitch": b.playing || audio.soundplayer.startSound(b, !0); f += geofs.animation.values.cameraAircraftSpeed * .001; try { audio.soundplayer.setRate(b, f) } catch (k) { } break; case "play": if (e.lastValue == f) continue; f > 0 && audio.soundplayer.startSound(b); break; case "start": if (e.lastValue == f) continue; f > 0 ? (audio.soundplayer.startSound(b), b.stopped = !1) : (audio.soundplayer.stopSound(b), b.stopped = !0); break; case "stop": if (e.lastValue == f) continue; f > 0 ? (audio.soundplayer.stopSound(b),
              b.stopped = !0) : (audio.soundplayer.startSound(b), b.stopped = !1)
        }e.lastValue = f
      }
    }
  }
}; audio.toggleMute = function () { audio.on ? audio.mute() : audio.unmute(); geofs.savePreferences() }; audio.stop = function () { try { if (audio.soundplayer && audio.soundplayer.stopSound) for (var a in audio.sounds) { var b = audio.sounds[a]; audio.soundplayer.stopSound(b); var c = b.effects, d; for (d in c) c[d].lastValue = null } } catch (e) { } }; audio.mute = function () { audio.stop(); audio.on = !1; geofs.preferences.sound = !1; ui.toggleButton(".geofs-button-mute", !0) };
audio.unmute = function () { audio.on = !0; geofs.preferences.sound = !0; ui.toggleButton(".geofs-button-mute", !1) }; audio.playStartup = function () { if (audio.on && audio.soundplayer) try { audio.soundplayer.playSound(audio.sounds.startup, !1) } catch (a) { } }; audio.playShutdown = function () { if (audio.on && audio.soundplayer) try { audio.soundplayer.playSound(audio.sounds.shutdown, !1) } catch (a) { } }; audio.playSoundLoop = function (a, b) { if (audio.on && audio.soundplayer) try { audio.soundplayer.playSound(audio.sounds[a], b) } catch (c) { } };
audio.stopSoundLoop = function (a) { if (audio.soundplayer && audio.soundplayer.stopSound) try { audio.soundplayer.stopSound(audio.sounds[a]) } catch (b) { } }; audio.impl = {};
audio.impl.webAudio = {
  decodingStack: [], createPlayer: function () { audio.impl.webAudio.destroyPlayer(); if (!window.AudioContext && !window.webkitAudioContext) return null; audio.impl.webAudio.context = audio.impl.webAudio.context || new (window.AudioContext || window.webkitAudioContext); return audio.impl.webAudio.context ? audio.impl.webAudio : null }, stackDecoding: function (a) {
    audio.impl.webAudio.decodingStack.push(function () { a(); audio.impl.webAudio.decodingStack.shift(); if (audio.impl.webAudio.decodingStack.length > 0) audio.impl.webAudio.decodingStack[0]() });
    if (audio.impl.webAudio.decodingStack.length == 1) audio.impl.webAudio.decodingStack[0]()
  }, setupSoundNodes: function (a) {
    a.buffer && (a.filterNode || (a.filterNode = audio.impl.webAudio.context.createBiquadFilter(), a.filterNode.type = "lowpass", a.filterNode.Q.value = 1, a.filterNode.frequency.value = 24E3, a.filterNode.connect(audio.impl.webAudio.context.destination)), a.gainNode || (a.gainNode = audio.impl.webAudio.context.createGain(), a.gainNode.connect(a.filterNode)), a.sourceNode || (a.sourceNode = audio.impl.webAudio.context.createBufferSource(),
      a.sourceNode.buffer = a.buffer, a.sourceNode.connect(a.gainNode)))
  }, loadSound: function (a, b) { var c = this; a.loading = !0; var d = new XMLHttpRequest; d.open("GET", a.file, !0); d.responseType = "arraybuffer"; d.onload = function () { audio.impl.webAudio.stackDecoding(function () { audio.impl.webAudio.context.decodeAudioData(d.response, function (e) { e && (a.buffer = e, a.loaded = !0, c.setupSoundNodes(a), b && b()) }, function (e) { throw "Error with decoding audio data" + e; }) }) }; d.send() }, playSound: function (a, b, c) {
    var d = this; this.loadSound(a,
      function () { d.startSound(a, b) })
  }, startSound: function (a, b, c) { var d = this; if (a.loaded && !a.stopped && !a.playing) if (audio.impl.webAudio.context.state == "suspended") audio.impl.webAudio.context.resume(); else { if (!a.sourceNode || a.sourceNode.started) this.stopSound(a), this.setupSoundNodes(a); a.sourceNode.addEventListener("ended", function () { d.stopSound(a); c && c() }); b = a.loop || b; a.sourceNode.loop = b; a.sourceNode.start(0); a.sourceNode.started = !0; a.playing = !0 } }, stopSound: function (a) {
    a.sourceNode && (a.sourceNode.started &&
      a.sourceNode.stop(), a.sourceNode.disconnect, a.sourceNode = null, a.playing = !1)
  }, setVolume: function (a, b) { a.volume = b; a.gainNode && (a.gainNode.gain.value = clamp(b / 100 * geofs.preferences.volume, 0, 1)) }, setRate: function (a, b) { a.rate = b || a.rate; a.sourceNode && (a.sourceNode.playbackRate.value = b || a.rate || 1) }, setFilter: function (a, b, c) {
    a.filterNode && (a.frequencyOffset = c || a.frequencyOffset || 0, a.frequency = b || a.frequency || audio.maxFilterFreq, a.filterNode.type = "lowpass", a.filterNode.Q.value = 1, a.filterNode.frequency.value =
      clamp(a.frequency + a.frequencyOffset, 0, audio.maxFilterFreq))
  }, unsetFilter: function (a) { a.filter.disconnect() }, destroySound: function (a) { this.stopSound(a); a.sourceNode && a.sourceNode.disconnect(); a.gainNode && a.gainNode.disconnect(); a.filter && a.filter.disconnect() }, destroyPlayer: function () { for (var a in audio.sounds) this.destroySound(audio.sounds[a]), audio.sounds[a] = null, delete audio.sounds[a] }, setMasterVolume: function () { for (var a in audio.sounds) this.setVolume(audio.sounds[a], audio.sounds[a].volume) }
};
audio.impl.html5 = {
  player: null, createPlayer: function () { audio.impl.html5.destroyPlayer(); return window.Audio ? audio.impl.html5 : null }, loadMP3: function (a, b, c) { a = audio.sounds[a] || {}; a.element = new Audio(b); a.loop && a.element.addEventListener("timeupdate", function () { this.currentTime > this.duration - 3 && (this.currentTime = 0, this.play()) }, !1); a.loaded = !0; c && a.element.play(); return a }, playFile: function (a, b, c) {
    if (geofs.preferences.sound) return a = new Audio(a), b && a.addEventListener("timeupdate", function () {
      this.currentTime >
        this.duration - 3 && (this.currentTime = 0, this.play())
    }, !1), a.play(), c && a.addEventListener("ended", c), a
  }, playSequence: function (a, b) {
    var c = {
      index: 0, files: a, loop: b || 0, stop: function () { this.loop = 0; clearTimeout(this.playTimeout); this.audioElement && (this.audioElement.pause(), this.audioElement = null) }, player: function () {
        var d = 50; if (c.index == c.files.length) if (--c.loop >= 0) c.index = 0, d = 1E3; else { c.stop(); c = null; return } c.playTimeout = setTimeout(function () {
          c.audioElement = audio.impl.html5.playFile(c.files[c.index], !1, c.player);
          c.index++
        }, d)
      }
    }; c.player(); return c
  }, playSound: function (a) { a = audio.sounds[a]; a.element && a.element.play() }, stopSound: function (a) { var b = audio.sounds[a]; b.element && b.element.pause(); audio.stopped(a) }, setVolume: function (a, b) { a = audio.sounds[a]; a.volume = b; a.element && (a.element.volume = b / 100) }, setRate: function (a, b) { }, destroyPlayer: function () { for (var a in audio.sounds) { var b = audio.sounds[a].element; b && b.close && b.close() } }, setMasterVolume: function () { for (var a in audio.sounds) this.setVolume(a, audio.sounds[a].volume) }
};
"use strict"; var multiplayer = window.multiplayer || {}; geofs.multiplayerHost = geofs.multiplayerHost || "https://mps.geo-fs.com"; multiplayer.nbUsers = 0; multiplayer.users = {}; multiplayer.visibleUsers = {}; multiplayer.numberOfLOD = 3; multiplayer.captainIconUrl = "images/captain-tag.png"; multiplayer.premiumIconUrl = "images/premium-tag.png"; multiplayer.minUpdateDelay = geofs.MPSMinUpdateDelay || 500; multiplayer.mapUpdatePeriod = geofs.MPSMapUpdatePeriod || 1E4; multiplayer.hearbeatTimeout; multiplayer.hearbeatLife = 9E3;
multiplayer.userLife = 2E4; multiplayer.userHalfLife = 1E4; multiplayer.userHeartBeatPeriod = 1E3; multiplayer.trafficLife = 24E4; multiplayer.trafficHalfLife = 12E4; multiplayer.trafficHeartBeatPeriod = 1E4;
multiplayer.contrailEmitters = { 1: { lod: 2, anchor: null, duration: 1E10, rate: .01, life: 3E4, startScale: .05, endScale: .1, randomizeStartScale: .1, randomizeEndScale: .4, startOpacity: .1, endOpacity: 1E-5, startRotation: "random", texture: "whitesmoke" }, 2: { lod: 2, anchor: null, duration: 1E10, rate: .01, life: 6E4, startScale: .05, endScale: .1, randomizeStartScale: .1, randomizeEndScale: .4, startOpacity: .1, endOpacity: 1E-5, startRotation: "random", texture: "whitesmoke" } }; multiplayer.myId = ""; multiplayer.lastRequest = null;
multiplayer.lastResponse = null; multiplayer.lastJoinedCoordinates = ""; multiplayer.lastRequestTime = Date.now(); multiplayer.serverTimeOffset = null; multiplayer.labelVisibilityRange = 5E4; multiplayer.farVisibilityRange = 1E4; multiplayer.lowVisibilityRange = 1E3; multiplayer.nearVisibilityRange = 10; multiplayer.chatMessage = ""; multiplayer.chatMessageId = 0; multiplayer.on = !1; multiplayer.started = !1; multiplayer.callsignPlacemarkAltitude = 5; multiplayer.updateFunctions = [];
multiplayer.init = function () {
  multiplayer.labelOptions = {
    "default": { font: "bold 12pt sans-serif", style: Cesium.LabelStyle.FILL_AND_OUTLINE, horizontalOrigin: Cesium.HorizontalOrigin.CENTER, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, eyeOffset: new Cesium.Cartesian3(0, 6, 0), fillColor: Cesium.Color.fromCssColorString("#00597b"), outlineColor: Cesium.Color.WHITE, outlineWidth: 4 }, xavier: {
      font: "bold 12pt sans-serif", style: Cesium.LabelStyle.FILL_AND_OUTLINE, horizontalOrigin: Cesium.HorizontalOrigin.CENTER, verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
      eyeOffset: new Cesium.Cartesian3(0, 6, 0), fillColor: Cesium.Color.fromCssColorString("#ffc107"), outlineColor: Cesium.Color.WHITE, outlineWidth: 4
    }, premium: { font: "bold 12pt sans-serif", style: Cesium.LabelStyle.FILL_AND_OUTLINE, horizontalOrigin: Cesium.HorizontalOrigin.CENTER, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, eyeOffset: new Cesium.Cartesian3(0, 6, 0), fillColor: Cesium.Color.fromCssColorString("#ffc107"), outlineColor: Cesium.Color.WHITE, outlineWidth: 4 }, traffic: {
      font: "bold 11pt sans-serif", style: Cesium.LabelStyle.FILL_AND_OUTLINE,
      horizontalOrigin: Cesium.HorizontalOrigin.CENTER, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, eyeOffset: new Cesium.Cartesian3(0, 6, 0), fillColor: Cesium.Color.fromCssColorString("#79abbd"), outlineColor: Cesium.Color.WHITE, outlineWidth: 2
    }
  }; multiplayer.iconOptions = {
    premium: { image: multiplayer.premiumIconUrl, horizontalOrigin: Cesium.HorizontalOrigin.RIGHT, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, eyeOffset: new Cesium.Cartesian3(0, 6, 0), pixelOffset: new Cesium.Cartesian2(-25, 1), width: 25, height: 25 }, xavier: {
      image: multiplayer.captainIconUrl,
      horizontalOrigin: Cesium.HorizontalOrigin.RIGHT, verticalOrigin: Cesium.VerticalOrigin.BOTTOM, eyeOffset: new Cesium.Cartesian3(0, 6, 0), pixelOffset: new Cesium.Cartesian2(-25, 1), width: 25, height: 25
    }
  }; multiplayer.flightSharing.init()
}; multiplayer.stop = function () { multiplayer.stopUpdates(); for (var a in multiplayer.users) multiplayer.users[a].remove(); $(".geofs-player-count").hide() }; multiplayer.start = function () { multiplayer.startUpdates(); $(".geofs-player-count").show() };
multiplayer.startUpdates = function () { geofs.preferences.multiplayer && !multiplayer.started && (multiplayer.started = !0, multiplayer.nextUpdateTime = Date.now(), multiplayer.sendUpdate(), multiplayer.startMapUpdate()) }; multiplayer.stopUpdates = function (a) { clearTimeout(multiplayer.hearbeatTimeout); clearInterval(multiplayer.mapInterval); multiplayer.nextUpdateTime = null; multiplayer.started = !1 }; multiplayer.getServerTime = function () { return Date.now() - multiplayer.serverTimeOffset }; multiplayer.getUser = function (a) { return multiplayer.users[a] };
multiplayer.flightSharing = {
  requestTimeout: 3E4, host: !1, control: !1, status: null, willpeer: null, waspeer: null, peer: null, init: function () {
    $(document).on("click", ".geofs-stopSharing", multiplayer.flightSharing.stop).on("click", ".geofs-acceptSharing", function () { multiplayer.flightSharing.accept(multiplayer.flightSharing.willpeer) }).on("click", ".geofs-refuseSharing", function () { multiplayer.flightSharing.refuse(multiplayer.flightSharing.willpeer) }).on("click", ".geofs-blockUser", function () { multiplayer.blockUser(multiplayer.flightSharing.willpeer.acid) }).on("click",
      ".geofs-controlSwap", function () { multiplayer.flightSharing.swapControl() })
  }, request: function (a) {
    multiplayer.flightSharing.peer = a; a.isPeer = !0; multiplayer.flightSharing.control = !0; multiplayer.flightSharing.host = !0; multiplayer.flightSharing.status = "requested"; $(".geofs-flightSharing-status").html('Flight sharing requested.<br/>Waiting for<span class="geofs-callsign">' + a.callsign + '</span><button class="geofs-stopSharing mdl-button mdl-button--raised">Cancel</button>').show(); clearTimeout(multiplayer.flightSharing.timeout);
    multiplayer.flightSharing.timeout = setTimeout(multiplayer.flightSharing.stop, multiplayer.flightSharing.requestTimeout)
  }, incoming: function (a) {
    multiplayer.flightSharing.status != "established" && multiplayer.flightSharing.status != "incoming" && multiplayer.flightSharing.status != "disconnected" && (multiplayer.flightSharing.host ? a.isPeer && multiplayer.flightSharing.accepted(a) : geofs.userRecord.muteListMap[a.acid] || (multiplayer.flightSharing.willpeer = a, multiplayer.flightSharing.peer = null, multiplayer.flightSharing.status =
      "incoming", $(".geofs-flightSharing-status").html('Flight sharing request from<span class="geofs-callsign">' + a.callsign + '</span><button class="geofs-acceptSharing mdl-button mdl-button--raised">accept</button><button class="geofs-refuseSharing mdl-button mdl-button--raised">refuse</button><button class="geofs-blockUser mdl-button mdl-button--raised mdl-button--colored">block user</button>').show(), clearTimeout(multiplayer.flightSharing.timeout), multiplayer.flightSharing.timeout = setTimeout(multiplayer.flightSharing.stop,
        multiplayer.flightSharing.requestTimeout)))
  }, accept: function (a) {
    flight.sharing.start(); multiplayer.flightSharing.status = "established"; multiplayer.flightSharing.control = !1; multiplayer.flightSharing.willpeer = null; multiplayer.flightSharing.peer = a; multiplayer.flightSharing.waspeer = a; a.isPeer = !0; a.aircraft != geofs.aircraft.instance.aircraftRecord.id && geofs.aircraft.instance.change(a.aircraft, a.currentLivery); $(".geofs-flightSharing-status").addClass("geofs-established").html('Sharing flight with<span class="geofs-callsign">' +
      a.callsign + '</span><span class="geofs-controlStatus">Peer has control</span><button class="geofs-stopSharing mdl-button mdl-button--raised">stop sharing</button>').show()
  }, accepted: function (a) { multiplayer.flightSharing.status = "established"; multiplayer.flightSharing.waspeer = a; multiplayer.flightSharing.control = !0; $(".geofs-flightSharing-status").addClass("geofs-established").html('Sharing flight with<span class="geofs-callsign">' + a.callsign + '</span><span class="geofs-controlStatus">You have control</span><button class="geofs-controlSwap mdl-button mdl-button--accent mdl-button--raised">give control</button><button class="geofs-stopSharing mdl-button mdl-button--raised">stop sharing</button>').show() },
  peerUpdate: function (a, b) {
    if (multiplayer.flightSharing.status == "established") {
      var c = a.st.sh; !c || c.pe != geofs.userRecord.id || c.ca ? multiplayer.flightSharing.stop() : (multiplayer.flightSharing.host || !!c.hct == multiplayer.flightSharing.control && multiplayer.flightSharing.swapControl(!c.hct), multiplayer.flightSharing.control || flight.sharing.peerUpdate({ ti: a.ti, co: a.co, ct: a.st.sh.ct, st: a.st.sh.st, ve: a.st.sh.ve, acc: a.st.sh.acc || [0, 0, 0, 0, 0, 0] }, b)); clearTimeout(multiplayer.flightSharing.timeout); multiplayer.flightSharing.timeout =
        setTimeout(function () { multiplayer.flightSharing.stop(); geofs.debug.log("flightSharing timedout") }, multiplayer.flightSharing.requestTimeout)
    }
  }, swapControl: function (a) {
    multiplayer.flightSharing.host && (a = !multiplayer.flightSharing.control, $(".geofs-flightSharing-status").find(".geofs-controlSwap").text(a ? "Give control" : "take control")); $(".geofs-flightSharing-status").find(".geofs-controlStatus").text(a ? "You have control" : "Peer has control"); (multiplayer.flightSharing.control = a) ? flight.sharing.stop() :
      flight.sharing.start(flight.recorder.makeRecord(Date.now()))
  }, refuse: function (a) { multiplayer.flightSharing.status = "canceling"; multiplayer.flightSharing.willpeer = null; multiplayer.flightSharing.peer = a; multiplayer.flightSharing.waspeer = a }, stop: function () {
    flight.sharing.stop(); multiplayer.flightSharing.willpeer = null; multiplayer.flightSharing.waspeer = null; multiplayer.flightSharing.peer && (multiplayer.flightSharing.peer.isPeer = !1, multiplayer.flightSharing.peer = null); multiplayer.flightSharing.status = "disconnected";
    multiplayer.flightSharing.control = !1; multiplayer.flightSharing.host = !1; clearTimeout(multiplayer.flightSharing.timeout); setTimeout(function () { multiplayer.flightSharing.status = null; $(".geofs-flightSharing-status").hide() }, 5E3); $(".geofs-flightSharing-status").html("Flight sharing ended").show()
  }
};
multiplayer.updateUsers = function (a) { a = a || []; for (var b = 0, c = a.length; b < c; b++) { var d = a[b], e = d.id; if ((!d.ad || geofs.preferences.adsb) && multiplayer.myId != e) try { multiplayer.users[e] ? multiplayer.users[e].update(d) : multiplayer.users[e] = new multiplayer.User(d) } catch (f) { geofs.debug.error(f, "exception in multiplayer.updateUsers") } } };
multiplayer.startMapUpdate = function () {
  var a = function (c) {
    multiplayer.setNbUsers(c.userCount); if (c && c.users) {
      c.users.sort(function (z, B) { try { var p = z.cs.toLowerCase(), r = B.cs.toLowerCase(); return p > r ? 1 : p < r ? -1 : 0 } catch (C) { return 0 } }); for (var d = $(".geofs-player-list"), e = d.is(":visible"), f = 0, g = "", k = 0, m = c.users.length; k < m; k++) {
        var n = c.users[k], q = n ? n.id : null; if (q && multiplayer.myId != q) {
          var u = multiplayer.users[q] || new multiplayer.User(n); u.update(n, !0); e && (u.callsign == "Foo" ? f++ : g += '<li data-player="' + q + '">' + u.callsign +
            " (" + u.aircraftName + ")</li>")
        }
      } e && (f > 0 && (g += "<li>    ...and " + f + " Foos</li>"), d.html(g))
    }
  }; clearInterval(multiplayer.mapInterval); var b = "/map" + (geofs.userRecord.licenseid ? "?gid=" + geofs.userRecord.licenseid : ""); multiplayer.mapInterval = setInterval(function () { geofs.ajax.post(geofs.multiplayerHost + b, { id: multiplayer.myId, gid: geofs.userRecord.licenseid }, a) }, multiplayer.mapUpdatePeriod); geofs.ajax.post(geofs.multiplayerHost + b, { id: multiplayer.myId, gid: geofs.userRecord.licenseid }, a)
};
multiplayer.update = function (a) {
  try {
    multiplayer.lastResponse && (multiplayer.updateUsers(multiplayer.lastResponse.users), multiplayer.lastResponse = null); multiplayer.nextUpdateTime && Date.now() > multiplayer.nextUpdateTime && multiplayer.sendUpdate(); for (var b in multiplayer.visibleUsers) {
      var c = multiplayer.visibleUsers[b]; c.currentServerTime = multiplayer.getServerTime(); if (c.model) {
        c.elapsedTime += a; var d = M3.add(c.referenceCoord, M3.scale(c.correctedVelocity, c.elapsedTime)); d[3] = fixAngle(d[3]); d[4] = fixAngle(d[4]);
        d[5] = fixAngle(d[5]); c.currentInterpolatedCoord = d; c.referencePoint.lla = c.currentInterpolatedCoord; c.model.setPositionOrientationAndScale([d[0], d[1], d[2]], [d[3], d[4], d[5]])
      } else d = c.lastUpdate.co; var e = [d[0], d[1], d[2]]; geofs.api.setLabelPosition(c.label, e); c.icon && c.icon.setLocation(e)
    }
  } catch (f) { geofs.debug.error(f, "multiplayer.update") }
}; multiplayer.errorCallback = function (a) { multiplayer.lastRequest = null; a = Date.now(); multiplayer.nextUpdateTime = a + multiplayer.minUpdateDelay };
multiplayer.updateCallback = function (a) {
  multiplayer.lastResponse = a; multiplayer.lastRequest = null; var b = Date.now(), c = b - multiplayer.lastRequestTime; multiplayer.avgPing = exponentialSmoothing("avgPing", c).toPrecision(2); multiplayer.minPing = Math.min(multiplayer.minPing, c).toPrecision(2); multiplayer.serverTimeOffset = exponentialSmoothing("serverTimeOffset", b - (a.serverTime + c / 2), null, .01); c = clamp(multiplayer.minUpdateDelay - c, 0, multiplayer.minUpdateDelay); multiplayer.myId = a.myId || null; multiplayer.chatMessageId =
    a.lastMsgId || multiplayer.chatMessageId; multiplayer.started && (multiplayer.nextUpdateTime = b + c); if (a.chatMessages) for (b = 0, c = a.chatMessages.length; b < c; b++) { var d = a.chatMessages[b]; geofs.userRecord.muteListMap[d.acid] || ui.chat.publish(d) }
};
multiplayer.sendUpdate = function () {
  try {
    if (!multiplayer.lastRequest && !flight.recorder.playing) {
      var a = geofs.aircraft.instance, b = Date.now(); multiplayer.lastRequestTime = b; var c = [geofs.utils.toFixedFloat(a.llaLocation[0], 7), geofs.utils.toFixedFloat(a.llaLocation[1], 7), geofs.utils.toFixedFloat(a.llaLocation[2], 2)], d = geofs.utils.arrayToFixed(a.htr, 2), e = $.merge($.merge([], c), d), f = V3.scale(xyz2lla(a.rigidBody.getLinearVelocity(), a.llaLocation), .001), g = geofs.utils.arrayToFixed($.merge(f, a.htrAngularSpeed), 8),
        k = { gr: controls.gear.position != 1 ? 1 : 0, as: Math.round(geofs.animation.values.kias) }; a.liveryId && (k.lv = a.liveryId); var m = { acid: geofs.userRecord.id, sid: geofs.userRecord.sessionId, id: multiplayer.myId, ro: { ad: geofs.preferences.adsb ? 1 : 0 }, ac: a.aircraftRecord.id, co: e, ve: g, st: k, ti: multiplayer.getServerTime(), m: multiplayer.chatMessage, ci: multiplayer.chatMessageId }; if (multiplayer.flightSharing.status && multiplayer.flightSharing.peer) {
          var n = [controls.rawPitch, controls.roll, controls.yaw, controls.throttle, controls.gear.position,
          controls.flaps.position, controls.airbrakes.position, controls.brakes, controls.elevatorTrim], q = [geofs.aircraft.instance.groundContact, geofs.aircraft.instance.engine.on, controls.flaps.target], u = geofs.aircraft.instance.rigidBody.getLinearVelocity().concat(geofs.aircraft.instance.rigidBody.getAngularVelocity()), z = geofs.aircraft.instance.rigidBody.getLinearAcceleration().concat(geofs.aircraft.instance.rigidBody.getAngularAcceleration()); m.st.sh = {
            pe: multiplayer.flightSharing.peer.acid, ca: multiplayer.flightSharing.status ==
              "canceling", hct: multiplayer.flightSharing.control, ct: n, ve: u, acc: z, st: q
          }
        } multiplayer.chatMessage && (multiplayer.chatMessage = ""); var B = parseInt(a.llaLocation[1]); multiplayer.lastRequest = geofs.ajax.post(geofs.multiplayerHost + "/update?l=" + B, m, multiplayer.updateCallback, multiplayer.errorCallback)
    }
  } catch (p) { geofs.debug.error(p, "multiplayer.sendUpdate") }
};
multiplayer.User = function (a) { var b = a.id; multiplayer.users[b] = this; this.id = b; this.acid = a.acid; this.callsign = geofs.userRecord.muteListMap && !geofs.userRecord.muteListMap[this.id] ? a.cs : ""; this.aircraft = null; this.lod = 0; this.model = this.lastUpdate = null; this.visibleGear = !0; this.referencePoint = { lla: [0, 0, 0] }; this.currentServerTime = multiplayer.getServerTime(); this.lastHeartbeatTime = Date.now(); this.isTraffic = a.ad; this.updated = !0; this.heartBeat() };
multiplayer.User.prototype = {
  heartBeat: function () { var a = this, b = Date.now(), c = b - this.lastHeartbeatTime; if (this.updated) this.updated = !1, this.lastHeartbeatTime = b; else if (c > (this.isTraffic ? multiplayer.trafficHalfLife : multiplayer.userHalfLife) && this.removeFromWorld(), c > (this.isTraffic ? multiplayer.trafficLife : multiplayer.userLife)) { this.remove(); return } clearTimeout(this.heartBeatTimeout); this.heartBeatTimeout = setTimeout(function () { a.heartBeat() }, this.isTraffic ? multiplayer.trafficHeartBeatPeriod : multiplayer.userHeartBeatPeriod) },
  update: function (a, b) {
    var c = a.st.sh; c ? (c.pe == geofs.userRecord.id && multiplayer.flightSharing.status != "established" && multiplayer.flightSharing.incoming(this), c.ca && multiplayer.flightSharing.stop()) : b || (multiplayer.flightSharing.willpeer && multiplayer.flightSharing.willpeer.acid == this.acid || multiplayer.flightSharing.waspeer && multiplayer.flightSharing.waspeer.acid == this.acid) && multiplayer.flightSharing.stop(); this.updateAircraft(a); if (!this.lastUpdate) if (this.lastUpdate = Object.assign({}, a), b) var d = !0; else return;
    if (!(a.ti - this.lastUpdate.ti <= 0) || d) if (geofs.map && geofs.map.mapActive && geofs.map.updatePlayerMarker(a.id, a.co, this.callsign, a.ad ? "traffic" : null, this.aircraftName, this.lastUpdate.st.as), this.isPeer && (multiplayer.visibleUsers[this.id] = this, multiplayer.flightSharing.peerUpdate(a, b)), this.updated = !0, !b) {
      this.lastUpdate = Object.assign({}, a); this.updateModel(a); if (this.model || this.isPeer) this.lastUpdate.ad && (this.lastUpdate.co[2] == 0 || this.lastUpdate.st.gr) && (this.lastUpdate.co[2] = geofs.api.getFastTerrainElevation([this.lastUpdate.co[0],
      this.lastUpdate.co[1], 0])), this.model && this.visibleGear != this.lastUpdate.st.gr && this.model.setNodeVisibilityByName("gear", this.lastUpdate.st.gr) && (this.visibleGear = this.lastUpdate.st.gr), this.elapsedTime = this.currentServerTime - this.lastUpdate.ti, this.correctedVelocity = M3.dup(this.lastUpdate.ve), this.currentInterpolatedCoord && (b = M3.add(this.lastUpdate.co, M3.scale(this.lastUpdate.ve, this.elapsedTime)), a = M3.sub(b, this.currentInterpolatedCoord), a[3] = fixAngle(a[3]), a[4] = fixAngle(a[4]), a[5] = fixAngle(a[5]),
        b = Math.abs(V3.length(lla2xyz(a, b))), c = Math.max(Math.abs(a[3]), Math.abs(a[4]), Math.abs(a[5])), this.lastUpdate.ad ? b > 5E3 || c > 30 ? (this.currentInterpolatedCoord = null, this.deviationFix = [0, 0, 0, 0, 0, 0]) : (this.deviationFix = M3.scale(a, 1E-5), this.correctedVelocity = M3.add(this.correctedVelocity, this.deviationFix)) : b > 40 || c > 30 ? this.deviationFix = this.currentInterpolatedCoord = null : (b = multiplayer.minUpdateDelay * 10, this.deviationFix = M3.scale(a, 1 / b), this.correctedVelocity = M3.add(this.correctedVelocity, this.deviationFix))),
        this.currentInterpolatedCoord ? (this.elapsedTime = 0, this.referenceCoord = this.currentInterpolatedCoord) : this.referenceCoord = this.lastUpdate.co; this.referencePoint.lla = this.currentInterpolatedCoord || this.lastUpdate.co; this.currentInterpolatedCoord = null; this.updateContrails()
    }
  }, getLOD: function (a) {
    this.distance = geofs.utils.llaDistanceInMeters(this.currentInterpolatedCoord || a.co, geofs.aircraft.instance.llaLocation, geofs.aircraft.instance.llaLocation); if (this.distance > multiplayer.nearVisibilityRange) {
      if (this.distance <
        multiplayer.farVisibilityRange) return this.distance > multiplayer.lowVisibilityRange ? 2 : 1; if (this.distance < multiplayer.labelVisibilityRange) return 3
    } return 0
  }, updateAircraft: function (a) { this.aircraft != a.ac && (this.removeModels(), this.aircraft = a.ac, this.aircraftName = null, this.isPeer && !multiplayer.flightSharing.host && geofs.aircraft.instance.change(this.aircraft, this.currentLivery)); this.aircraftName || (this.aircraftName = geofs.aircraftList[this.aircraft] ? geofs.aircraftList[this.aircraft].name : "unknown") },
  updateContrails: function () {
    if (geofs.preferences.graphics.contrails && this.referencePoint.lla[2] > weather.contrailAltitude) { if (this.contrailEmitter && this.contrailLod != this.lod && (this.contrailEmitter.destroy(), this.contrailEmitter = null), this.contrailLod != this.lod && multiplayer.contrailEmitters[this.lod]) { var a = Object.assign({}, multiplayer.contrailEmitters[this.lod]); a.anchor = this.referencePoint; this.contrailEmitter = new geofs.fx.ParticleEmitter(a) } } else this.contrailEmitter && (this.contrailEmitter.destroy(),
      this.contrailEmitter = null); this.contrailLod = this.lod
  }, updateModel: function (a) {
    var b = this.getLOD(a); if (this.isPeer) this.removeModels(), multiplayer.visibleUsers[this.id] = this, this.lod = b; else {
      var c = !(!geofs.preferences.showCommunityMultiplayer && geofs.aircraftList[this.aircraft] && geofs.aircraftList[this.aircraft].community); this.models && this.models.length != 0 ? c || this.removeModels() : b > 0 && b < multiplayer.numberOfLOD && c && (this.models = multiplayer.loadModels(a.ac), this.lod = null); b != this.lod && (this.removeFromWorld(),
        b > 0 && b <= multiplayer.numberOfLOD ? multiplayer.visibleUsers[this.id] = this : delete multiplayer.visibleUsers[this.id], c = b - 1, this.models.length > c && c >= 0 && (this.model = this.models[c], this.model.addToWorld()), this.lod = b); multiplayer.visibleUsers[this.id] && this.lod == 1 && a.st.lv && this.currentLivery != a.st.lv && this.model.isReady() && (this.currentLivery = a.st.lv, this.model.changeTexture(geofs.aircraftList[this.aircraft].path + "texture-low_" + this.currentLivery + ".jpg", { index: 0 })); if (this.premium != a.p || this.callsign != a.cs) this.premium =
          a.p, this.callsign = a.cs, this.removeCallsign(); this.label || (b = a.p ? "premium" : "default", b = this.isTraffic ? "traffic" : b, b = a.acid == 1 ? "xavier" : b, this.addCallsign(this.callsign, b))
    }
  }, addCallsign: function (a, b) { this.label = geofs.api.addLabel(a, null, multiplayer.labelOptions[b]); multiplayer.iconOptions[b] && (a = Object.assign({}, multiplayer.iconOptions[b], { pixelOffset: new Cesium.Cartesian2(-(a.length * 4 + 5), 2) }), this.icon = new geofs.api.billboard(null, null, a)) }, removeCallsign: function () {
    geofs.api.removeLabel(this.label);
    this.label = null; this.icon && (this.icon.destroy(), this.icon = null)
  }, removeFromWorld: function () { this.model && this.model.removeFromWorld(); this.lod = this.model = null; this.removeCallsign() }, removeModels: function () { this.removeFromWorld(); if (this.models) for (var a = 0; a < this.models.length; a++)this.models[a].destroy(); this.currentLivery = this.lod = null; this.models = [] }, remove: function () {
    clearTimeout(this.heartBeatTimeout); this.removeModels(); this.contrailEmitter && (this.contrailEmitter.destroy(), this.contrailEmitter =
      null); geofs.map && geofs.map.deletePlayerMarker(this.id); delete multiplayer.visibleUsers[this.id]; delete multiplayer.users[this.id]
  }, getCoordinates: function () { return this.lastUpdate.co }, isOnGround: function () { return this.lastUpdate.st.gr }
}; multiplayer.blockUser = function (a) { ui.chat.removeUserMessages(a); $.ajax("/backend/accounts/api.php?action=muteplayer&offenderid=" + a); geofs.userRecord.muteListMap[a] = 1 }; multiplayer.banUser = function (a) { $.ajax("/backend/accounts/api.php?action=ban&offenderid=" + a) };
multiplayer.loadModels = function (a) { var b = []; if (geofs.aircraftList[a]) { var c = ["multiplayer.glb", "multiplayer-low.glb"]; geofs.aircraftList[a].multiplayerFiles && (c = geofs.aircraftList[a].multiplayerFiles.split(",")); var d = geofs.aircraftList[a].path + c[0]; a = geofs.aircraftList[a].path + c[1]; b.push(new geofs.api.Model(d, { justLoad: !0, shadows: SHADOWS_CAST, incrementallyLoadTextures: !1, cacheKey: Math.random() })); b.push(new geofs.api.Model(a, { justLoad: !0, shadows: SHADOWS_CAST, incrementallyLoadTextures: !1 })) } return b };
multiplayer.setNbUsers = function (a) { --a; multiplayer.nbUsers != a && ($(".geofs-player-count").html(a + " pilots online"), multiplayer.nbUsers = a) }; multiplayer.setChatMessage = function (a) { multiplayer.chatMessage = a }; "use strict"; geofs.debug = {}; geofs.debug.logStack = []; geofs.debug.logStackMaxLength = 10; geofs.debug.init = function () { geofs.debug.$panel = $(".geofs-debug"); geofs.debug.axis = null; var a = function (b) { b.stopPropagation() }; geofs.debug.$panel.keydown(a); geofs.debug.$panel.keyup(a) };
geofs.debug.turnOn = function () { geofs.debug.$panel || geofs.debug.init(); geofs.debug.$debugFrame = $(".geofs-debugFrame"); geofs.debug.$debugWatch = $(".geofs-debugWatch"); geofs.debug.$debugLog = $(".geofs-debugLog"); geofs.debugOn = !0 }; geofs.debug.afterWorldInit = function () { geofs.api.debug(geofs.debugOn) }; geofs.debug.turnOff = function () { geofs.debugOn = !1; geofs.api.debug(!1) };
geofs.debug.watch = function (a, b) { geofs.debugOn && geofs.debug.$debugFrame && (geofs.debug[a] || (geofs.debug[a] = document.createElement("div"), geofs.debug.$debugFrame.append(geofs.debug[a])), geofs.debug[a].innerHTML = a + ": " + b) }; geofs.debug.error = function (a, b) { b = b || "unknown"; a ? (b = b + ": " + a.message, geofs.debug.log(b), geofs.debug.throw(a)) : geofs.debug.log(b) };
geofs.debug.log = function (a) { geofs.debugOn && (geofs.debug.$debugLog && geofs.debug.$debugLog.html(geofs.debug.$debugLog.html() + "<br/>" + a), window.console && window.console.log && console.log(a)); geofs.debug.stackLog(a) }; geofs.debug.debugger = function () { if (geofs.debugOn) debugger }; geofs.debug.throw = function (a) { geofs.debugOn && a && setTimeout(function () { throw a; }, 0) }; geofs.debug.alert = function (a, b) { if (geofs.debugOn && b) throw b; geofs.debug.stackLog(a) };
geofs.debug.stackLog = function (a) { geofs.debug.logStack.push(a); geofs.debug.logStack.length > geofs.debug.logStackMaxLength && geofs.debug.logStack.shift() };
geofs.debug.update = function (a) {
  geofs.debug.fps = exponentialSmoothing("fps", 1E3 / a).toPrecision(2); if (geofs.debugOn) {
    if (a = $(".debugPartName")[0]) {
      a = a.value; var b = geofs.aircraft.instance.parts[a], c = instruments.list[a]; if (b) {
        var d = $(".debugCollisionPointIndex")[0].value; d ? (d = b.collisionPoints[parseInt(d)] || b.points[d], geofs.debug.placeAxis(b.object3d.getWorldFrame(), d.worldPosition)) : ($(".debugShowForceSource")[0].checked && geofs.debug.placeAxis(b.object3d.getWorldFrame(), b.points.forceSourcePoint.worldPosition),
          $(".debugShowForceDirection")[0].checked && geofs.debug.placeAxis(b.object3d.getWorldFrame(), b.points.forceDirection.worldPosition), $(".debugShowLocalPosition")[0].checked && geofs.debug.placeAxis(b.object3d.getWorldFrame(), b.object3d.worldPosition), $(".debugShowsuspensionOrigin")[0].checked && geofs.debug.placeAxis(b.object3d.getWorldFrame(), b.points.suspensionOrigin.worldPosition)); $(".debugPartData").text("Node Origin: " + b.object3d._nodeOrigin)
      } c && c.definition.cockpit && (b = c.definition.cockpit.position,
        geofs.debug.placeAxis(geofs.aircraft.instance.object3d.getWorldFrame(), b.worldPosition)); a == "camera" && (b = geofs.aircraft.instance.definition.camera.cockpit, geofs.aircraft.instance.object3d.setVectorWorldPosition(b), geofs.debug.placeAxis(geofs.aircraft.instance.object3d.getWorldFrame(), b.worldPosition))
    } geofs.debug.placingObjectId = $(".objectId").val(); geofs.debug.placingObjectId && $(".geofs-debugObjectLlaHtr").text(geofs.objects.getLla(geofs.debug.placingObjectId) + " " + geofs.objects.getHtr(geofs.debug.placingObjectId) +
      " " + geofs.objects.getScale(geofs.debug.placingObjectId))
  }
}; geofs.debug.loadAxis = function () { geofs.debug.axis = {}; geofs.debug.axis.model = new geofs.api.Model("models/debug/axis.glb") }; geofs.debug.placeProbe = function (a) { geofs.debug.probe ? geofs.debug.probe.model.setPositionOrientationAndScale([a[0], a[1], a[2]]) : geofs.debug.loadProbe() }; geofs.debug.loadProbe = function () { geofs.debug.probe = {}; geofs.debug.probe.model = new geofs.api.Model("models/debug/probe.glb") };
geofs.debug.placeAxis = function (a, b) { geofs.debug.axis || geofs.debug.loadAxis(); try { var c = V3.add(geofs.aircraft.instance.llaLocation, xyz2lla(b, geofs.aircraft.instance.llaLocation)), d = M33.getOrientation(a); geofs.debug.axis.model.setPositionOrientationAndScale(c, d) } catch (e) { geofs.debug.error(e, "placeAxis") } }; geofs.debug.toggleDebug = function () { ui.panel.toggle(".geofs-debug") }; geofs.debug.atmosphereSize = [.02, .02, 1500]; geofs.debug.atmosphereResolution = [.001, .001, 200];
geofs.debug.drawAtmosphere = function (a) {
  geofs.debug.dataSource ? geofs.debug.dataSource.entities.removeAll() : (geofs.debug.dataSource = new Cesium.CustomDataSource("windDebug"), geofs.api.viewer.dataSources.add(geofs.debug.dataSource)); a = a || geofs.aircraft.instance.llaLocation; for (var b = weather.windLayers[weather.activeWindLayer], c = a[0] - geofs.debug.atmosphereSize[0]; c <= a[0] + geofs.debug.atmosphereSize[0]; c += geofs.debug.atmosphereResolution[0])for (var d = a[1] - geofs.debug.atmosphereSize[1]; d <= a[1] + geofs.debug.atmosphereSize[1]; d +=
    geofs.debug.atmosphereResolution[1])for (var e = 50; e <= geofs.debug.atmosphereSize[2]; e += geofs.debug.atmosphereResolution[2]) {
      var f = [c, d, e], g = b.computeTerrainLift(f); f[2] = g.origin[2] + e; g = V3.scale(g, b.speed); var k = weather.getLocalThermal(f); g = V3.add(g, k); var m = clamp(g[2], .5, 10); k = Cesium.Color.fromHsl(clamp(.7 - k[2] * .5, 0, .9), clamp(.5 + g[2] * .5, 0, 1), .5); g = V3.scale(g, 15); var n = Cesium.Cartesian3.fromDegrees(f[1], f[0], f[2]); f = V3.add(f, xyz2lla(g, f)); f = Cesium.Cartesian3.fromDegrees(f[1], f[0], f[2]); g = new Cesium.PolylineGraphics;
      g.material = new Cesium.ColorMaterialProperty(k); g.width = new Cesium.ConstantProperty(m); g.arcType = new Cesium.ConstantProperty(Cesium.ArcType.NONE); g.positions = new Cesium.ConstantProperty([n, f]); m = new Cesium.Entity({ show: !0, polyline: g }); geofs.debug.dataSource.entities.add(m)
    }
};
geofs.mobile = {
  configuration: {
    physicsDeltaMs: [20, 20, 20, 20, 20, 15, 10, 10], renderingQualityLevels: {
      0: { resolutionScale: .5, tileCacheSize: 0, fxaa: !1, globeLighting: !1, dropShadow: !1, cloudCoverToCloudNumber: 15, scatteringQuality: 0, shadowMapSize: 1024, viewingDistance: 0, degradedCollisions: !1, lowResRunways: !1 }, 1: { resolutionScale: .5, tileCacheSize: 50, fxaa: !1, globeLighting: !0, dropShadow: !1, cloudCoverToCloudNumber: 1, scatteringQuality: 0, shadowMapSize: 1024, viewingDistance: 1, degradedCollisions: !0, lowResRunways: !0 }, 2: {
        resolutionScale: .6,
        tileCacheSize: 50, fxaa: !0, globeLighting: !0, dropShadow: !1, cloudCoverToCloudNumber: 5, scatteringQuality: 1, shadowMapSize: 1024, viewingDistance: 2, degradedCollisions: !0, lowResRunways: !0
      }, 3: { resolutionScale: .7, tileCacheSize: 50, fxaa: !0, globeLighting: !0, dropShadow: !1, cloudCoverToCloudNumber: 10, scatteringQuality: 2, shadowMapSize: 1024, viewingDistance: 3, degradedCollisions: !0, lowResRunways: !0 }, 4: {
        resolutionScale: .8, tileCacheSize: 50, fxaa: !0, globeLighting: !0, dropShadow: !1, cloudCoverToCloudNumber: 12, scatteringQuality: 3,
        shadowMapSize: 2048, viewingDistance: 4, degradedCollisions: !0, lowResRunways: !1
      }, 5: { resolutionScale: .9, tileCacheSize: 50, fxaa: !0, globeLighting: !0, dropShadow: !1, cloudCoverToCloudNumber: 14, scatteringQuality: 4, shadowMapSize: 2048, viewingDistance: 5, degradedCollisions: !0, lowResRunways: !1 }, 6: { resolutionScale: 1, tileCacheSize: 100, fxaa: !0, globeLighting: !0, dropShadow: !1, cloudCoverToCloudNumber: 15, scatteringQuality: 5, shadowMapSize: 4096, viewingDistance: 6, degradedCollisions: !0, lowResRunways: !1 }
    }, screenSpacePresets: {
      maximumScreenSpaceError: [5,
        4, 3, 2, 2, 2, 1.5, 1], fogScreenSpaceErrorFactor: [2, 2, 2, 2, 2, 2, 1.5, 1], fogDensity: [.001, 8E-4, 6E-4, 4E-4, 3E-4, 2E-4, 1.5E-4, 1E-4]
    }, qualityToBuildingTexture: { 1: "low", 2: "low", 3: "low", 4: "low", 5: "low", 6: "med", 7: "high" }
  }, init: function () { geofs.api.testIfMobileDevice() ? ($("body").addClass("geofs-mobileDevice"), geofs.isMobileDevice = !0) : ($("body").removeClass("geofs-mobileDevice"), geofs.isMobileDevice = !1) }, configure: function () {
    geofs.preferencesDefault.mobile = !0; geofs.preferencesDefault.chat = !1; geofs.preferencesDefault.interface.transparent =
      !0; geofs.preferencesDefault.controlMode = "touch"
  }, turnOn: function () {
    if (!geofs.mobile.on) {
      geofs.mobile.on = !0; $("body").addClass("geofs-mobile"); geofs.buildings.GLSLReflection = !1; geofs.api.preferredCompositor = "canvas"; if (geofs.api.getPlatform() == "ios") for (var a in geofs.mobile.configuration.renderingQualityLevels) geofs.mobile.configuration.renderingQualityLevels[a].tileCacheSize = 1; geofs.configuration.applyConfiguration(geofs.mobile.configuration); geofs.api.renderingQuality(); try {
        geofs.isApp || (document.documentElement.requestFullscreen(),
          screen.orientation.lock("landscape-primary"))
      } catch (b) { }
    }
  }, turnOff: function () { geofs.mobile.on && (geofs.mobile.on = !1, geofs.preferences.mobile = !1, geofs.savePreferences(), $("body").removeClass("geofs-mobile"), screen.orientation.unlock(), geofs.preferencesDefault.controlMode = "mouse", geofs.api.preferredCompositor = "css", geofs.configuration.applyConfiguration(), geofs.api.renderingQuality()) }, setMobileMode: function () { geofs.preferences.mobile ? geofs.mobile.turnOn() : geofs.mobile.turnOff() }
};
function executeWebXRCommands(a, b, c) {
  var d = a._view, e = d.camera, f = a._environmentState.renderTranslucentDepthForPick; updateAndClearFramebuffers(a, b, c); updateAndRenderPrimitives(a); d.createPotentiallyVisibleSet(a); executeComputeCommands(a); f || executeShadowMapCastCommands(a); c = Camera.clone(e, a._cameraVR); c.frustum = e.frustum; if (b.XRViews) for (d = (0, $jscomp.makeIterator)(b.XRViews), f = d.next(); !f.done; f = d.next()) {
    f = f.value; var g = b.XRglLayer.getViewport(f); b.viewport.x = g.x; b.viewport.y = g.y; b.viewport.width =
      g.width; b.viewport.height = g.height; e.frustum.aspectRatio = g.width / g.height; geofs.camera.setPosition(f.transform.position.x, -f.transform.position.z, f.transform.position.y); f = M33.getOrientation(M4.fromColumnMajorArray(f.transform.matrix)); geofs.camera.setRotation(-f[2], f[1], f[0]); geofs.camera.update(1E-5); executeCommands$1(a, b)
  } Camera.clone(c, e)
};
